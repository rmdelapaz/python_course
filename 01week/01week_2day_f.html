<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pushing and Pulling Code</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Pushing and Pulling Code</h1>
        <h2>Python Full Stack Web Developer Course - Week 1: Tuesday</h2>
    </header>

    <main>
        <section class="introduction">
            <h3>The Heartbeat of Collaborative Development</h3>
            <p>In the world of version control, pushing and pulling code represents the fundamental rhythm of collaborative development. 
            These operations are how developers synchronize their work, share changes, and maintain a coherent project across 
            distributed teams. Think of them as the inhale and exhale of your project's lifecycle—a continuous exchange of code between 
            your local environment and shared repositories.</p>
            
            <p>While previous sessions covered Git basics and remote repositories, today we'll focus specifically on the mechanics, 
            strategies, and best practices for pushing and pulling code effectively. Understanding these operations in depth will 
            help you avoid common pitfalls, resolve conflicts gracefully, and maintain a healthy collaborative workflow.</p>
            
            <p>Whether you're working on personal projects, contributing to open source, or collaborating in a professional team, 
            mastering these skills will make you a more effective and confident developer. Let's dive into the essential operations 
            that keep code flowing between developers around the world.</p>
        </section>

        <section class="understanding-remotes">
            <h3>Understanding Remote Connections</h3>
            
            <h4>The Concept of Remotes</h4>
            <p>Before diving into pushing and pulling, it's essential to understand what we're pushing to and pulling from. 
            In Git, a "remote" is a version of your repository that's hosted somewhere else—typically on a server or another 
            developer's machine.</p>
            
            <p>Think of remotes like synchronized folders in cloud storage services. Your local repository and remote repositories 
            are separate copies of the same project that can be synchronized through Git commands.</p>
            
            <h4>Viewing Your Remote Connections</h4>
            <p>To see which remote servers you've configured, use the <code>git remote</code> command:</p>
            
            <div class="code-example">
                <code>$ git remote</code>
                <p>This lists the short names of all specified remote handles, typically "origin".</p>
            </div>
            
            <p>For more detailed information, including the URLs:</p>
            
            <div class="code-example">
                <code>$ git remote -v</code>
                <p>This shows the URLs that Git has stored for the shortname to be used when reading and writing to that remote.</p>
            </div>
            
            <p>A typical output might look like:</p>
            
            <div class="code-example">
                <code>origin    git@github.com:username/repository.git (fetch)</code>
                <code>origin    git@github.com:username/repository.git (push)</code>
            </div>
            
            <h4>Adding Remote Connections</h4>
            <p>If you've created a new repository locally, you'll need to add a remote to push your code to GitHub or another hosting service:</p>
            
            <div class="code-example">
                <code>$ git remote add origin git@github.com:username/repository.git</code>
                <p>This adds a new remote named "origin" pointing to the specified URL.</p>
            </div>
            
            <p>You can add multiple remotes to a single repository. This is useful when:</p>
            <ul>
                <li>Working with forked repositories (e.g., "origin" for your fork, "upstream" for the original)</li>
                <li>Pushing to multiple hosting services (e.g., GitHub and GitLab)</li>
                <li>Setting up different remotes for different environments (e.g., staging and production)</li>
            </ul>
            
            <div class="code-example">
                <code>$ git remote add upstream git@github.com:original-owner/repository.git</code>
                <p>This adds a second remote named "upstream" pointing to the original repository.</p>
            </div>
            
            <h4>Removing and Renaming Remotes</h4>
            <p>If a remote is no longer needed or you want to rename it:</p>
            
            <div class="code-example">
                <code>$ git remote rename origin github</code>
                <p>This renames the "origin" remote to "github".</p>
            </div>
            
            <div class="code-example">
                <code>$ git remote remove upstream</code>
                <p>This removes the "upstream" remote.</p>
            </div>
        </section>

        <section class="pushing-code">
            <h3>Pushing Code: Sharing Your Changes</h3>
            
            <h4>What is Git Push?</h4>
            <p>The <code>git push</code> command is used to upload local repository content to a remote repository. It transfers commits 
            from your local repository to the remote repository, effectively publishing your work for others to see and use.</p>
            
            <p>Think of pushing as uploading your work to a shared drive. You're taking changes that exist only on your computer and 
            making them available to everyone with access to the remote repository.</p>
            
            <h4>Basic Push Syntax</h4>
            <p>The most common form of the push command is:</p>
            
            <div class="code-example">
                <code>$ git push &lt;remote&gt; &lt;branch&gt;</code>
                <p>This pushes the specified branch to the specified remote.</p>
            </div>
            
            <p>For example, to push your main branch to the origin remote:</p>
            
            <div class="code-example">
                <code>$ git push origin main</code>
            </div>
            
            <h4>Push with Tracking: Setting Up Upstream</h4>
            <p>When you clone a repository, Git automatically sets up tracking between your local main branch and the remote's main branch. 
            For new branches, you can set up tracking when you push:</p>
            
            <div class="code-example">
                <code>$ git push -u origin feature-branch</code>
                <p>The <code>-u</code> or <code>--set-upstream</code> flag sets up tracking, associating your local branch with the remote branch.</p>
            </div>
            
            <p>Once tracking is established, you can simply use:</p>
            
            <div class="code-example">
                <code>$ git push</code>
                <p>Git knows which remote and branch to push to based on the tracking information.</p>
            </div>
            
            <h4>Pushing All Branches</h4>
            <p>You can push all of your local branches that have the same name on the remote:</p>
            
            <div class="code-example">
                <code>$ git push --all origin</code>
                <p>This pushes all of your local branches to the origin remote.</p>
            </div>
            
            <p>However, use this with caution. It's generally better to be explicit about which branches you're pushing, especially 
            in a collaborative environment.</p>
            
            <h4>Push Options and Variations</h4>
            
            <h5>Force Push</h5>
            <p>A force push overwrites the remote branch with your local branch, regardless of the remote's state. This can be dangerous 
            in a collaborative environment because it can erase commits that others have pushed.</p>
            
            <div class="code-example">
                <code>$ git push --force origin main</code>
                <p>Force pushes should be used with extreme caution, and only when you understand the implications.</p>
            </div>
            
            <p>A safer alternative is <code>--force-with-lease</code>, which only allows the force push if you haven't fetched any unmerged changes:</p>
            
            <div class="code-example">
                <code>$ git push --force-with-lease origin main</code>
                <p>This provides some protection against overwriting changes you haven't seen yet.</p>
            </div>
            
            <h5>Tags</h5>
            <p>By default, <code>git push</code> doesn't transfer tags. To push tags to the remote repository:</p>
            
            <div class="code-example">
                <code>$ git push origin --tags</code>
                <p>This pushes all of your local tags to the remote.</p>
            </div>
            
            <h5>Delete a Remote Branch</h5>
            <p>To delete a branch on the remote repository:</p>
            
            <div class="code-example">
                <code>$ git push origin --delete feature-branch</code>
                <p>This removes the specified branch from the remote repository.</p>
            </div>
            
            <h4>Common Push Scenarios and Solutions</h4>
            
            <h5>Scenario 1: Push Rejected (Non-Fast-Forward)</h5>
            <p>One of the most common issues is having your push rejected because the remote contains work that you don't have locally:</p>
            
            <div class="code-example">
                <code>! [rejected]        main -> main (non-fast-forward)</code>
                <code>error: failed to push some refs to 'git@github.com:username/repository.git'</code>
                <code>hint: Updates were rejected because the remote contains work that you do</code>
                <code>hint: not have locally. This is usually caused by another repository pushing</code>
                <code>hint: to the same ref. You may want to first integrate the remote changes</code>
                <code>hint: (e.g., 'git pull ...') before pushing again.</code>
            </div>
            
            <p>Solution: Pull first to integrate remote changes, then push:</p>
            
            <div class="code-example">
                <code>$ git pull</code>
                <code>$ git push</code>
            </div>
            
            <h5>Scenario 2: Local and Remote Branch Names Differ</h5>
            <p>If your local branch has a different name than the remote branch you want to push to:</p>
            
            <div class="code-example">
                <code>$ git push origin local-branch:remote-branch</code>
                <p>This pushes your local branch named "local-branch" to the remote branch named "remote-branch".</p>
            </div>
            
            <h5>Scenario 3: Push to a Non-Default Branch</h5>
            <p>If you've created a new branch locally and want to push it to the remote:</p>
            
            <div class="code-example">
                <code>$ git checkout -b feature-branch</code>
                <code># Make changes and commit them</code>
                <code>$ git push -u origin feature-branch</code>
            </div>
            
            <h4>Best Practices for Pushing Code</h4>
            <ul>
                <li><strong>Pull before you push:</strong> Always integrate the latest remote changes before pushing to avoid conflicts</li>
                <li><strong>Push regularly:</strong> Frequent small pushes are easier to manage than infrequent large ones</li>
                <li><strong>Commit atomically, push logically:</strong> Group related commits into meaningful pushes</li>
                <li><strong>Verify your changes:</strong> Review what you're about to push with <code>git diff origin/main</code></li>
                <li><strong>Write meaningful commit messages:</strong> They become part of the project's documentation</li>
                <li><strong>Don't force push to shared branches:</strong> This can overwrite others' work</li>
                <li><strong>Use feature branches:</strong> Keep main stable by developing in feature branches</li>
            </ul>
        </section>

        <section class="pulling-code">
            <h3>Pulling Code: Integrating Others' Changes</h3>
            
            <h4>What is Git Pull?</h4>
            <p>The <code>git pull</code> command is used to fetch and download content from a remote repository and immediately update your local 
            repository to match that content. It's essentially a combination of <code>git fetch</code> followed by <code>git merge</code>.</p>
            
            <p>Think of pulling as downloading the latest version of files from a shared drive and automatically updating your local copies. 
            It brings your local repository up to date with the remote repository.</p>
            
            <h4>Basic Pull Syntax</h4>
            <p>The most common form of the pull command is:</p>
            
            <div class="code-example">
                <code>$ git pull</code>
                <p>This fetches and merges changes from the remote tracked branch into your current branch.</p>
            </div>
            
            <p>You can also be more explicit:</p>
            
            <div class="code-example">
                <code>$ git pull &lt;remote&gt; &lt;branch&gt;</code>
                <p>This pulls from the specified branch of the specified remote.</p>
            </div>
            
            <p>For example, to pull from the main branch of the origin remote:</p>
            
            <div class="code-example">
                <code>$ git pull origin main</code>
            </div>
            
            <h4>Understanding Pull vs. Fetch</h4>
            <p>It's important to understand the difference between <code>git pull</code> and <code>git fetch</code>:</p>
            
            <ul>
                <li><strong>git fetch:</strong> Downloads commits, files, and refs from a remote repository into your local repo, but doesn't integrate 
                any of these changes into your working files. It's like checking what's new without applying those changes.</li>
                <li><strong>git pull:</strong> Fetches and then immediately merges. It's a more direct way to bring your repository up to date, 
                but gives you less control over the process.</li>
            </ul>
            
            <p>Using fetch before merge gives you the opportunity to review changes before integrating them:</p>
            
            <div class="code-example">
                <code>$ git fetch origin</code>
                <code>$ git log --oneline main..origin/main</code>
                <code>$ git merge origin/main</code>
            </div>
            
            <h4>Pull Options and Variations</h4>
            
            <h5>Pull with Rebase</h5>
            <p>Instead of merging fetched changes, you can rebase your current branch on top of the fetched changes:</p>
            
            <div class="code-example">
                <code>$ git pull --rebase origin main</code>
                <p>This rewrites your commit history to include the remote changes as if you had created your commits after the remote changes.</p>
            </div>
            
            <p>Rebasing can create a cleaner project history but should be used with caution on shared branches.</p>
            
            <h5>Pull from Multiple Remotes</h5>
            <p>If you have multiple remotes configured, you can pull from any of them:</p>
            
            <div class="code-example">
                <code>$ git pull upstream main</code>
                <p>This pulls from the "upstream" remote's main branch.</p>
            </div>
            
            <h5>Pull Specific Files</h5>
            <p>Unlike <code>git push</code>, <code>git pull</code> doesn't allow you to pull specific files directly. However, you can achieve 
            similar results by:</p>
            
            <div class="code-example">
                <code>$ git fetch origin</code>
                <code>$ git checkout origin/main -- path/to/file</code>
                <p>This fetches all changes, then checks out just the specific file from the remote branch.</p>
            </div>
            
            <h4>Common Pull Scenarios and Solutions</h4>
            
            <h5>Scenario 1: Merge Conflicts</h5>
            <p>When pulling changes that conflict with your local changes, Git will report a merge conflict:</p>
            
            <div class="code-example">
                <code>$ git pull origin main</code>
                <code>Auto-merging index.html</code>
                <code>CONFLICT (content): Merge conflict in index.html</code>
                <code>Automatic merge failed; fix conflicts and then commit the result.</code>
            </div>
            
            <p>Solution: Resolve conflicts in your editor, then complete the merge:</p>
            
            <div class="code-example">
                <code># Edit the file to resolve conflicts</code>
                <code>$ git add index.html</code>
                <code>$ git commit</code>
                <p>Git will open an editor with a default merge commit message.</p>
            </div>
            
            <h5>Scenario 2: Pull Overwrites Local Changes</h5>
            <p>If you have local changes that haven't been committed, pulling can overwrite them:</p>
            
            <div class="code-example">
                <code>error: Your local changes to the following files would be overwritten by merge:</code>
                <code>        file.txt</code>
                <code>Please commit your changes or stash them before you merge.</code>
            </div>
            
            <p>Solution: Commit or stash your changes first:</p>
            
            <div class="code-example">
                <code># Option 1: Commit your changes</code>
                <code>$ git add .</code>
                <code>$ git commit -m "Work in progress"</code>
                <code>$ git pull</code>
                <code></code>
                <code># Option 2: Stash your changes</code>
                <code>$ git stash</code>
                <code>$ git pull</code>
                <code>$ git stash pop</code>
            </div>
            
            <h5>Scenario 3: Pulling from a Forked Repository</h5>
            <p>When working with forked repositories, you often need to pull changes from the original repository:</p>
            
            <div class="code-example">
                <code># Add the original repository as "upstream"</code>
                <code>$ git remote add upstream git@github.com:original-owner/repository.git</code>
                <code></code>
                <code># Pull from upstream</code>
                <code>$ git pull upstream main</code>
            </div>
            
            <h4>Best Practices for Pulling Code</h4>
            <ul>
                <li><strong>Pull regularly:</strong> Frequent pulls keep your divergence from the remote manageable</li>
                <li><strong>Consider using fetch + merge:</strong> This gives you more control over the integration process</li>
                <li><strong>Commit your changes first:</strong> Always commit local changes before pulling</li>
                <li><strong>Configure pull.rebase:</strong> Set <code>git config --global pull.rebase true</code> if you prefer rebasing to merging</li>
                <li><strong>Look before you merge:</strong> Check what you're pulling with <code>git fetch</code> and <code>git diff origin/main</code></li>
                <li><strong>Pull before starting work:</strong> Always start with the latest code</li>
                <li><strong>Be cautious with force-push after pull:</strong> This can disrupt the project history</li>
            </ul>
        </section>

        <section class="understanding-merge">
            <h3>Understanding Merge and Rebase</h3>
            
            <h4>Merge vs. Rebase: Two Ways to Integrate Changes</h4>
            <p>When pulling changes, Git offers two primary methods for integrating remote changes with your local work: merge and rebase. 
            Understanding the difference is crucial for maintaining a clean and meaningful project history.</p>
            
            <h5>Merge: The Default Approach</h5>
            <p>By default, <code>git pull</code> uses a merge strategy:</p>
            <ul>
                <li>Creates a new "merge commit" that ties together the two histories</li>
                <li>Preserves the complete history and chronological order</li>
                <li>Results in a branch graph that shows all branches and merges</li>
            </ul>
            
            <div class="code-example">
                <code>$ git pull origin main</code>
                <p>This fetches changes and creates a merge commit if needed.</p>
            </div>
            
            <p>Merge is like creating a meeting point where two paths converge. It's safe and preserves all information, but can create a 
            complex history with many merge commits in collaborative projects.</p>
            
            <h5>Rebase: The Linear Approach</h5>
            <p>When using rebase:</p>
            <ul>
                <li>Your local commits are temporarily set aside</li>
                <li>The remote changes are applied to your branch first</li>
                <li>Your local commits are then reapplied on top</li>
                <li>Results in a linear, cleaner history</li>
            </ul>
            
            <div class="code-example">
                <code>$ git pull --rebase origin main</code>
                <p>This fetches changes and reapplies your work on top of them.</p>
            </div>
            
            <p>Rebase is like re-telling the story of your changes as if you had started working from the latest point. It creates a cleaner 
            history but modifies the commit history, which can cause issues in shared branches.</p>
            
            <h4>Choosing Between Merge and Rebase</h4>
            <p>Here's when to use each strategy:</p>
            
            <h5>Use Merge When:</h5>
            <ul>
                <li>The branch is public and shared with others</li>
                <li>You want to preserve the exact history of when changes were made</li>
                <li>You need to track when and how branches were integrated</li>
                <li>You're less experienced with Git and want safer operations</li>
            </ul>
            
            <h5>Use Rebase When:</h5>
            <ul>
                <li>Working on a private branch that only you use</li>
                <li>You want a clean, linear project history</li>
                <li>You want to avoid unnecessary merge commits</li>
                <li>You're preparing a feature branch for integration into the main branch</li>
            </ul>
            
            <h4>Setting a Default Pull Strategy</h4>
            <p>You can configure Git to always use rebase or merge when pulling:</p>
            
            <div class="code-example">
                <code># Configure pull to use rebase by default</code>
                <code>$ git config --global pull.rebase true</code>
                <code></code>
                <code># Configure pull to use merge by default</code>
                <code>$ git config --global pull.rebase false</code>
            </div>
            
            <p>This allows you to use a simple <code>git pull</code> command while still applying your preferred integration strategy.</p>
        </section>

        <section class="conflict-resolution">
            <h3>Handling Merge Conflicts</h3>
            
            <h4>What Are Merge Conflicts?</h4>
            <p>Merge conflicts occur when competing changes are made to the same line of a file, or when one person edits a file and another person 
            deletes it. Git cannot automatically determine what is correct, so it marks the file as being conflicted and halts the merging process, 
            leaving it to you to resolve.</p>
            
            <p>Think of conflicts as Git asking for your input: "I don't know which of these changes to keep, so you need to decide."</p>
            
            <h4>Identifying Conflicts</h4>
            <p>When a conflict occurs during a pull or merge, Git will tell you which files are affected:</p>
            
            <div class="code-example">
                <code>$ git pull origin main</code>
                <code>Auto-merging README.md</code>
                <code>CONFLICT (content): Merge conflict in README.md</code>
                <code>Automatic merge failed; fix conflicts and then commit the result.</code>
            </div>
            
            <p>You can also check for conflicted files:</p>
            
            <div class="code-example">
                <code>$ git status</code>
                <code>On branch main</code>
                <code>You have unmerged paths.</code>
                <code>  (fix conflicts and run "git commit")</code>
                <code>  (use "git merge --abort" to abort the merge)</code>
                <code></code>
                <code>Unmerged paths:</code>
                <code>  (use "git add <file>..." to mark resolution)</code>
                <code>        both modified:      README.md</code>
            </div>
            
            <h4>Understanding Conflict Markers</h4>
            <p>When you open a conflicted file, you'll see sections marked with special dividers:</p>
            
            <div class="code-example">
                <code><<<<<<< HEAD</code>
                <code>This is your local change</code>
                <code>=======</code>
                <code>This is the incoming change from the remote</code>
                <code>>>>>>> branch-name</code>
            </div>
            
            <ul>
                <li><code><<<<<<< HEAD</code> marks the beginning of your changes</li>
                <li><code>=======</code> separates your changes from the incoming changes</li>
                <li><code>>>>>>> branch-name</code> marks the end of the incoming changes</li>
            </ul>
            
            <h4>Resolving Conflicts</h4>
            <p>Resolving a conflict involves editing the file to keep the changes you want, removing the conflict markers, and then completing the merge process.</p>
            
            <h5>Step 1: Open the Conflicted File</h5>
            <p>Open the file in your preferred text editor or IDE:</p>
            
            <div class="code-example">
                <code>$ code README.md</code>
            </div>
            
            <h5>Step 2: Edit the File</h5>
            <p>Decide what to keep. You have several options:</p>
            <ul>
                <li>Keep your changes (the content between <code><<<<<<< HEAD</code> and <code>=======</code>)</li>
                <li>Keep the incoming changes (the content between <code>=======</code> and <code>>>>>>> branch-name</code>)</li>
                <li>Keep both changes (modify the content as needed)</li>
                <li>Discard both changes and write something completely different</li>
            </ul>
            
            <p>Remove all the conflict markers (<code><<<<<<< HEAD</code>, <code>=======</code>, <code>>>>>>> branch-name</code>) once you've decided what to keep.</p>
            
            <h5>Step 3: Mark as Resolved</h5>
            <p>Once you've edited the file to resolve the conflict, you need to stage it:</p>
            
            <div class="code-example">
                <code>$ git add README.md</code>
            </div>
            
            <h5>Step 4: Complete the Merge</h5>
            <p>After resolving all conflicts, complete the merge:</p>
            
            <div class="code-example">
                <code>$ git commit</code>
                <p>Git will open an editor with a default merge commit message that you can customize.</p>
            </div>
            
            <h4>Tools for Conflict Resolution</h4>
            <p>Several tools can make conflict resolution easier:</p>
            
            <h5>Visual Merge Tools</h5>
            <ul>
                <li><strong>Visual Studio Code:</strong> Has built-in merge conflict resolution</li>
                <li><strong>GitHub Desktop:</strong> Provides a visual interface for resolving conflicts</li>
                <li><strong>GitKraken:</strong> Offers a visual diff and merge tool</li>
                <li><strong>Beyond Compare:</strong> A powerful file comparison tool</li>
            </ul>
            
            <p>You can configure Git to use your preferred merge tool:</p>
            
            <div class="code-example">
                <code>$ git config --global merge.tool vscode</code>
                <code>$ git config --global mergetool.vscode.cmd 'code --wait $MERGED'</code>
                <code>$ git mergetool</code>
            </div>
            
            <h4>Preventing Conflicts</h4>
            <p>While conflicts are a natural part of collaborative development, you can minimize them with these practices:</p>
            
            <ul>
                <li><strong>Pull frequently:</strong> Integrate changes from the remote often to reduce divergence</li>
                <li><strong>Communicate with your team:</strong> Coordinate who's working on which files</li>
                <li><strong>Use small, focused branches:</strong> Work on isolated features to reduce overlap</li>
                <li><strong>Use meaningful commit messages:</strong> Help others understand what your changes do</li>
                <li><strong>Follow consistent code formatting:</strong> Avoid conflicts from whitespace changes</li>
            </ul>
        </section>

        <section class="practical-examples">
            <h3>Practical Examples: Pushing and Pulling in Action</h3>
            
            <h4>Example 1: Basic Push and Pull Workflow</h4>
            <p>Let's walk through a typical workflow for a solo developer working on a personal project:</p>
            
            <div class="code-example">
                <code># Start the day by pulling the latest changes</code>
                <code>$ git pull</code>
                <code></code>
                <code># Make changes to the code</code>
                <code>$ echo "# New section" >> README.md</code>
                <code></code>
                <code># Stage and commit changes</code>
                <code>$ git add README.md</code>
                <code>$ git commit -m "docs: Add new section to README"</code>
                <code></code>
                <code># Push changes to the remote</code>
                <code>$ git push</code>
            </div>
            
            <h4>Example 2: Feature Branch Workflow</h4>
            <p>This workflow is common in team environments where features are developed in separate branches:</p>
            
            <div class="code-example">
                <code># Make sure main is up to date</code>
                <code>$ git checkout main</code>
                <code>$ git pull</code>
                <code></code>
                <code># Create a feature branch</code>
                <code>$ git checkout -b feature/add-login</code>
                <code></code>
                <code># Make changes, stage, and commit</code>
                <code>$ touch login.py</code>
                <code>$ git add login.py</code>
                <code>$ git commit -m "feat: Add login functionality"</code>
                <code></code>
                <code># Push the feature branch to the remote</code>
                <code>$ git push -u origin feature/add-login</code>
                <code></code>
                <code># Later, pull changes from main to keep feature branch updated</code>
                <code>$ git pull origin main</code>
            </div>
            
            <h4>Example 3: Collaborative Workflow with Conflicts</h4>
            <p>Let's see how to handle conflicts in a team environment:</p>
            
            <div class="code-example">
                <code># Pull the latest changes</code>
                <code>$ git pull</code>
                <code>Auto-merging utils.py</code>
                <code>CONFLICT (content): Merge conflict in utils.py</code>
                <code>Automatic merge failed; fix conflicts and then commit the result.</code>
                <code></code>
                <code># Open the file and resolve conflicts</code>
                <code>$ code utils.py</code>
                <code># Edit the file to resolve conflicts</code>
                <code></code>
                <code># Mark the file as resolved</code>
                <code>$ git add utils.py</code>
                <code></code>
                <code># Complete the merge</code>
                <code>$ git commit</code>
                <code></code>
                <code># Push the resolved code</code>
                <code>$ git push</code>
            </div>
            
            <h4>Example 4: Fork and Pull Request Workflow</h4>
            <p>This workflow is common for contributing to open-source projects:</p>
            
            <div class="code-example">
                <code># Clone your fork</code>
                <code>$ git clone git@github.com:your-username/project.git</code>
                <code>$ cd project</code>
                <code></code>
                <code># Add the original repository as upstream</code>
                <code>$ git remote add upstream git@github.com:original-owner/project.git</code>
                <code></code>
                <code># Create a feature branch</code>
                <code>$ git checkout -b feature/fix-bug</code>
                <code></code>
                <code># Make changes, stage, and commit</code>
                <code>$ git add .</code>
                <code>$ git commit -m "fix: Resolve issue with authentication"</code>
                <code></code>
                <code># Push to your fork</code>
                <code>$ git push -u origin feature/fix-bug</code>
                <code></code>
                <code># Keep your fork's main branch updated with upstream</code>
                <code>$ git checkout main</code>
                <code>$ git pull upstream main</code>
                <code>$ git push origin main</code>
            </div>
            
            <h4>Example 5: Rebase Workflow</h4>
            <p>This workflow keeps commit history clean by using rebase instead of merge:</p>
            
            <div class="code-example">
                <code># Create a feature branch</code>
                <code>$ git checkout -b feature/new-api</code>
                <code></code>
                <code># Make changes and commit</code>
                <code>$ git add api.py</code>
                <code>$ git commit -m "feat: Implement new API endpoint"</code>
                <code></code>
                <code># Meanwhile, main has been updated with new commits</code>
                <code># Update your feature branch with latest changes using rebase</code>
                <code>$ git checkout main</code>
                <code>$ git pull</code>
                <code>$ git checkout feature/new-api</code>
                <code>$ git rebase main</code>
                <code></code>
                <code># Resolve any conflicts that arise during rebase</code>
                <code># Then continue the rebase</code>
                <code>$ git add .</code>
                <code>$ git rebase --continue</code>
                <code></code>
                <code># Push to remote (requires force push after rebase)</code>
                <code>$ git push --force-with-lease origin feature/new-api</code>
            </div>
        </section>

        <section class="common-scenarios">
            <h3>Common Scenarios and Solutions</h3>
            
            <h4>Scenario 1: Forgot to Pull Before Working</h4>
            <p>You've made local changes without pulling first, and now you need to integrate remote changes:</p>
            
            <div class="code-example">
                <code># Option 1: Commit your changes, then pull</code>
                <code>$ git add .</code>
                <code>$ git commit -m "feat: Add new functionality"</code>
                <code>$ git pull</code>
                <code># Resolve any conflicts if needed</code>
                <code></code>
                <code># Option 2: Stash your changes, pull, then reapply</code>
                <code>$ git stash</code>
                <code>$ git pull</code>
                <code>$ git stash pop</code>
                <code># Resolve any conflicts if needed</code>
            </div>
            
            <h4>Scenario 2: Pushed to the Wrong Branch</h4>
            <p>You accidentally pushed changes to the wrong branch:</p>
            
            <div class="code-example">
                <code># Identify the commit hash you need to move</code>
                <code>$ git log --oneline</code>
                <code></code>
                <code># Cherry-pick the commit to the correct branch</code>
                <code>$ git checkout correct-branch</code>
                <code>$ git cherry-pick &lt;commit-hash&gt;</code>
                <code>$ git push</code>
                <code></code>
                <code># Optionally, remove the commit from the wrong branch</code>
                <code>$ git checkout wrong-branch</code>
                <code>$ git reset --hard HEAD~1</code>
                <code>$ git push --force-with-lease</code>
            </div>
            
            <h4>Scenario 3: Need to Undo a Pushed Commit</h4>
            <p>You've pushed a commit that needs to be reversed:</p>
            
            <div class="code-example">
                <code># Create a new commit that undoes the changes</code>
                <code>$ git revert &lt;commit-hash&gt;</code>
                <code>$ git push</code>
                <code></code>
                <code># Alternative: Remove the commit entirely (use with caution on shared branches)</code>
                <code>$ git reset --hard HEAD~1</code>
                <code>$ git push --force-with-lease</code>
            </div>
            
            <h4>Scenario 4: Pull Conflicts with Work in Progress</h4>
            <p>You need to pull, but have work in progress that isn't ready to commit:</p>
            
            <div class="code-example">
                <code># Stash your changes</code>
                <code>$ git stash save "Work in progress on feature X"</code>
                <code></code>
                <code># Pull the latest changes</code>
                <code>$ git pull</code>
                <code></code>
                <code># Reapply your changes</code>
                <code>$ git stash pop</code>
                <code># Resolve any conflicts if needed</code>
            </div>
            
            <h4>Scenario 5: Supporting Multiple Remote Repositories</h4>
            <p>You need to work with multiple remotes (e.g., GitHub and GitLab):</p>
            
            <div class="code-example">
                <code># Add multiple remotes</code>
                <code>$ git remote add github git@github.com:username/repository.git</code>
                <code>$ git remote add gitlab git@gitlab.com:username/repository.git</code>
                <code></code>
                <code># Push to specific remotes</code>
                <code>$ git push github main</code>
                <code>$ git push gitlab main</code>
                <code></code>
                <code># Pull from a specific remote</code>
                <code>$ git pull github main</code>
            </div>
        </section>

        <section class="best-practices">
            <h3>Best Practices and Workflow Recommendations</h3>
            
            <h4>Synchronization Practices</h4>
            <ul>
                <li><strong>Start with a pull:</strong> Begin each work session by pulling the latest changes</li>
                <li><strong>Pull frequently:</strong> Regular pulls prevent large divergences that lead to complex conflicts</li>
                <li><strong>Push meaningful units:</strong> Push after completing a logical unit of work</li>
                <li><strong>Commit locally often, push deliberately:</strong> Fine-grained local commits, but push when a feature is complete</li>
            </ul>
            
            <h4>Branch Management</h4>
            <ul>
                <li><strong>Use feature branches:</strong> Develop new features in dedicated branches</li>
                <li><strong>Keep branches short-lived:</strong> Merge feature branches back to main promptly</li>
                <li><strong>Delete merged branches:</strong> Clean up after branches are merged to reduce clutter</li>
                <li><strong>Follow naming conventions:</strong> Use descriptive branch names (e.g., feature/login, bugfix/header-alignment)</li>
            </ul>
            
            <h4>Commit Discipline</h4>
            <ul>
                <li><strong>Write meaningful commit messages:</strong> Clearly describe what changes you made and why</li>
                <li><strong>Keep commits atomic:</strong> Each commit should represent a single logical change</li>
                <li><strong>Verify before committing:</strong> Review changes with <code>git diff</code> before staging</li>
                <li><strong>Follow consistent commit message format:</strong> Consider a convention like Conventional Commits</li>
            </ul>
            
            <h4>Conflict Management</h4>
            <ul>
                <li><strong>Communicate with your team:</strong> Coordinate who's working on which files</li>
                <li><strong>Resolve conflicts promptly:</strong> Don't let conflicted files linger</li>
                <li><strong>Test after resolving conflicts:</strong> Ensure the code still works after resolution</li>
                <li><strong>Use visual tools:</strong> Leverage merge tools for complex conflicts</li>
            </ul>
            
            <h4>Recommended Workflows</h4>
            
            <h5>For Solo Developers</h5>
            <ul>
                <li>Use a simple main + feature branches workflow</li>
                <li>Pull at the start of each session</li>
                <li>Push at logical stopping points</li>
                <li>Consider using rebase for a cleaner history</li>
            </ul>
            
            <h5>For Small Teams</h5>
            <ul>
                <li>Use a GitHub Flow or Feature Branch workflow</li>
                <li>Protect the main branch from direct pushes</li>
                <li>Use Pull Requests for code review</li>
                <li>Pull frequently to stay in sync with teammates</li>
            </ul>
            
            <h5>For Larger Teams</h5>
            <ul>
                <li>Consider a more structured workflow like GitFlow</li>
                <li>Use dedicated branches for features, releases, and hotfixes</li>
                <li>Implement CI/CD to validate changes before merging</li>
                <li>Establish clear guidelines for push/pull practices</li>
            </ul>
        </section>

        <section class="hands-on">
            <h3>Hands-On Exercise: Mastering Push and Pull</h3>
            
            <p>Let's practice pushing and pulling with a simple Python project. We'll simulate a collaborative environment where multiple team members are working together.</p>
            
            <h4>Exercise Setup</h4>
            <ol>
                <li><strong>Create a new repository on GitHub</strong>
                    <ul>
                        <li>Name: "python_calculator"</li>
                        <li>Description: "A simple calculator implemented in Python"</li>
                        <li>Initialize with a README</li>
                        <li>Add a .gitignore for Python</li>
                        <li>Choose an open-source license (e.g., MIT)</li>
                    </ul>
                </li>
                
                <li><strong>Clone the repository locally</strong>
                    <div class="code-example">
                        <code>$ git clone git@github.com:your-username/python_calculator.git</code>
                        <code>$ cd python_calculator</code>
                    </div>
                </li>
            </ol>
            
            <h4>Part 1: Basic Push and Pull</h4>
            <ol>
                <li><strong>Create a basic calculator module</strong>
                    <div class="code-example">
                        <code>$ touch calculator.py</code>
                    </div>
                    <p>Add the following code to calculator.py:</p>
                    <div class="code-example">
                        <code>
def add(a, b):
    """Add two numbers and return the result."""
    return a + b

def subtract(a, b):
    """Subtract b from a and return the result."""
    return a - b
                        </code>
                    </div>
                </li>
                
                <li><strong>Add a test file</strong>
                    <div class="code-example">
                        <code>$ touch test_calculator.py</code>
                    </div>
                    <p>Add the following code to test_calculator.py:</p>
                    <div class="code-example">
                        <code>
import unittest
from calculator import add, subtract

class TestCalculator(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)
        
    def test_subtract(self):
        self.assertEqual(subtract(5, 3), 2)
        self.assertEqual(subtract(1, 1), 0)
        
if __name__ == '__main__':
    unittest.main()
                        </code>
                    </div>
                </li>
                
                <li><strong>Stage, commit, and push the changes</strong>
                    <div class="code-example">
                        <code>$ git add calculator.py test_calculator.py</code>
                        <code>$ git commit -m "feat: Add basic calculator with add and subtract functions"</code>
                        <code>$ git push</code>
                    </div>
                </li>
                
                <li><strong>Simulate a change on the remote</strong>
                    <p>Go to GitHub, edit the README.md file directly on the website. Add some basic documentation:</p>
                    <div class="code-example">
                        <code>
# Python Calculator

A simple calculator implemented in Python.

## Features

- Addition
- Subtraction

## Usage

```python
from calculator import add, subtract

result = add(5, 3)  # Returns 8
result = subtract(5, 3)  # Returns 2
```

## Testing

Run the tests with:

```
python -m unittest test_calculator.py
```
                        </code>
                    </div>
                    <p>Commit these changes directly on GitHub.</p>
                </li>
                
                <li><strong>Pull the remote changes</strong>
                    <div class="code-example">
                        <code>$ git pull</code>
                        <p>Observe how Git pulls and integrates the README changes.</p>
                    </div>
                </li>
            </ol>
            
            <h4>Part 2: Feature Branches and Collaboration</h4>
            <ol>
                <li><strong>Create a feature branch for multiplication</strong>
                    <div class="code-example">
                        <code>$ git checkout -b feature/multiplication</code>
                    </div>
                </li>
                
                <li><strong>Add multiplication functionality</strong>
                    <p>Update calculator.py to add a multiply function:</p>
                    <div class="code-example">
                        <code>
def add(a, b):
    """Add two numbers and return the result."""
    return a + b

def subtract(a, b):
    """Subtract b from a and return the result."""
    return a - b

def multiply(a, b):
    """Multiply two numbers and return the result."""
    return a * b
                        </code>
                    </div>
                    <p>Also update test_calculator.py:</p>
                    <div class="code-example">
                        <code>
import unittest
from calculator import add, subtract, multiply

class TestCalculator(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)
        
    def test_subtract(self):
        self.assertEqual(subtract(5, 3), 2)
        self.assertEqual(subtract(1, 1), 0)
        
    def test_multiply(self):
        self.assertEqual(multiply(2, 3), 6)
        self.assertEqual(multiply(-1, 5), -5)
        
if __name__ == '__main__':
    unittest.main()
                        </code>
                    </div>
                </li>
                
                <li><strong>Commit and push the feature branch</strong>
                    <div class="code-example">
                        <code>$ git add calculator.py test_calculator.py</code>
                        <code>$ git commit -m "feat: Add multiplication function"</code>
                        <code>$ git push -u origin feature/multiplication</code>
                    </div>
                </li>
                
                <li><strong>Create another feature branch for division</strong>
                    <div class="code-example">
                        <code>$ git checkout main</code>
                        <code>$ git checkout -b feature/division</code>
                    </div>
                </li>
                
                <li><strong>Add division functionality</strong>
                    <p>Update calculator.py to add a divide function:</p>
                    <div class="code-example">
                        <code>
def add(a, b):
    """Add two numbers and return the result."""
    return a + b

def subtract(a, b):
    """Subtract b from a and return the result."""
    return a - b

def divide(a, b):
    """Divide a by b and return the result."""
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
                        </code>
                    </div>
                    <p>Also update test_calculator.py:</p>
                    <div class="code-example">
                        <code>
import unittest
from calculator import add, subtract, divide

class TestCalculator(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)
        
    def test_subtract(self):
        self.assertEqual(subtract(5, 3), 2)
        self.assertEqual(subtract(1, 1), 0)
        
    def test_divide(self):
        self.assertEqual(divide(6, 3), 2)
        self.assertEqual(divide(1, 1), 1)
        with self.assertRaises(ValueError):
            divide(1, 0)
        
if __name__ == '__main__':
    unittest.main()
                        </code>
                    </div>
                </li>
                
                <li><strong>Commit and push the division branch</strong>
                    <div class="code-example">
                        <code>$ git add calculator.py test_calculator.py</code>
                        <code>$ git commit -m "feat: Add division function with zero check"</code>
                        <code>$ git push -u origin feature/division</code>
                    </div>
                </li>
            </ol>
            
            <h4>Part 3: Merging and Handling Conflicts</h4>
            <ol>
                <li><strong>Merge the multiplication branch into main</strong>
                    <div class="code-example">
                        <code>$ git checkout main</code>
                        <code>$ git merge feature/multiplication</code>
                        <code>$ git push</code>
                    </div>
                </li>
                
                <li><strong>Try to merge the division branch (this will cause a conflict)</strong>
                    <div class="code-example">
                        <code>$ git merge feature/division</code>
                        <p>This will likely result in a merge conflict in calculator.py and test_calculator.py</p>
                    </div>
                </li>
                
                <li><strong>Resolve the conflicts</strong>
                    <div class="code-example">
                        <code>$ code calculator.py</code>
                        <code>$ code test_calculator.py</code>
                    </div>
                    <p>Edit the files to resolve conflicts, keeping both multiplication and division functionality. The final calculator.py should look like:</p>
                    <div class="code-example">
                        <code>
def add(a, b):
    """Add two numbers and return the result."""
    return a + b

def subtract(a, b):
    """Subtract b from a and return the result."""
    return a - b

def multiply(a, b):
    """Multiply two numbers and return the result."""
    return a * b

def divide(a, b):
    """Divide a by b and return the result."""
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
                        </code>
                    </div>
                    <p>And test_calculator.py should include tests for all functions:</p>
                    <div class="code-example">
                        <code>
import unittest
from calculator import add, subtract, multiply, divide

class TestCalculator(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)
        
    def test_subtract(self):
        self.assertEqual(subtract(5, 3), 2)
        self.assertEqual(subtract(1, 1), 0)
        
    def test_multiply(self):
        self.assertEqual(multiply(2, 3), 6)
        self.assertEqual(multiply(-1, 5), -5)
        
    def test_divide(self):
        self.assertEqual(divide(6, 3), 2)
        self.assertEqual(divide(1, 1), 1)
        with self.assertRaises(ValueError):
            divide(1, 0)
        
if __name__ == '__main__':
    unittest.main()
                        </code>
                    </div>
                </li>
                
                <li><strong>Complete the merge and push</strong>
                    <div class="code-example">
                        <code>$ git add calculator.py test_calculator.py</code>
                        <code>$ git commit</code>
                        <code>$ git push</code>
                    </div>
                </li>
                
                <li><strong>Update the README on GitHub</strong>
                    <p>Go to GitHub and update the README.md to include the new functions, then pull these changes:</p>
                    <div class="code-example">
                        <code>$ git pull</code>
                    </div>
                </li>
            </ol>
            
            <h4>Part 4: Advanced Push and Pull Operations</h4>
            <ol>
                <li><strong>Create a power function in a new branch</strong>
                    <div class="code-example">
                        <code>$ git checkout -b feature/power</code>
                    </div>
                    <p>Add a power function to calculator.py:</p>
                    <div class="code-example">
                        <code>
def power(a, b):
    """Raise a to the power of b and return the result."""
    return a ** b
                        </code>
                    </div>
                    <p>And add a test to test_calculator.py.</p>
                </li>
                
                <li><strong>Commit the changes</strong>
                    <div class="code-example">
                        <code>$ git add calculator.py test_calculator.py</code>
                        <code>$ git commit -m "feat: Add power function"</code>
                    </div>
                </li>
                
                <li><strong>Simulate remote changes by asking a partner to edit main</strong>
                    <p>If you're working alone, use GitHub's web interface to edit a file in the main branch, such as adding a comment or improving documentation.</p>
                </li>
                
                <li><strong>Use rebase to integrate main changes</strong>
                    <div class="code-example">
                        <code>$ git checkout main</code>
                        <code>$ git pull</code>
                        <code>$ git checkout feature/power</code>
                        <code>$ git rebase main</code>
                    </div>
                </li>
                
                <li><strong>Push with force-with-lease after rebase</strong>
                    <div class="code-example">
                        <code>$ git push --force-with-lease origin feature/power</code>
                    </div>
                </li>
            </ol>
        </section>

        <section class="conclusion">
            <h3>Key Takeaways</h3>
            
            <ul>
                <li><strong>Push and pull keep repositories synchronized:</strong> They form the foundation of collaborative development</li>
                <li><strong>Understanding remote connections is essential:</strong> Properly configuring remotes allows smooth collaboration</li>
                <li><strong>Regular pushing and pulling prevents conflicts:</strong> Frequent synchronization is key to smooth teamwork</li>
                <li><strong>Choosing the right integration strategy matters:</strong> Merge vs. rebase depends on your workflow and needs</li>
                <li><strong>Conflicts are a natural part of collaboration:</strong> Knowing how to resolve them efficiently is crucial</li>
                <li><strong>Following best practices improves teamwork:</strong> Consistent workflows make collaboration smoother</li>
            </ul>
            
            <p>Mastering push and pull operations is fundamental to using Git effectively. These commands bridge the gap between local and remote 
            development, enabling collaboration across teams and continents. By understanding the mechanics, strategies, and best practices we've 
            covered, you're well-equipped to participate in collaborative development workflows, whether on personal projects, open-source contributions, 
            or professional teams.</p>
        </section>

        <section class="assignment">
            <h3>Assignment: Collaborative Calculator Project</h3>
            
            <p>For this assignment, you'll work in pairs (or small groups) to extend the calculator application we started in the hands-on exercise, using proper pushing and pulling techniques.</p>
            
            <h4>Requirements</h4>
            <ol>
                <li><strong>Form pairs or small groups</strong> (2-3 students)</li>
                
                <li><strong>Set up collaboration</strong>
                    <ul>
                        <li>One student creates a repository on GitHub named "collaborative_calculator"</li>
                        <li>Add teammates as collaborators (Settings → Collaborators → Add people)</li>
                        <li>All team members clone the repository</li>
                    </ul>
                </li>
                
                <li><strong>Implement calculator features</strong>
                    <ul>
                        <li>Basic arithmetic (add, subtract, multiply, divide)</li>
                        <li>Advanced functions (power, square root, modulus)</li>
                        <li>Memory functions (store, recall, clear)</li>
                        <li>A basic command-line interface</li>
                    </ul>
                </li>
                
                <li><strong>Follow a proper Git workflow</strong>
                    <ul>
                        <li>Create feature branches for each function</li>
                        <li>Make regular commits with meaningful messages</li>
                        <li>Create Pull Requests for review</li>
                        <li>Review each other's code before merging</li>
                        <li>Resolve any conflicts that arise</li>
                    </ul>
                </li>
                
                <li><strong>Document your process</strong>
                    <ul>
                        <li>Create a comprehensive README.md</li>
                        <li>Add docstrings to all functions</li>
                        <li>Include examples of how to use the calculator</li>
                        <li>Create a CONTRIBUTING.md with team workflow guidelines</li>
                    </ul>
                </li>
                
                <li><strong>Intentionally create and resolve conflicts</strong>
                    <ul>
                        <li>Have multiple team members edit the same function</li>
                        <li>Document how you resolved these conflicts</li>
                    </ul>
                </li>
            </ol>
            
            <h4>Submission</h4>
            <p>Submit the following:</p>
            <ol>
                <li>A link to your GitHub repository</li>
                <li>A document describing your team's workflow and collaboration process, including:
                    <ul>
                        <li>How you divided the work</li>
                        <li>How you handled synchronization</li>
                        <li>Any conflicts that arose and how you resolved them</li>
                        <li>Lessons learned about collaborative development</li>
                    </ul>
                </li>
                <li>A log of key commands used during the project (focus on push/pull operations)</li>
            </ol>
            
            <h4>Bonus Challenges</h4>
            <ul>
                <li>Implement a graphical user interface using Tkinter</li>
                <li>Add scientific calculator functions</li>
                <li>Create unit tests for all functionality</li>
                <li>Set up GitHub Actions for continuous integration</li>
                <li>Create a release with proper versioning</li>
            </ul>
            
            <p>This assignment is designed to give you practical experience with collaborative Git workflows, focusing specifically on pushing and pulling code in a team environment.</p>
        </section>

        <section class="resources">
            <h3>Additional Resources</h3>
            
            <h4>Git Documentation and Guides</h4>
            <ul>
                <li><a href="https://git-scm.com/docs/git-push" target="_blank">git-push Documentation</a></li>
                <li><a href="https://git-scm.com/docs/git-pull" target="_blank">git-pull Documentation</a></li>
                <li><a href="https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes" target="_blank">Git Book: Working with Remotes</a></li>
            </ul>
            
            <h4>Tutorials and Workflows</h4>
            <ul>
                <li><a href="https://www.atlassian.com/git/tutorials/syncing" target="_blank">Atlassian: Syncing Tutorials</a></li>
                <li><a href="https://github.com/k88hudson/git-flight-rules" target="_blank">Git Flight Rules</a> - A guide for what to do when things go wrong</li>
                <li><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank">A Successful Git Branching Model</a> - The original GitFlow article</li>
            </ul>
            
            <h4>Conflict Resolution</h4>
            <ul>
                <li><a href="https://code.visualstudio.com/docs/editor/versioncontrol#_merge-conflicts" target="_blank">VS Code Merge Conflict Resolution</a></li>
                <li><a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/resolving-a-merge-conflict-using-the-command-line" target="_blank">GitHub: Resolving Merge Conflicts</a></li>
            </ul>
            
            <h4>Advanced Topics</h4>
            <ul>
                <li><a href="https://git-scm.com/docs/git-rebase" target="_blank">git-rebase Documentation</a></li>
                <li><a href="https://blog.developer.atlassian.com/force-with-lease/" target="_blank">Git: Force with lease</a> - A safer way to force push</li>
                <li><a href="https://www.conventionalcommits.org/" target="_blank">Conventional Commits</a> - A specification for commit messages</li>
                </ul>
             
                              
                              <h4>Git Documentation and Guides</h4>
                              <ul>
                                  <li><a href="https://git-scm.com/docs/git-push" target="_blank">git-push Documentation</a></li>
                                  <li><a href="https://git-scm.com/docs/git-pull" target="_blank">git-pull Documentation</a></li>
                                  <li><a href="https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes" target="_blank">Git Book: Working with Remotes</a></li>
                              </ul>
                              
                              <h4>Tutorials and Workflows</h4>
                              <ul>
                                  <li><a href="https://www.atlassian.com/git/tutorials/syncing" target="_blank">Atlassian: Syncing Tutorials</a></li>
                                  <li><a href="https://github.com/k88hudson/git-flight-rules" target="_blank">Git Flight Rules</a> - A guide for what to do when things go wrong</li>
                                  <li><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank">A Successful Git Branching Model</a> - The original GitFlow article</li>
                              </ul>
                              
                              <h4>Conflict Resolution</h4>
                              <ul>
                                  <li><a href="https://code.visualstudio.com/docs/editor/versioncontrol#_merge-conflicts" target="_blank">VS Code Merge Conflict Resolution</a></li>
                                  <li><a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-using-the-command-line" target="_blank">GitHub: Resolving Merge Conflicts</a></li>
                              </ul>
                              
                              <h4>Advanced Topics</h4>
                              <ul>
                                  <li><a href="https://git-scm.com/docs/git-rebase" target="_blank">git-rebase Documentation</a></li>
                                  <li><a href="https://blog.developer.atlassian.com/force-with-lease/" target="_blank">Git: Force with lease</a> - A safer way to force push</li>
                                  <li><a href="https://www.conventionalcommits.org/" target="_blank">Conventional Commits</a> - A specification for commit messages</li>
                              </ul>
                          </section>
                  
                          <section class="advanced-scenarios">
                              <h3>Advanced Pushing and Pulling Scenarios</h3>
                              
                              <h4>Working with Submodules</h4>
                              <p>Git submodules allow you to include one Git repository inside another. This is useful for incorporating external libraries or shared components into your project while keeping them as separate repositories.</p>
                              
                              <p>When working with repositories that contain submodules, pushing and pulling requires some special considerations:</p>
                              
                              <div class="code-example">
                                  <code># Clone a repository with submodules</code>
                                  <code>$ git clone --recurse-submodules git@github.com:username/main-project.git</code>
                                  <code></code>
                                  <code># If you already cloned the repository, initialize and update the submodules</code>
                                  <code>$ git submodule update --init --recursive</code>
                                  <code></code>
                                  <code># Pull changes in the main repository and all submodules</code>
                                  <code>$ git pull --recurse-submodules</code>
                                  <code></code>
                                  <code># Update a specific submodule</code>
                                  <code>$ git submodule update --remote vendor/library</code>
                              </div>
                              
                              <p>Submodules are particularly useful in Python projects for managing dependencies that you want to modify or that aren't available through package managers like pip.</p>
                              
                              <h4>Git LFS (Large File Storage)</h4>
                              <p>When working with large files (such as datasets, images, or binaries), Git LFS helps manage them efficiently. Instead of storing the large files directly in your repository, Git LFS replaces them with text pointers and stores the actual content on a remote server.</p>
                              
                              <div class="code-example">
                                  <code># Install Git LFS</code>
                                  <code>$ git lfs install</code>
                                  <code></code>
                                  <code># Track large file types</code>
                                  <code>$ git lfs track "*.csv" "*.h5" "*.zip"</code>
                                  <code></code>
                                  <code># Make sure .gitattributes is committed</code>
                                  <code>$ git add .gitattributes</code>
                                  <code>$ git commit -m "Configure Git LFS for data files"</code>
                                  <code></code>
                                  <code># Add and commit large files normally</code>
                                  <code>$ git add data.csv</code>
                                  <code>$ git commit -m "Add dataset"</code>
                                  <code>$ git push</code>
                              </div>
                              
                              <p>When pulling from a repository that uses Git LFS, you'll need to ensure Git LFS is installed on your system. The LFS content will be downloaded automatically when you pull.</p>
                              
                              <h4>Cherry-Picking Across Repositories</h4>
                              <p>Sometimes you might want to pull a specific commit from one repository into another. This can be done with a combination of git remote, fetch, and cherry-pick:</p>
                              
                              <div class="code-example">
                                  <code># Add the other repository as a remote</code>
                                  <code>$ git remote add other-repo git@github.com:username/other-repository.git</code>
                                  <code></code>
                                  <code># Fetch the changes from the other repository</code>
                                  <code>$ git fetch other-repo</code>
                                  <code></code>
                                  <code># Cherry-pick a specific commit</code>
                                  <code>$ git cherry-pick commit-hash</code>
                                  <code></code>
                                  <code># Push the changes to your repository</code>
                                  <code>$ git push</code>
                              </div>
                              
                              <p>This technique is useful when you have multiple related projects and want to share specific features or fixes between them without merging the entire repositories.</p>
                              
                              <h4>Shallow Clones and Partial Clones</h4>
                              <p>For large repositories with extensive history, you can use shallow or partial clones to reduce the amount of data transferred:</p>
                              
                              <div class="code-example">
                                  <code># Shallow clone (only get the latest commit)</code>
                                  <code>$ git clone --depth 1 git@github.com:username/large-repository.git</code>
                                  <code></code>
                                  <code># Partial clone (exclude certain files)</code>
                                  <code>$ git clone --filter=blob:none git@github.com:username/large-repository.git</code>
                                  <code>$ git clone --filter=blob:limit=50k git@github.com:username/large-repository.git</code>
                              </div>
                              
                              <p>These options can significantly speed up cloning of large repositories, especially when working with limited bandwidth or storage.</p>
                              
                              <h4>Subtree Merging</h4>
                              <p>Git subtrees are an alternative to submodules that allow you to include one repository inside another, but with the content directly integrated into your repository:</p>
                              
                              <div class="code-example">
                                  <code># Add a subtree</code>
                                  <code>$ git subtree add --prefix=vendor/library git@github.com:username/library.git main --squash</code>
                                  <code></code>
                                  <code># Pull updates from the subtree</code>
                                  <code>$ git subtree pull --prefix=vendor/library git@github.com:username/library.git main --squash</code>
                                  <code></code>
                                  <code># Push changes back to the original repository</code>
                                  <code>$ git subtree push --prefix=vendor/library git@github.com:username/library.git main</code>
                              </div>
                              
                              <p>Subtrees can be more user-friendly than submodules in some cases, as they don't require special commands for other team members to clone and work with the repository.</p>
                          </section>
                  
                          <section class="continuous-integration">
                              <h3>Push and Pull in Continuous Integration</h3>
                              
                              <h4>Automated Workflows with GitHub Actions</h4>
                              <p>Modern development often incorporates continuous integration (CI) systems that automatically test and deploy code when changes are pushed. GitHub Actions is a popular CI system that integrates directly with your GitHub repositories.</p>
                              
                              <p>When you push code to a repository with GitHub Actions configured, it can trigger various workflows:</p>
                              
                              <div class="code-example">
                                  <code># .github/workflows/python-test.yml</code>
                                  <code>name: Python Tests</code>
                                  <code></code>
                                  <code>on:</code>
                                  <code>  push:</code>
                                  <code>    branches: [ main ]</code>
                                  <code>  pull_request:</code>
                                  <code>    branches: [ main ]</code>
                                  <code></code>
                                  <code>jobs:</code>
                                  <code>  test:</code>
                                  <code>    runs-on: ubuntu-latest</code>
                                  <code>    steps:</code>
                                  <code>    - uses: actions/checkout@v3</code>
                                  <code>    - name: Set up Python</code>
                                  <code>      uses: actions/setup-python@v4</code>
                                  <code>      with:</code>
                                  <code>        python-version: '3.10'</code>
                                  <code>    - name: Install dependencies</code>
                                  <code>      run: |</code>
                                  <code>        python -m pip install --upgrade pip</code>
                                  <code>        pip install -r requirements.txt</code>
                                  <code>    - name: Run tests</code>
                                  <code>      run: |</code>
                                  <code>        python -m unittest discover</code>
                              </div>
                              
                              <p>This workflow configuration runs Python tests whenever code is pushed to the main branch or a pull request is created targeting the main branch.</p>
                              
                              <h4>Protected Branches and Required Status Checks</h4>
                              <p>To maintain code quality, many teams configure protected branches that restrict who can push directly to important branches like main. Instead, changes must go through pull requests and pass automated checks before they can be merged.</p>
                              
                              <p>On GitHub, you can set up branch protection rules under repository settings:</p>
                              
                              <ol>
                                  <li>Go to Settings → Branches → Branch protection rules → Add rule</li>
                                  <li>Set "Branch name pattern" to "main"</li>
                                  <li>Enable "Require pull request reviews before merging"</li>
                                  <li>Enable "Require status checks to pass before merging"</li>
                                  <li>Select specific status checks (like your CI tests)</li>
                                  <li>Save changes</li>
                              </ol>
                              
                              <p>With these settings, direct pushes to main will be rejected, enforcing your team's code review and quality processes.</p>
                              
                              <h4>Deployment from Git</h4>
                              <p>Many modern hosting platforms can automatically deploy your application when changes are pushed to specific branches:</p>
                              
                              <div class="code-example">
                                  <code># Deploy to staging environment on push to develop branch</code>
                                  <code>$ git push origin develop</code>
                                  <code></code>
                                  <code># Deploy to production environment on push to main branch</code>
                                  <code>$ git push origin main</code>
                              </div>
                              
                              <p>This approach, known as continuous deployment (CD), allows for rapid release cycles and tight integration between your development workflow and infrastructure.</p>
                              
                              <h4>Git Hooks for Pre-push Validation</h4>
                              <p>To prevent pushing code that doesn't meet quality standards, you can use Git hooks to run tests or linters before allowing a push:</p>
                              
                              <div class="code-example">
                                  <code># .git/hooks/pre-push (make this file executable)</code>
                                  <code>#!/bin/sh</code>
                                  <code></code>
                                  <code>echo "Running tests before push..."</code>
                                  <code>python -m unittest discover</code>
                                  <code></code>
                                  <code>if [ $? -ne 0 ]; then</code>
                                  <code>  echo "Tests failed. Push aborted."</code>
                                  <code>  exit 1</code>
                                  <code>fi</code>
                                  <code></code>
                                  <code>echo "Running flake8 before push..."</code>
                                  <code>flake8 .</code>
                                  <code></code>
                                  <code>if [ $? -ne 0 ]; then</code>
                                  <code>  echo "Linting failed. Push aborted."</code>
                                  <code>  exit 1</code>
                                  <code>fi</code>
                                  <code></code>
                                  <code>exit 0</code>
                              </div>
                              
                              <p>This script runs tests and a linter (flake8) before allowing a push. If either fails, the push is canceled.</p>
                          </section>
                  
                          <section class="team-workflows">
                              <h3>Push and Pull in Team Workflows</h3>
                              
                              <h4>Trunk-Based Development</h4>
                              <p>Trunk-based development is a source control workflow where most development happens on the main branch (the "trunk") or on short-lived feature branches that are frequently merged back to main. This approach emphasizes continuous integration and small, incremental changes.</p>
                              
                              <div class="example-workflow">
                                  <h5>Typical Trunk-Based Development Workflow:</h5>
                                  <ol>
                                      <li>Pull the latest changes from main:
                                          <div class="code-example">
                                              <code>$ git pull origin main</code>
                                          </div>
                                      </li>
                                      <li>Make changes directly on main or on a short-lived branch:
                                          <div class="code-example">
                                              <code># Option 1: Work directly on main</code>
                                              <code>$ git add .</code>
                                              <code>$ git commit -m "Add feature X"</code>
                                              <code></code>
                                              <code># Option 2: Use a short-lived feature branch</code>
                                              <code>$ git checkout -b feature/x</code>
                                              <code>$ git add .</code>
                                              <code>$ git commit -m "Add feature X"</code>
                                          </div>
                                      </li>
                                      <li>Push changes at least once per day:
                                          <div class="code-example">
                                              <code># If working on main</code>
                                              <code>$ git push origin main</code>
                                              <code></code>
                                              <code># If working on a feature branch</code>
                                              <code>$ git push origin feature/x</code>
                                          </div>
                                      </li>
                                      <li>Merge feature branches quickly (usually within a day):
                                          <div class="code-example">
                                              <code>$ git checkout main</code>
                                              <code>$ git pull</code>
                                              <code>$ git merge feature/x</code>
                                              <code>$ git push origin main</code>
                                          </div>
                                      </li>
                                  </ol>
                              </div>
                              
                              <p>This approach works well with continuous integration systems, as changes are integrated frequently, reducing the risk of complex merge conflicts.</p>
                              
                              <h4>GitFlow</h4>
                              <p>GitFlow is a more structured workflow with dedicated branches for different purposes. It's particularly well-suited for projects with scheduled releases.</p>
                              
                              <div class="example-workflow">
                                  <h5>Typical GitFlow Workflow:</h5>
                                  <ol>
                                      <li>Feature development:
                                          <div class="code-example">
                                              <code># Start from develop branch</code>
                                              <code>$ git checkout develop</code>
                                              <code>$ git pull</code>
                                              <code></code>
                                              <code># Create feature branch</code>
                                              <code>$ git checkout -b feature/new-login</code>
                                              <code># Make changes, commit, and push</code>
                                              <code>$ git push -u origin feature/new-login</code>
                                          </div>
                                      </li>
                                      <li>Complete feature and merge to develop:
                                          <div class="code-example">
                                              <code># Ensure feature is up to date with develop</code>
                                              <code>$ git checkout develop</code>
                                              <code>$ git pull</code>
                                              <code>$ git checkout feature/new-login</code>
                                              <code>$ git merge develop</code>
                                              <code>$ git push</code>
                                              <code></code>
                                              <code># Merge feature to develop</code>
                                              <code>$ git checkout develop</code>
                                              <code>$ git merge feature/new-login</code>
                                              <code>$ git push origin develop</code>
                                          </div>
                                      </li>
                                      <li>Prepare a release:
                                          <div class="code-example">
                                              <code>$ git checkout develop</code>
                                              <code>$ git pull</code>
                                              <code>$ git checkout -b release/1.0.0</code>
                                              <code># Make any release-specific changes</code>
                                              <code>$ git push -u origin release/1.0.0</code>
                                          </div>
                                      </li>
                                      <li>Finalize release:
                                          <div class="code-example">
                                              <code># Merge to main</code>
                                              <code>$ git checkout main</code>
                                              <code>$ git pull</code>
                                              <code>$ git merge release/1.0.0</code>
                                              <code>$ git tag -a v1.0.0 -m "Version 1.0.0"</code>
                                              <code>$ git push origin main --tags</code>
                                              <code></code>
                                              <code># Also merge back to develop</code>
                                              <code>$ git checkout develop</code>
                                              <code>$ git merge release/1.0.0</code>
                                              <code>$ git push origin develop</code>
                                          </div>
                                      </li>
                                  </ol>
                              </div>
                              
                              <p>While more complex, GitFlow provides a clear structure for managing releases and hotfixes.</p>
                              
                              <h4>GitHub Flow</h4>
                              <p>GitHub Flow is a simpler alternative to GitFlow that centers around pull requests and is well-suited for continuous delivery environments.</p>
                              
                              <div class="example-workflow">
                                  <h5>Typical GitHub Flow Workflow:</h5>
                                  <ol>
                                      <li>Create a branch for new work:
                                          <div class="code-example">
                                              <code>$ git checkout main</code>
                                              <code>$ git pull</code>
                                              <code>$ git checkout -b feature-x</code>
                                          </div>
                                      </li>
                                      <li>Make changes and commit:
                                          <div class="code-example">
                                              <code>$ git add .</code>
                                              <code>$ git commit -m "Implement feature X"</code>
                                          </div>
                                      </li>
                                      <li>Push to GitHub and create a Pull Request:
                                          <div class="code-example">
                                              <code>$ git push -u origin feature-x</code>
                                              <code># Create PR through GitHub interface</code>
                                          </div>
                                      </li>
                                      <li>Discuss and review code in the PR</li>
                                      <li>Deploy and test the changes (often automated via CI/CD)</li>
                                      <li>Merge the PR:
                                          <div class="code-example">
                                              <code># Done through the GitHub interface</code>
                                              <code># Then pull the updated main locally</code>
                                              <code>$ git checkout main</code>
                                              <code>$ git pull</code>
                                          </div>
                                      </li>
                                  </ol>
                              </div>
                              
                              <p>This workflow is popular for its simplicity and strong integration with GitHub's features.</p>
                              
                              <h4>Choosing the Right Workflow</h4>
                              <p>The best workflow depends on your team's size, release cadence, and project complexity:</p>
                              
                              <ul>
                                  <li><strong>Trunk-Based Development:</strong> Best for small teams with continuous delivery and strong automated testing</li>
                                  <li><strong>GitFlow:</strong> Suited for larger teams with scheduled releases and multiple versions in production</li>
                                  <li><strong>GitHub Flow:</strong> Good balance for teams of various sizes who use GitHub and practice continuous delivery</li>
                              </ul>
                              
                              <p>Regardless of which workflow you choose, consistent use of pushing and pulling is crucial for keeping everyone synchronized.</p>
                          </section>
                  
                          <section class="troubleshooting">
                              <h3>Troubleshooting Push and Pull Issues</h3>
                              
                              <h4>Error: failed to push some refs</h4>
                              <p>This common error occurs when your local repository is behind the remote:</p>
                              
                              <div class="code-example">
                                  <code>! [rejected]        main -> main (non-fast-forward)</code>
                                  <code>error: failed to push some refs to 'git@github.com:username/repository.git'</code>
                                  <code>hint: Updates were rejected because the remote contains work that you do</code>
                                  <code>hint: not have locally. This is usually caused by another repository pushing</code>
                                  <code>hint: to the same ref. You may want to first integrate the remote changes</code>
                                  <code>hint: (e.g., 'git pull ...') before pushing again.</code>
                              </div>
                              
                              <p><strong>Solution:</strong> Pull first to integrate remote changes, then push:</p>
                              
                              <div class="code-example">
                                  <code>$ git pull</code>
                                  <code># Resolve any conflicts</code>
                                  <code>$ git push</code>
                              </div>
                              
                              <h4>Error: fatal: refusing to merge unrelated histories</h4>
                              <p>This occurs when trying to pull between repositories that don't share a common commit history:</p>
                              
                              <div class="code-example">
                                  <code>fatal: refusing to merge unrelated histories</code>
                              </div>
                              
                              <p><strong>Solution:</strong> Use the --allow-unrelated-histories flag if you're sure you want to merge the repositories:</p>
                              
                              <div class="code-example">
                                  <code>$ git pull origin main --allow-unrelated-histories</code>
                              </div>
                              
                              <h4>Error: cannot lock ref</h4>
                              <p>This can happen when there's a reference naming conflict:</p>
                              
                              <div class="code-example">
                                  <code>error: cannot lock ref 'refs/remotes/origin/main': ref refs/remotes/origin/main is at &lt;hash1&gt; but expected &lt;hash2&gt;</code>
                              </div>
                              
                              <p><strong>Solution:</strong> Delete the problematic reference and fetch again:</p>
                              
                              <div class="code-example">
                                  <code>$ git gc --prune=now</code>
                                  <code>$ git remote prune origin</code>
                                  <code>$ git fetch --all</code>
                              </div>
                              
                              <h4>Accidentally Pushed Sensitive Data</h4>
                              <p>If you've pushed sensitive data like passwords or API keys:</p>
                              
                              <p><strong>Solution:</strong></p>
                              <ol>
                                  <li>First, change the compromised credentials immediately</li>
                                  <li>Then, remove the sensitive data from your repository history:</li>
                              </ol>
                              
                              <div class="code-example">
                                  <code># Option 1: Use BFG Repo-Cleaner (faster, simpler)</code>
                                  <code>$ java -jar bfg.jar --replace-text passwords.txt my-repo.git</code>
                                  <code></code>
                                  <code># Option 2: Use git-filter-repo</code>
                                  <code>$ git filter-repo --path-glob "*.config" --invert-paths</code>
                                  <code></code>
                                  <code># Force push the cleaned history</code>
                                  <code>$ git push --force origin main</code>
                              </div>
                              
                              <p>Remember that this doesn't remove the data from any clones other team members might have.</p>
                              
                              <h4>Cannot Pull with Uncommitted Changes</h4>
                              <p>Git won't let you pull if you have uncommitted changes that could be overwritten:</p>
                              
                              <div class="code-example">
                                  <code>error: Your local changes to the following files would be overwritten by merge:</code>
                                  <code>        file.txt</code>
                                  <code>Please commit your changes or stash them before you merge.</code>
                              </div>
                              
                              <p><strong>Solution:</strong> Commit or stash your changes first:</p>
                              
                              <div class="code-example">
                                  <code># Option 1: Commit your changes</code>
                                  <code>$ git add .</code>
                                  <code>$ git commit -m "WIP: Save progress"</code>
                                  <code>$ git pull</code>
                                  <code></code>
                                  <code># Option 2: Stash your changes</code>
                                  <code>$ git stash</code>
                                  <code>$ git pull</code>
                                  <code>$ git stash pop</code>
                              </div>
                              
                              <h4>Unable to Connect to Remote Repository</h4>
                              <p>Network or authentication issues can prevent pushing and pulling:</p>
                              
                              <div class="code-example">
                                  <code>fatal: Could not read from remote repository.</code>
                                  <code>Please make sure you have the correct access rights</code>
                                  <code>and the repository exists.</code>
                              </div>
                              
                              <p><strong>Solutions:</strong></p>
                              <ul>
                                  <li>Check your Internet connection</li>
                                  <li>Verify your SSH key is set up correctly:
                                      <div class="code-example">
                                          <code>$ ssh -T git@github.com</code>
                                      </div>
                                  </li>
                                  <li>Ensure the remote URL is correct:
                                      <div class="code-example">
                                          <code>$ git remote -v</code>
                                          <code>$ git remote set-url origin git@github.com:username/repository.git</code>
                                      </div>
                                  </li>
                                  <li>Check that you have the necessary permissions to the repository</li>
                              </ul>
                          </section>
                  
                          <section class="real-world-example">
                              <h3>Real-World Example: Developing a Python Web App</h3>
                              
                              <p>Let's walk through a realistic scenario of using push and pull operations when developing a Python web application with Flask, working in a small team.</p>
                              
                              <h4>Project Setup</h4>
                              <p>Your team is building a Flask-based web application for managing tasks. The repository is hosted on GitHub.</p>
                              
                              <div class="code-example">
                                  <code># Clone the repository</code>
                                  <code>$ git clone git@github.com:team/task-manager.git</code>
                                  <code>$ cd task-manager</code>
                                  <code></code>
                                  <code># Create and activate a virtual environment</code>
                                  <code>$ python -m venv venv</code>
                                  <code>$ source venv/bin/activate  # On Windows: venv\Scripts\activate</code>
                                  <code></code>
                                  <code># Install dependencies</code>
                                  <code>$ pip install -r requirements.txt</code>
                              </div>
                              
                              <h4>Day 1: Starting a New Feature</h4>
                              <p>You're assigned to add a user authentication system.</p>
                              
                              <div class="code-example">
                                  <code># Make sure main branch is up to date</code>
                                  <code>$ git checkout main</code>
                                  <code>$ git pull</code>
                                  <code></code>
                                  <code># Create a feature branch</code>
                                  <code>$ git checkout -b feature/user-auth</code>
                                  <code></code>
                                  <code># Create necessary files</code>
                                  <code>$ touch auth.py</code>
                                  <code>$ mkdir templates/auth</code>
                                  <code>$ touch templates/auth/login.html templates/auth/register.html</code>
                              </div>
                              
                              <p>After implementing basic authentication functionality:</p>
                              
                              <div class="code-example">
                                  <code># Stage and commit your changes</code>
                                  <code>$ git add .</code>
                                  <code>$ git commit -m "feat: Add basic user model and authentication routes"</code>
                                  <code></code>
                                  <code># Push your branch to GitHub</code>
                                  <code>$ git push -u origin feature/user-auth</code>
                              </div>
                              
                              <h4>Day 2: Continuing Feature Development</h4>
                              <p>As you continue working, your colleague has made changes to the main branch that you need.</p>
                              
                              <div class="code-example">
                                  <code># First, commit your current work</code>
                                  <code>$ git add .</code>
                                  <code>$ git commit -m "feat: Implement login and registration forms"</code>
                                  <code></code>
                                  <code># Get the latest changes from main</code>
                                  <code>$ git checkout main</code>
                                  <code>$ git pull</code>
                                  <code>$ git checkout feature/user-auth</code>
                                  <code>$ git merge main</code>
                                  <code></code>
                                  <code># If there are conflicts, resolve them</code>
                                  <code>$ git add .</code>
                                  <code>$ git commit -m "merge: Integrate latest changes from main"</code>
                                  <code></code>
                                  <code># Continue working, then commit and push</code>
                                  <code>$ git add .</code>
                                  <code>$ git commit -m "feat: Complete authentication system with password hashing"</code>
                                  <code>$ git push</code>
                              </div>
                              
                              <h4>Day 3: Code Review and Pull Request</h4>
                              <p>Your feature is ready for review. Create a pull request on GitHub, and address review feedback.</p>
                              
                              <div class="code-example">
                                  <code># Make changes based on review feedback</code>
                                  <code>$ git add .</code>
                                  <code>$ git commit -m "refactor: Address code review feedback"</code>
                                  <code>$ git push</code>
                              </div>
                              
                              <p>After approval, the reviewer merges your PR on GitHub.</p>
                              
                              <h4>Day 4: Starting a New Feature and Handling Conflicts</h4>
                              <p>Now, you're assigned to add email notifications. Meanwhile, a colleague has modified auth.py in a way that will conflict with your changes.</p>
                              
                              <div class="code-example">
                                  <code># Update your main branch</code>
                                  <code>$ git checkout main</code>
                                  <code>$ git pull</code>
                                  <code></code>
                                  <code># Create a new feature branch</code>
                                  <code>$ git checkout -b feature/email-notifications</code>
                                  <code></code>
                                  <code># Make changes and commit</code>
                                  <code>$ git add .</code>
                                  <code>$ git commit -m "feat: Add email notification system"</code>
                                  <code>$ git push -u origin feature/email-notifications</code>
                              </div>
                              
                              <p>Your colleague merges their changes to main. When you try to merge main into your branch:</p>
                              
                              <div class="code-example">
                                  <code>$ git checkout main</code>
                                  <code>$ git pull</code>
                                  <code>$ git checkout feature/email-notifications</code>
                                  <code>$ git merge main</code>
                                  <code>Auto-merging auth.py</code>
                                  <code>CONFLICT (content): Merge conflict in auth.py</code>
                                  <code>Automatic merge failed; fix conflicts and then commit the result.</code>
                              </div>
                              
                              <p>Resolving the conflict:</p>
                              
                              <div class="code-example">
                                  <code>$ code auth.py  # Open in VS Code to resolve conflict</code>
                                  <code>$ git add auth.py</code>
                                  <code>$ git commit -m "merge: Resolve conflicts with main branch"</code>
                                  <code>$ git push</code>
                              </div>
                              
                              <h4>Day 5: Finalizing Features and Release</h4>
                              <p>After your email notification feature is merged, the team prepares for a release.</p>
                              
                              <div class="code-example">
                                  <code># Make sure you have the latest code</code>
                                  <code>$ git checkout main</code>
                                  <code>$ git pull</code>
                                  <code></code>
                                  <code># Create a release branch</code>
                                  <code>$ git checkout -b release/v1.0.0</code>
                                  <code></code>
                                  <code># Make any release-specific changes</code>
                                  <code>$ git add .</code>
                                  <code>$ git commit -m "chore: Prepare version 1.0.0 for release"</code>
                                  <code>$ git push -u origin release/v1.0.0</code>
                              </div>
                              
                              <p>After testing, the release is finalized:</p>
                              
                              <div class="code-example">
                                  <code>$ git checkout main</code>
                                  <code>$ git merge release/v1.0.0</code>
                                  <code>$ git tag -a v1.0.0 -m "Version 1.0.0"</code>
                                  <code>$ git push --tags</code>
                              </div>
                              
                              <p>This real-world example demonstrates how pushing and pulling operations are integrated into the daily workflow of a development team, enabling collaboration, conflict resolution, and coordinated releases.</p>
                          </section>
                  
                          <section class="conclusion">
                              <h3>Key Takeaways and Best Practices</h3>
                              
                              <h4>Essential Push/Pull Habits</h4>
                              <ul>
                                  <li><strong>Always pull before starting work.</strong> Begin each session with the latest code to minimize conflicts.</li>
                                  <li><strong>Commit locally often.</strong> Make small, focused commits for clear history and easier conflict resolution.</li>
                                  <li><strong>Push regularly.</strong> Don't keep changes local for too long; share your work with the team.</li>
                                  <li><strong>Write meaningful commit messages.</strong> These become part of your project's documentation.</li>
                                  <li><strong>Verify before pushing.</strong> Use <code>git diff</code> and <code>git status</code> to ensure you're pushing what you intend.</li>
                              </ul>
                              
                              <h4>Conflict Management Strategy</h4>
                              <ul>
                                  <li><strong>Pull frequently to reduce conflict size.</strong> Regular integration keeps divergence manageable.</li>
                                  <li><strong>Communicate with your team.</strong> Coordination reduces conflicts in shared files.</li>
                                  <li><strong>Resolve conflicts promptly.</strong> Don't let conflicted states linger in your workspace.</li>
                                  <li><strong>Test after resolving conflicts.</strong> Ensure merged code still works as expected.</li>
                                  <li><strong>Use proper tools.</strong> Visual merge tools can simplify complex conflict resolution.</li>
                              </ul>
                              
                              <h4>Advanced Techniques to Remember</h4>
                              <ul>
                                  <li><strong>Git hooks</strong> can automate validation before pushing.</li>
                                  <li><strong>Rebase</strong> can create a cleaner history for feature branches.</li>
                                  <li><strong>Pull with --rebase</strong> avoids unnecessary merge commits.</li>
                                  <li><strong>Force-with-lease</strong> is safer than force push when history rewriting is necessary.</li>
                                  <li><strong>Continuous integration</strong> can validate changes automatically when pushed.</li>
                              </ul>
                              
                              <p>By incorporating these practices into your daily workflow, you'll make effective use of Git's distributed nature, 
                              enabling smooth collaboration with your team while maintaining a clean, meaningful project history. Remember that 
                              pushing and pulling are more than just technical operations—they're the communication channels through which your 
                              team coordinates its work.</p>
                              
                              <p>As you continue your journey as a developer, your understanding of these fundamental operations will deepen, 
                              and you'll develop workflows that match your team's specific needs and coding style. The investment you make in 
                              mastering these concepts will pay dividends throughout your career.</p>
                          </section>
                      </main>
                  
                      <footer>
                          <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
                      </footer>
                  </body>
                  </html>
