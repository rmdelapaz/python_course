<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Setup: Putting It All Together</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Project Setup: Putting It All Together</h1>
        <p class="subtitle">Week 1 - Friday: Full Stack Web Development with Python</p>
    </header>

    <main>
        <section>
            <h2>Introduction</h2>
            <p>Congratulations on reaching the final day of our first week! We've covered a lot of ground, from web fundamentals to version control with Git and containerization with Docker. Today, we'll put everything together to create a solid foundation for our full-stack Python web development projects.</p>
            
            <p>Think of today as assembling the framework of a house. We've learned about the various components—foundation (web fundamentals), structure (Git), utilities (Docker)—and now we'll combine them into a cohesive starting point that we can build upon throughout the rest of the course.</p>
            
            <p>By the end of today's session, you'll have a fully configured development environment and project structure that follows industry best practices. This setup will serve as the template for all our future work.</p>
        </section>

        <section>
            <h2>Recap of Week 1</h2>
            
            <p>Before we dive into today's material, let's quickly recap what we've learned this week:</p>
            
            <h3>Monday: Web Fundamentals</h3>
            <ul>
                <li>The web as an ecosystem of clients, servers, and databases</li>
                <li>HTTP protocol and the request-response cycle</li>
                <li>Web browsers and their developer tools</li>
                <li>Setting up our development environment</li>
            </ul>
            
            <h3>Tuesday: Version Control with Git</h3>
            <ul>
                <li>Git fundamentals: repositories, commits, branches</li>
                <li>Basic Git workflow: add, commit, push, pull</li>
                <li>Branching and merging strategies</li>
                <li>Collaboration using GitHub</li>
            </ul>
            
            <h3>Wednesday: Docker Basics</h3>
            <ul>
                <li>Docker concepts: images, containers, Dockerfile</li>
                <li>Building and running containers</li>
                <li>Managing Docker resources</li>
                <li>Creating Docker images for Python applications</li>
            </ul>
            
            <h3>Thursday: Docker Compose</h3>
            <ul>
                <li>Multi-container applications with Docker Compose</li>
                <li>Configuration with docker-compose.yml</li>
                <li>Managing service dependencies</li>
                <li>Development vs. production environments</li>
            </ul>
            
            <p>Today, we'll integrate these concepts to create a project template that incorporates all these best practices.</p>
        </section>

        <section>
            <h2>Project Planning</h2>
            
            <p>Before writing any code, it's important to plan our project. This step is often overlooked by beginners but is crucial for creating maintainable applications.</p>
            
            <h3>Defining Project Requirements</h3>
            <p>For our course, we'll be building a blog application with the following features:</p>
            <ul>
                <li>User authentication (register, login, logout)</li>
                <li>Create, read, update, and delete blog posts</li>
                <li>Comment system</li>
                <li>Tag and category organization</li>
                <li>Search functionality</li>
                <li>User profiles</li>
            </ul>
            
            <h3>Choosing a Technology Stack</h3>
            <p>Based on our requirements, we'll use the following stack:</p>
            <ul>
                <li><strong>Backend Framework</strong>: Flask (a lightweight Python web framework)</li>
                <li><strong>Database</strong>: PostgreSQL (a powerful, open-source relational database)</li>
                <li><strong>ORM</strong>: SQLAlchemy (for database interactions)</li>
                <li><strong>Frontend</strong>: HTML, CSS, JavaScript with Bootstrap</li>
                <li><strong>Authentication</strong>: Flask-Login</li>
                <li><strong>Forms</strong>: Flask-WTF</li>
                <li><strong>Development/Deployment</strong>: Docker and Docker Compose</li>
                <li><strong>Version Control</strong>: Git and GitHub</li>
            </ul>
            
            <h3>Project Architecture</h3>
            <p>We'll follow a modular architecture that separates concerns and allows for easy maintenance and extension:</p>
            
            <pre><code>blog_app/
├── docker-compose.yml     # Docker Compose configuration
├── .gitignore             # Git ignore file
├── README.md              # Project documentation
├── app/                   # Application code
│   ├── __init__.py        # Application factory
│   ├── models/            # Database models
│   ├── views/             # Route handlers
│   ├── templates/         # HTML templates
│   ├── static/            # Static files (CSS, JS, images)
│   ├── forms/             # Form definitions
│   └── utils/             # Utility functions
├── migrations/            # Database migrations
├── tests/                 # Test suite
├── requirements.txt       # Python dependencies
└── Dockerfile             # Docker configuration</code></pre>
            
            <p>This structure follows the package pattern, which is ideal for medium to large Flask applications. It separates different concerns into their own modules, making the codebase more maintainable.</p>
        </section>

        <section>
            <h2>Setting Up the Project</h2>
            
            <p>Now that we have our plan, let's create our project structure and set up the development environment.</p>
            
            <h3>Step 1: Create the Project Directory</h3>
            <pre><code>mkdir -p blog_app/app/models blog_app/app/views blog_app/app/templates blog_app/app/static blog_app/app/forms blog_app/app/utils blog_app/tests
cd blog_app
touch app/__init__.py</code></pre>
            
            <h3>Step 2: Initialize Git Repository</h3>
            <pre><code>git init
touch .gitignore README.md</code></pre>
            
            <p>Add the following to .gitignore:</p>
            <pre><code># Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/

# Flask
instance/
.webassets-cache

# Docker
.env

# IDE
.idea/
.vscode/
*.swp
*.swo

# Database
*.db
*.sqlite3

# Logs
logs/
*.log</code></pre>
            
            <p>Add the following to README.md:</p>
            <pre><code># Blog Application

A full-stack blog application built with Flask, PostgreSQL, and Docker.

## Features

- User authentication
- Blog post management
- Comment system
- Tags and categories
- Search functionality
- User profiles

## Development Setup

1. Clone the repository
2. Run `docker-compose up -d`
3. Access the application at http://localhost:5000

## Project Structure

[Project structure description]

## License

[Your license information]</code></pre>
            
            <h3>Step 3: Create Dockerfile</h3>
            <pre><code>touch Dockerfile</code></pre>
            
            <p>Add the following to Dockerfile:</p>
            <pre><code>FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

ENV FLASK_APP=app
ENV FLASK_ENV=development

EXPOSE 5000

CMD ["flask", "run", "--host=0.0.0.0"]</code></pre>
            
            <h3>Step 4: Create Docker Compose Configuration</h3>
            <pre><code>touch docker-compose.yml</code></pre>
            
            <p>Add the following to docker-compose.yml:</p>
            <pre><code>version: '3'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    environment:
      - FLASK_APP=app
      - FLASK_ENV=development
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/blog_db
    volumes:
      - .:/app
    depends_on:
      - db
    command: flask run --host=0.0.0.0
  
  db:
    image: postgres:14
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=blog_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data:</code></pre>
            
            <h3>Step 5: Define Python Dependencies</h3>
            <pre><code>touch requirements.txt</code></pre>
            
            <p>Add the following to requirements.txt:</p>
            <pre><code>Flask==2.0.1
Flask-SQLAlchemy==2.5.1
Flask-Migrate==3.1.0
Flask-Login==0.5.0
Flask-WTF==0.15.1
psycopg2-binary==2.9.1
email-validator==1.1.3
python-dotenv==0.19.0
Werkzeug==2.0.1
Jinja2==3.0.1
itsdangerous==2.0.1
pytest==6.2.5
flask-testing==0.8.1
black==21.6b0
flake8==3.9.2</code></pre>
        </section>

        <section>
            <h2>Implementing the Application Core</h2>
            
            <p>Now let's implement the core components of our application.</p>
            
            <h3>Step 1: Application Factory</h3>
            <p>Edit app/__init__.py to create an application factory:</p>
            <pre><code>import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_login import LoginManager

# Initialize extensions
db = SQLAlchemy()
migrate = Migrate()
login_manager = LoginManager()

def create_app(test_config=None):
    """Application factory function."""
    # Create and configure the app
    app = Flask(__name__, instance_relative_config=True)
    
    # Set default configuration
    app.config.from_mapping(
        SECRET_KEY='dev',
        SQLALCHEMY_DATABASE_URI=os.environ.get('DATABASE_URL', 'sqlite:///blog.db'),
        SQLALCHEMY_TRACK_MODIFICATIONS=False,
    )
    
    if test_config is None:
        # Load the instance config, if it exists, when not testing
        app.config.from_pyfile('config.py', silent=True)
    else:
        # Load the test config if passed in
        app.config.from_mapping(test_config)
    
    # Ensure the instance folder exists
    try:
        os.makedirs(app.instance_path)
    except OSError:
        pass
    
    # Initialize extensions with app
    db.init_app(app)
    migrate.init_app(app, db)
    login_manager.init_app(app)
    login_manager.login_view = 'auth.login'
    
    # Register blueprints
    from app.views import main, auth
    app.register_blueprint(main.bp)
    app.register_blueprint(auth.bp)
    
    return app</code></pre>
            
            <h3>Step 2: Create Basic Models</h3>
            <p>Create app/models/user.py:</p>
            <pre><code>from datetime import datetime
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash

from app import db, login_manager

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    posts = db.relationship('Post', backref='author', lazy='dynamic')
    
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
    
    def __repr__(self):
        return f'<User {self.username}>'

@login_manager.user_loader
def load_user(id):
    return User.query.get(int(id))</code></pre>
            
            <p>Create app/models/post.py:</p>
            <pre><code>from datetime import datetime
from app import db

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    comments = db.relationship('Comment', backref='post', lazy='dynamic')
    
    def __repr__(self):
        return f'<Post {self.title}>'

class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    post_id = db.Column(db.Integer, db.ForeignKey('post.id'), nullable=False)
    
    def __repr__(self):
        return f'<Comment {self.id}>'</code></pre>
            
            <p>Create app/models/__init__.py to import models:</p>
            <pre><code>from app.models.user import User
from app.models.post import Post, Comment</code></pre>
            
            <h3>Step 3: Create Basic Views</h3>
            <p>Create app/views/main.py for main routes:</p>
            <pre><code>from flask import Blueprint, render_template, flash, redirect, url_for, request
from flask_login import login_required, current_user
from app import db
from app.models import Post, Comment

bp = Blueprint('main', __name__)

@bp.route('/')
def index():
    page = request.args.get('page', 1, type=int)
    posts = Post.query.order_by(Post.created_at.desc()).paginate(
        page=page, per_page=5, error_out=False
    )
    return render_template('index.html', posts=posts)

@bp.route('/post/<int:post_id>')
def post(post_id):
    post = Post.query.get_or_404(post_id)
    return render_template('post.html', post=post)

@bp.route('/create', methods=('GET', 'POST'))
@login_required
def create():
    if request.method == 'POST':
        title = request.form['title']
        content = request.form['content']
        error = None

        if not title:
            error = 'Title is required.'
        
        if error is not None:
            flash(error)
        else:
            post = Post(title=title, content=content, author=current_user)
            db.session.add(post)
            db.session.commit()
            return redirect(url_for('main.index'))
    
    return render_template('create.html')</code></pre>
            
            <p>Create app/views/auth.py for authentication routes:</p>
            <pre><code>from flask import Blueprint, render_template, redirect, url_for, flash, request
from flask_login import login_user, logout_user, login_required
from app import db
from app.models import User

bp = Blueprint('auth', __name__, url_prefix='/auth')

@bp.route('/register', methods=('GET', 'POST'))
def register():
    if request.method == 'POST':
        username = request.form['username']
        email = request.form['email']
        password = request.form['password']
        error = None

        if not username:
            error = 'Username is required.'
        elif not email:
            error = 'Email is required.'
        elif not password:
            error = 'Password is required.'
        elif User.query.filter_by(username=username).first() is not None:
            error = f'User {username} is already registered.'
        elif User.query.filter_by(email=email).first() is not None:
            error = f'Email {email} is already registered.'

        if error is None:
            user = User(username=username, email=email)
            user.set_password(password)
            db.session.add(user)
            db.session.commit()
            return redirect(url_for('auth.login'))

        flash(error)

    return render_template('auth/register.html')

@bp.route('/login', methods=('GET', 'POST'))
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        error = None
        
        user = User.query.filter_by(username=username).first()
        
        if user is None:
            error = 'Incorrect username.'
        elif not user.check_password(password):
            error = 'Incorrect password.'
        
        if error is None:
            login_user(user)
            next_page = request.args.get('next')
            return redirect(next_page or url_for('main.index'))
        
        flash(error)
    
    return render_template('auth/login.html')

@bp.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('main.index'))</code></pre>
            
            <p>Create app/views/__init__.py to import views:</p>
            <pre><code># Import views modules here</code></pre>
            
            <h3>Step 4: Create Basic Templates</h3>
            <p>Create app/templates/base.html:</p>
            <pre><code><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Blog{% endblock %}</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container">
            <a class="navbar-brand" href="{{ url_for('main.index') }}">Blog</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('main.index') }}">Home</a>
                    </li>
                    {% if current_user.is_authenticated %}
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('main.create') }}">Create Post</a>
                    </li>
                    {% endif %}
                </ul>
                <ul class="navbar-nav">
                    {% if current_user.is_authenticated %}
                    <li class="nav-item">
                        <span class="nav-link">Welcome, {{ current_user.username }}</span>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('auth.logout') }}">Logout</a>
                    </li>
                    {% else %}
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('auth.login') }}">Login</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('auth.register') }}">Register</a>
                    </li>
                    {% endif %}
                </ul>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        {% for message in get_flashed_messages() %}
        <div class="alert alert-info">{{ message }}</div>
        {% endfor %}
        
        {% block content %}{% endblock %}
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html></code></pre>
            
            <p>Create app/templates/index.html:</p>
            <pre><code>{% extends 'base.html' %}

{% block title %}Home - Blog{% endblock %}

{% block content %}
<h1>Latest Posts</h1>

{% for post in posts.items %}
<div class="card mb-3">
    <div class="card-body">
        <h5 class="card-title">{{ post.title }}</h5>
        <h6 class="card-subtitle mb-2 text-muted">By {{ post.author.username }} on {{ post.created_at.strftime('%Y-%m-%d') }}</h6>
        <p class="card-text">{{ post.content|truncate(200) }}</p>
        <a href="{{ url_for('main.post', post_id=post.id) }}" class="card-link">Read more</a>
    </div>
</div>
{% else %}
<p>No posts yet.</p>
{% endfor %}

<nav aria-label="Page navigation">
    <ul class="pagination">
        {% if posts.has_prev %}
        <li class="page-item">
            <a class="page-link" href="{{ url_for('main.index', page=posts.prev_num) }}">Previous</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <span class="page-link">Previous</span>
        </li>
        {% endif %}
        
        {% for page_num in posts.iter_pages() %}
            {% if page_num %}
                {% if page_num == posts.page %}
                <li class="page-item active">
                    <span class="page-link">{{ page_num }}</span>
                </li>
                {% else %}
                <li class="page-item">
                    <a class="page-link" href="{{ url_for('main.index', page=page_num) }}">{{ page_num }}</a>
                </li>
                {% endif %}
            {% else %}
                <li class="page-item disabled">
                    <span class="page-link">...</span>
                </li>
            {% endif %}
        {% endfor %}
        
        {% if posts.has_next %}
        <li class="page-item">
            <a class="page-link" href="{{ url_for('main.index', page=posts.next_num) }}">Next</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <span class="page-link">Next</span>
        </li>
        {% endif %}
    </ul>
</nav>
{% endblock %}</code></pre>
            
            <p>Create app/templates/auth/login.html and app/templates/auth/register.html with basic authentication forms.</p>
            
            <p>Create app/templates/post.html and app/templates/create.html for post viewing and creation.</p>
            
            <h3>Step 5: Add Static Files</h3>
            <p>Create app/static/css/style.css for custom styling.</p>
            <p>Create app/static/js/main.js for any custom JavaScript.</p>
        </section>

        <section>
            <h2>Setting Up Testing</h2>
            
            <p>Testing is a crucial part of software development. Let's set up a basic testing framework:</p>
            
            <h3>Step 1: Create Basic Test Structure</h3>
            <pre><code>mkdir -p tests/unit tests/functional</code></pre>
            
            <h3>Step 2: Create Test Configuration</h3>
            <p>Create tests/conftest.py:</p>
            <pre><code>import os
import pytest
from app import create_app, db
from app.models import User, Post

@pytest.fixture
def app():
    app = create_app({
        'TESTING': True,
        'SQLALCHEMY_DATABASE_URI': 'sqlite:///:memory:',
    })
    
    with app.app_context():
        db.create_all()
        
        # Create test user
        user = User(username='testuser', email='test@example.com')
        user.set_password('password')
        db.session.add(user)
        
        # Create test post
        post = Post(title='Test Post', content='Test content', author=user)
        db.session.add(post)
        
        db.session.commit()
    
    yield app
    
    with app.app_context():
        db.drop_all()

@pytest.fixture
def client(app):
    return app.test_client()

@pytest.fixture
def runner(app):
    return app.test_cli_runner()</code></pre>
            
            <h3>Step 3: Create Sample Tests</h3>
            <p>Create tests/functional/test_auth.py:</p>
            <pre><code>def test_register_page(client):
    response = client.get('/auth/register')
    assert response.status_code == 200
    assert b'Register' in response.data

def test_login_page(client):
    response = client.get('/auth/login')
    assert response.status_code == 200
    assert b'Login' in response.data

def test_login_success(client):
    response = client.post(
        '/auth/login',
        data={'username': 'testuser', 'password': 'password'},
        follow_redirects=True
    )
    assert response.status_code == 200
    assert b'Welcome, testuser' in response.data

def test_login_failure(client):
    response = client.post(
        '/auth/login',
        data={'username': 'testuser', 'password': 'wrongpassword'},
        follow_redirects=True
    )
    assert response.status_code == 200
    assert b'Incorrect password' in response.data</code></pre>
            
            <p>Create tests/unit/test_models.py:</p>
            <pre><code>from app.models import User, Post

def test_user_password(app):
    with app.app_context():
        user = User(username='newuser', email='new@example.com')
        user.set_password('password')
        assert not user.check_password('wrongpassword')
        assert user.check_password('password')

def test_post_creation(app):
    with app.app_context():
        user = User.query.filter_by(username='testuser').first()
        post = Post(title='New Post', content='New content', author=user)
        assert post.title == 'New Post'
        assert post.author.username == 'testuser'</code></pre>
        </section>

        <section>
            <h2>Running the Application</h2>
            
            <p>Now that we have our project set up, let's run it using Docker Compose:</p>
            
            <h3>Step 1: Build and Start Containers</h3>
            <pre><code>docker-compose up -d</code></pre>
            
            <h3>Step 2: Initialize the Database</h3>
            <pre><code>docker-compose exec web flask db init
docker-compose exec web flask db migrate -m "Initial migration"
docker-compose exec web flask db upgrade</code></pre>
            
            <h3>Step 3: Access the Application</h3>
            <p>Open your browser and navigate to <a href="http://localhost:5000" target="_blank">http://localhost:5000</a></p>
            
            <h3>Step 4: Run Tests</h3>
            <pre><code>docker-compose exec web pytest -v</code></pre>
        </section>

        <section>
            <h2>Development Workflow</h2>
            
            <p>Let's establish a development workflow that combines Git, Docker, and our Python application:</p>
            
            <h3>Feature Development Workflow</h3>
            <ol>
                <li><strong>Create a Feature Branch</strong>:
                <pre><code>git checkout -b feature/user-profiles</code></pre>
                </li>
                
                <li><strong>Make Changes to the Code</strong>:
                <p>Develop new features or fix bugs in your local environment.</p>
                </li>
                
                <li><strong>Run the Application</strong>:
                <pre><code>docker-compose up -d</code></pre>
                <p>Test changes in your browser at http://localhost:5000</p>
                </li>
                
                <li><strong>Run Tests</strong>:
                <pre><code>docker-compose exec web pytest -v</code></pre>
                </li>
                
                <li><strong>Commit Changes</strong>:
                <pre><code>git add .
git commit -m "Add user profile feature"</code></pre>
                </li>
                
                <li><strong>Push to GitHub</strong>:
                <pre><code>git push origin feature/user-profiles</code></pre>
                </li>
                
                <li><strong>Create a Pull Request</strong>:
                <p>Use GitHub to create a PR from your feature branch to main.</p>
                </li>
                
                <li><strong>Code Review</strong>:
                <p>Have teammates review your code and provide feedback.</p>
                </li>
                
                <li><strong>Merge to Main</strong>:
                <p>Once approved, merge your feature branch into main.</p>
                <pre><code>git checkout main
git merge feature/user-profiles
git push origin main</code></pre>
                </li>
            </ol>
            
            <h3>Continuous Integration</h3>
            <p>For a more professional workflow, consider setting up continuous integration (CI) with GitHub Actions. Create a file named .github/workflows/ci.yml:</p>
            <pre><code>name: Python CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: blog_db_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    
    - name: Lint with flake8
      run: |
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
    
    - name: Test with pytest
      run: |
        pytest
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/blog_db_test</code></pre>
            
            <p>This workflow will run tests and linting checks automatically when you push to main or create a pull request.</p>
        </section>

        <section>
            <h2>Deployment Considerations</h2>
            
            <p>While we won't be deploying our application yet, it's good to think about deployment early in the development process.</p>
            
            <h3>Production Configuration</h3>
            <p>Create a production Docker Compose file (docker-compose.prod.yml):</p>
            <pre><code>version: '3'

services:
  web:
    build: .
    restart: always
    environment:
      - FLASK_APP=app
      - FLASK_ENV=production
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/blog_db
      - SECRET_KEY=${SECRET_KEY}
    depends_on:
      - db
    command: gunicorn --bind 0.0.0.0:5000 'app:create_app()'
  
  db:
    image: postgres:14
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=blog_db
    volumes:
      - postgres_data:/var/lib/postgresql/data

  nginx:
    image: nginx:alpine
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx:/etc/nginx/conf.d
    depends_on:
      - web

volumes:
  postgres_data:</code></pre>
            
            <h3>Security Considerations</h3>
            <ul>
                <li>Never commit sensitive information (passwords, API keys) to Git</li>
                <li>Use environment variables for configuration</li>
                <li>Consider using a secrets management solution</li>
                <li>Keep dependencies updated</li>
                <li>Use HTTPS for all production traffic</li>
                <li>Implement proper authentication and authorization</li>
            </ul>
            
            <h3>Scaling Considerations</h3>
            <ul>
                <li>Implement database indexing for performance</li>
                <li>Consider using a CDN for static assets</li>
                <li>Implement caching where appropriate</li>
                <li>Use load balancing for high-traffic applications</li>
                <li>Consider containerized deployment with Kubernetes for larger applications</li>
            </ul>
        </section>
        
        <section>
            <h2>Project Documentation</h2>
            
            <p>Good documentation is essential for any project. Let's update our README.md to be more comprehensive:</p>
            
            <pre><code># Blog Application

A full-stack blog application built with Flask, PostgreSQL, and Docker.

## Features

- User authentication (register, login, logout)
- Blog post management (create, read, update, delete)
- Comment system
- Responsive design with Bootstrap
- Containerized with Docker and Docker Compose

## Technology Stack

- **Backend**: Flask, Python 3.10
- **Database**: PostgreSQL 14
- **ORM**: SQLAlchemy
- **Frontend**: HTML, CSS, JavaScript, Bootstrap 5
- **Containerization**: Docker, Docker Compose
- **Testing**: pytest
- **CI/CD**: GitHub Actions

## Development Setup

### Prerequisites

- Docker and Docker Compose
- Git

### Installation

1. Clone the repository
```
git clone https://github.com/yourusername/blog-app.git
cd blog-app
```

2. Start the application with Docker Compose
```
docker-compose up -d
```

3. Initialize the database
```
docker-compose exec web flask db init
docker-compose exec web flask db migrate -m "Initial migration"
docker-compose exec web flask db upgrade
```

4. Access the application at http://localhost:5000

### Development Workflow

1. Create a feature branch
```
git checkout -b feature/your-feature-name
```

2. Make changes and test locally

3. Run tests
```
docker-compose exec web pytest -v
```

4. Commit and push changes
```
git add .
git commit -m "Your commit message"
git push origin feature/your-feature-name
```

5. Create a pull request on GitHub

### Running Tests

```
docker-compose exec web pytest -v
```

## Project Structure

```
blog_app/
├── docker-compose.yml     # Docker Compose configuration
├── .gitignore             # Git ignore file
├── README.md              # Project documentation
├── app/                   # Application code
│   ├── __init__.py        # Application factory
│   ├── models/            # Database models
│   ├── views/             # Route handlers
│   ├── templates/         # HTML templates
│   ├── static/            # Static files (CSS, JS, images)
│   ├── forms/             # Form definitions
│   └── utils/             # Utility functions
├── migrations/            # Database migrations
├── tests/                 # Test suite
├── requirements.txt       # Python dependencies
└── Dockerfile             # Docker configuration
```

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

Distributed under the MIT License. See `LICENSE` for more information.

## Contact

Your Name - your.email@example.com

Project Link: https://github.com/yourusername/blog-app</code></pre>
        </section>

        <section>
            <h2>Next Steps and Weekly Assignment</h2>
            
            <p>Congratulations on completing the first week of the course! You now have a solid understanding of web fundamentals, version control with Git, containerization with Docker, and how to set up a full-stack Python web application project.</p>
            
            <h3>Next Week Preview</h3>
            <p>Next week, we'll dive deeper into Python fundamentals and start building our application's core functionality:</p>
            <ul>
                <li>Monday: Python Fundamentals and Virtual Environments</li>
                <li>Tuesday: Flask Basics and Routing</li>
                <li>Wednesday: Database Integration with SQLAlchemy</li>
                <li>Thursday: User Authentication</li>
                <li>Friday: Forms and Validation</li>
            </ul>
            
            <h3>Weekly Assignment</h3>
            <p>To reinforce what you've learned this week, complete the following assignment:</p>
            
            <ol>
                <li>Create a new GitHub repository for your blog application</li>
                <li>Set up the project structure as outlined in today's session</li>
                <li>Implement the basic models (User, Post)</li>
                <li>Create Docker and Docker Compose configurations</li>
                <li>Implement a simple home page that displays "Hello, World!"</li>
                <li>Write at least one test for your application</li>
                <li>Create a comprehensive README.md</li>
                <li>Submit the URL of your GitHub repository</li>
            </ol>
            
            <p>Bonus points for:</p>
            <ul>
                <li>Setting up GitHub Actions for continuous integration</li>
                <li>Implementing user registration and login</li>
                <li>Creating a basic blog post listing page</li>
            </ul>
        </section>

        <section>
            <h2>Questions and Additional Resources</h2>
            
            <h3>Common Questions</h3>
            
            <h4>Q: Do I need to use Docker for my projects?</h4>
            <p>A: While not strictly required, Docker provides significant benefits for development consistency and deployment. We strongly recommend learning and using it.</p>
            
            <h4>Q: What if I encounter errors when setting up my environment?</h4>
            <p>A: Document the error, search for solutions online, and if you're still stuck, ask for help in our course forum. Include the exact error message and steps to reproduce.</p>
            
            <h4>Q: Can I use a different database than PostgreSQL?</h4>
            <p>A: Yes, SQLAlchemy supports multiple databases. However, we recommend PostgreSQL for this course as it's widely used in production environments.</p>
            
            <h4>Q: How detailed should my git commits be?</h4>
            <p>A: Aim for atomic commits with clear, descriptive messages. Each commit should represent a single logical change.</p>
            
            <h3>Additional Resources</h3>
            
            <h4>Project Structure</h4>
            <ul>
                <li><a href="https://flask.palletsprojects.com/en/2.0.x/patterns/appfactories/" target="_blank">Flask Application Factories</a></li>
                <li><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world" target="_blank">The Flask Mega-Tutorial</a></li>
            </ul>
            
            <h4>Docker</h4>
            <ul>
                <li><a href="https://docs.docker.com/compose/production/" target="_blank">Docker Compose in Production</a></li>
                <li><a href="https://testdriven.io/blog/dockerizing-flask-with-postgres-gunicorn-and-nginx/" target="_blank">Dockerizing Flask with Postgres, Gunicorn, and Nginx</a></li>
            </ul>
            
            <h4>Testing</h4>
            <ul>
                <li><a href="https://flask.palletsprojects.com/en/2.0.x/testing/" target="_blank">Flask Testing Documentation</a></li>
                <li><a href="https://docs.pytest.org/en/latest/" target="_blank">pytest Documentation</a></li>
            </ul>
            
            <h4>Deployment</h4>
            <ul>
                <li><a href="https://flask.palletsprojects.com/en/2.0.x/deploying/" target="_blank">Flask Deployment Options</a></li>
                <li><a href="https://www.digitalocean.com/community/tutorials/how-to-deploy-a-flask-application-with-gunicorn-and-nginx-on-ubuntu-20-04" target="_blank">Deploy Flask with Gunicorn and Nginx</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Full Stack Python Web Development Course</p>
    </footer>
</body>
</html>
