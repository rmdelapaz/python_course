<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic Command Line Interface (CLI) Navigation</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 1, Monday: Basic Command Line Interface (CLI) Navigation</h2>
    </header>

    <main>
        <section class="introduction">
            <h3>The Power of Text-Based Computing</h3>
            <p>
                Welcome to the world of command line interfaces! While graphical user interfaces (GUIs) make computers accessible, the command line interface (CLI) remains one of the most powerful tools in a developer's arsenal. Understanding how to navigate and use the CLI is an essential skill for any web developer.
            </p>
            <p>
                Think of the command line as having a direct conversation with your computer. Instead of pointing and clicking through menus and icons, you express your intentions through precise text commands. This direct communication channel offers speed, flexibility, and automation capabilities that GUIs simply cannot match.
            </p>
            <p>
                In this session, we'll explore the fundamental commands and concepts that will empower you to navigate your system, manage files, and execute operations efficiently through the command line.
            </p>
            <p>
                This file is located in the course materials folder as <code>week1_day1_basic_cli_navigation.html</code>.
            </p>
        </section>

        <section class="why_cli">
            <h3>Why Learn the Command Line?</h3>
            <p>
                You might wonder, "Why bother with text commands when I have a perfectly good GUI?" Here are compelling reasons why the command line is worth mastering:
            </p>
            
            <h4>Efficiency and Speed</h4>
            <p>
                Once familiar with CLI commands, you can execute complex operations with just a few keystrokes:
            </p>
            <ul>
                <li>Rename 100 files following a pattern in seconds</li>
                <li>Search through folder hierarchies with precision</li>
                <li>Chain multiple operations together seamlessly</li>
            </ul>
            <p>
                This efficiency is like the difference between writing an email versus hand-delivering individual messages—the time saved compounds dramatically.
            </p>
            
            <h4>Access to Developer Tools</h4>
            <p>
                Many essential development tools are primarily or exclusively available through the command line:
            </p>
            <ul>
                <li>Version control systems (Git)</li>
                <li>Package managers (npm, pip)</li>
                <li>Build tools and task runners</li>
                <li>Docker containers</li>
                <li>Cloud service CLIs (AWS, Azure, GCP)</li>
            </ul>
            <p>
                Without command line proficiency, you'd be locked out of using these powerful tools effectively—like having a toolbox but being unable to open it.
            </p>
            
            <h4>Automation and Scripting</h4>
            <p>
                The command line enables you to:
            </p>
            <ul>
                <li>Create scripts to automate repetitive tasks</li>
                <li>Schedule operations to run at specific times</li>
                <li>Process data in batches</li>
                <li>Set up continuous integration/deployment pipelines</li>
            </ul>
            <p>
                This automation capability is like having a tireless assistant who can handle repetitive tasks exactly as instructed, freeing you to focus on more creative work.
            </p>
            
            <h4>Remote System Management</h4>
            <p>
                The command line is often the only way to:
            </p>
            <ul>
                <li>Connect to remote servers via SSH</li>
                <li>Manage cloud-based resources</li>
                <li>Troubleshoot systems without graphical interfaces</li>
            </ul>
            <p>
                This remote access ability is like having a master key that works on all doors, regardless of their design or location.
            </p>
            
            <h4>Understanding System Operations</h4>
            <p>
                Working with the CLI deepens your understanding of:
            </p>
            <ul>
                <li>How operating systems actually work</li>
                <li>File system organization and permissions</li>
                <li>Process management and system resources</li>
            </ul>
            <p>
                This deeper knowledge is like being able to look under the hood of a car instead of just knowing how to drive it—you gain insight into the machinery that powers your computing experience.
            </p>
        </section>

        <section class="terminals">
            <h3>Terminal Emulators: Your Gateway to the Command Line</h3>
            <p>
                To interact with the command line, you'll use a terminal emulator—a program that provides a text-based interface to your operating system. Different operating systems come with different default terminals:
            </p>
            
            <h4>Windows Terminals</h4>
            <ul>
                <li>
                    <strong>Command Prompt (cmd.exe)</strong>: Windows' traditional command interpreter
                    <ul>
                        <li>Limited compatibility with Unix-style commands</li>
                        <li>Uses a different syntax for many operations</li>
                    </ul>
                </li>
                <li>
                    <strong>PowerShell</strong>: Modern command shell with enhanced scripting capabilities
                    <ul>
                        <li>Object-oriented approach to command-line tasks</li>
                        <li>More powerful but with different syntax from Unix shells</li>
                    </ul>
                </li>
                <li>
                    <strong>Windows Terminal</strong>: New integrated terminal that supports multiple tab profiles
                    <ul>
                        <li>Can run Command Prompt, PowerShell, and WSL simultaneously</li>
                        <li>Modern features like tabs, split panes, and GPU acceleration</li>
                    </ul>
                </li>
                <li>
                    <strong>Windows Subsystem for Linux (WSL)</strong>: Provides a Linux environment directly in Windows
                    <ul>
                        <li>Gives access to Bash and Unix tools on Windows</li>
                        <li>Highly recommended for web development on Windows</li>
                    </ul>
                </li>
            </ul>
            
            <h4>macOS Terminals</h4>
            <ul>
                <li>
                    <strong>Terminal.app</strong>: The default terminal emulator
                    <ul>
                        <li>Includes tabs, themes, and basic customization</li>
                        <li>Runs Bash (older macOS) or Zsh (newer macOS) by default</li>
                    </ul>
                </li>
                <li>
                    <strong>iTerm2</strong>: A popular alternative with additional features
                    <ul>
                        <li>Split panes, search, autocomplete, and more advanced features</li>
                        <li>Highly customizable with profiles and themes</li>
                    </ul>
                </li>
            </ul>
            
            <h4>Linux Terminals</h4>
            <ul>
                <li>
                    <strong>GNOME Terminal</strong>: Default on GNOME-based distributions
                </li>
                <li>
                    <strong>Konsole</strong>: Default on KDE-based distributions
                </li>
                <li>
                    <strong>Xterm</strong>: Classic X Window System terminal emulator
                </li>
                <li>
                    <strong>Terminator</strong>: Features grid arrangement of terminals
                </li>
                <li>
                    <strong>Alacritty</strong>: GPU-accelerated terminal emulator
                </li>
            </ul>
            <p>
                These terminal emulators are like different types of vehicles—all will get you to your destination, but with different features, comfort levels, and learning curves. Choose one that suits your preferences and workflow.
            </p>
            
            <h4>Shell Types</h4>
            <p>
                The terminal emulator runs a shell—a program that interprets your commands and communicates with the operating system. Common shells include:
            </p>
            <ul>
                <li>
                    <strong>Bash (Bourne Again SHell)</strong>: The most common Unix shell
                </li>
                <li>
                    <strong>Zsh (Z Shell)</strong>: Extended Bash with additional features (now default on macOS)
                </li>
                <li>
                    <strong>Fish</strong>: User-friendly shell with enhanced autocomplete and syntax highlighting
                </li>
                <li>
                    <strong>PowerShell</strong>: Microsoft's task automation shell
                </li>
            </ul>
            <p>
                The shell is like the specific language you use to communicate with your computer—each has its own dialect, idioms, and special features.
            </p>
        </section>

        <section class="navigation_commands">
            <h3>Basic Navigation: Finding Your Way</h3>
            <p>
                Let's start with the fundamental commands for navigating the file system. These commands are the equivalent of being able to walk around and look at things in a physical space.
            </p>
            
            <h4>Understanding Paths</h4>
            <p>
                Before diving into commands, it's important to understand how file system paths work:
            </p>
            <ul>
                <li>
                    <strong>Absolute Paths</strong>: Start from the root directory
                    <ul>
                        <li>On Unix-like systems (Linux/macOS): <code>/home/username/documents/project</code></li>
                        <li>On Windows: <code>C:\Users\Username\Documents\Project</code></li>
                    </ul>
                </li>
                <li>
                    <strong>Relative Paths</strong>: Start from the current directory
                    <ul>
                        <li><code>documents/project</code> (go into documents, then project)</li>
                        <li><code>../images</code> (go up one level, then into images)</li>
                    </ul>
                </li>
                <li>
                    <strong>Special Path Notations</strong>:
                    <ul>
                        <li><code>.</code> - Current directory</li>
                        <li><code>..</code> - Parent directory</li>
                        <li><code>~</code> - Home directory (Unix-like systems)</li>
                        <li><code>/</code> - Root directory (Unix-like systems)</li>
                    </ul>
                </li>
            </ul>
            <p>
                Understanding paths is like understanding addresses in a city—absolute paths give the complete address from the city entrance, while relative paths give directions from your current location.
            </p>
            
            <h4>Essential Navigation Commands</h4>
            <p>
                Here are the key commands for moving around the file system:
            </p>
            
            <h5>1. <code>pwd</code> (Print Working Directory)</h5>
            <p>
                Shows your current location in the file system.
            </p>
            <pre><code>
$ pwd
/home/username/projects/web-app
            </code></pre>
            <p>
                Think of <code>pwd</code> as checking a "You Are Here" map in a shopping mall—it orients you within the file system.
            </p>
            
            <h5>2. <code>ls</code> (List)</h5>
            <p>
                Lists the contents of the current directory (or a specified directory).
            </p>
            <pre><code>
# Basic listing
$ ls
Documents  Downloads  Pictures  Projects

# Detailed listing with hidden files
$ ls -la
total 116
drwxr-xr-x  19 username username  4096 Mar 15 09:23 .
drwxr-xr-x   3 root     root      4096 Jan 5  10:42 ..
-rw-------   1 username username 12288 Mar 10 20:45 .bash_history
drwxr-xr-x   4 username username  4096 Feb 27 14:32 Documents
drwxr-xr-x   3 username username  4096 Mar 12 16:20 Downloads
drwxr-xr-x   2 username username  4096 Mar 1  17:35 Pictures
drwxr-xr-x   5 username username  4096 Mar 15 09:20 Projects

# Listing with human-readable file sizes
$ ls -lh
total 16K
drwxr-xr-x 4 username username 4.0K Feb 27 14:32 Documents
drwxr-xr-x 3 username username 4.0K Mar 12 16:20 Downloads
drwxr-xr-x 2 username username 4.0K Mar 1  17:35 Pictures
drwxr-xr-x 5 username username 4.0K Mar 15 09:20 Projects
            </code></pre>
            <p>
                Common <code>ls</code> options:
            </p>
            <ul>
                <li><code>-l</code>: Long format with details (permissions, owner, size)</li>
                <li><code>-a</code>: Show all files (including hidden ones)</li>
                <li><code>-h</code>: Human-readable file sizes</li>
                <li><code>-R</code>: Recursive (list subdirectories)</li>
            </ul>
            <p>
                The <code>ls</code> command is like looking around in a room—it shows you what's there without changing anything.
            </p>
            
            <h5>3. <code>cd</code> (Change Directory)</h5>
            <p>
                Changes your current working directory.
            </p>
            <pre><code>
# Go to a specific directory (absolute path)
$ cd /home/username/Projects

# Go to a subdirectory (relative path)
$ cd web-app

# Go up one directory
$ cd ..

# Go to home directory
$ cd ~
# or simply
$ cd

# Go to previous directory
$ cd -
            </code></pre>
            <p>
                The <code>cd</code> command is like physically walking from one room to another—it changes your location in the file system.
            </p>
            
            <h5>4. <code>find</code></h5>
            <p>
                Searches for files and directories.
            </p>
            <pre><code>
# Find all .js files in current directory and subdirectories
$ find . -name "*.js"

# Find directories named "node_modules"
$ find . -type d -name "node_modules"

# Find files modified in the last 24 hours
$ find . -type f -mtime -1
            </code></pre>
            <p>
                The <code>find</code> command is like having a search party that can look through many rooms at once, using specific criteria to locate items.
            </p>
            
            <h5>Windows Equivalents</h5>
            <p>
                If you're using Windows Command Prompt:
            </p>
            <ul>
                <li><code>cd</code> works the same (but use backslashes in paths)</li>
                <li><code>dir</code> instead of <code>ls</code></li>
                <li><code>cd</code> without arguments shows current directory (like <code>pwd</code>)</li>
                <li><code>findstr</code> for simple file searches</li>
            </ul>
            <p>
                In PowerShell, many Unix-like commands are available as aliases:
            </p>
            <ul>
                <li><code>pwd</code> or <code>Get-Location</code></li>
                <li><code>ls</code> or <code>Get-ChildItem</code></li>
                <li><code>cd</code> or <code>Set-Location</code></li>
                <li><code>Get-ChildItem -Recurse -Filter "*.js"</code> (similar to <code>find</code>)</li>
            </ul>
        </section>

        <section class="file_manipulation">
            <h3>File and Directory Manipulation</h3>
            <p>
                Now that you can navigate the file system, let's learn how to create, copy, move, and delete files and directories.
            </p>
            
            <h4>Creating Files and Directories</h4>
            
            <h5>1. <code>mkdir</code> (Make Directory)</h5>
            <p>
                Creates a new directory.
            </p>
            <pre><code>
# Create a single directory
$ mkdir projects

# Create nested directories (with -p option)
$ mkdir -p projects/web-app/src/components
            </code></pre>
            <p>
                The <code>mkdir</code> command is like building new rooms in your file system house.
            </p>
            
            <h5>2. <code>touch</code></h5>
            <p>
                Creates an empty file or updates the timestamp of an existing file.
            </p>
            <pre><code>
# Create a single file
$ touch index.html

# Create multiple files
$ touch index.html style.css app.js
            </code></pre>
            <p>
                The <code>touch</code> command is like placing an empty container in a room, ready to be filled with content later.
            </p>
            
            <h5>3. File Redirection</h5>
            <p>
                Create files with content directly from the command line.
            </p>
            <pre><code>
# Redirect output to a file (overwrites existing content)
$ echo "Hello, World!" > greeting.txt

# Append to a file
$ echo "This is a new line" >> greeting.txt
            </code></pre>
            <p>
                File redirection is like having a direct pipeline from your commands to file storage.
            </p>
            
            <h4>Copying and Moving</h4>
            
            <h5>1. <code>cp</code> (Copy)</h5>
            <p>
                Copies files or directories.
            </p>
            <pre><code>
# Copy a file
$ cp source.txt destination.txt

# Copy a file to another directory
$ cp source.txt destination_directory/

# Copy multiple files
$ cp file1.txt file2.txt destination_directory/

# Copy a directory and its contents recursively
$ cp -r source_directory/ destination_directory/
            </code></pre>
            <p>
                The <code>cp</code> command is like a photocopier—it creates duplicates of files or folders while leaving the originals unchanged.
            </p>
            
            <h5>2. <code>mv</code> (Move)</h5>
            <p>
                Moves or renames files and directories.
            </p>
            <pre><code>
# Rename a file
$ mv oldname.txt newname.txt

# Move a file to another directory
$ mv file.txt destination_directory/

# Move multiple files
$ mv file1.txt file2.txt destination_directory/

# Move and rename in one command
$ mv source/oldname.txt destination/newname.txt
            </code></pre>
            <p>
                The <code>mv</code> command is like physically relocating items—the original is gone from its previous location. When used with the same directory but a different name, it serves as a renaming tool.
            </p>
            
            <h4>Removing Files and Directories</h4>
            
            <h5>1. <code>rm</code> (Remove)</h5>
            <p>
                Deletes files and directories.
            </p>
            <pre><code>
# Remove a file
$ rm file.txt

# Remove multiple files
$ rm file1.txt file2.txt

# Remove a directory and its contents
$ rm -r directory/

# Force removal without confirmation
$ rm -f file.txt

# Combine options (remove directory forcefully)
$ rm -rf directory/
            </code></pre>
            <p>
                <strong>Warning</strong>: Be extremely careful with <code>rm</code>, especially with the <code>-rf</code> flags. There is no "trash bin" or "recycle bin" for the command line—deleted means gone forever.
            </p>
            <p>
                The <code>rm</code> command is like a paper shredder—once something goes through it, recovery is either impossible or very difficult.
            </p>
            
            <h5>2. <code>rmdir</code></h5>
            <p>
                Removes empty directories.
            </p>
            <pre><code>
# Remove an empty directory
$ rmdir empty_directory/
            </code></pre>
            <p>
                This command will fail if the directory contains any files or subdirectories.
            </p>
            
            <h4>Windows Equivalents</h4>
            <p>
                In Command Prompt:
            </p>
            <ul>
                <li><code>mkdir</code> or <code>md</code> for creating directories</li>
                <li><code>copy</code> instead of <code>cp</code></li>
                <li><code>move</code> instead of <code>mv</code></li>
                <li><code>del</code> or <code>erase</code> instead of <code>rm</code> for files</li>
                <li><code>rmdir</code> or <code>rd</code> for directories</li>
            </ul>
            <p>
                In PowerShell:
            </p>
            <ul>
                <li><code>New-Item -ItemType Directory -Path "path\to\dir"</code> or <code>mkdir</code></li>
                <li><code>Copy-Item</code> or <code>cp</code></li>
                <li><code>Move-Item</code> or <code>mv</code></li>
                <li><code>Remove-Item</code> or <code>rm</code></li>
            </ul>
        </section>

        <section class="viewing_files">
            <h3>Viewing File Contents</h3>
            <p>
                The command line offers several ways to examine file contents without opening a full-fledged text editor.
            </p>
            
            <h5>1. <code>cat</code> (Concatenate)</h5>
            <p>
                Displays the entire content of a file.
            </p>
            <pre><code>
# View a single file
$ cat file.txt

# View multiple files sequentially
$ cat file1.txt file2.txt

# View with line numbers
$ cat -n file.txt
            </code></pre>
            <p>
                The <code>cat</code> command is best for small files, as it outputs the entire file at once.
            </p>
            
            <h5>2. <code>less</code></h5>
            <p>
                Allows paginated viewing of files (scrollable).
            </p>
            <pre><code>
$ less large-file.txt
            </code></pre>
            <p>
                Navigation in <code>less</code>:
            </p>
            <ul>
                <li>Arrow keys to scroll</li>
                <li>Space or Page Down to move forward one page</li>
                <li>b or Page Up to move back one page</li>
                <li>/pattern to search forward for "pattern"</li>
                <li>n to find the next occurrence</li>
                <li>q to quit</li>
            </ul>
            <p>
                The <code>less</code> command is ideal for larger files, as it loads only what you're viewing, not the entire file at once.
            </p>
            
            <h5>3. <code>head</code> and <code>tail</code></h5>
            <p>
                Show the beginning or end of a file, respectively.
            </p>
            <pre><code>
# View the first 10 lines (default)
$ head file.txt

# View the first 5 lines
$ head -n 5 file.txt

# View the last 10 lines (default)
$ tail file.txt

# View the last 20 lines
$ tail -n 20 file.txt

# Follow a file as it grows (useful for log files)
$ tail -f server.log
            </code></pre>
            <p>
                These commands are like peeking at just the beginning or end of a book, rather than reading the whole thing.
            </p>
            
            <h5>4. <code>grep</code></h5>
            <p>
                Searches for patterns in files.
            </p>
            <pre><code>
# Search for a word in a file
$ grep "function" app.js

# Case-insensitive search
$ grep -i "error" log.txt

# Show line numbers
$ grep -n "TODO" *.js

# Recursive search in directories
$ grep -r "API_KEY" .

# Show only filenames that match
$ grep -l "class" *.py
            </code></pre>
            <p>
                The <code>grep</code> command is like having a detective who can scan through files looking for specific clues—incredibly useful for finding where certain code elements are defined or used.
            </p>
            
            <h4>Windows Equivalents</h4>
            <p>
                In Command Prompt:
            </p>
            <ul>
                <li><code>type</code> instead of <code>cat</code></li>
                <li><code>more</code> (simpler version of <code>less</code>)</li>
                <li>Windows has no direct equivalent of <code>head</code> and <code>tail</code></li>
                <li><code>findstr</code> instead of <code>grep</code></li>
            </ul>
            <p>
                In PowerShell:
            </p>
            <ul>
                <li><code>Get-Content</code> or <code>cat</code> or <code>gc</code></li>
                <li><code>Get-Content file.txt | more</code> for paging</li>
                <li><code>Get-Content file.txt -Head 10</code> for first 10 lines</li>
                <li><code>Get-Content file.txt -Tail 10</code> for last 10 lines</li>
                <li><code>Select-String</code> or <code>sls</code> (similar to <code>grep</code>)</li>
            </ul>
        </section>

        <section class="redirection">
            <h3>Redirection and Pipes</h3>
            <p>
                The command line becomes truly powerful when you can connect commands together and redirect their output.
            </p>
            
            <h4>Output Redirection</h4>
            <p>
                Directing command output to files:
            </p>
            <pre><code>
# Redirect output to a file (overwrites existing content)
$ ls -l > file_list.txt

# Append output to a file
$ echo "New entry" >> log.txt

# Redirect error messages
$ command 2> errors.log

# Redirect both standard output and errors
$ command > output.log 2>&1
            </code></pre>
            
            <h4>Input Redirection</h4>
            <p>
                Providing file content as input to commands:
            </p>
            <pre><code>
# Use file contents as input
$ sort < unsorted.txt

# Count words in a file
$ wc -w < document.txt
            </code></pre>
            
            <h4>Pipes</h4>
            <p>
                Connecting the output of one command to the input of another:
            </p>
            <pre><code>
# List files and filter for JavaScript files
$ ls | grep ".js"

# Count files in a directory
$ ls -l | wc -l

# Find the 5 largest files
$ ls -lS | head -n 5

# Find all TODOs in JavaScript files
$ grep -r "TODO" . | grep ".js"
            </code></pre>
            <p>
                Pipes are like assembly lines in a factory—the output of one step becomes the input for the next, allowing complex operations to be broken down into simpler components.
            </p>
            
            <h4>Command Substitution</h4>
            <p>
                Using the output of a command as part of another command:
            </p>
            <pre><code>
# Old syntax
$ echo "Today is `date`"

# Modern syntax
$ echo "Today is $(date)"

# Use in variable assignment
$ current_dir=$(pwd)
$ echo "You are in $current_dir"
            </code></pre>
            <p>
                Command substitution is like having a calculator that you can embed directly within a sentence—it computes a value and inserts it right where you need it.
            </p>
        </section>

        <section class="cli_navigation_tips">
            <h3>CLI Navigation Tips and Tricks</h3>
            <p>
                Mastering a few shortcuts and techniques can dramatically improve your command line efficiency:
            </p>
            
            <h4>Keyboard Shortcuts</h4>
            <table>
                <tr>
                    <th>Shortcut</th>
                    <th>Function</th>
                </tr>
                <tr>
                    <td>Up/Down Arrows</td>
                    <td>Navigate command history</td>
                </tr>
                <tr>
                    <td>Ctrl+A</td>
                    <td>Move cursor to beginning of line</td>
                </tr>
                <tr>
                    <td>Ctrl+E</td>
                    <td>Move cursor to end of line</td>
                </tr>
                <tr>
                    <td>Ctrl+L</td>
                    <td>Clear the screen</td>
                </tr>
                <tr>
                    <td>Ctrl+U</td>
                    <td>Cut text from cursor to beginning of line</td>
                </tr>
                <tr>
                    <td>Ctrl+K</td>
                    <td>Cut text from cursor to end of line</td>
                </tr>
                <tr>
                    <td>Ctrl+Y</td>
                    <td>Paste previously cut text</td>
                </tr>
                <tr>
                    <td>Ctrl+R</td>
                    <td>Search command history (reverse search)</td>
                </tr>
                <tr>
                    <td>Ctrl+C</td>
                    <td>Interrupt/cancel the current command</td>
                </tr>
                <tr>
                    <td>Ctrl+D</td>
                    <td>Exit the current shell (or EOF)</td>
                </tr>
                <tr>
                    <td>Tab</td>
                    <td>Auto-complete commands, files, and directories</td>
                </tr>
            </table>
            
            <h4>Wildcards and Patterns</h4>
            <p>
                Using wildcards to match multiple files:
            </p>
            <pre><code>
# All JavaScript files
$ ls *.js

# Any single character
$ ls file?.txt  # Matches file1.txt, fileA.txt, etc.

# Character ranges
$ ls [a-c]*.txt  # Files starting with a, b, or c

# Negation
$ ls [!a-c]*.txt  # Files NOT starting with a, b, or c

# All files in a directory and subdirectories
$ ls **/*.js  # (in some shells)
            </code></pre>
            <p>
                Wildcards are like using a broad description to identify objects—"all the blue books" or "any container that's round"—instead of naming each one individually.
            </p>
            
            <h4>Command History</h4>
            <p>
                Leveraging your command history:
            </p>
            <pre><code>
# View command history
$ history

# Re-run previous command
$ !!

# Re-run specific command from history
$ !42  # Re-runs command number 42

# Re-run last command starting with "git"
$ !git

# Search history interactively
$ Ctrl+R (then type search term)
            </code></pre>
            <p>
                Command history is like having a personal assistant who remembers all your previous instructions and can repeat them on demand.
            </p>
            
            <h4>Path Navigation Shortcuts</h4>
            <pre><code>
# Jump to specific directories using aliases
$ cd ~  # Home directory
$ cd -  # Previous directory
$ cd ../..  # Up two levels

# Create directory aliases (in .bashrc or .zshrc)
alias proj='cd ~/projects'
alias docs='cd ~/documents'
            </code></pre>
            <p>
                Path shortcuts are like having teleportation devices to frequently visited locations, eliminating the need to manually navigate through the file system hierarchy.
            </p>
        </section>

        <section class="cli_customization">
            <h3>Customizing Your Command Line Environment</h3>
            <p>
                The command line is highly customizable, allowing you to create an environment that suits your workflow:
            </p>
            
            <h4>Configuration Files</h4>
            <p>
                Common shell configuration files:
            </p>
            <ul>
                <li><strong>Bash</strong>: <code>~/.bashrc</code>, <code>~/.bash_profile</code></li>
                <li><strong>Zsh</strong>: <code>~/.zshrc</code></li>
                <li><strong>PowerShell</strong>: <code>$PROFILE</code></li>
            </ul>
            <p>
                These files are executed when your shell starts and can contain:
            </p>
            <ul>
                <li>Environment variable settings</li>
                <li>Aliases (command shortcuts)</li>
                <li>Custom functions</li>
                <li>Path configurations</li>
                <li>Prompt customizations</li>
            </ul>
            
            <h4>Creating Aliases</h4>
            <p>
                Aliases are shortcuts for longer commands:
            </p>
            <pre><code>
# Add to your .bashrc or .zshrc
alias ll='ls -la'
alias gs='git status'
alias gp='git pull'
alias gc='git commit -m'
alias python='python3'
alias serve='python -m http.server'
            </code></pre>
            <p>
                After adding aliases, run <code>source ~/.bashrc</code> (or your appropriate config file) to apply changes without restarting your terminal.
            </p>
            <p>
                Aliases are like creating custom buttons on a universal remote—you program them once with complex commands, then use the simple shortcuts repeatedly.
            </p>
            
            <h4>Customizing the Prompt</h4>
            <p>
                The prompt is what appears before each command you type. Customizing it can add useful information:
            </p>
            <pre><code>
# For Bash (add to .bashrc)
# Shows username, hostname, current directory, and git branch
export PS1='\u@\h \[\033[32m\]\w\[\033[33m\]$(__git_ps1 " (%s)")\[\033[00m\] $ '

# For Zsh, many prefer using Oh My Zsh with themes
# Install Oh My Zsh and choose a theme in .zshrc
            </code></pre>
            <p>
                A well-designed prompt is like a dashboard in a car—it displays the most relevant information at a glance, helping you navigate more effectively.
            </p>
        </section>

        <section class="permissions">
            <h3>File Permissions and Ownership</h3>
            <p>
                Understanding file permissions is essential for proper file management and security:
            </p>
            
            <h4>Viewing Permissions</h4>
            <p>
                The <code>ls -l</code> command shows file permissions:
            </p>
            <pre><code>
$ ls -l script.sh
-rwxr-xr--  1 username  groupname  1240 Mar 15 10:32 script.sh
^----------  ----------  ---------  ---- ------------ ---------
|            |            |          |    |            |
Permissions  Owner        Group      Size  Date        Filename
            </code></pre>
            <p>
                Permission string breakdown:
            </p>
            <ul>
                <li>First character: File type (- for regular file, d for directory)</li>
                <li>Next three characters: Owner permissions (r=read, w=write, x=execute)</li>
                <li>Next three characters: Group permissions</li>
                <li>Last three characters: Everyone else (others) permissions</li>
            </ul>
            
            <h4>Changing Permissions</h4>
            <p>
                The <code>chmod</code> command changes file permissions:
            </p>
            <pre><code>
# Symbolic notation
$ chmod u+x script.sh  # Add execute permission for user
$ chmod g-w file.txt   # Remove write permission for group
$ chmod o=r file.txt   # Set others permission to read only
$ chmod a+r file.txt   # Add read permission for all

# Numeric notation
$ chmod 755 script.sh  # rwxr-xr-x
$ chmod 644 file.txt   # rw-r--r--
$ chmod 600 key.pem    # rw-------
            </code></pre>
            <p>
                Common numeric permission patterns:
            </p>
            <ul>
                <li><code>777</code> (rwxrwxrwx): Full permissions for everyone (rarely appropriate)</li>
                <li><code>755</code> (rwxr-xr-x): Owner can do anything, others can read and execute</li>
                <li><code>644</code> (rw-r--r--): Owner can read and write, others can only read</li>
                <li><code>700</code> (rwx------): Owner can do anything, no access for others</li>
                <li><code>600</code> (rw-------): Owner can read and write, no access for others</li>
            </ul>
            
            <h4>Changing Ownership</h4>
            <p>
                The <code>chown</code> command changes file/directory ownership:
            </p>
            <pre><code>
# Change owner
$ chown username file.txt

# Change owner and group
$ chown username:groupname file.txt

# Change recursively for directories
$ chown -R username:groupname directory/
            </code></pre>
            <p>
                The <code>chgrp</code> command changes just the group:
            </p>
            <pre><code>
$ chgrp groupname file.txt
            </code></pre>
            <p>
                Understanding permissions is like knowing the access rules to different rooms in a building—who can enter, who can modify the contents, and who can execute the machinery inside.
            </p>
        </section>

        <section class="cli_practical_examples">
            <h3>Practical Examples for Web Developers</h3>
            <p>
                Let's explore some real-world examples of how these commands can be used in web development workflows:
            </p>
            
            <h4>Setting Up a New Project</h4>
            <pre><code>
# Create project directory structure
$ mkdir -p my-project/{src/{components,assets,styles},public,scripts}
$ cd my-project

# Initialize git repository
$ git init

# Create initial files
$ touch src/index.js
$ touch src/styles/main.css
$ touch public/index.html
$ touch README.md

# Initialize npm project
$ npm init -y

# Initialize Python virtual environment
$ python -m venv venv
            </code></pre>
            
            <h4>Working with Files in a Project</h4>
            <pre><code>
# Find all TODO comments in JavaScript files
$ grep -r "TODO" --include="*.js" .

# Count lines of code by file type
$ find . -name "*.js" | xargs wc -l
$ find . -name "*.css" | xargs wc -l
$ find . -name "*.html" | xargs wc -l

# Find large files that might need optimization
$ find . -type f -size +1M

# Replace a string in multiple files
$ grep -l "oldFunction" --include="*.js" . | xargs sed -i 's/oldFunction/newFunction/g'

# Check which files would be affected before making changes
$ grep -l "oldFunction" --include="*.js" .
            </code></pre>
            
            <h4>Managing Dependencies</h4>
            <pre><code>
# Find and remove node_modules directories to save space
$ find . -name "node_modules" -type d -prune -exec rm -rf {} \;

# Check for outdated npm packages
$ npm outdated

# List all installed Python packages
$ pip list

# Create requirements file
$ pip freeze > requirements.txt
            </code></pre>
            
            <h4>Deployment and Server Tasks</h4>
            <pre><code>
# Build and deploy in one command
$ npm run build && scp -r dist/* user@server:/var/www/mysite/

# Monitor logs in real-time
$ ssh user@server 'tail -f /var/log/nginx/access.log'

# Check server disk usage
$ ssh user@server 'df -h'

# Simple HTTP server for testing
$ cd dist && python -m http.server 8000
            </code></pre>
            
            <h4>File Processing</h4>
            <pre><code>
# Batch resize images with ImageMagick
$ for file in *.jpg; do convert "$file" -resize 800x600 "resized-$file"; done

# Combine multiple CSS files into one
$ cat src/styles/*.css > dist/styles.css

# Convert Markdown to HTML with Pandoc
$ for file in *.md; do pandoc "$file" -o "${file%.md}.html"; done

# Extract all URLs from an HTML file
$ grep -o 'https://[^"]*' index.html
            </code></pre>
            <p>
                These examples demonstrate how the command line can automate tedious tasks, process multiple files at once, and integrate different tools into a seamless workflow—capabilities that would be cumbersome or impossible through graphical interfaces alone.
            </p>
        </section>

        <section class="windows_considerations">
            <h3>Special Considerations for Windows Users</h3>
            <p>
                If you're using Windows for web development, there are a few special considerations to be aware of:
            </p>
            
            <h4>WSL: Windows Subsystem for Linux</h4>
            <p>
                WSL provides a Linux environment directly integrated with Windows:
            </p>
            <ul>
                <li>Lets you use Bash and Linux tools directly in Windows</li>
                <li>Available in Windows 10 and later</li>
                <li>WSL 2 offers improved performance with a real Linux kernel</li>
                <li>Enables seamless development with Linux-first tools while staying in Windows</li>
            </ul>
            <pre><code>
# Install WSL from PowerShell (as Administrator)
> wsl --install

# List available Linux distributions
> wsl --list --online

# Install a specific distribution
> wsl --install -d Ubuntu-20.04
            </code></pre>
            <p>
                WSL is highly recommended for web development on Windows, as it provides the best of both worlds—Windows applications and Linux command line tools.
            </p>
            
            <h4>Path Differences</h4>
            <p>
                Windows paths use backslashes, while Unix-like systems use forward slashes:
            </p>
            <ul>
                <li>Windows: <code>C:\Users\Username\Documents\Project</code></li>
                <li>Unix-like: <code>/home/username/documents/project</code></li>
            </ul>
            <p>
                Modern Windows tools are becoming more flexible:
            </p>
            <ul>
                <li>PowerShell accepts both forward and backslashes</li>
                <li>WSL uses Unix-style paths</li>
                <li>In Command Prompt, you still need to use backslashes</li>
            </ul>
            
            <h4>Line Endings</h4>
            <p>
                Different operating systems use different line ending characters:
            </p>
            <ul>
                <li>Windows: CR+LF (Carriage Return + Line Feed, \r\n)</li>
                <li>Unix/Linux/macOS: LF (Line Feed, \n)</li>
            </ul>
            <p>
                This can cause issues when sharing text files between systems. Configure Git to handle line endings:
            </p>
            <pre><code>
# Configure Git to normalize line endings
$ git config --global core.autocrlf true  # On Windows
$ git config --global core.autocrlf input  # On Unix-like systems
            </code></pre>
            
            <h4>PowerShell as an Alternative</h4>
            <p>
                PowerShell offers many Unix-like capabilities with Windows integration:
            </p>
            <ul>
                <li>Object-oriented approach (commands return objects, not just text)</li>
                <li>Aliased Unix-like commands (ls, cat, etc.)</li>
                <li>Powerful scripting capabilities</li>
                <li>Access to .NET framework</li>
            </ul>
            <pre><code>
# PowerShell example: Find large files, sort by size, and format output
PS> Get-ChildItem -Recurse | Where-Object { $_.Length -gt 1MB } | 
    Sort-Object -Property Length -Descending | 
    Select-Object Name, @{Name="SizeInMB";Expression={$_.Length / 1MB}} | 
    Format-Table -AutoSize
            </code></pre>
            <p>
                PowerShell is worth learning for Windows-specific tasks, though WSL is often preferred for web development due to compatibility with Unix-centric tools and tutorials.
            </p>
        </section>

        <section class="common_mistakes">
            <h3>Common Mistakes and How to Avoid Them</h3>
            <p>
                As you start working with the command line, watch out for these common pitfalls:
            </p>
            
            <h4>Destructive Commands</h4>
            <ul>
                <li>
                    <strong>Running <code>rm -rf</code> carelessly</strong>: This can delete entire directories without confirmation
                    <ul>
                        <li>Always double-check paths before running destructive commands</li>
                        <li>Consider using <code>rm -i</code> for interactive deletion with confirmation</li>
                        <li>Never run <code>rm -rf /</code> or <code>rm -rf /*</code> (deletes everything from root)</li>
                    </ul>
                </li>
                <li>
                    <strong>Overwriting files with redirection</strong>: <code>></code> overwrites files without warning
                    <ul>
                        <li>Use <code>>></code> to append instead when appropriate</li>
                        <li>Check file existence before redirecting: <code>[ -f file.txt ] && echo "File exists"</code></li>
                    </ul>
                </li>
            </ul>
            
            <h4>Path and Permission Issues</h4>
            <ul>
                <li>
                    <strong>Forgetting to use relative/absolute paths correctly</strong>
                    <ul>
                        <li>Remember that <code>cd folder</code> looks for "folder" in current directory</li>
                        <li>Use <code>pwd</code> to check current location if uncertain</li>
                    </ul>
                </li>
                <li>
                    <strong>Permission denied errors</strong>
                    <ul>
                        <li>Check file ownership: <code>ls -l filename</code></li>
                        <li>Use <code>chmod</code> to update permissions when needed</li>
                        <li>Use <code>sudo</code> judiciously (only when necessary)</li>
                    </ul>
                </li>
            </ul>
            
            <h4>Command Syntax Errors</h4>
            <ul>
                <li>
                    <strong>Mixing up command options</strong>
                    <ul>
                        <li>Use <code>man command</code> or <code>command --help</code> to check options</li>
                        <li>Start with simpler commands and build up complexity</li>
                    </ul>
                </li>
                <li>
                    <strong>Forgetting quotes around filenames with spaces</strong>
                    <ul>
                        <li>Use quotes: <code>ls "My Documents"</code></li>
                        <li>Or escape spaces: <code>ls My\ Documents</code></li>
                        <li>Better yet, avoid spaces in filenames for command line work</li>
                    </ul>
                </li>
            </ul>
            
            <h4>Recovery Strategies</h4>
            <p>
                If you make a mistake:
            </p>
            <ul>
                <li>Use <code>Ctrl+C</code> to cancel commands that are running</li>
                <li>Check what happened with <code>ls</code>, <code>pwd</code>, or other inspection commands</li>
                <li>For accidental file deletion, stop using the disk immediately (further operations might overwrite data)</li>
                <li>When in doubt about a command, try it on a test file or directory first</li>
                <li>Maintain backups of important files</li>
            </ul>
        </section>

        <section class="resources">
            <h3>Learning Resources</h3>
            <p>
                To continue developing your command line skills:
            </p>
            
            <h4>Online Documentation and Tutorials</h4>
            <ul>
                <li><a href="https://linuxcommand.org/" target="_blank">LinuxCommand.org</a> - Excellent introduction to the command line</li>
                <li><a href="https://www.gnu.org/software/bash/manual/bash.html" target="_blank">Bash Reference Manual</a> - Official documentation</li>
                <li><a href="https://ss64.com/" target="_blank">SS64</a> - Command reference for various shells</li>
                <li><a href="https://www.shellscript.sh/" target="_blank">Shell Scripting Tutorial</a> - For advancing to shell scripting</li>
                <li><a href="https://explainshell.com/" target="_blank">ExplainShell</a> - Explains command parts interactively</li>
            </ul>
            
            <h4>Interactive Learning</h4>
            <ul>
                <li><a href="https://www.learnshell.org/" target="_blank">LearnShell.org</a> - Interactive shell tutorials</li>
                <li><a href="https://cmdchallenge.com/" target="_blank">CMD Challenge</a> - Command line puzzles to test skills</li>
                <li><a href="https://overthewire.org/wargames/bandit/" target="_blank">Over The Wire: Bandit</a> - Security-focused command line learning</li>
            </ul>
            
            <h4>Books</h4>
            <ul>
                <li>"The Linux Command Line" by William Shotts</li>
                <li>"Learning the bash Shell" by Cameron Newham</li>
                <li>"PowerShell in a Month of Lunches" by Don Jones (for Windows users)</li>
            </ul>
            
            <h4>Cheat Sheets</h4>
            <ul>
                <li><a href="https://github.com/RehanSaeed/Bash-Cheat-Sheet" target="_blank">Bash Cheat Sheet</a></li>
                <li><a href="https://devhints.io/bash" target="_blank">Bash Scripting Cheatsheet</a></li>
                <li><a href="https://github.com/jlevy/the-art-of-command-line" target="_blank">The Art of Command Line</a></li>
            </ul>
        </section>

        <section class="practical_exercise">
            <h3>Practical Exercise: CLI Navigation Challenge</h3>
            <p>
                Let's practice what we've learned with a practical exercise:
            </p>
            
            <h4>Exercise Setup</h4>
            <p>
                Copy and paste these commands to set up the exercise (or use the provided setup script):
            </p>
            <pre><code>
# Create directory structure
mkdir -p cli_practice/{project1/{src,dist,docs},project2/{public,src/{components,assets}},logs}

# Create sample files
touch cli_practice/project1/src/{index.js,app.js,styles.css}
touch cli_practice/project1/README.md
touch cli_practice/project2/src/components/{Header.js,Footer.js,Sidebar.js}
touch cli_practice/project2/src/assets/{logo.svg,background.jpg}
touch cli_practice/project2/public/index.html
echo "This is a log entry at $(date)" > cli_practice/logs/app.log
echo "ERROR: Something went wrong at $(date)" >> cli_practice/logs/app.log
echo "INFO: System recovered at $(date)" >> cli_practice/logs/app.log

# Change to the starting directory
cd cli_practice
            </code></pre>
            
            <h4>Navigation and Information Gathering Tasks</h4>
            <ol>
                <li>From the <code>cli_practice</code> directory, list all subdirectories (not files)</li>
                <li>Navigate to <code>project2/src/components</code> and list all JavaScript files</li>
                <li>Without changing directories, count how many files are in <code>project1/src</code></li>
                <li>Navigate back to the <code>cli_practice</code> directory using an absolute path</li>
                <li>Find all JavaScript files in the entire directory structure</li>
                <li>Count the number of lines in the log file</li>
                <li>Search the log file for entries containing "ERROR"</li>
            </ol>
            
            <h4>File Manipulation Tasks</h4>
            <ol>
                <li>Create a new directory called <code>project3/config</code> in one command</li>
                <li>Create a file called <code>settings.json</code> in the new config directory</li>
                <li>Add the text <code>{"version": "1.0", "environment": "development"}</code> to the settings file</li>
                <li>Copy the <code>README.md</code> from <code>project1</code> to <code>project3</code></li>
                <li>Rename <code>project3/README.md</code> to <code>project3/DOCUMENTATION.md</code></li>
                <li>Create a backup of the log file called <code>app.log.bak</code></li>
            </ol>
            
            <h4>Challenge Pipe and Redirection Tasks</h4>
            <ol>
                <li>Count how many files (not directories) exist in the entire directory structure</li>
                <li>Create a file called <code>file_list.txt</code> containing the names of all <code>.js</code> files</li>
                <li>Append the current date and time to <code>file_list.txt</code></li>
                <li>Find all lines in the log file containing "ERROR" or "INFO" and save them to <code>filtered_logs.txt</code></li>
            </ol>
            
            <h4>Solutions</h4>
            <p>
                Try solving these challenges on your own first! Here are the solutions to check your work:
            </p>
            <pre><code>
# Navigation and Information Gathering Solutions
1. ls -d */
2. cd project2/src/components && ls *.js
3. ls -l ../../../project1/src | wc -l
4. cd /absolute/path/to/cli_practice
   # or
   cd ~/cli_practice
5. find . -name "*.js"
6. wc -l logs/app.log
7. grep "ERROR" logs/app.log

# File Manipulation Solutions
1. mkdir -p project3/config
2. touch project3/config/settings.json
3. echo '{"version": "1.0", "environment": "development"}' > project3/config/settings.json
4. cp project1/README.md project3/
5. mv project3/README.md project3/DOCUMENTATION.md
6. cp logs/app.log logs/app.log.bak

# Challenge Pipe and Redirection Solutions
1. find . -type f | wc -l
2. find . -name "*.js" > file_list.txt
3. date >> file_list.txt
4. grep -E "ERROR|INFO" logs/app.log > filtered_logs.txt
            </code></pre>
        </section>

        <section class="conclusion">
            <h3>Conclusion: Building Your CLI Foundation</h3>
            <p>
                The command line interface is a powerful tool that will significantly enhance your capabilities as a web developer. While the learning curve might seem steep at first, the efficiency and control you gain are well worth the investment.
            </p>
            <p>
                Remember that mastering the CLI is an ongoing journey—you'll continue to learn new commands, shortcuts, and techniques throughout your career. Start with the basics we've covered today, practice regularly, and gradually incorporate more advanced techniques into your workflow.
            </p>
            <p>
                As you become more comfortable with the command line, you'll find yourself able to:
            </p>
            <ul>
                <li>Navigate complex project structures with ease</li>
                <li>Automate repetitive tasks</li>
                <li>Perform operations that would be cumbersome or impossible via GUI</li>
                <li>Efficiently manage remote servers and cloud resources</li>
                <li>Integrate various development tools into cohesive workflows</li>
            </ul>
            <p>
                In our next sessions, we'll build upon this foundation as we explore version control with Git, which relies heavily on command line operations. The CLI skills you develop now will serve as building blocks for more advanced topics throughout the course.
            </p>
        </section>

        <section class="assignment">
            <h3>Assignment: Command Line Proficiency</h3>
            <p>
                To reinforce your command line skills, complete the following tasks:
            </p>
            <ol>
                <li>
                    <strong>Directory Explorer</strong>:
                    <ul>
                        <li>Create a shell script called <code>explorer.sh</code> that accepts a directory path as an argument</li>
                        <li>The script should output:
                            <ul>
                                <li>The total number of files and directories</li>
                                <li>The disk space used by the directory</li>
                                <li>A count of files by type (extension)</li>
                                <li>The 5 largest files with their sizes</li>
                            </ul>
                        </li>
                        <li>Make the script executable and test it on different directories</li>
                    </ul>
                </li>
                <li>
                    <strong>Web Project Setup</strong>:
                    <ul>
                        <li>Using only the command line, create a directory structure for a web project with:
                            <ul>
                                <li>Folders for HTML, CSS, JavaScript, images, and fonts</li>
                                <li>Basic HTML file linking to CSS and JS</li>
                                <li>A README.md file with project description</li>
                                <li>A .gitignore file with common exclusions</li>
                            </ul>
                        </li>
                        <li>Bonus: Initialize a Git repository and make the initial commit</li>
                    </ul>
                </li>
                <li>
                    <strong>Log File Analyzer</strong>:
                    <ul>
                        <li>Download the sample log file provided in the course materials</li>
                        <li>Using only command line tools:
                            <ul>
                                <li>Count the total number of requests</li>
                                <li>Find the most common HTTP status code</li>
                                <li>Identify the top 5 IP addresses by request count</li>
                                <li>Extract all requests that resulted in a 404 status</li>
                                <li>Determine the hour of day with the most traffic</li>
                            </ul>
                        </li>
                        <li>Document the commands you used and their output</li>
                    </ul>
                </li>
                <li>
                    <strong>Command Line Journal</strong>:
                    <ul>
                        <li>Create a file called <code>cli_journal.md</code></li>
                        <li>For one week, add at least 3 new commands you've learned each day</li>
                        <li>For each command, include:
                            <ul>
                                <li>Basic syntax and common options</li>
                                <li>A practical example of how you used it</li>
                                <li>Any challenges you encountered</li>
                            </ul>
                        </li>
                        <li>By the end, you should have documented at least 15 useful commands</li>
                    </ul>
                </li>
            </ol>
            <p>
                Submit your completed assignment files before the next class session. The goal is not just to complete the tasks, but to become more comfortable navigating and manipulating your system through the command line.
            </p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course</p>
    </footer>
</body>
</html>
