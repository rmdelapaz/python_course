<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Version Control</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Introduction to Version Control</h1>
        <p class="subtitle">Week 1 - Tuesday Morning: Full Stack Web Development with Python</p>
    </header>

    <main>
        <section>
            <h2>Understanding Version Control</h2>
            
            <p>Imagine you're writing a novel. You draft your first chapter, then revise it several times. You try a different approach to chapter two, but aren't sure if it's better than your original idea. Later, you decide to completely rewrite the beginning, but want to keep your earlier version just in case. Soon, you have dozens of files named "novel_draft1.doc", "novel_final.doc", "novel_REALLY_final.doc", "novel_FINAL_FINAL_v2.doc"... Sound familiar?</p>
            
            <p>Version control systems solve this exact problem for code. They track changes to files over time, allowing you to:</p>
            <ul>
                <li>Maintain a complete history of changes</li>
                <li>Work on different versions simultaneously</li>
                <li>Revert to previous states if needed</li>
                <li>Understand when, why, and by whom changes were made</li>
                <li>Collaborate with others without overwriting each other's work</li>
            </ul>
            
            <p>Think of version control as a sophisticated time machine for your code—it allows you to save snapshots of your project at different points in time and travel back to any of them whenever necessary.</p>
            
            <h3>Types of Version Control Systems</h3>
            <p>Version control has evolved over time:</p>
            
            <h4>Local Version Control</h4>
            <p>The simplest form involves keeping copies of files on your local machine, often with date or version numbers in filenames. This approach is error-prone and inefficient, especially for collaborative work.</p>
            
            <h4>Centralized Version Control</h4>
            <p>Systems like SVN (Subversion) use a central server that contains all versioned files. Developers check out files from this central location. While better than local systems, they have a single point of failure—if the central server goes down, no one can collaborate or save versioned changes.</p>
            
            <h4>Distributed Version Control</h4>
            <p>Modern systems like Git are distributed, meaning every developer has a full copy of the repository, including its complete history. This approach offers significant advantages:</p>
            <ul>
                <li>Working offline (you have the full history locally)</li>
                <li>Faster operations (many commands don't need network access)</li>
                <li>No single point of failure</li>
                <li>Multiple backup copies distributed across developers</li>
                <li>More flexible workflows for collaboration</li>
            </ul>
            
            <p>Git has become the dominant version control system in software development, and it's what we'll focus on in this course.</p>
        </section>

        <section>
            <h2>Why Version Control Matters</h2>
            
            <p>For new developers, the importance of version control might not be immediately obvious. After all, if you're working alone on small projects, couldn't you just make backup copies? Let me share some real-world scenarios that highlight why version control is indispensable:</p>
            
            <h3>Scenario 1: The Broken Feature</h3>
            <p>You've spent all day implementing a new feature. Everything worked perfectly until you made "one small change" that somehow broke the entire application. Without version control, you're faced with tedious manual debugging or starting over. With Git, you can simply revert to the last working state and try again with a different approach.</p>
            
            <p><strong>Example:</strong> You're building a user registration system for a web application. After implementing the basic functionality, you decide to add password strength validation. Somehow, this change breaks the entire registration process. With Git, you can compare your current code to the previous working version, see exactly what changed, and either fix the issue or revert to the working state.</p>
            
            <h3>Scenario 2: The Parallel Development</h3>
            <p>You're working on a long-term feature that will take several days to complete. Suddenly, you discover a critical bug that needs immediate attention. Without version control, you'd have to either finish the feature first or save your work somewhere else. With Git, you can create a branch to fix the bug, then return to your feature work seamlessly.</p>
            
            <p><strong>Example:</strong> While developing an e-commerce checkout process, you get an urgent message that users can't log in to their accounts. With Git, you can commit your in-progress checkout code, switch to a new branch to fix the login bug, deploy the fix, and then switch back to continue working on the checkout feature exactly where you left off.</p>
            
            <h3>Scenario 3: The Collaboration Challenge</h3>
            <p>You and a colleague are both working on the same project. You've implemented a login system while they've built the user profile page. Without version control, integrating these changes could be a manual, error-prone process of copying and pasting code. With Git, you can merge these changes automatically, dealing only with actual conflicts.</p>
            
            <p><strong>Example:</strong> You're working on a team building a social media platform. You're responsible for the posting functionality, while your colleague handles user authentication. When it's time to integrate your work, Git can automatically combine both sets of changes, flagging only the specific areas where you might have modified the same files in conflicting ways.</p>
            
            <h3>Scenario 4: The "What Changed?" Mystery</h3>
            <p>A feature that worked perfectly last month is now broken, and no one knows why. Without version control, you might have to rely on memory or incomplete documentation to figure out what changed. With Git, you can see exactly what changed, when, and by whom.</p>
            
            <p><strong>Example:</strong> Your application's file upload functionality suddenly stops working. By using Git's history and comparison tools, you can trace exactly when the feature broke, see what code changes were made around that time, and identify that a seemingly unrelated change to the server configuration caused the issue.</p>
            
            <h3>Real-World Examples</h3>
            <p>Every major software project uses version control. Here are some examples:</p>
            <ul>
                <li>The Linux kernel is maintained by thousands of developers worldwide, all coordinating through Git</li>
                <li>Popular Python frameworks like Django and Flask manage contributions from hundreds of developers using Git</li>
                <li>Companies like Google, Microsoft, and Amazon use Git to manage codebases with millions of lines of code</li>
                <li>Even non-code projects like legal documents, research papers, and books (including this course material!) are often managed with version control</li>
            </ul>
            
            <p>Version control isn't just a tool for large teams or complex projects—it's a fundamental practice that will make you more efficient and effective as a developer, even when working on small personal projects.</p>
        </section>

        <section>
            <h2>Introduction to Git</h2>
            
            <p>Git was created by Linus Torvalds in 2005 for the development of the Linux kernel. He needed a distributed version control system that could handle large projects with speed and efficiency. Since then, Git has grown to become the most widely used version control system in the world.</p>
            
            <h3>Key Characteristics of Git</h3>
            <ul>
                <li><strong>Distributed</strong>: Every developer has a complete copy of the repository</li>
                <li><strong>Speed</strong>: Most operations are local and therefore very fast</li>
                <li><strong>Data integrity</strong>: Git uses checksums to ensure data consistency</li>
                <li><strong>Staging area</strong>: Provides an intermediate step between working files and committed changes</li>
                <li><strong>Branching</strong>: Lightweight, flexible branching and merging capabilities</li>
                <li><strong>Non-linear development</strong>: Supports parallel work through branching and merging</li>
            </ul>
            
            <h3>How Git Stores Data</h3>
            <p>Understanding how Git stores information helps explain its behavior:</p>
            
            <h4>Snapshots, Not Differences</h4>
            <p>While many version control systems store changes as differences (or "deltas") between versions, Git stores each version as a complete snapshot of all tracked files. This makes retrieving old versions very fast, as Git doesn't need to reconstruct them by applying a series of changes.</p>
            
            <h4>Content-Addressable Storage</h4>
            <p>Git uses a content-addressable filesystem. This means that the content of files is hashed using SHA-1, and the hash becomes the identifier for the file in Git's database. This approach ensures data integrity—even a small change results in a completely different hash.</p>
            
            <h4>Three States of Files</h4>
            <p>In Git, files exist in one of three states:</p>
            <ul>
                <li><strong>Modified</strong>: You've changed the file, but haven't committed it yet</li>
                <li><strong>Staged</strong>: You've marked a modified file to go into your next commit</li>
                <li><strong>Committed</strong>: The file is safely stored in your local database</li>
            </ul>
            
            <p>This leads to the three main sections of a Git project:</p>
            <ul>
                <li><strong>Working directory</strong>: Where you modify files</li>
                <li><strong>Staging area</strong> (or index): Where you prepare changes for committing</li>
                <li><strong>Git directory</strong> (repository): Where Git stores your project's history</li>
            </ul>
            
            <p>This staging area concept is one of Git's unique features, allowing you to craft commits that group related changes together, even if you're working on multiple features simultaneously.</p>
        </section>

        <section>
            <h2>Git Fundamentals</h2>
            
            <h3>Core Concepts</h3>
            <p>Before diving into commands, let's understand some fundamental Git concepts:</p>
            
            <h4>Repository (Repo)</h4>
            <p>A repository is a collection of files and the history of changes made to those files. It contains the complete history of the project, along with metadata about who changed what and when. Repositories can be local (on your computer) or remote (on a server like GitHub).</p>
            
            <p>In the physical world, think of a repository as a project folder with a special hidden section that contains all previous versions of every file, like a filing cabinet with a complete historical archive built in.</p>
            
            <h4>Commit</h4>
            <p>A commit is a snapshot of your files at a specific point in time. Think of it as saving a milestone in your project. Each commit has:</p>
            <ul>
                <li>A unique identifier (hash) that looks like <code>a1b2c3d...</code></li>
                <li>A message describing what changed</li>
                <li>Information about who made the commit and when</li>
                <li>A reference to the previous commit(s)</li>
            </ul>
            
            <p>Think of commits as photographs taken at different stages of building a house. Each photo (commit) shows the state of the house at that point, and looking through them in sequence shows how the house evolved.</p>
            
            <h4>Branch</h4>
            <p>Branches allow parallel lines of development. The main branch (often called "main" or "master") represents the official project. Creating a branch is like creating an alternate timeline where you can make changes without affecting the main timeline.</p>
            
            <p>Imagine you're writing a choose-your-own-adventure story. The main branch is the primary storyline, while feature branches are alternate paths you're exploring. Eventually, these paths might rejoin the main story (through merging).</p>
            
            <div style="text-align: center; margin: 20px 0;">
                <img src="https://git-scm.com/book/en/v2/images/basic-branching-1.png" alt="Basic Git branching" style="max-width: 90%; height: auto;">
                <p><small>Image source: Git documentation</small></p>
            </div>
            
            <h4>Staging Area</h4>
            <p>Git has a unique intermediate area called the "staging area" or "index". Before committing changes, you select which changes to include. This is like preparing ingredients before cooking—you might not use everything you've taken out of the refrigerator.</p>
            
            <p>This feature lets you create logical, well-organized commits even when you have multiple modifications across different features or bug fixes.</p>
            
            <h4>Working Directory</h4>
            <p>This is where you actually edit files. Changes here are initially "untracked" until you tell Git to pay attention to them. It's your active workspace where you create, edit, delete, and organize files.</p>
        </section>

        <section>
            <h2>The Git Workflow</h2>
            
            <p>Now that we understand the key concepts, let's walk through the basic Git workflow. This is the cycle you'll follow countless times in your development career:</p>
            
            <ol>
                <li><strong>Modify</strong> files in your working directory</li>
                <li><strong>Stage</strong> the changes you want to include in your next commit</li>
                <li><strong>Commit</strong> your staged changes to create a permanent snapshot</li>
                <li><strong>Repeat</strong> the process as you continue development</li>
            </ol>
            
            <p>Let's examine this workflow visually:</p>
            
            <div style="text-align: center; margin: 20px 0;">
                <img src="https://git-scm.com/book/en/v2/images/areas.png" alt="Git workflow areas" style="max-width: 90%; height: auto;">
                <p><small>Image source: Git documentation</small></p>
            </div>
            
            <h3>Extended Workflow with Remote Repositories</h3>
            <p>When working with a team or storing your code on a service like GitHub, the workflow expands to include:</p>
            
            <ol>
                <li><strong>Pull</strong> the latest changes from the remote repository</li>
                <li><strong>Modify</strong> files in your working directory</li>
                <li><strong>Stage</strong> your changes</li>
                <li><strong>Commit</strong> your staged changes</li>
                <li><strong>Push</strong> your commits to the remote repository</li>
            </ol>
            
            <p>This cycle ensures that you're working with the latest code and sharing your changes with the team.</p>
            
            <h3>Branching Workflow</h3>
            <p>For more complex development, a branching workflow might look like:</p>
            
            <ol>
                <li><strong>Create</strong> a new branch for a feature or bug fix</li>
                <li><strong>Make</strong> changes, stage, and commit them on this branch</li>
                <li><strong>Switch</strong> back to the main branch when needed</li>
                <li><strong>Merge</strong> your feature branch into the main branch when complete</li>
                <li><strong>Delete</strong> the feature branch once it's merged</li>
            </ol>
            
            <p>This approach allows you to work on multiple features in parallel without them interfering with each other or with the stable main branch.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Full Stack Python Web Development Course</p>
    </footer>
</body>
</html>
