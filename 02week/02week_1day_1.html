<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Fundamentals and Virtual Environments</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Fundamentals and Virtual Environments</h1>
        <p class="subtitle">Week 2 - Monday: Full Stack Web Development with Python</p>
    </header>

    <main>
        <section>
            <h2>Introduction to Week 2</h2>
            <p>Welcome to Week 2 of our Full Stack Web Development course! Last week, we established a solid foundation by learning about web fundamentals, version control with Git, and containerization with Docker. We concluded by setting up a project structure for our blog application.</p>
            
            <p>This week, we'll focus on Python and Flask, building the core functionality of our web application. Today, we'll start by reviewing Python fundamentals that are essential for web development and learn about virtual environments, which help us manage dependencies for our projects.</p>
            
            <p>Even if you've used Python before, this refresher will ensure we're all on the same page and highlight aspects of the language that are particularly relevant for web development.</p>
        </section>

        <section>
            <h2>Python for Web Development</h2>
            
            <p>Python has become one of the most popular languages for web development due to its readability, versatility, and the robust ecosystem of libraries and frameworks available. Here's why Python is an excellent choice for web development:</p>
            
            <h3>Advantages of Python for Web Development</h3>
            <ul>
                <li><strong>Readability</strong>: Python's clean syntax makes it easier to write and maintain code</li>
                <li><strong>Rapid Development</strong>: Python allows for faster development cycles</li>
                <li><strong>Versatility</strong>: Python can be used for both frontend and backend development</li>
                <li><strong>Robust Ecosystem</strong>: Python has numerous libraries and frameworks for web development (Flask, Django, FastAPI)</li>
                <li><strong>Strong Community</strong>: A large, active community provides support and resources</li>
                <li><strong>Integration Capabilities</strong>: Python works well with other languages and systems</li>
            </ul>
            
            <h3>Python Web Frameworks</h3>
            <p>Python offers several frameworks for web development, each with its own strengths:</p>
            <ul>
                <li><strong>Flask</strong>: A lightweight, flexible microframework that gives developers more control</li>
                <li><strong>Django</strong>: A full-featured framework with "batteries included" for rapid development</li>
                <li><strong>FastAPI</strong>: A modern, high-performance framework specialized for building APIs</li>
                <li><strong>Pyramid</strong>: A flexible framework that can start small and scale up</li>
            </ul>
            
            <p>In this course, we'll focus on Flask because it provides a good balance between simplicity and functionality. Flask doesn't impose a particular project structure or dependencies, allowing us to learn web development concepts from the ground up.</p>
        </section>

        <section>
            <h2>Python Fundamentals Review</h2>
            
            <p>Let's review some Python fundamentals that are particularly important for web development.</p>
            
            <h3>Variables and Data Types</h3>
            <pre><code>
# Basic data types
name = "John Doe"  # String
age = 30           # Integer
height = 1.85      # Float
is_student = True  # Boolean

# Collections
fruits = ["apple", "banana", "cherry"]  # List (mutable)
coordinates = (10.0, 20.0)              # Tuple (immutable)
user = {"name": "John", "age": 30}      # Dictionary (key-value pairs)
unique_colors = {"red", "green", "blue"} # Set (unique elements)
            </code></pre>
            
            <h3>Control Flow</h3>
            <pre><code>
# Conditional statements
if age >= 18:
    print("You are an adult")
elif age >= 13:
    print("You are a teenager")
else:
    print("You are a child")

# Loops
for fruit in fruits:
    print(f"I like {fruit}")

count = 0
while count < 5:
    print(f"Count is {count}")
    count += 1
            </code></pre>
            
            <h3>Functions</h3>
            <pre><code>
# Basic function
def greet(name):
    return f"Hello, {name}!"

# Function with default parameter
def greet_with_time(name, time_of_day="morning"):
    return f"Good {time_of_day}, {name}!"

# Function with multiple parameters
def calculate_total(price, tax_rate=0.1, discount=0):
    tax = price * tax_rate
    discounted_price = price - discount
    return discounted_price + tax

# Lambda function (anonymous function)
square = lambda x: x ** 2
            </code></pre>
            
            <h3>Classes and Objects</h3>
            <pre><code>
# Basic class definition
class User:
    def __init__(self, username, email):
        self.username = username
        self.email = email
        self.is_active = True
    
    def deactivate(self):
        self.is_active = False
    
    def __str__(self):
        status = "active" if self.is_active else "inactive"
        return f"{self.username} ({status})"

# Creating and using objects
new_user = User("johndoe", "john@example.com")
print(new_user)  # "johndoe (active)"
new_user.deactivate()
print(new_user)  # "johndoe (inactive)"
            </code></pre>
            
            <h3>Modules and Packages</h3>
            <pre><code>
# Importing a standard library module
import datetime

current_time = datetime.datetime.now()
print(f"Current time: {current_time}")

# Importing specific items from a module
from math import sqrt, pi

circle_area = pi * sqrt(4)

# Aliasing imports
import pandas as pd
import numpy as np

# Creating a module (in file mymodule.py)
# def greet(name):
#     return f"Hello, {name}!"
# 
# PI = 3.14159

# Importing custom module
# import mymodule
# print(mymodule.greet("Alice"))
# print(mymodule.PI)
            </code></pre>
            
            <h3>Context Managers</h3>
            <pre><code>
# File handling with context manager
with open("example.txt", "w") as file:
    file.write("Hello, World!")

# Reading a file
with open("example.txt", "r") as file:
    content = file.read()
    print(content)  # "Hello, World!"
            </code></pre>
            
            <h3>Exception Handling</h3>
            <pre><code>
# Basic exception handling
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")

# Handling multiple exceptions
try:
    value = int("abc")
except ValueError:
    print("Invalid integer")
except Exception as e:
    print(f"An unexpected error occurred: {e}")
finally:
    print("This runs whether there's an exception or not")

# Raising exceptions
def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
            </code></pre>
            
            <h3>List Comprehensions</h3>
            <pre><code>
# Basic list comprehension
numbers = [1, 2, 3, 4, 5]
squares = [x**2 for x in numbers]  # [1, 4, 9, 16, 25]

# List comprehension with condition
even_squares = [x**2 for x in numbers if x % 2 == 0]  # [4, 16]

# Dictionary comprehension
users = ["Alice", "Bob", "Charlie"]
user_roles = {user: "admin" if user == "Alice" else "user" for user in users}
# {'Alice': 'admin', 'Bob': 'user', 'Charlie': 'user'}
            </code></pre>
            
            <h3>Advanced Function Features</h3>
            <pre><code>
# *args and **kwargs
def print_info(*args, **kwargs):
    for arg in args:
        print(f"Positional argument: {arg}")
    for key, value in kwargs.items():
        print(f"Keyword argument {key}: {value}")

print_info("Alice", 30, location="New York", role="Developer")

# Decorators
def log_function_call(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned: {result}")
        return result
    return wrapper

@log_function_call
def add(a, b):
    return a + b

sum_result = add(3, 5)  
# Outputs:
# Calling add with args: (3, 5), kwargs: {}
# add returned: 8
            </code></pre>
        </section>

        <section>
            <h2>Python Virtual Environments</h2>
            
            <p>When working on multiple Python projects, you might encounter situations where different projects require different versions of the same library. Virtual environments solve this problem by creating isolated environments for each project.</p>
            
            <h3>Why Use Virtual Environments?</h3>
            <ul>
                <li><strong>Dependency Isolation</strong>: Each project can have its own dependencies, regardless of what other projects need</li>
                <li><strong>Version Control</strong>: You can specify exact versions of packages for each project</li>
                <li><strong>Clean Development</strong>: Avoid cluttering your global Python installation with project-specific packages</li>
                <li><strong>Reproducibility</strong>: Makes it easier for others to set up the same environment</li>
            </ul>
            
            <h3>Creating and Using Virtual Environments</h3>
            
            <h4>Using venv (Built-in)</h4>
            <p>Python comes with a built-in module called <code>venv</code> for creating virtual environments:</p>
            <pre><code>
# Create a virtual environment
python -m venv myenv

# Activate the virtual environment
# On Windows
myenv\Scripts\activate

# On macOS/Linux
source myenv/bin/activate

# Install packages
pip install flask

# Generate a requirements.txt file
pip freeze > requirements.txt

# Deactivate the virtual environment
deactivate
            </code></pre>
            
            <h4>Using virtualenv</h4>
            <p><code>virtualenv</code> is a more feature-rich alternative to <code>venv</code>:</p>
            <pre><code>
# Install virtualenv
pip install virtualenv

# Create a virtual environment
virtualenv myenv

# Activate and use as with venv
            </code></pre>
            
            <h4>Using pipenv</h4>
            <p><code>pipenv</code> combines package management and virtual environment management:</p>
            <pre><code>
# Install pipenv
pip install pipenv

# Create environment and install packages
pipenv install flask

# Activate the environment
pipenv shell

# Install a development dependency
pipenv install pytest --dev
            </code></pre>
            
            <h3>Managing Dependencies</h3>
            <p>It's important to keep track of your project's dependencies to ensure reproducibility:</p>
            <pre><code>
# Generate requirements.txt
pip freeze > requirements.txt

# Install from requirements.txt
pip install -r requirements.txt
            </code></pre>
            
            <p>For pipenv, dependencies are managed in a Pipfile and Pipfile.lock, which are automatically created and updated when you install packages.</p>
        </section>

        <section>
            <h2>Python in Our Project Structure</h2>
            
            <p>Let's examine how Python fits into the project structure we created last week:</p>
            
            <pre><code>blog_app/
├── app/                   # Python package for our application
│   ├── __init__.py        # Makes app a package, contains application factory
│   ├── models/            # Python modules for database models
│   ├── views/             # Python modules for route handlers
│   ├── templates/         # Jinja2 templates (processed by Python)
│   ├── static/            # Static files
│   ├── forms/             # Python modules for form definitions
│   └── utils/             # Python utility functions
├── migrations/            # Database migration scripts (Python)
├── tests/                 # Python tests
├── requirements.txt       # Python dependencies
└── Dockerfile             # Instructions for Docker (includes Python setup)</code></pre>
            
            <p>In this structure, most of our code will be Python code organized into modules and packages.</p>
            
            <h3>Understanding Python Modules and Packages</h3>
            <p>A <strong>module</strong> is a Python file containing definitions and statements. A <strong>package</strong> is a directory containing Python files and an <code>__init__.py</code> file, which makes it a package.</p>
            
            <p>Our application uses a package structure to organize related functionality:</p>
            <ul>
                <li><code>app/</code> is our main package</li>
                <li><code>app/models/</code> is a sub-package for database models</li>
                <li><code>app/views/</code> is a sub-package for view functions (route handlers)</li>
                <li>And so on...</li>
            </ul>
            
            <p>This structure allows us to organize our code logically and import functionality where needed.</p>
        </section>

        <section>
            <h2>Virtual Environments in Docker</h2>
            
            <p>When using Docker, you might wonder if virtual environments are still necessary. Docker containers already provide isolation, so virtual environments might seem redundant. However, there are reasons you might still use them together:</p>
            
            <h3>Docker vs. Virtual Environments</h3>
            <table>
                <thead>
                    <tr>
                        <th>Docker</th>
                        <th>Virtual Environments</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Isolates entire operating system</td>
                        <td>Isolates only Python dependencies</td>
                    </tr>
                    <tr>
                        <td>Ensures consistency across different machines</td>
                        <td>Lightweight and easier to set up</td>
                    </tr>
                    <tr>
                        <td>Includes all dependencies, not just Python</td>
                        <td>Integrates better with Python development tools</td>
                    </tr>
                    <tr>
                        <td>More resource-intensive</td>
                        <td>More lightweight</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>Using Both Together</h3>
            <p>For our development workflow, we can use:</p>
            <ol>
                <li><strong>Virtual environments</strong> for local development and testing</li>
                <li><strong>Docker</strong> for ensuring consistency across development, testing, and production environments</li>
            </ol>
            
            <p>Our Dockerfile already sets up a clean Python environment inside the container, so we don't need to explicitly create a virtual environment within the container.</p>
            
            <pre><code># From our Dockerfile

FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

ENV FLASK_APP=app
ENV FLASK_ENV=development

EXPOSE 5000

CMD ["flask", "run", "--host=0.0.0.0"]</code></pre>
            
            <p>The Docker container acts as an isolated environment, and the pip install step in the Dockerfile installs the dependencies specified in requirements.txt.</p>
        </section>

        <section>
            <h2>Python Best Practices for Web Development</h2>
            
            <p>As we build our web application, following these Python best practices will help us create clean, maintainable code:</p>
            
            <h3>Code Style and Organization</h3>
            <ul>
                <li><strong>Follow PEP 8</strong>: Python's style guide for code formatting</li>
                <li><strong>Use meaningful names</strong>: Choose descriptive names for variables, functions, and classes</li>
                <li><strong>Write docstrings</strong>: Document your code with docstrings following PEP 257</li>
                <li><strong>Organize imports</strong>: Group imports by standard library, third-party, and local modules</li>
            </ul>
            
            <h3>Design Patterns</h3>
            <ul>
                <li><strong>Factory Pattern</strong>: Used in our application factory (<code>create_app</code>)</li>
                <li><strong>MVC Pattern</strong>: Separating models, views, and controllers (templates in Flask)</li>
                <li><strong>Blueprints</strong>: Organizing related routes and functionality</li>
                <li><strong>Dependency Injection</strong>: Passing dependencies rather than creating them within functions</li>
            </ul>
            
            <h3>Security Considerations</h3>
            <ul>
                <li><strong>Input validation</strong>: Always validate and sanitize user input</li>
                <li><strong>Use parameterized queries</strong>: Avoid SQL injection by using ORM or query parameters</li>
                <li><strong>Secure password handling</strong>: Use proper hashing with salt (we'll use Flask-Login)</li>
                <li><strong>Protect against CSRF</strong>: Use Flask-WTF's CSRF protection</li>
                <li><strong>Don't trust client-side data</strong>: Always validate on the server</li>
            </ul>
            
            <h3>Testing</h3>
            <ul>
                <li><strong>Write tests early</strong>: Adopt a test-driven development approach when possible</li>
                <li><strong>Use pytest</strong>: A powerful testing framework for Python</li>
                <li><strong>Test at multiple levels</strong>: Unit tests, integration tests, functional tests</li>
                <li><strong>Use fixtures</strong>: For setting up test data and environments</li>
            </ul>
            
            <h3>Performance</h3>
            <ul>
                <li><strong>Use efficient data structures</strong>: Choose appropriate data structures for your tasks</li>
                <li><strong>Minimize database queries</strong>: Use eager loading when retrieving related objects</li>
                <li><strong>Implement caching</strong>: Cache expensive operations and database queries</li>
                <li><strong>Pagination</strong>: Paginate large result sets</li>
            </ul>
        </section>

        <section>
            <h2>Python Debugging and Development Tools</h2>
            
            <p>Python provides several tools to help with debugging and development:</p>
            
            <h3>Debugging</h3>
            <pre><code>
# Using print statements
print(f"Variable value: {variable}")

# Using pdb (Python debugger)
import pdb
pdb.set_trace()  # Code execution will pause here

# Using breakpoint() (Python 3.7+)
breakpoint()  # Equivalent to pdb.set_trace()

# Using logging
import logging
logging.basicConfig(level=logging.DEBUG)
logging.debug("This is a debug message")
logging.info("This is an info message")
logging.error("This is an error message")
            </code></pre>
            
            <h3>Development Tools</h3>
            <ul>
                <li><strong>Linters</strong>: Tools like flake8, pylint to check code style and find potential errors</li>
                <li><strong>Formatters</strong>: Tools like black, autopep8 to automatically format code</li>
                <li><strong>Type Checking</strong>: Using mypy for static type checking with type hints</li>
                <li><strong>Testing</strong>: pytest for writing and running tests</li>
                <li><strong>Code Coverage</strong>: pytest-cov to measure code coverage</li>
            </ul>
            
            <h3>Setting Up Development Tools</h3>
            <pre><code>
# Install development tools
pip install flake8 black mypy pytest pytest-cov

# Run flake8 linter
flake8 app/

# Format code with black
black app/

# Run type checking with mypy
mypy app/

# Run tests with coverage
pytest --cov=app tests/
            </code></pre>
            
            <p>You can configure these tools to run automatically in your editor (VS Code) or as pre-commit hooks in Git.</p>
        </section>

        <section>
            <h2>Hands-On Exercise: Setting Up Development Environment</h2>
            
            <p>Let's practice what we've learned by setting up a development environment for our blog application:</p>
            
            <h3>Option 1: Using Virtual Environment</h3>
            <ol>
                <li>Create a virtual environment:
                <pre><code>cd blog_app
python -m venv venv</code></pre>
                </li>
                
                <li>Activate the virtual environment:
                <pre><code># On Windows
venv\Scripts\activate

# On macOS/Linux
source venv/bin/activate</code></pre>
                </li>
                
                <li>Install dependencies:
                <pre><code>pip install -r requirements.txt</code></pre>
                </li>
                
                <li>Run the Flask application:
                <pre><code>flask run</code></pre>
                </li>
            </ol>
            
            <h3>Option 2: Using Docker</h3>
            <ol>
                <li>Build and start the containers:
                <pre><code>docker-compose up -d</code></pre>
                </li>
                
                <li>Check the logs:
                <pre><code>docker-compose logs web</code></pre>
                </li>
                
                <li>Access the application at <a href="http://localhost:5000" target="_blank">http://localhost:5000</a></li>
            </ol>
            
            <h3>Development Workflow</h3>
            <p>With this setup, you can:</p>
            <ol>
                <li>Edit Python files in your preferred editor</li>
                <li>The changes will be automatically detected by Flask's development server</li>
                <li>Refresh your browser to see the changes</li>
            </ol>
            
            <h3>Challenge: Add a New Route</h3>
            <p>Try adding a new route to your application:</p>
            <ol>
                <li>Open <code>app/views/main.py</code></li>
                <li>Add a new route function:
                <pre><code>@bp.route('/about')
def about():
    return render_template('about.html', title='About')</code></pre>
                </li>
                
                <li>Create <code>app/templates/about.html</code>:
                <pre><code>{% extends 'base.html' %}

{% block title %}About - Blog{% endblock %}

{% block content %}
<h1>About This Blog</h1>
<p>This is a blog application built with Flask for the Full Stack Web Development course.</p>
{% endblock %}</code></pre>
                </li>
                
                <li>Add a link to the about page in <code>app/templates/base.html</code>:
                <pre><code><li class="nav-item">
    <a class="nav-link" href="{{ url_for('main.about') }}">About</a>
</li></code></pre>
                </li>
                
                <li>Refresh your browser and navigate to the About page</li>
            </ol>
        </section>

        <section>
            <h2>Advanced Python Features Relevant to Web Development</h2>
            
            <p>As you progress in your web development journey, these advanced Python features will become increasingly useful:</p>
            
            <h3>Asynchronous Programming</h3>
            <p>Python 3.5+ introduced <code>async</code> and <code>await</code> for writing asynchronous code:</p>
            <pre><code>
import asyncio

async def fetch_data():
    print("Fetching data...")
    await asyncio.sleep(2)  # Simulating an I/O operation
    return {"data": "Here's your data!"}

async def main():
    result = await fetch_data()
    print(result)

# Run the async function
asyncio.run(main())
            </code></pre>
            
            <p>This is particularly useful for web applications that need to handle many concurrent connections or make external API calls.</p>
            
            <h3>Type Hints</h3>
            <p>Python 3.5+ supports type hints, which can make your code more readable and catch type-related errors:</p>
            <pre><code>
from typing import List, Dict, Optional

def get_user_by_id(user_id: int) -> Optional[Dict[str, str]]:
    users = [
        {"id": 1, "name": "Alice"},
        {"id": 2, "name": "Bob"}
    ]
    for user in users:
        if user["id"] == user_id:
            return user
    return None

def get_user_names(users: List[Dict[str, str]]) -> List[str]:
    return [user["name"] for user in users]
            </code></pre>
            
            <h3>Context Managers</h3>
            <p>You can create your own context managers for resource management:</p>
            <pre><code>
class Database:
    def __init__(self, connection_string):
        self.connection_string = connection_string
        self.connection = None
    
    def __enter__(self):
        print("Opening database connection")
        self.connection = f"Connection to {self.connection_string}"
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Closing database connection")
        self.connection = None
        
    def query(self, sql):
        return f"Executing {sql} on {self.connection}"

# Using the context manager
with Database("postgresql://localhost/mydb") as db:
    result = db.query("SELECT * FROM users")
    print(result)
            </code></pre>
            
            <h3>Decorators</h3>
            <p>Decorators are widely used in web frameworks like Flask. You can create your own decorators for cross-cutting concerns:</p>
            <pre><code>
import functools
import time

def timing_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.2f} seconds to run")
        return result
    return wrapper

@timing_decorator
def slow_function():
    time.sleep(1)
    return "Done!"

result = slow_function()  # Outputs: slow_function took 1.00 seconds to run
            </code></pre>
            
            <h3>Metaclasses</h3>
            <p>Metaclasses are advanced but can be useful for framework development:</p>
            <pre><code>
class ModelMeta(type):
    def __new__(mcs, name, bases, attrs):
        # Add fields to a special attribute
        attrs['__fields__'] = {
            key: value for key, value in attrs.items()
            if not key.startswith('__') and not callable(value)
        }
        return super().__new__(mcs, name, bases, attrs)

class Model(metaclass=ModelMeta):
    def save(self):
        fields = self.__class__.__fields__
        field_values = {field: getattr(self, field) for field in fields}
        print(f"Saving {self.__class__.__name__} with fields: {field_values}")

class User(Model):
    name = "default_name"
    email = "default@example.com"

user = User()
user.name = "John"
user.save()  # Outputs: Saving User with fields: {'name': 'John', 'email': 'default@example.com'}
            </code></pre>
        </section>

        <section>
            <h2>Python's Role in Our Web Application</h2>
            
            <p>Throughout this course, Python will play various roles in our application:</p>
            
            <h3>Server-Side Logic</h3>
            <ul>
                <li>Handling HTTP requests and responses</li>
                <li>Processing form data</li>
                <li>Authentication and authorization</li>
                <li>Business logic implementation</li>
            </ul>
            
            <h3>Database Operations</h3>
            <ul>
                <li>Defining data models</li>
                <li>Creating, reading, updating, and deleting records</li>
                <li>Querying and filtering data</li>
                <li>Managing database migrations</li>
            </ul>
            
            <h3>Template Rendering</h3>
            <ul>
                <li>Generating HTML using Jinja2 templates</li>
                <li>Passing data from the server to templates</li>
                <li>Creating reusable template components</li>
            </ul>
            
            <h3>API Integration</h3>
            <ul>
                <li>Consuming external APIs</li>
                <li>Parsing and processing JSON data</li>
                <li>Handling asynchronous requests</li>
            </ul>
            
            <h3>Testing and Validation</h3>
            <ul>
                <li>Writing unit and integration tests</li>
                <li>Validating user input</li>
                <li>Ensuring application security</li>
            </ul>
        </section>

        <section>
            <h2>Next Steps</h2>
            
            <p>Now that we've refreshed our Python knowledge and set up our development environment, we're ready to dive into Flask development tomorrow. Here's what we'll cover:</p>
            
            <h3>Tomorrow: Flask Basics and Routing</h3>
            <ul>
                <li>Introduction to Flask framework</li>
                <li>Creating routes and views</li>
                <li>Working with request and response objects</li>
                <li>Template rendering with Jinja2</li>
                <li>Static files and resources</li>
            </ul>
            
            <h3>Preparation</h3>
            <p>To prepare for tomorrow's session:</p>
            <ol>
                <li>Make sure your development environment is set up (either virtual environment or Docker)</li>
                <li>Review the basic project structure we created last week</li>
                <li>Browse the Flask documentation at <a href="https://flask.palletsprojects.com/" target="_blank">https://flask.palletsprojects.com/</a></li>
            </ol>
        </section>

        <section>
            <h2>Today's Assignment: Python Refresher</h2>
            
            <p>To reinforce what we've learned today, complete the following exercises:</p>
            
            <h3>Exercise 1: Virtual Environment Setup</h3>
            <ol>
                <li>Create a virtual environment for your blog project (if not using Docker)</li>
                <li>Install the required dependencies from requirements.txt</li>
                <li>Create a simple Python script that prints the versions of the installed packages</li>
                <li>Take a screenshot of your terminal showing the activated virtual environment and the output of your script</li>
            </ol>
            
            <h3>Exercise 2: Python Basics Review</h3>
            <p>Create a Python module (<code>blog_tools.py</code>) with the following functions:</p>
            <ol>
                <li>A function that takes a blog post title and returns a URL-friendly slug (e.g., "My First Post" → "my-first-post")</li>
                <li>A function that takes a block of text and returns a summary (first 100 characters + "...")</li>
                <li>A function that takes a publish date and returns a human-friendly string (e.g., "2 days ago", "Just now", etc.)</li>
                <li>A class called <code>BlogPost</code> that has attributes for title, content, author, and publish date, with methods for generating slugs and summaries using the functions above</li>
            </ol>
            
            <h3>Exercise 3: Testing Your Code</h3>
            <ol>
                <li>Write at least three test functions to verify that your <code>blog_tools.py</code> functions work correctly</li>
                <li>Use assertions to check the expected output against the actual output</li>
                <li>Run your tests and ensure they all pass</li>
            </ol>
            
            <h3>Bonus Challenge: Working with Files</h3>
            <p>Create a script that:</p>
            <ol>
                <li>Reads a Markdown file containing a blog post</li>
                <li>Extracts the title (first heading) and content</li>
                <li>Creates a <code>BlogPost</code> object with this data</li>
                <li>Writes the post summary to a new file</li>
            </ol>
            
            <p>Submit your code and screenshots through the course platform before tomorrow's session.</p>
        </section>

        <section>
            <h2>Additional Resources</h2>
            
            <h3>Python Documentation and Tutorials</h3>
            <ul>
                <li><a href="https://docs.python.org/3/" target="_blank">Official Python Documentation</a></li>
                <li><a href="https://realpython.com/" target="_blank">Real Python Tutorials</a></li>
                <li><a href="https://docs.python-guide.org/" target="_blank">The Hitchhiker's Guide to Python</a></li>
                <li><a href="https://peps.python.org/pep-0008/" target="_blank">PEP 8 - Style Guide for Python Code</a></li>
            </ul>
            
            <h3>Virtual Environments</h3>
            <ul>
                <li><a href="https://docs.python.org/3/library/venv.html" target="_blank">venv - Creation of virtual environments</a></li>
                <li><a href="https://virtualenv.pypa.io/en/latest/" target="_blank">virtualenv documentation</a></li>
                <li><a href="https://pipenv.pypa.io/en/latest/" target="_blank">pipenv documentation</a></li>
                <li><a href="https://python-poetry.org/docs/" target="_blank">Poetry - Python packaging and dependency management</a></li>
            </ul>
            
            <h3>Python for Web Development</h3>
            <ul>
                <li><a href="https://flask.palletsprojects.com/en/2.0.x/" target="_blank">Flask Documentation</a></li>
                <li><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world" target="_blank">The Flask Mega-Tutorial</a></li>
                <li><a href="https://testdriven.io/blog/flask-factory-pattern/" target="_blank">Organizing Flask Applications with the Factory Pattern</a></li>
                <li><a href="https://realpython.com/python-web-applications/" target="_blank">Python Web Applications: The Big Picture</a></li>
            </ul>
            
            <h3>Books</h3>
            <ul>
                <li>"Fluent Python" by Luciano Ramalho</li>
                <li>"Python Cookbook" by David Beazley and Brian K. Jones</li>
                <li>"Flask Web Development" by Miguel Grinberg</li>
                <li>"Test-Driven Development with Python" by Harry Percival</li>
            </ul>
        </section>
        
        <section>
            <h2>Conclusion</h2>
            
            <p>Today, we've refreshed our knowledge of Python fundamentals and learned about virtual environments, which are essential for managing dependencies in Python projects. We've also discussed how Python fits into our web development project structure and explored best practices for Python development.</p>
            
            <p>Remember that Python is a versatile language with a gentle learning curve but substantial depth. As you progress through this course, you'll discover more advanced features that will help you build robust web applications. The key is to practice regularly and apply what you learn to real-world problems.</p>
            
            <p>Tomorrow, we'll dive into Flask, a Python web framework that will allow us to create dynamic web applications. We'll learn about routing, views, and template rendering, which form the foundation of web development with Flask.</p>
            
            <p>Don't hesitate to ask questions and engage with your peers. Learning is a collaborative process, and we're all here to help each other succeed.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Full Stack Python Web Development Course</p>
    </footer>
</body>
</html>
