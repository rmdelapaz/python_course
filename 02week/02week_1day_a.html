<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Python and Installation Verification</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Introduction to Python and Installation Verification</h1>
        <h2>Week 2: Python Fundamentals - Monday Morning Session</h2>
    </header>

    <main>
        <section class="session_intro">
            <h3>Session Overview</h3>
            <p>Welcome to our deep dive into Python! Today, we'll explore Python's philosophy, verify our installations, understand Python in containerized environments, work with the interactive shell, run Python scripts, and cover the fundamentals of variables, data types, and basic operations.</p>
        </section>

        <section class="python_philosophy">
            <h3>Understanding Python's Philosophy</h3>
            
            <p>Python was created by Guido van Rossum in the late 1980s and released in 1991. The language was designed with a focus on readability and simplicity, allowing developers to express concepts in fewer lines of code than would be possible in languages like C++ or Java.</p>
            
            <p>At the heart of Python is the "Zen of Python" - a collection of 19 guiding principles that influence the design of the language. You can access these principles by typing <code>import this</code> in your Python interpreter:</p>
            
            <pre><code>>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!</code></pre>
            
            <h4>Key Python Philosophies Explained</h4>
            
            <ul>
                <li><strong>Readability Matters:</strong> Python's design emphasizes clean, readable code. Think of code as a book - it should be easy to follow and understand, not just by the original author but by anyone who reads it later.</li>
                
                <li><strong>Explicit is Better Than Implicit:</strong> Python avoids "magic" or hidden operations. It's like giving detailed instructions for a recipe rather than saying "cook it until it feels right." Clear intentions lead to fewer surprises.</li>
                
                <li><strong>Simple is Better Than Complex:</strong> Python encourages straightforward solutions. Imagine building furniture - while a complex design with hidden compartments might be impressive, a simple, sturdy table is more practical and easier to maintain.</li>
                
                <li><strong>One Obvious Way to Do It:</strong> Unlike some languages that offer multiple ways to perform the same task, Python typically promotes a single, clear approach. It's like having a city with well-planned roads rather than a maze of confusing alleys.</li>
            </ul>
            
            <h4>Real-World Impact of Python's Philosophy</h4>
            
            <p>Python's philosophy has made it exceptionally versatile. It's used in:</p>
            
            <ul>
                <li><strong>Web Development:</strong> Frameworks like Django and Flask power millions of websites</li>
                <li><strong>Data Science &amp; AI:</strong> Libraries like Pandas, NumPy, and TensorFlow have made Python the dominant language in these fields</li>
                <li><strong>Automation:</strong> From simple scripts to complex system management</li>
                <li><strong>Education:</strong> Often chosen as a first programming language due to its readability</li>
                <li><strong>DevOps:</strong> Infrastructure automation with tools like Ansible</li>
            </ul>
            
            <p>As we progress through this course, you'll see how Python's design philosophy enables rapid development of robust applications while maintaining clarity and simplicity.</p>
        </section>

        <section class="installation_verification">
            <h3>Python Installation Verification</h3>
            
            <p>Before diving deeper, we need to ensure Python is correctly installed on our systems. The verification process is like checking if you have the right tools before starting a project - essential for a smooth experience.</p>
            
            <h4>Checking Your Python Installation</h4>
            
            <p>Open your command line or terminal and try the following commands:</p>
            
            <pre><code># Check if Python is installed and its version
python --version
# or on some systems:
python3 --version</code></pre>
            
            <p>You should see output similar to:</p>
            <pre><code>Python 3.10.4</code></pre>
            
            <p>For our course, we'll be using Python 3.10 or newer, as it includes important modern features and improvements.</p>
            
            <h4>Verifying Python's Location</h4>
            
            <p>To see where Python is installed on your system:</p>
            
            <pre><code># On Windows
where python

# On macOS/Linux
which python
which python3</code></pre>
            
            <p>This command returns the path to your Python executable, which is useful for understanding your environment setup.</p>
            
            <h4>Testing Python's Core Functionality</h4>
            
            <p>Let's verify Python is working correctly by testing some basic operations:</p>
            
            <pre><code># Start the Python interpreter
python
# or
python3

# Try some basic operations in the interpreter
>>> 2 + 2
4
>>> print("Hello, Python World!")
Hello, Python World!
>>> exit()  # To exit the interpreter</code></pre>
            
            <h4>Checking Installed Packages</h4>
            
            <p>Python's package manager, pip, should be included with your installation. Verify it works:</p>
            
            <pre><code># Check pip version
pip --version
# or
pip3 --version

# List installed packages
pip list</code></pre>
            
            <h4>Troubleshooting Common Installation Issues</h4>
            
            <ul>
                <li><strong>Command Not Found:</strong> If you get "command not found" errors, Python may not be in your PATH environment variable. We'll cover path configuration in our session.</li>
                
                <li><strong>Multiple Python Versions:</strong> Many systems have multiple Python versions installed. Be explicit about which one you're using (python3 vs. python).</li>
                
                <li><strong>Permission Issues:</strong> On Unix-based systems, you might need to use sudo for system-wide installations.</li>
            </ul>
            
            <div class="analogy_box">
                <h4>Analogy: Python Installation as Setting Up a Workshop</h4>
                <p>Think of Python installation like setting up a woodworking workshop:</p>
                <ul>
                    <li>The Python interpreter is your workbench - the foundation for all your projects</li>
                    <li>Standard libraries are like your basic tools (hammers, saws, drills)</li>
                    <li>pip is your supplier, allowing you to order specialized tools (packages)</li>
                    <li>PATH configuration is like ensuring you can easily access all areas of your workshop</li>
                    <li>Virtual environments (which we'll cover) are like having separate workbenches for different projects, preventing tool conflicts</li>
                </ul>
                <p>Just as a carpenter verifies their tools are working before starting a project, we verify our Python installation before coding.</p>
            </div>
        </section>

        <section class="python_in_docker">
            <h3>Python in Docker Containers</h3>
            
            <p>Docker containers provide isolated, consistent environments for developing and deploying Python applications. This approach solves the classic "it works on my machine" problem by packaging your code with all its dependencies.</p>
            
            <h4>Benefits of Containerized Python</h4>
            
            <ul>
                <li><strong>Consistency:</strong> Everyone on the team works with identical environments</li>
                <li><strong>Isolation:</strong> Projects don't interfere with each other</li>
                <li><strong>Portability:</strong> Applications run the same way across development, testing, and production</li>
                <li><strong>Version Management:</strong> Easy to use specific Python versions without affecting your system</li>
            </ul>
            
            <h4>Verifying Python in a Docker Container</h4>
            
            <p>If you're using Docker, you can verify Python within a container:</p>
            
            <pre><code># Pull an official Python image
docker pull python:3.10

# Run Python in a container
docker run -it python:3.10 python --version

# Start an interactive Python session in a container
docker run -it python:3.10</code></pre>
            
            <h4>Creating a Simple Python Container</h4>
            
            <p>Let's create a basic Dockerfile for a Python application:</p>
            
            <p>Create a file named <code>Dockerfile</code> in your project directory with the following content:</p>
            
            <pre><code># Base image
FROM python:3.10-slim

# Set working directory
WORKDIR /app

# Copy requirements first (for better caching)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Command to run when container starts
CMD ["python", "app.py"]</code></pre>
            
            <p>And create a simple <code>app.py</code> file:</p>
            
            <pre><code>print("Hello from Python in Docker!")
import sys
print(f"Python version: {sys.version}")</code></pre>
            
            <p>Build and run the container:</p>
            
            <pre><code># Build the image
docker build -t my-python-app .

# Run the container
docker run my-python-app</code></pre>
            
            <div class="analogy_box">
                <h4>Analogy: Docker Containers as Food Delivery Boxes</h4>
                <p>Think of Docker containers like those meal kit delivery services:</p>
                <ul>
                    <li>The recipe (your code) comes with exactly the right ingredients (dependencies)</li>
                    <li>Everything is pre-measured and packaged together</li>
                    <li>It works the same way regardless of whose kitchen it's prepared in</li>
                    <li>Different meals (applications) don't interfere with each other</li>
                    <li>You can easily make the same meal again later with consistent results</li>
                </ul>
            </div>

            <h4>Real-World Example: Microservice Architecture</h4>
            <p>Major companies like Netflix and Spotify use containerized Python microservices to build scalable architectures. Each service runs in its own container, allowing teams to develop, deploy, and scale independently. For instance, one Python container might handle user authentication while another processes recommendations, all communicating via well-defined APIs.</p>
        </section>

        <section class="python_interactive">
            <h3>Interactive Python (REPL) Basics</h3>
            
            <p>The Python interpreter can be used interactively through what's known as the REPL (Read-Evaluate-Print Loop). This powerful tool allows you to execute Python code line by line, immediately seeing the results.</p>
            
            <h4>Starting the REPL</h4>
            
            <p>To start the interactive interpreter:</p>
            
            <pre><code># Simple way
python
# or
python3</code></pre>
            
            <p>You'll see something like:</p>
            
            <pre><code>Python 3.10.4 (main, Mar 31 2022, 08:41:55) [GCC 7.5.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>></code></pre>
            
            <p>The <code>>>></code> prompt indicates the interpreter is ready for your input.</p>
            
            <h4>REPL Basics</h4>
            
            <p>The REPL operates in a cycle:</p>
            <ol>
                <li><strong>Read:</strong> It reads your input</li>
                <li><strong>Evaluate:</strong> It evaluates/executes the code</li>
                <li><strong>Print:</strong> It prints the result</li>
                <li><strong>Loop:</strong> It returns to the prompt, waiting for more input</li>
            </ol>
            
            <h4>Using the REPL Effectively</h4>
            
            <pre><code>>>> 2 + 3 * 4  # Python follows mathematical order of operations
14

>>> name = "Python Learner"
>>> print(f"Hello, {name}!")
Hello, Python Learner!

>>> # Multiline statements need continuation
>>> if True:
...     print("This is true")
...     print("And this runs too")
...
This is true
And this runs too

>>> # The REPL automatically prints expression results
>>> [i**2 for i in range(5)]  # A list comprehension
[0, 1, 4, 9, 16]</code></pre>
            
            <h4>Special REPL Features</h4>
            
            <ul>
                <li><strong>Underscore (_) Variable:</strong> Stores the last expression result</li>
                <li><strong>Tab Completion:</strong> Press Tab to complete code or show options</li>
                <li><strong>History Navigation:</strong> Use up/down arrows to navigate through command history</li>
                <li><strong>Help Function:</strong> Get documentation with <code>help(object)</code></li>
            </ul>
            
            <pre><code>>>> 10 * 20
200
>>> _ + 5  # Using the last result
205

>>> import math
>>> math.  # Press Tab here to see all available methods
>>> help(math.sqrt)  # Get help on a specific function</code></pre>
            
            <h4>IPython: An Enhanced REPL</h4>
            
            <p>Consider using IPython for an improved interactive experience:</p>
            
            <pre><code># Install IPython
pip install ipython

# Launch IPython
ipython</code></pre>
            
            <p>IPython offers syntax highlighting, better tab completion, and many other enhancements.</p>
            
            <div class="analogy_box">
                <h4>Analogy: REPL as a Conversation</h4>
                <p>Using the REPL is like having a conversation with Python:</p>
                <ul>
                    <li>You say something (input code)</li>
                    <li>Python thinks about it (evaluates)</li>
                    <li>Python responds (shows the result)</li>
                    <li>Then waits for you to say something else</li>
                </ul>
                <p>It's immediate feedback makes it perfect for learning - like having a tutor who instantly checks your work.</p>
            </div>

            <h4>Real-World Applications of the REPL</h4>
            <p>Data scientists regularly use enhanced REPLs like Jupyter Notebooks for exploratory data analysis. They can run code segments, visualize results, and refine their approach iteratively. Software engineers use the REPL to test small code snippets before incorporating them into larger projects, verifying behavior without creating full test files.</p>
        </section>

        <section class="running_scripts">
            <h3>Running Python Scripts</h3>
            
            <p>While the REPL is great for experimentation, most Python code is written in script files that can be executed as complete programs.</p>
            
            <h4>Creating a Python Script</h4>
            
            <p>Python scripts are simply text files with a <code>.py</code> extension. Create a file named <code>hello_world.py</code> with the following content:</p>
            
            <pre><code># This is a comment in Python
print("Hello, World!")
print("Welcome to Python programming!")

# Variables and simple calculation
name = "Python Learner"
experience_years = 5
print(f"{name} has {experience_years} years of programming experience.")
print(f"In 2 more years, they will have {experience_years + 2} years of experience.")</code></pre>
            
            <h4>Running Scripts from the Command Line</h4>
            
            <pre><code># Basic execution
python hello_world.py
# or
python3 hello_world.py</code></pre>
            
            <h4>Script Execution Modes</h4>
            
            <p>Python scripts can be run in different ways:</p>
            
            <ul>
                <li><strong>Direct Execution:</strong> Running the script directly with the Python interpreter</li>
                <li><strong>Module Execution:</strong> Running a script as a module with <code>python -m module_name</code></li>
                <li><strong>Executable Scripts:</strong> Making scripts directly executable (Unix-based systems)</li>
            </ul>
            
            <p>For executable scripts on Unix-based systems, add a shebang line and make the file executable:</p>
            
            <pre><code>#!/usr/bin/env python3
print("This script is directly executable!")</code></pre>
            
            <p>Then run:</p>
            
            <pre><code>chmod +x script_name.py
./script_name.py</code></pre>
            
            <h4>Command-line Arguments</h4>
            
            <p>Scripts can accept arguments from the command line. Create a file named <code>greet.py</code>:</p>
            
            <pre><code>import sys

if len(sys.argv) > 1:
    name = sys.argv[1]
    print(f"Hello, {name}!")
else:
    print("Hello, stranger! Please provide your name as an argument.")</code></pre>
            
            <p>Run it with:</p>
            
            <pre><code>python greet.py Alice</code></pre>
            
            <h4>Importing Scripts as Modules</h4>
            
            <p>Python scripts can also be imported as modules. Create a file <code>math_helpers.py</code>:</p>
            
            <pre><code>def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

if __name__ == "__main__":
    # This code only runs when the script is executed directly
    print("Testing math functions:")
    print(f"5 + 3 = {add(5, 3)}")
    print(f"4 * 6 = {multiply(4, 6)}")</code></pre>
            
            <p>The <code>if __name__ == "__main__":</code> block is a common pattern that allows a file to function both as a script and as an importable module.</p>
            
            <div class="analogy_box">
                <h4>Analogy: Scripts vs. REPL</h4>
                <p>If the REPL is like having a conversation, then scripts are like writing a letter:</p>
                <ul>
                    <li>Scripts are prepared in advance (written completely before execution)</li>
                    <li>They can be reviewed, edited, and perfected before being "sent" (executed)</li>
                    <li>They can be saved and re-used many times</li>
                    <li>They can be shared with others to run exactly the same way</li>
                </ul>
                <p>The REPL is great for exploration and quick tests (like a phone call), while scripts are better for complete programs and automation (like a detailed written plan).</p>
            </div>

            <h4>Real-World Script Examples</h4>
            <p>In production environments, Python scripts handle critical automation tasks. For example, a deployment script might:</p>
            <ol>
                <li>Pull the latest code from version control</li>
                <li>Run tests to verify functionality</li>
                <li>Build application assets</li>
                <li>Upload to servers</li>
                <li>Switch traffic to the new version</li>
                <li>Send notification emails to the team</li>
            </ol>
            <p>Companies like Instagram use thousands of Python scripts to automate everything from content moderation to server management.</p>
        </section>
        
        <section class="next_steps">
            <h3>Wrapping Up and Looking Ahead</h3>
            
            <p>Today we've covered the foundations of Python, including its philosophy, installation verification, working with Python in containers, using the interactive REPL, and running Python scripts. These fundamentals will serve as building blocks for everything else we learn in this course.</p>
            
            <p>In our next session, we'll dive deeper into Python's data model, exploring variables, data types, and basic operations in greater detail.</p>
            
            <h4>Practice Exercises</h4>
            
            <ol>
                <li>Verify your Python installation and try running code in the REPL.</li>
                <li>Create a simple script that calculates and displays your age in days, hours, and minutes.</li>
                <li>If using Docker, build a container that runs your script.</li>
                <li>Explore one principle from the Zen of Python and write a small script that demonstrates it.</li>
            </ol>
            
            <h4>Additional Resources</h4>
            
            <ul>
                <li><a href="https://docs.python.org/3/" target="_blank">Official Python Documentation</a></li>
                <li><a href="https://www.python.org/dev/peps/pep-0020/" target="_blank">PEP 20 - The Zen of Python</a></li>
                <li><a href="https://realpython.com/python-first-steps/" target="_blank">Real Python: Python First Steps</a></li>
                <li><a href="https://hub.docker.com/_/python" target="_blank">Official Python Docker Images</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
