<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python vs JavaScript Data Types Comparison</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python vs JavaScript Data Types Comparison</h1>
        <h2>For JavaScript Developers Learning Python</h2>
    </header>

    <main>
        <section class="session_intro">
            <h3>Session Overview</h3>
            <p>Welcome, JavaScript developers! This guide will help you understand how Python data types compare to JavaScript data types. We'll explore the similarities, differences, and unique features of both languages to ease your transition to Python programming. By understanding these comparisons, you'll be able to apply your JavaScript knowledge while quickly adapting to Python's conventions.</p>
        </section>

        <section class="fundamentals">
            <h3>Fundamental Differences</h3>
            
            <p>Before diving into specific data types, let's understand some fundamental differences between Python and JavaScript:</p>
            
            <h4>Type Systems</h4>
            
            <ul>
                <li><strong>JavaScript</strong>: Weakly typed and dynamically typed. Variables can change types implicitly during operations.</li>
                <li><strong>Python</strong>: Strongly typed but still dynamically typed. Variables can change types, but Python doesn't perform implicit type conversions during operations.</li>
            </ul>
            
            <pre><code>// JavaScript
let x = "5";
let y = x * 2;  // y = 10, implicit conversion from string to number

# Python
x = "5"
y = x * 2  # Results in "55", not 10 (string duplication)
y = int(x) * 2  # Now y = 10, explicit conversion needed</code></pre>
            
            <h4>Variable Declaration</h4>
            
            <ul>
                <li><strong>JavaScript</strong>: Uses <code>var</code>, <code>let</code>, or <code>const</code> to declare variables.</li>
                <li><strong>Python</strong>: No declaration needed. Variables are created when you first assign a value.</li>
            </ul>
            
            <pre><code>// JavaScript
let name = "Alice";
const age = 30;

# Python
name = "Alice"
age = 30  # No declaration keywords needed</code></pre>
            
            <h4>Truthy and Falsy Values</h4>
            
            <ul>
                <li><strong>JavaScript</strong>: Has many falsy values (0, "", false, null, undefined, NaN).</li>
                <li><strong>Python</strong>: Has fewer falsy values (False, None, 0, 0.0, "", [], {}, set(), etc.).</li>
            </ul>
            
            <pre><code>// JavaScript
if (0) console.log("This won't print");  // 0 is falsy
if ("0") console.log("This will print");  // "0" is truthy

# Python
if 0: print("This won't print")  # 0 is falsy
if "0": print("This will print")  # "0" is truthy</code></pre>
            
            <div class="analogy_box">
                <h4>Analogy: Type Systems as Communication Styles</h4>
                <p>Think of the difference between JavaScript and Python's type systems like different communication styles:</p>
                <ul>
                    <li><strong>JavaScript</strong> is like a flexible, accommodating friend who tries to understand what you mean even if you mix languages or use vague terms. They'll make educated guesses about your meaning.</li>
                    <li><strong>Python</strong> is like a precise friend who speaks clearly but expects you to be explicit. They won't guess what you mean if you mix languages - you need to translate properly.</li>
                </ul>
                <p>Both friends are helpful, but they have different expectations about how you communicate with them.</p>
            </div>
        </section>

        <section class="primitives">
            <h3>Primitive Data Types</h3>
            
            <h4>Numbers</h4>
            
            <table>
                <tr>
                    <th>JavaScript</th>
                    <th>Python</th>
                    <th>Key Differences</th>
                </tr>
                <tr>
                    <td>
                        <code>Number</code> - represents both integers and floating-point numbers
                        <br><br>
                        <code>BigInt</code> - for arbitrarily large integers (newer)
                    </td>
                    <td>
                        <code>int</code> - integers with unlimited precision
                        <br><br>
                        <code>float</code> - 64-bit floating-point numbers
                        <br><br>
                        <code>complex</code> - complex numbers (a + bj)
                    </td>
                    <td>
                        • Python has separate <code>int</code> and <code>float</code> types
                        <br><br>
                        • Python <code>int</code> has unlimited precision (like <code>BigInt</code>)
                        <br><br>
                        • Python has built-in <code>complex</code> numbers
                        <br><br>
                        • No <code>NaN</code> or <code>Infinity</code> literals in Python (use <code>float("nan")</code>, <code>float("inf")</code>)
                    </td>
                </tr>
            </table>
            
            <pre><code>// JavaScript
let num = 42;           // Number
let float = 3.14;       // Number
let bigInt = 1234567890123456789012345678901234567890n;  // BigInt
let notANumber = NaN;   // NaN is a special Number value
let infinity = Infinity;  // Also a special Number value

# Python
num = 42                # int
float_num = 3.14        # float
big_int = 1234567890123456789012345678901234567890  # Still an int, no special syntax
complex_num = 3 + 4j    # complex
not_a_number = float("nan")  # Need to use float() function
infinity = float("inf")  # Need to use float() function</code></pre>
            
            <h4>Strings</h4>
            
            <table>
                <tr>
                    <th>JavaScript</th>
                    <th>Python</th>
                    <th>Key Differences</th>
                </tr>
                <tr>
                    <td>
                        <code>String</code> - sequence of characters
                        <br><br>
                        Can use single or double quotes
                        <br><br>
                        Template literals with backticks
                    </td>
                    <td>
                        <code>str</code> - immutable sequence of characters
                        <br><br>
                        Can use single, double, or triple quotes
                    </td>
                    <td>
                        • Python strings are immutable (can't be changed after creation)
                        <br><br>
                        • Python has triple quotes for multiline strings (<code>"""text"""</code>)
                        <br><br>
                        • Python uses f-strings for string interpolation (<code>f"Hello {name}"</code>)
                        <br><br>
                        • Python has no separate character type
                    </td>
                </tr>
            </table>
            
            <pre><code>// JavaScript
let singleQuoted = 'Hello';
let doubleQuoted = "World";
let template = `Hello, ${name}!`;  // Template literal
let multiline = `This is a
multiline string`;

# Python
single_quoted = 'Hello'
double_quoted = "World"
f_string = f"Hello, {name}!"  # f-string (similar to template literals)
multiline = """This is a
multiline string"""  # Triple quotes</code></pre>
            
            <h4>Booleans and None/Null</h4>
            
            <table>
                <tr>
                    <th>JavaScript</th>
                    <th>Python</th>
                    <th>Key Differences</th>
                </tr>
                <tr>
                    <td>
                        <code>true</code> and <code>false</code> (lowercase)
                        <br><br>
                        <code>null</code> - explicit absence of value
                        <br><br>
                        <code>undefined</code> - uninitialized variable
                    </td>
                    <td>
                        <code>True</code> and <code>False</code> (capitalized)
                        <br><br>
                        <code>None</code> - represents absence of value
                    </td>
                    <td>
                        • Python booleans are capitalized
                        <br><br>
                        • Python has <code>None</code> but no equivalent of <code>undefined</code>
                        <br><br>
                        • <code>None</code>, <code>False</code>, and <code>0</code> are different but all falsy
                    </td>
                </tr>
            </table>
            
            <pre><code>// JavaScript
let isActive = true;
let noValue = null;
let uninitialized;  // undefined

// Type checking
typeof true;        // "boolean"
typeof null;        // "object" (a historical JavaScript bug)
typeof undefined;   // "undefined"

# Python
is_active = True
no_value = None

# Type checking
type(True)          # <class 'bool'>
type(None)          # <class 'NoneType'></code></pre>
        </section>

        <section class="collections">
            <h3>Collection Data Types</h3>
            
            <h4>Arrays vs Lists</h4>
            
            <table>
                <tr>
                    <th>JavaScript Arrays</th>
                    <th>Python Lists</th>
                    <th>Key Differences</th>
                </tr>
                <tr>
                    <td>
                        Mutable, ordered collections
                        <br><br>
                        Can contain mixed types
                        <br><br>
                        Methods: push, pop, shift, unshift, slice, splice, etc.
                    </td>
                    <td>
                        Mutable, ordered collections
                        <br><br>
                        Can contain mixed types
                        <br><br>
                        Methods: append, extend, insert, remove, pop, etc.
                    </td>
                    <td>
                        • Python doesn't have <code>push</code> (use <code>append</code>)
                        <br><br>
                        • Python uses <code>extend</code> instead of <code>concat</code>
                        <br><br>
                        • Python's <code>slice</code> syntax is <code>list[start:end]</code>
                        <br><br>
                        • Python doesn't have <code>splice</code> - you use slicing assignment
                    </td>
                </tr>
            </table>
            
            <pre><code>// JavaScript
let arr = [1, 2, 3, "four", true];
arr.push(5);            // Add to end: [1, 2, 3, "four", true, 5]
arr.pop();              // Remove from end: [1, 2, 3, "four", true]
arr.unshift(0);         // Add to beginning: [0, 1, 2, 3, "four", true]
arr.shift();            // Remove from beginning: [1, 2, 3, "four", true]
let sliced = arr.slice(1, 3);   // [2, 3]
arr.splice(1, 1, "two");  // Replace: [1, "two", 3, "four", true]

# Python
arr = [1, 2, 3, "four", True]
arr.append(5)          # Add to end: [1, 2, 3, "four", True, 5]
arr.pop()              # Remove from end: [1, 2, 3, "four", True]
arr.insert(0, 0)       # Add to beginning: [0, 1, 2, 3, "four", True]
arr.pop(0)             # Remove from beginning: [1, 2, 3, "four", True]
sliced = arr[1:3]      # [2, 3]
arr[1:2] = ["two"]     # Replace: [1, "two", 3, "four", True]</code></pre>
            
            <h4>Objects vs Dictionaries</h4>
            
            <table>
                <tr>
                    <th>JavaScript Objects</th>
                    <th>Python Dictionaries</th>
                    <th>Key Differences</th>
                </tr>
                <tr>
                    <td>
                        Key-value pairs (keys are strings or symbols)
                        <br><br>
                        Object literal syntax: <code>{key: value}</code>
                        <br><br>
                        Methods: Object.keys(), Object.values(), etc.
                    </td>
                    <td>
                        Key-value pairs (keys can be any immutable type)
                        <br><br>
                        Dict literal syntax: <code>{key: value}</code>
                        <br><br>
                        Methods: keys(), values(), items(), etc.
                    </td>
                    <td>
                        • Python dict keys can be any hashable type, not just strings
                        <br><br>
                        • Python dict methods are called on the object, not from a global object
                        <br><br>
                        • Python has useful methods like <code>get()</code> with default value
                        <br><br>
                        • Python dict comprehensions: <code>{k:v for k, v in ...}</code>
                    </td>
                </tr>
            </table>
            
            <pre><code>// JavaScript
let person = {
    name: "Alice",
    age: 30,
    "likes python": true
};

// Accessing properties
person.name;            // "Alice"
person["likes python"];  // true

// Methods
Object.keys(person);    // ["name", "age", "likes python"]
Object.values(person);  // ["Alice", 30, true]

// Checking if a key exists
"name" in person;       // true

# Python
person = {
    "name": "Alice",
    "age": 30,
    "likes python": True
}

# Accessing properties
person["name"]          # "Alice"
person["likes python"]  # True
# person.name          # Error! No dot notation for arbitrary keys

# Methods
person.keys()           # dict_keys(["name", "age", "likes python"])
person.values()         # dict_values(["Alice", 30, True])
person.items()          # dict_items([("name", "Alice"), ("age", 30), ("likes python", True)])

# Getting with default (no KeyError)
person.get("height", 165)  # 165 (default value if key doesn't exist)

# Checking if a key exists
"name" in person        # True</code></pre>
            
            <div class="analogy_box">
                <h4>Analogy: Dictionaries vs Objects</h4>
                <p>Think of JavaScript objects and Python dictionaries as different types of organizers:</p>
                <ul>
                    <li><strong>JavaScript objects</strong> are like filing cabinets where all the labels must be text or symbols. You can access files by opening a specific drawer (dot notation) or by using their label (bracket notation).</li>
                    <li><strong>Python dictionaries</strong> are like advanced filing systems where labels can be almost anything (numbers, tuples, strings, etc.) as long as they don't change. You have to use the label lookup system (brackets) to find files, but it comes with many built-in organization helpers (methods).</li>
                </ul>
            </div>
            
            <h4>JavaScript Sets vs Python Sets</h4>
            
            <table>
                <tr>
                    <th>JavaScript Sets</th>
                    <th>Python Sets</th>
                    <th>Key Differences</th>
                </tr>
                <tr>
                    <td>
                        Collection of unique values
                        <br><br>
                        Methods: add, delete, has, etc.
                        <br><br>
                        Limited mathematical set operations
                    </td>
                    <td>
                        Collection of unique, hashable objects
                        <br><br>
                        Methods: add, remove, discard, etc.
                        <br><br>
                        Rich set of mathematical operations
                    </td>
                    <td>
                        • Python sets can only contain hashable objects
                        <br><br>
                        • Python has robust mathematical set operations (union, intersection, etc.)
                        <br><br>
                        • Python has set comprehensions: <code>{x for x in ...}</code>
                        <br><br>
                        • Python has immutable frozenset type
                    </td>
                </tr>
            </table>
            
            <pre><code>// JavaScript
let set = new Set([1, 2, 3, 3]);  // Set(3) {1, 2, 3}
set.add(4);             // Set(4) {1, 2, 3, 4}
set.has(2);             // true
set.delete(3);          // Set(3) {1, 2, 4}

// Set operations (ES6+)
let set1 = new Set([1, 2, 3]);
let set2 = new Set([3, 4, 5]);
let union = new Set([...set1, ...set2]);  // Set(5) {1, 2, 3, 4, 5}

# Python
set_a = {1, 2, 3, 3}    # {1, 2, 3}
set_a.add(4)            # {1, 2, 3, 4}
2 in set_a              # True
set_a.remove(3)         # {1, 2, 4}

# Set operations
set1 = {1, 2, 3}
set2 = {3, 4, 5}
union = set1 | set2     # {1, 2, 3, 4, 5}
intersection = set1 & set2  # {3}
difference = set1 - set2    # {1, 2}
symmetric_diff = set1 ^ set2  # {1, 2, 4, 5}</code></pre>
            
            <h4>Maps vs Python Dictionaries</h4>
            
            <pre><code>// JavaScript Map
let map = new Map();
map.set("key1", "value1");
map.set(42, "value2");  // Keys can be any type
map.get("key1");        // "value1"
map.has(42);            // true
map.delete("key1");     // true

# Python Dictionary (Equivalent to JavaScript Map)
dict_a = {}
dict_a["key1"] = "value1"
dict_a[42] = "value2"   # Keys can be any hashable type
dict_a["key1"]          # "value1"
42 in dict_a            # True
del dict_a["key1"]      # Removes the key</code></pre>
            
            <h4>Other Collection Types in Python</h4>
            
            <p>Python has several collection types that don't have direct JavaScript equivalents:</p>
            
            <pre><code># Tuple - immutable sequence
coordinates = (10, 20)  # Can't be modified after creation
first_coord = coordinates[0]  # Access like lists

# Named Tuple - immutable with named fields
from collections import namedtuple
Person = namedtuple('Person', ['name', 'age'])
alice = Person('Alice', 30)
alice.name  # 'Alice' - access by name
alice[0]    # 'Alice' - access by index

# Deque - efficient append/pop at both ends
from collections import deque
queue = deque([1, 2, 3])
queue.append(4)      # Add to right: [1, 2, 3, 4]
queue.appendleft(0)  # Add to left: [0, 1, 2, 3, 4]

# Counter - count occurrences
from collections import Counter
c = Counter("hello")  # Counter({'l': 2, 'h': 1, 'e': 1, 'o': 1})</code></pre>
        </section>

        <section class="functions_classes">
            <h3>Functions and Classes</h3>
            
            <h4>Functions</h4>
            
            <table>
                <tr>
                    <th>JavaScript Functions</th>
                    <th>Python Functions</th>
                    <th>Key Differences</th>
                </tr>
                <tr>
                    <td>
                        Function declarations or expressions
                        <br><br>
                        Arrow functions for concise syntax
                        <br><br>
                        Functions are objects with properties
                    </td>
                    <td>
                        Functions defined with <code>def</code> keyword
                        <br><br>
                        Lambda expressions for simple functions
                        <br><br>
                        Functions are first-class objects
                    </td>
                    <td>
                        • Python uses <code>def</code> instead of <code>function</code>
                        <br><br>
                        • Python's <code>lambda</code> is more limited than arrow functions
                        <br><br>
                        • Python supports advanced parameter features like default values, keyword arguments, and unpacking
                        <br><br>
                        • Python functions can have docstrings
                    </td>
                </tr>
            </table>
            
            <pre><code>// JavaScript Function
function add(a, b) {
    return a + b;
}

// Arrow function
const multiply = (a, b) => a * b;

// Default parameters
function greet(name = "friend") {
    return `Hello, ${name}!`;
}

// Rest parameters
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

# Python Function
def add(a, b):
    return a + b

# Lambda expression (similar to arrow function)
multiply = lambda a, b: a * b

# Default parameters
def greet(name="friend"):
    return f"Hello, {name}!"

# Variable arguments (*args and **kwargs)
def sum(*numbers):
    return sum(numbers)

def person_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")</code></pre>
            
            <h4>Classes and Objects</h4>
            
            <table>
                <tr>
                    <th>JavaScript Classes</th>
                    <th>Python Classes</th>
                    <th>Key Differences</th>
                </tr>
                <tr>
                    <td>
                        ES6 class syntax
                        <br><br>
                        Prototype-based inheritance
                        <br><br>
                        Constructor method
                    </td>
                    <td>
                        Class definition with <code>class</code> keyword
                        <br><br>
                        Class-based inheritance
                        <br><br>
                        <code>__init__</code> method as constructor
                    </td>
                    <td>
                        • Python requires explicit <code>self</code> parameter for methods
                        <br><br>
                        • Python uses <code>__init__</code> instead of <code>constructor</code>
                        <br><br>
                        • Python has special "dunder" methods (<code>__str__</code>, <code>__repr__</code>, etc.)
                        <br><br>
                        • Python supports multiple inheritance
                    </td>
                </tr>
            </table>
            
            <pre><code>// JavaScript Class
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        return `Hello, my name is ${this.name}`;
    }
    
    // Static method
    static create(name, age) {
        return new Person(name, age);
    }
}

// Inheritance
class Employee extends Person {
    constructor(name, age, title) {
        super(name, age);
        this.title = title;
    }
    
    work() {
        return `${this.name} is working as a ${this.title}`;
    }
}

// Usage
const alice = new Person("Alice", 30);
console.log(alice.greet());

# Python Class
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def greet(self):
        return f"Hello, my name is {self.name}"
    
    # Static method
    @staticmethod
    def create(name, age):
        return Person(name, age)

# Inheritance
class Employee(Person):
    def __init__(self, name, age, title):
        super().__init__(name, age)
        self.title = title
    
    def work(self):
        return f"{self.name} is working as a {self.title}"

# Usage
alice = Person("Alice", 30)
print(alice.greet())</code></pre>
        </section>

        <section class="type_conversion">
            <h3>Type Conversion and Checking</h3>
            
            <h4>Type Conversion</h4>
            
            <table>
                <tr>
                    <th>JavaScript</th>
                    <th>Python</th>
                </tr>
                <tr>
                    <td>
                        <code>Number(value)</code> or <code>+value</code>
                        <br>
                        <code>String(value)</code> or <code>value.toString()</code>
                        <br>
                        <code>Boolean(value)</code> or <code>!!value</code>
                        <br>
                        <code>Array.from(value)</code>
                        <br>
                        <code>Object.entries(obj)</code>, <code>Object.fromEntries(entries)</code>
                    </td>
                    <td>
                        <code>int(value)</code>, <code>float(value)</code>
                        <br>
                        <code>str(value)</code>
                        <br>
                        <code>bool(value)</code>
                        <br>
                        <code>list(value)</code>, <code>tuple(value)</code>
                        <br>
                        <code>dict(items)</code>
                    </td>
                </tr>
            </table>
            
            <pre><code>// JavaScript
let num = Number("42");    // 42
let str = String(42);      // "42"
let bool = Boolean(1);     // true
let arr = Array.from("abc");  // ["a", "b", "c"]
let obj = Object.fromEntries([["a", 1], ["b", 2]]);  // {a: 1, b: 2}

# Python
num = int("42")          # 42
str_val = str(42)        # "42"
bool_val = bool(1)       # True
arr = list("abc")        # ["a", "b", "c"]
dict_val = dict([("a", 1), ("b", 2)])  # {"a": 1, "b": 2}</code></pre>
            
            <h4>Type Checking</h4>
            
            <table>
                <tr>
                    <th>JavaScript</th>
                    <th>Python</th>
                </tr>
                <tr>
                    <td>
                        <code>typeof value</code> - primitive types
                        <br>
                        <code>value instanceof Constructor</code> - objects
                        <br>
                        <code>Array.isArray(value)</code> - special case for arrays
                    </td>
                    <td>
                        <code>type(value)</code> - returns the class/type
                        <br>
                        <code>isinstance(value, Class)</code> - check inheritance
                        <br>
                        <code>issubclass(Class, ParentClass)</code> - check class inheritance
                    </td>
                </tr>
            </table>
            
            <pre><code>// JavaScript
typeof 42;                // "number"
typeof "hello";           // "string"
typeof true;              // "boolean"
typeof undefined;         // "undefined"
typeof {};                // "object"
typeof [];                // "object" (can't distinguish arrays)
typeof null;              // "object" (a JS quirk)

Array.isArray([]);        // true
value instanceof Array;   // true for arrays
value instanceof Object;  // true for any object

# Python
type(42)                 # <class 'int'>
type("hello")            # <class 'str'>
type(True)               # <class 'bool'>
type(None)               # <class 'NoneType'>
type({})                 # <class 'dict'>
type([])                 # <class 'list'>

isinstance([], list)     # True
isinstance([], object)   # True for any object
issubclass(bool, int)    # True (booleans are a subclass of integers in Python)</code></pre>
        </section>

        <section class="common_pitfalls">
            <h3>Common Pitfalls and Gotchas</h3>
            
            <h4>Equality Comparisons</h4>
            
            <pre><code>// JavaScript has == (loose equality) and === (strict equality)
1 == "1";  // true (loose equality with type coercion)
1 === "1"; // false (strict equality, no type coercion)

// Object equality checks reference, not contents
{} == {};  // false
{} === {}; // false
let obj = {};
obj == obj;  // true

# Python has only == (value equality) and is (identity)
1 == "1"  # False (no type coercion)
1 == 1.0  # True (value equality)

# Object equality checks value, not reference
{} == {}  # True
{} is {}  # False (different objects)
obj = {}
obj is obj  # True</code></pre>
            
            <h4>Mutable Default Arguments</h4>
            
            <pre><code>// JavaScript - no issue with mutable defaults
function addItem(item, list = []) {
    list.push(item);
    return list;
}

addItem("a");  // ["a"]
addItem("b");  // ["b"]  (new default list each time)

# Python - beware of mutable defaults!
def add_item(item, list=[]):  # DANGER! list created only once
    list.append(item)
    return list

add_item("a")  # ["a"]
add_item("b")  # ["a", "b"]  (same list reused!)

# Correct pattern:
def add_item_safe(item, list=None):
    if list is None:
        list = []
    list.append(item)
    return list</code></pre>
            
            <h4>Variable Scoping</h4>
            
            <pre><code>// JavaScript - block scope with let/const
function jsScope() {
    if (true) {
        let x = 10;  // Block scoped
        var y = 20;  // Function scoped
    }
    console.log(y);  // 20
    console.log(x);  // ReferenceError: x is not defined
}

# Python - function scope only
def python_scope():
    if True:
        x = 10  # Function scoped
        y = 20  # Function scoped
    print(x)  # 10 - still in scope
    print(y)  # 20 - still in scope</code></pre>
            
            <h4>Copying Objects</h4>
            
            <pre><code>// JavaScript - shallow copy
let original = {a: 1, b: {c: 2}};
let shallowCopy = {...original};  // ES6 spread syntax
let deepCopy = JSON.parse(JSON.stringify(original));  // Simple deep copy

# Python - shallow copy
original = {'a': 1, 'b': {'c': 2}}
shallow_copy = original.copy()  # or dict(original)
# Python - deep copy
import copy
deep_copy = copy.deepcopy(original)</code></pre>
        </section>

        <section class="practical_examples">
            <h3>Practical Examples</h3>
            
            <h4>Data Processing</h4>
            
            <pre><code>// JavaScript
const data = [
    { name: "Alice", age: 30, active: true },
    { name: "Bob", age: 25, active: false },
    { name: "Charlie", age: 35, active: true }
];

// Get active users
const activeUsers = data.filter(user => user.active);

// Map user names to uppercase
const upperNames = data.map(user => user.name.toUpperCase());

// Calculate average age
const averageAge = data.reduce((sum, user) => sum + user.age, 0) / data.length;

# Python
data = [
    {"name": "Alice", "age": 30, "active": True},
    {"name": "Bob", "age": 25, "active": False},
    {"name": "Charlie", "age": 35, "active": True}
]

# Get active users
active_users = [user for user in data if user["active"]]

# Map user names to uppercase
upper_names = [user["name"].upper() for user in data]

# Calculate average age
average_age = sum(user["age"] for user in data) / len(data)</code></pre>
            
            <h4>Asynchronous Code</h4>
            
            <pre><code>// JavaScript - Promises and async/await
function fetchData() {
    return fetch('https://api.example.com/data')
        .then(response => response.json());
}

// With async/await
async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error:', error);
    }
}

# Python - asyncio and async/await
import asyncio
import aiohttp

async def fetch_data():
    async with aiohttp.ClientSession() as session:
        async with session.get('https://api.example.com/data') as response:
            return await response.json()

# With async/await
async def get_data():
    try:
        data = await fetch_data()
        return data
    except Exception as e:
        print(f"Error: {e}")

# Running async code
asyncio.run(get_data())</code></pre>
        </section>

        <section class="exercises">
            <h3>Practice Exercises</h3>
            
            <h4>Exercise 1: Type Conversion</h4>
            
            <p>Write functions in both JavaScript and Python to:</p>
            <ol>
                <li>Convert a list of mixed values to their corresponding string representations</li>
                <li>Filter out all falsy values from a collection</li>
                <li>Calculate the sum of all numeric values in a mixed-type collection</li>
            </ol>
            
            <h4>Exercise 2: Data Transformation</h4>
            
            <p>Given a list of objects/dictionaries representing people:</p>
            <ol>
                <li>Filter to find all people over 30</li>
                <li>Transform the data to a format grouping people by age ranges</li>
                <li>Sort the list by name in alphabetical order</li>
            </ol>
            
            <h4>Exercise 3: Class Conversion</h4>
            
            <p>Take a JavaScript class you've written before and convert it to a Python class, ensuring it follows Python conventions and best practices.</p>
        </section>

        <section class="best_practices">
            <h3>Best Practices for JavaScript Developers Learning Python</h3>
            
            <ul>
                <li><strong>Embrace Pythonic Style:</strong> Follow PEP 8 style guidelines (snake_case for variables/functions, PascalCase for classes)</li>
                <li><strong>Use List/Dict Comprehensions:</strong> Learn to use comprehensions instead of <code>map</code>/<code>filter</code> when appropriate</li>
                <li><strong>Leverage Built-in Functions:</strong> Python has many useful built-in functions (<code>len</code>, <code>max</code>, <code>min</code>, <code>sum</code>, etc.)</li>
                <li><strong>Avoid Overusing Classes:</strong> Python functions and modules can do a lot without needing classes</li>
                <li><strong>Remember <code>self</code> Parameter:</strong> Always include <code>self</code> as the first parameter in instance methods</li>
                <li><strong>Type Annotations:</strong> Consider using type hints (Python 3.5+) for better code clarity, especially if coming from TypeScript</li>
                <li><strong>Context Managers:</strong> Use <code>with</code> statements for resource management instead of try/finally</li>
                <li><strong>Explicit is Better than Implicit:</strong> Python values clarity over terseness</li>
            </ul>
            
            <pre><code># Good Pythonic code example
def process_user_data(users, min_age=18):
    """Process user data to get active users above a minimum age."""
    active_adults = [
        user for user in users
        if user["active"] and user["age"] >= min_age
    ]
    
    # Group by age decade
    by_decade = {}
    for user in active_adults:
        decade = user["age"] // 10 * 10
        if decade not in by_decade:
            by_decade[decade] = []
        by_decade[decade].append(user)
    
    return {
        "active_adult_count": len(active_adults),
        "by_decade": by_decade,
        "average_age": sum(user["age"] for user in active_adults) / len(active_adults) if active_adults else 0
    }</code></pre>
        </section>

        <section class="next_steps">
            <h3>Next Steps for JavaScript Developers</h3>
            
            <p>Now that you understand the key differences between Python and JavaScript data types, here are some next steps to deepen your Python knowledge:</p>
            
            <ol>
                <li><strong>Explore the Standard Library:</strong> Python's built-in modules like <code>collections</code>, <code>itertools</code>, and <code>functools</code> offer powerful tools</li>
                <li><strong>Learn Generators and Iterators:</strong> These Python features can replace many array operations in JavaScript</li>
                <li><strong>Dive into Decorators:</strong> Python's decorator pattern is powerful and widely used</li>
                <li><strong>Understand Python's Context Managers:</strong> The <code>with</code> statement provides elegant resource management</li>
                <li><strong>Try Type Annotations:</strong> If you're used to TypeScript, exploring Python's typing module can help</li>
                <li><strong>Learn Dependency Management:</strong> Understand pip, virtual environments, and requirements.txt</li>
            </ol>
            
            <h4>Additional Resources</h4>
            
            <ul>
                <li><a href="https://docs.python.org/3/tutorial/index.html" target="_blank">The Python Tutorial</a></li>
                <li><a href="https://realpython.com/tutorials/intermediate/" target="_blank">Real Python - Intermediate Tutorials</a></li>
                <li><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank">PEP 8 - Style Guide for Python Code</a></li>
                <li><a href="https://pypi.org/project/pylint/" target="_blank">Pylint - A Python Linter</a></li>
                <li><a href="https://docs.python.org/3/library/typing.html" target="_blank">Python Type Hints</a></li>
            </ul>
            
            <p>In our next session, we'll explore control flow in Python, including conditionals, loops, and exception handling, and how they compare to JavaScript's control flow mechanisms.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
