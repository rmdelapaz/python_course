<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Conditional Statements - Control Flow</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Conditional Statements</h1>
        <h2>Week 2 Day 2: Control Flow Fundamentals</h2>
    </header>

    <main>
        <section class="intro">
            <h3>Introduction to Control Flow</h3>
            <p>
                Welcome to our deep dive into Python's conditional statements! Today, we'll explore how Python makes decisions—one of the most fundamental aspects of programming. Just as humans make countless decisions daily, our programs need to evaluate conditions and choose different paths based on those evaluations.
            </p>
            <p>
                Imagine your program as a river flowing downstream. Conditional statements are like forks in that river, directing the flow of execution based on certain conditions. Without these decision points, our programs would simply execute linearly from top to bottom—limiting their usefulness for solving real-world problems.
            </p>
            <p>
                The code for this lesson can be found in the <code>/week2/day2/conditional_statements.py</code> file in your course repository.
            </p>
        </section>

        <section class="if_statements">
            <h3>If Statements: The Basic Decision Maker</h3>
            <p>
                The <code>if</code> statement is Python's most basic decision-making tool. It evaluates a condition and executes a block of code only if that condition is True.
            </p>
            <p>
                Think of an <code>if</code> statement as a bouncer at a club. It checks if you meet certain criteria (the condition), and only if you do, grants you entry (executes the code block).
            </p>
            <p>
                Here's the basic syntax:
            </p>
            <pre><code>if condition:
    # Code to execute if condition is True
    statement1
    statement2
    # ... more statements</code></pre>
            
            <p>
                A few key points about Python's <code>if</code> statements:
            </p>
            <ul>
                <li>The condition must evaluate to a boolean value (True or False)</li>
                <li>The colon (:) is required and marks the beginning of the conditional block</li>
                <li>The indentation defines the scope of the conditional block (conventionally 4 spaces)</li>
                <li>If the condition is False, Python simply skips the entire block</li>
            </ul>
            
            <h4>Simple Example: Age Verification</h4>
            <pre><code>age = 19

if age >= 18:
    print("You are an adult.")
    print("You can vote.")
    
# Output: 
# You are an adult.
# You can vote.</code></pre>

            <h4>Real-World Application: Authentication System</h4>
            <pre><code>username = "user123"
password = "securepass"

input_username = input("Enter username: ")
input_password = input("Enter password: ")

if input_username == username and input_password == password:
    print("Login successful!")
    print("Welcome to the system.")</code></pre>
            
            <p>
                In this example, if either the username OR password is incorrect, nothing is printed and the login fails silently. We'll improve this with else statements shortly.
            </p>
        </section>

        <section class="if_else">
            <h3>If-Else: Handling Alternative Outcomes</h3>
            <p>
                The <code>if-else</code> statement extends our decision-making capabilities by providing an alternative path when our condition is False.
            </p>
            <p>
                Imagine a fork in a road: the <code>if</code> condition decides which path to take, but with <code>if-else</code>, we're guaranteed to take one of the two paths. There's no possibility of standing still.
            </p>
            
            <pre><code>if condition:
    # Execute this block if condition is True
    statements_when_true
else:
    # Execute this block if condition is False
    statements_when_false</code></pre>
            
            <h4>Example: Improved Age Verification</h4>
            <pre><code>age = 15

if age >= 18:
    print("You are an adult.")
    print("You can vote.")
else:
    print("You are a minor.")
    print("You cannot vote yet.")
    
# Output:
# You are a minor.
# You cannot vote yet.</code></pre>

            <h4>Real-World Application: Improved Authentication</h4>
            <pre><code>username = "user123"
password = "securepass"

input_username = input("Enter username: ")
input_password = input("Enter password: ")

if input_username == username and input_password == password:
    print("Login successful!")
    print("Welcome to the system.")
else:
    print("Login failed.")
    print("Please check your username and password.")</code></pre>
            
            <p>
                Much better! Now our users get feedback whether they succeed or fail to login.
            </p>
            
            <h4>The Binary Nature of If-Else</h4>
            <p>
                Think of <code>if-else</code> as a binary switch—it's either on or off, yes or no, true or false. Every possible input falls into one of exactly two categories. This is perfect for binary decisions, but what about when we need to consider multiple possibilities?
            </p>
        </section>

        <section class="if_elif_else">
            <h3>If-Elif-Else: Handling Multiple Possibilities</h3>
            <p>
                The <code>elif</code> statement (short for "else if") allows us to check multiple conditions in sequence. It extends the binary nature of <code>if-else</code> to accommodate multiple pathways.
            </p>
            <p>
                Think of it as a series of filters or checkpoints, where Python evaluates each condition in order until it finds one that's True. Once it finds a True condition, it executes that block and skips all the rest.
            </p>
            
            <pre><code>if condition1:
    # Execute if condition1 is True
    statements_for_condition1
elif condition2:
    # Execute if condition1 is False AND condition2 is True
    statements_for_condition2
elif condition3:
    # Execute if condition1 and condition2 are False AND condition3 is True
    statements_for_condition3
else:
    # Execute if all conditions are False
    statements_when_all_false</code></pre>
            
            <p>
                The <code>else</code> block is optional. If omitted and all conditions are False, nothing will execute.
            </p>

            <h4>Example: Grading System</h4>
            <pre><code>score = 85

if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
elif score >= 70:
    grade = "C"
elif score >= 60:
    grade = "D"
else:
    grade = "F"

print(f"Your grade is: {grade}")
# Output: Your grade is: B</code></pre>

            <p>
                Note how we only need to specify the lower bound in each condition, because once a condition is satisfied, the subsequent conditions aren't checked. This is more efficient and readable than writing:
            </p>
            
            <pre><code># Less elegant approach
if score >= 90:
    grade = "A"
elif score >= 80 and score < 90:
    grade = "B"
elif score >= 70 and score < 80:
    grade = "C"
# and so on...</code></pre>

            <h4>Real-World Application: Multi-tier Pricing System</h4>
            <pre><code>item_count = int(input("How many items are you purchasing? "))
base_price = 10.0

if item_count == 1:
    total = base_price
    print(f"Regular price: ${total:.2f}")
elif 2 <= item_count <= 5:
    total = item_count * base_price * 0.95  # 5% discount
    print(f"5% bulk discount applied: ${total:.2f}")
elif 6 <= item_count <= 10:
    total = item_count * base_price * 0.9  # 10% discount
    print(f"10% bulk discount applied: ${total:.2f}")
else:
    total = item_count * base_price * 0.8  # 20% discount
    print(f"20% bulk discount applied: ${total:.2f}")</code></pre>

            <h4>Important Consideration: Order Matters!</h4>
            <p>
                With <code>if-elif-else</code> chains, the order of conditions can significantly impact behavior. Python evaluates from top to bottom and executes the first True condition it encounters.
            </p>
            <p>
                Consider our grading example with the conditions reversed:
            </p>
            
            <pre><code># Incorrect order
score = 85

if score >= 60:  # This will always trigger for passing scores
    grade = "D"
elif score >= 70:
    grade = "C"
elif score >= 80:
    grade = "B"
elif score >= 90:
    grade = "A"
else:
    grade = "F"

print(f"Your grade is: {grade}")
# Output: Your grade is: D (Incorrect!)</code></pre>
            
            <p>
                Since 85 satisfies the first condition (≥60), Python assigns "D" and skips all other checks—even though the score qualifies for a higher grade!
            </p>
        </section>

        <section class="comparison">
            <h3>Comparison and Logical Operators</h3>
            <p>
                Conditional statements rely on expressions that evaluate to either True or False. Python provides several operators to form these expressions:
            </p>
            
            <h4>Comparison Operators</h4>
            <ul>
                <li><code>==</code>: Equal to</li>
                <li><code>!=</code>: Not equal to</li>
                <li><code>&gt;</code>: Greater than</li>
                <li><code>&lt;</code>: Less than</li>
                <li><code>&gt;=</code>: Greater than or equal to</li>
                <li><code>&lt;=</code>: Less than or equal to</li>
            </ul>
            
            <h4>Logical Operators</h4>
            <ul>
                <li><code>and</code>: True if both conditions are True</li>
                <li><code>or</code>: True if at least one condition is True</li>
                <li><code>not</code>: Inverts the boolean value (True becomes False, False becomes True)</li>
            </ul>
            
            <h4>Example: Combining Operators</h4>
            <pre><code>age = 25
income = 45000

# Using AND - both conditions must be True
if age > 18 and income > 30000:
    print("You qualify for a basic credit card.")

# Using OR - at least one condition must be True
if age > 65 or income > 100000:
    print("You qualify for premium services.")

# Using NOT - inverts the condition
if not (age < 18):
    print("You are not a minor.")</code></pre>
            
            <h4>Practical Application: Weather Clothing Advisor</h4>
            <pre><code>temperature = float(input("What's the temperature outside? "))
is_raining = input("Is it raining? (yes/no) ").lower() == "yes"

if temperature > 80:
    if is_raining:
        print("It's hot and rainy. Wear light clothes and take an umbrella.")
    else:
        print("It's hot. Wear light clothes and consider a hat.")
elif temperature > 60:
    if is_raining:
        print("It's mild and rainy. Wear a light jacket and take an umbrella.")
    else:
        print("It's mild. A t-shirt should be fine.")
elif temperature > 40:
    if is_raining:
        print("It's cool and rainy. Wear a warm jacket and take an umbrella.")
    else:
        print("It's cool. Wear a light jacket.")
else:
    if is_raining:
        print("It's cold and rainy. Wear a heavy coat, hat, gloves, and take an umbrella.")
    else:
        print("It's cold. Wear a heavy coat, hat, and gloves.")</code></pre>
        </section>

        <section class="nested">
            <h3>Nested Conditionals</h3>
            <p>
                Conditional statements can be nested within other conditional blocks, creating more complex decision trees. This is useful when a second decision depends on the outcome of the first.
            </p>
            <p>
                Think of nested conditionals like a choose-your-own-adventure book, where each decision leads to a new set of choices.
            </p>
            
            <pre><code>if outer_condition:
    # This code runs if outer_condition is True
    
    if nested_condition:
        # This code runs if both outer_condition and nested_condition are True
    else:
        # This code runs if outer_condition is True but nested_condition is False
else:
    # This code runs if outer_condition is False</code></pre>
            
            <h4>Example: Advanced Authentication System</h4>
            <pre><code>username = "admin"
password = "adminpass"
is_admin = True
system_locked = False

input_username = input("Username: ")
input_password = input("Password: ")

if input_username == username and input_password == password:
    print("Authentication successful!")
    
    if is_admin:
        print("Admin access granted.")
        
        if system_locked:
            print("System is currently locked. Admin override? (yes/no)")
            override = input().lower()
            
            if override == "yes":
                print("Override accepted. System unlocked.")
                system_locked = False
            else:
                print("Override cancelled. System remains locked.")
        else:
            print("System is operational. Full access granted.")
    else:
        print("User access granted. Limited functionality available.")
else:
    print("Authentication failed. Please try again.")</code></pre>
            
            <p>
                While nested conditionals can be powerful, deep nesting can lead to confusing "arrow code" or "pyramid of doom." Consider refactoring deeply nested conditionals into separate functions or using early returns to flatten the structure.
            </p>
            
            <h4>Flattening Nested Conditionals</h4>
            <pre><code># Instead of this deeply nested structure:
if condition1:
    if condition2:
        if condition3:
            do_something()
        else:
            do_alternative()
    else:
        handle_condition2_false()
else:
    handle_condition1_false()

# Consider early returns or guard clauses:
if not condition1:
    handle_condition1_false()
    return  # Exit the function early

if not condition2:
    handle_condition2_false()
    return

if condition3:
    do_something()
else:
    do_alternative()</code></pre>
        </section>

        <section class="truthiness">
            <h3>Truthiness in Python</h3>
            <p>
                In Python, conditional statements evaluate the "truthiness" of expressions. Beyond the boolean values <code>True</code> and <code>False</code>, other values can be interpreted as either truthy or falsy in boolean contexts.
            </p>
            
            <h4>Falsy Values in Python:</h4>
            <ul>
                <li><code>False</code>: The boolean False</li>
                <li><code>None</code>: Python's null equivalent</li>
                <li><code>0</code>: Zero in any numeric type (0, 0.0, 0j)</li>
                <li><code>""</code>: Empty string</li>
                <li><code>[]</code>: Empty list</li>
                <li><code>()</code>: Empty tuple</li>
                <li><code>{}</code>: Empty dictionary</li>
                <li><code>set()</code>: Empty set</li>
            </ul>
            
            <p>
                Everything else is considered truthy.
            </p>
            
            <h4>Example: Leveraging Truthiness in Conditionals</h4>
            <pre><code># Checking if a list is empty
items = []
if items:
    print("We have some items!")
else:
    print("The list is empty.")
    
# Checking for default values
name = input("Enter your name (or leave empty for 'Guest'): ")
if not name:  # True if name is an empty string
    name = "Guest"
print(f"Welcome, {name}!")

# Checking for None
result = some_function()
if result is None:  # Explicit check for None
    print("Function returned None.")
elif result:  # General truthiness check
    print("Function returned a truthy value.")
else:
    print("Function returned a falsy value (but not None).")</code></pre>
            
            <p>
                An important note: When checking for <code>None</code> specifically, use <code>is None</code> rather than <code>== None</code>. This checks for identity rather than equality, which is more appropriate for the singleton <code>None</code> object.
            </p>
            
            <h4>Real-World Application: Default Configuration</h4>
            <pre><code>def process_order(items, shipping_address=None, payment_method=None, coupon_code=""):
    # Validate essential components
    if not items:
        return "Error: Cannot process an order with no items"
    
    if not shipping_address:
        return "Error: Shipping address is required"
        
    # Set default payment method if none provided
    if not payment_method:
        payment_method = "Credit Card"
        
    # Apply coupon if provided
    discount = 0
    if coupon_code:
        discount = calculate_discount(coupon_code)
        
    # Process the order...
    return "Order processed successfully"</code></pre>
        </section>

        <section class="short_circuit">
            <h3>Short-Circuit Evaluation</h3>
            <p>
                Python uses short-circuit evaluation for logical operators, which can be leveraged for more concise and efficient code.
            </p>
            <ul>
                <li>For <code>and</code>: If the left operand is False, Python knows the entire expression must be False regardless of the right operand, so it doesn't evaluate the right side at all.</li>
                <li>For <code>or</code>: If the left operand is True, Python knows the entire expression must be True regardless of the right operand, so it doesn't evaluate the right side.</li>
            </ul>
            <p>
                This behavior enables elegant patterns like default values and guard clauses.
            </p>
            
            <h4>Example: Default Values with OR</h4>
            <pre><code># Traditional approach
name = input("Enter your name: ")
if not name:
    name = "Guest"
    
# Short-circuit approach
name = input("Enter your name: ") or "Guest"

# The above works because:
# - If the input is non-empty (truthy), it's used as the name
# - If the input is empty (falsy), "Guest" is used instead</code></pre>
            
            <h4>Example: Early Returns with AND</h4>
            <pre><code># Traditional approach
def process_item(item):
    if item:
        # Process the item
        return True
    else:
        return False
        
# Short-circuit approach
def process_item(item):
    return bool(item) and process_item_internal(item)
    
# In this case, if item is falsy, the function returns False immediately
# without calling process_item_internal().</code></pre>
        </section>

        <section class="ternary">
            <h3>Conditional Expressions (The Ternary Operator)</h3>
            <p>
                Python offers a condensed one-line conditional expression, often called the "ternary operator" (though it's not technically an operator in Python):
            </p>
            
            <pre><code>value_if_true if condition else value_if_false</code></pre>
            
            <p>
                This compact form is perfect for simple conditional assignments.
            </p>
            
            <h4>Example: Basic Usage</h4>
            <pre><code># Traditional if-else
if age >= 18:
    status = "adult"
else:
    status = "minor"
    
# Ternary equivalent
status = "adult" if age >= 18 else "minor"</code></pre>
            
            <h4>Example: Nested Ternary (Use with caution)</h4>
            <pre><code>category = "child" if age < 13 else "teenager" if age < 18 else "adult"</code></pre>
            
            <p>
                While nested ternary expressions are possible, they can quickly become difficult to read. Use them sparingly and consider traditional if-elif-else blocks for more complex conditions.
            </p>
            
            <h4>Real-World Application: Message Formatting</h4>
            <pre><code>item_count = 5
message = f"You have {item_count} item{'s' if item_count != 1 else ''} in your cart."

# With item_count = 5: "You have 5 items in your cart."
# With item_count = 1: "You have 1 item in your cart."</code></pre>
        </section>

        <section class="switch_case">
            <h3>Switch-Case Alternative in Python</h3>
            <p>
                Unlike many programming languages, Python traditionally didn't have a switch-case statement. Instead, we used if-elif-else chains or dictionary-based dispatchers. However, Python 3.10 (released in 2021) introduced the match-case statement, which provides similar functionality.
            </p>
            
            <h4>Traditional Dictionary-Based Switch</h4>
            <pre><code>def get_day_type(day):
    return {
        "Monday": "Weekday",
        "Tuesday": "Weekday",
        "Wednesday": "Weekday",
        "Thursday": "Weekday",
        "Friday": "Weekday",
        "Saturday": "Weekend",
        "Sunday": "Weekend"
    }.get(day, "Unknown")  # .get() allows us to specify a default value

day = "Wednesday"
day_type = get_day_type(day)
print(f"{day} is a {day_type}.")  # Output: Wednesday is a Weekday.</code></pre>
            
            <h4>Python 3.10+ Match-Case</h4>
            <pre><code># Requires Python 3.10 or newer
def get_day_type(day):
    match day:
        case "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday":
            return "Weekday"
        case "Saturday" | "Sunday":
            return "Weekend"
        case _:  # Default case (like 'default' in other languages)
            return "Unknown"

day = "Sunday"
day_type = get_day_type(day)
print(f"{day} is a {day_type}.")  # Output: Sunday is a Weekend.</code></pre>
            
            <p>
                Match-case offers more powerful pattern matching capabilities than traditional switch statements, including destructuring, guard clauses, and more.
            </p>
        </section>

        <section class="best_practices">
            <h3>Best Practices and Common Pitfalls</h3>
            
            <h4>Best Practices</h4>
            <ul>
                <li><strong>Clarity over cleverness</strong>: Prefer readable code over unnecessarily compact expressions.</li>
                <li><strong>Use meaningful comparisons</strong>: <code>if is_valid:</code> is better than <code>if is_valid == True:</code></li>
                <li><strong>Consider the default case</strong>: Always include an else clause when appropriate to handle unexpected inputs.</li>
                <li><strong>Keep conditionals simple</strong>: Break complex conditions into separate variables with descriptive names.</li>
                <li><strong>Avoid deeply nested conditionals</strong>: Consider refactoring or early returns to flatten the code.</li>
            </ul>
            
            <h4>Common Pitfalls</h4>
            <ul>
                <li><strong>Assignment vs. comparison</strong>: Using <code>=</code> (assignment) instead of <code>==</code> (comparison) in conditions.</li>
                <li><strong>Order of conditions</strong>: Placing more specific conditions after more general ones in if-elif chains.</li>
                <li><strong>Redundant boolean comparisons</strong>: Writing <code>if x == True:</code> instead of <code>if x:</code></li>
                <li><strong>Forgetting that 0 and empty containers are falsy</strong>: This can lead to unexpected behavior when checking numeric values or collections.</li>
                <li><strong>Incorrect indentation</strong>: Python uses indentation to define code blocks, so inconsistent spacing can cause syntax errors or logical bugs.</li>
            </ul>
            
            <h4>Example: Refactoring for Readability</h4>
            <pre><code># Less readable
if age > 18 and income > 30000 and credit_score > 700 and not has_defaulted:
    approve_loan()

# More readable
is_adult = age > 18
has_sufficient_income = income > 30000
has_good_credit = credit_score > 700
has_clean_history = not has_defaulted

if is_adult and has_sufficient_income and has_good_credit and has_clean_history:
    approve_loan()</code></pre>
        </section>

        <section class="exercises">
            <h3>Practice Exercises</h3>
            <p>
                To solidify your understanding of conditional statements, try these exercises. Solutions will be reviewed in class.
            </p>
            
            <ol>
                <li>
                    <p><strong>Basic If-Else</strong>: Write a program that asks for a user's age and prints whether they are eligible to vote (18 or older).</p>
                </li>
                <li>
                    <p><strong>If-Elif-Else Chain</strong>: Create a BMI calculator that categorizes the result as Underweight, Normal, Overweight, or Obese based on standard BMI ranges.</p>
                </li>
                <li>
                    <p><strong>Nested Conditionals</strong>: Write a program that determines whether a year is a leap year. (Hint: A leap year is divisible by 4, except for century years which must be divisible by 400).</p>
                </li>
                <li>
                    <p><strong>Logical Operators</strong>: Create a simple password validator that checks if a password:
                        <ul>
                            <li>Is at least 8 characters long</li>
                            <li>Contains at least one uppercase letter</li>
                            <li>Contains at least one digit</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <p><strong>Truthiness</strong>: Write a function that checks if an input string is a palindrome (reads the same forwards and backwards, ignoring case), using Python's truthiness to handle empty inputs.</p>
                </li>
                <li>
                    <p><strong>Ternary Expressions</strong>: Rewrite the following using a ternary expression:</p>
                    <pre><code>message = ""
if number % 2 == 0:
    message = "Even"
else:
    message = "Odd"</code></pre>
                </li>
                <li>
                    <p><strong>Advanced Challenge</strong>: Create a rock, paper, scissors game where the user plays against the computer. Use conditional statements to determine the winner.</p>
                </li>
            </ol>
        </section>

        <section class="real_world">
            <h3>Real-World Applications</h3>
            <p>
                Conditional statements are foundational to virtually all programming tasks. Here are some real-world applications that rely heavily on conditionals:
            </p>
            
            <ul>
                <li><strong>Form Validation</strong>: Checking if user inputs meet required criteria.</li>
                <li><strong>Authentication Systems</strong>: Verifying credentials and authorization levels.</li>
                <li><strong>E-commerce</strong>: Calculating discounts, shipping costs, and eligibility for promotions.</li>
                <li><strong>Content Management</strong>: Displaying different content based on user roles or preferences.</li>
                <li><strong>Data Processing</strong>: Filtering and categorizing data based on various criteria.</li>
                <li><strong>Game Development</strong>: Making decisions based on player actions and game state.</li>
                <li><strong>Financial Applications</strong>: Approving transactions based on account status and limits.</li>
            </ul>
            
            <h4>Example: E-commerce Checkout Logic</h4>
            <pre><code>def calculate_total(items, user_type, coupon_code=None, shipping_country="US"):
    subtotal = sum(item["price"] * item["quantity"] for item in items)
    
    # Apply user type discount
    if user_type == "premium":
        discount_rate = 0.10  # 10% discount for premium users
    elif user_type == "loyalty" and subtotal > 100:
        discount_rate = 0.05  # 5% for loyalty members on orders over $100
    else:
        discount_rate = 0
        
    # Apply additional coupon if valid
    additional_discount = 0
    if coupon_code:
        if coupon_code == "WELCOME20" and not user_has_used_code_before(user_id, coupon_code):
            additional_discount = min(20, subtotal * 0.20)  # $20 or 20%, whichever is less
        elif coupon_code == "FREESHIP":
            shipping_fee = 0  # Will override shipping calculation below
            
    # Calculate discounted subtotal
    discounted_subtotal = subtotal * (1 - discount_rate) - additional_discount
    
    # Calculate shipping
    if "shipping_fee" not in locals():  # If not already set by a coupon
        if shipping_country == "US":
            if discounted_subtotal >= 50 or user_type == "premium":
                shipping_fee = 0
            else:
                shipping_fee = 5.99
        else:
            if discounted_subtotal >= 100:
                shipping_fee = 9.99
            else:
                shipping_fee = 19.99
                
    # Calculate tax (simplified)
    if shipping_country == "US":
        tax_rate = 0.07  # 7% sales tax
    else:
        tax_rate = 0  # Assume tax is handled differently for international
        
    tax = discounted_subtotal * tax_rate
    
    # Final total
    total = discounted_subtotal + shipping_fee + tax
    
    return {
        "subtotal": subtotal,
        "discount": subtotal * discount_rate + additional_discount,
        "shipping": shipping_fee,
        "tax": tax,
        "total": total
    }</code></pre>
            
            <p>
                This example demonstrates how real-world business logic often involves multiple layers of conditional checks, from user status to coupon validation to shipping rules.
            </p>
        </section>

        <section class="conclusion">
            <h3>Conclusion and Next Steps</h3>
            <p>
                We've covered the essential aspects of conditional statements in Python, from basic if-else structures to more complex patterns and best practices. These tools give your programs the ability to make decisions and respond dynamically to different conditions.
            </p>
            <p>
                Tomorrow, we'll build on this foundation by exploring loops in Python, which allow for repeated execution of code blocks. The combination of conditionals and loops will significantly expand your ability to solve complex problems through code.
            </p>
            <p>
                Remember to practice these concepts by completing the exercises and experimenting with your own examples. The ability to write effective conditional logic is one of the most important skills you'll develop as a programmer.
            </p>
            <p>
                For further exploration, I recommend reviewing the official Python documentation on control flow: <a href="https://docs.python.org/3/tutorial/controlflow.html" target="_blank">https://docs.python.org/3/tutorial/controlflow.html</a>
            </p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
