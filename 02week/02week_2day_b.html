<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Comparison and Logical Operators</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Comparison and Logical Operators</h1>
        <h2>Week 2 Day 2: Control Flow Fundamentals</h2>
    </header>

    <main>
        <section class="intro">
            <h3>Introduction to Operators in Python</h3>
            <p>
                Welcome to our exploration of comparison and logical operators in Python! These operators are the fundamental building blocks that allow our programs to make decisions and evaluate conditions. If Python were a language (which it is!), then operators would be the verbs and adjectives that give it expressive power.
            </p>
            <p>
                Imagine you're a judge in a courtroom. Comparison operators are like asking questions such as "Is the defendant taller than 6 feet?" while logical operators are like connecting multiple pieces of evidence: "Was the defendant at the scene AND do they have a motive?"
            </p>
            <p>
                The code for this lesson can be found in the <code>/week2/day2/comparison_logical_operators.py</code> file in your course repository.
            </p>
        </section>

        <section class="comparison_operators">
            <h3>Comparison Operators</h3>
            <p>
                Comparison operators allow us to compare values and determine the relationship between them. Every comparison operation results in a boolean value: either <code>True</code> or <code>False</code>.
            </p>
            
            <h4>Types of Comparison Operators</h4>
            <table>
                <tr>
                    <th>Operator</th>
                    <th>Description</th>
                    <th>Example</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td><code>==</code></td>
                    <td>Equal to</td>
                    <td><code>5 == 5</code></td>
                    <td><code>True</code></td>
                </tr>
                <tr>
                    <td><code>!=</code></td>
                    <td>Not equal to</td>
                    <td><code>5 != 3</code></td>
                    <td><code>True</code></td>
                </tr>
                <tr>
                    <td><code>&gt;</code></td>
                    <td>Greater than</td>
                    <td><code>7 &gt; 3</code></td>
                    <td><code>True</code></td>
                </tr>
                <tr>
                    <td><code>&lt;</code></td>
                    <td>Less than</td>
                    <td><code>5 &lt; 10</code></td>
                    <td><code>True</code></td>
                </tr>
                <tr>
                    <td><code>&gt;=</code></td>
                    <td>Greater than or equal to</td>
                    <td><code>5 &gt;= 5</code></td>
                    <td><code>True</code></td>
                </tr>
                <tr>
                    <td><code>&lt;=</code></td>
                    <td>Less than or equal to</td>
                    <td><code>5 &lt;= 10</code></td>
                    <td><code>True</code></td>
                </tr>
            </table>
            
            <h4>Basic Examples</h4>
            <pre><code>a = 10
b = 20
c = 10

# Equal to
print(a == b)  # False
print(a == c)  # True

# Not equal to
print(a != b)  # True

# Greater than
print(a > b)   # False

# Less than
print(a < b)   # True

# Greater than or equal to
print(a >= c)  # True

# Less than or equal to
print(a <= c)  # True</code></pre>

            <h4>Comparison with Different Data Types</h4>
            <p>
                Python can compare different data types, but the behavior can sometimes be unexpected. Let's explore some examples:
            </p>
            
            <pre><code># Numbers of different types
print(5 == 5.0)  # True - integer and float with same value are considered equal

# Strings are compared lexicographically (alphabetically)
print("apple" < "banana")  # True - 'a' comes before 'b'
print("apple" < "Apple")   # False - capital letters come before lowercase in ASCII

# Different data types
print("5" == 5)  # False - string '5' is not equal to integer 5
print(True == 1)  # True - True is equal to 1
print(False == 0)  # True - False is equal to 0

# None comparisons
print(None == 0)  # False
print(None == "")  # False
print(None == None)  # True</code></pre>

            <p>
                Think of comparing strings like looking up words in a dictionary: Python compares characters one by one based on their Unicode code point values.
            </p>

            <h4>Comparing Complex Data Structures</h4>
            <pre><code># Lists - compared element by element
print([1, 2, 3] == [1, 2, 3])  # True
print([1, 2, 3] == [1, 2, 4])  # False
print([1, 2, 3] < [1, 2, 4])   # True - the third element is smaller

# Dictionaries - compare if they have the same key-value pairs
print({'a': 1, 'b': 2} == {'b': 2, 'a': 1})  # True - order doesn't matter
print({'a': 1, 'b': 2} == {'a': 1, 'c': 3})  # False - different keys</code></pre>

            <h4>Identity vs. Equality: <code>is</code> vs <code>==</code></h4>
            <p>
                Python provides two ways to compare objects:
            </p>
            <ul>
                <li><code>==</code> checks if the values are equal</li>
                <li><code>is</code> checks if the objects are identical (same memory location)</li>
            </ul>
            
            <pre><code>a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(a == b)  # True - same values
print(a is b)  # False - different objects in memory
print(a is c)  # True - same object in memory

# Special case with small integers and strings
x = 5
y = 5
print(x is y)  # True - Python optimizes small integers

# But with larger numbers
large_x = 1000
large_y = 1000
print(large_x is large_y)  # May be False depending on implementation

# String interning
s1 = "hello"
s2 = "hello"
print(s1 is s2)  # True - Python may optimize common strings</code></pre>

            <p>
                Think of <code>==</code> as comparing the contents of two books, while <code>is</code> checks if they are literally the same physical book.
            </p>

            <h4>Real-World Example: Data Validation</h4>
            <pre><code>def validate_user_input(username, password, age):
    """Validate user registration data."""
    
    errors = []
    
    # Username validation
    if len(username) < 3:
        errors.append("Username must be at least 3 characters long")
    
    if " " in username:
        errors.append("Username cannot contain spaces")
    
    # Password validation
    if len(password) < 8:
        errors.append("Password must be at least 8 characters long")
    
    if password.isalpha() or password.isdigit():
        errors.append("Password must contain both letters and numbers")
    
    # Age validation
    if not isinstance(age, (int, float)):
        errors.append("Age must be a number")
    elif age < 13:
        errors.append("You must be at least 13 years old to register")
    elif age > 120:
        errors.append("Please enter a valid age")
    
    # Return results
    if errors:
        return False, errors
    else:
        return True, ["Validation successful!"]

# Test the function
result, messages = validate_user_input("Alice123", "pass123word", 25)
print(f"Valid: {result}")
for message in messages:
    print(f"- {message}")

result, messages = validate_user_input("Bo", "password", 10)
print(f"Valid: {result}")
for message in messages:
    print(f"- {message}")</code></pre>

            <p>
                This example shows how comparison operators are essential for validating user input in real-world applications.
            </p>
        </section>

        <section class="logical_operators">
            <h3>Logical Operators</h3>
            <p>
                Logical operators allow us to combine multiple conditions and create complex logical expressions. They operate on boolean values and return boolean results.
            </p>

            <h4>Types of Logical Operators</h4>
            <table>
                <tr>
                    <th>Operator</th>
                    <th>Description</th>
                    <th>Example</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td><code>and</code></td>
                    <td>True if both operands are true</td>
                    <td><code>True and True</code></td>
                    <td><code>True</code></td>
                </tr>
                <tr>
                    <td><code>or</code></td>
                    <td>True if at least one operand is true</td>
                    <td><code>True or False</code></td>
                    <td><code>True</code></td>
                </tr>
                <tr>
                    <td><code>not</code></td>
                    <td>Inverts the boolean value</td>
                    <td><code>not True</code></td>
                    <td><code>False</code></td>
                </tr>
            </table>

            <h4>Truth Tables</h4>
            <p>
                Truth tables help us understand how logical operators behave with different combinations of inputs:
            </p>
            
            <h5>AND Operator</h5>
            <table>
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>A and B</th>
                </tr>
                <tr>
                    <td>True</td>
                    <td>True</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td>True</td>
                    <td>False</td>
                    <td>False</td>
                </tr>
                <tr>
                    <td>False</td>
                    <td>True</td>
                    <td>False</td>
                </tr>
                <tr>
                    <td>False</td>
                    <td>False</td>
                    <td>False</td>
                </tr>
            </table>
            
            <h5>OR Operator</h5>
            <table>
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>A or B</th>
                </tr>
                <tr>
                    <td>True</td>
                    <td>True</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td>True</td>
                    <td>False</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td>False</td>
                    <td>True</td>
                    <td>True</td>
                </tr>
                <tr>
                    <td>False</td>
                    <td>False</td>
                    <td>False</td>
                </tr>
            </table>

            <h5>NOT Operator</h5>
            <table>
                <tr>
                    <th>A</th>
                    <th>not A</th>
                </tr>
                <tr>
                    <td>True</td>
                    <td>False</td>
                </tr>
                <tr>
                    <td>False</td>
                    <td>True</td>
                </tr>
            </table>

            <h4>Basic Examples</h4>
            <pre><code>a = True
b = False

# AND operator
print(a and a)  # True
print(a and b)  # False
print(b and b)  # False

# OR operator
print(a or a)   # True
print(a or b)   # True
print(b or b)   # False

# NOT operator
print(not a)    # False
print(not b)    # True</code></pre>

            <h4>Combining Logical Operators</h4>
            <pre><code>a = True
b = False
c = True

# Complex expressions
print((a and b) or c)  # True
print(a and (b or c))  # True
print(not (a and b))   # True

# Using parentheses to control order of evaluation
print(not a and b)     # False - equivalent to (not a) and b
print(not (a and b))   # True - equivalent to not (False) = True</code></pre>

            <p>
                Just like in mathematics, you can use parentheses to control the order of operations. If you're uncertain about the precedence, it's always a good practice to use parentheses to make your code more readable.
            </p>

            <h4>Short-Circuit Evaluation</h4>
            <p>
                Python's logical operators use short-circuit evaluation, meaning they stop evaluating as soon as the result is determined.
            </p>
            
            <pre><code># AND short-circuit: if first operand is False, second is not evaluated
def print_and_return_false():
    print("Evaluating first operand")
    return False

def print_and_return_true():
    print("Evaluating second operand")
    return True

# First operand is False, so second is never evaluated
print(print_and_return_false() and print_and_return_true())
# Output:
# Evaluating first operand
# False

# OR short-circuit: if first operand is True, second is not evaluated
print(print_and_return_true() or print_and_return_false())
# Output:
# Evaluating second operand
# True</code></pre>

            <p>
                Think of short-circuit evaluation like a chef who stops tasting a recipe as soon as they determine it won't work: if one crucial ingredient is spoiled, there's no need to taste the rest.
            </p>

            <h4>Using Short-Circuit Evaluation for Efficient Code</h4>
            <pre><code># Safe dictionary access
user_data = {"name": "Alice"}

# Without short-circuit
if "age" in user_data and user_data["age"] > 18:
    print("User is an adult")
else:
    print("Age unknown or user is not an adult")

# If we forget the existence check, this would raise a KeyError
if user_data.get("age") and user_data["age"] > 18:
    print("User is an adult")
else:
    print("Age unknown or user is not an adult")</code></pre>

            <p>
                In the first example, if "age" is not in the dictionary, the second part is never evaluated, preventing a KeyError.
            </p>

            <h4>Non-Boolean Operands in Logical Operations</h4>
            <p>
                Logical operators in Python don't always return boolean values! When used with non-boolean values, they return one of the operands:
            </p>
            
            <pre><code># AND returns the first falsy value, or the last value if all are truthy
print(0 and 1)        # 0 (first falsy value)
print(1 and 2)        # 2 (last value, all truthy)
print([] and "hello") # [] (first falsy value)
print(42 and "")      # "" (first falsy value)
print("hi" and [1])   # [1] (last value, all truthy)

# OR returns the first truthy value, or the last value if all are falsy
print(0 or 1)         # 1 (first truthy value)
print(False or "")    # "" (last value, all falsy)
print([] or ())       # () (last value, all falsy)
print("hi" or 42)     # "hi" (first truthy value)
print(None or 0 or "default" or []) # "default" (first truthy value)</code></pre>

            <p>
                This behavior enables Pythonic idioms like providing default values:
            </p>
            
            <pre><code>def greet(name):
    # Use the provided name or default to "Guest" if name is falsy
    actual_name = name or "Guest"
    return f"Hello, {actual_name}!"

print(greet("Alice"))  # "Hello, Alice!"
print(greet(""))       # "Hello, Guest!"
print(greet(None))     # "Hello, Guest!"</code></pre>

            <h4>Real-World Example: Access Control System</h4>
            <pre><code>def check_access(user_id, resource_id, is_admin=False):
    """
    Determines if a user has access to a specific resource.
    
    Access is granted if any of these conditions are met:
    1. User is an admin
    2. User is the owner of the resource
    3. Resource is public AND the user has a verified account
    """
    # Simulate database lookup
    user = get_user_by_id(user_id)
    resource = get_resource_by_id(resource_id)
    
    if user is None or resource is None:
        return False, "User or resource not found"
    
    # Check if admin (short-circuit for efficiency)
    if is_admin:
        return True, "Admin access granted"
    
    # Check if owner
    if user['id'] == resource['owner_id']:
        return True, "Owner access granted"
    
    # Check if public resource and user is verified
    if resource['is_public'] and user['is_verified']:
        return True, "Public access granted to verified user"
    
    # No access conditions met
    return False, "Access denied"

def get_user_by_id(user_id):
    # Simulate database lookup
    users = {
        101: {'id': 101, 'name': 'Alice', 'is_verified': True},
        102: {'id': 102, 'name': 'Bob', 'is_verified': False},
        103: {'id': 103, 'name': 'Charlie', 'is_verified': True}
    }
    return users.get(user_id)

def get_resource_by_id(resource_id):
    # Simulate database lookup
    resources = {
        1: {'id': 1, 'name': 'Company Wiki', 'owner_id': 101, 'is_public': True},
        2: {'id': 2, 'name': 'Financial Report', 'owner_id': 101, 'is_public': False},
        3: {'id': 3, 'name': 'Project Plan', 'owner_id': 102, 'is_public': False}
    }
    return resources.get(resource_id)

# Test the function
test_cases = [
    (101, 1, False),  # Alice accessing her public Wiki
    (102, 1, False),  # Bob accessing public Wiki (but he's not verified)
    (103, 1, False),  # Charlie accessing public Wiki (verified user)
    (102, 2, False),  # Bob accessing Alice's private Financial Report
    (101, 3, False),  # Alice accessing Bob's private Project Plan
    (103, 3, True)    # Charlie as admin accessing Bob's Project Plan
]

for user_id, resource_id, is_admin in test_cases:
    user = get_user_by_id(user_id)
    resource = get_resource_by_id(resource_id)
    has_access, reason = check_access(user_id, resource_id, is_admin)
    
    print(f"User: {user['name']}, Resource: {resource['name']}")
    print(f"Access: {'✅' if has_access else '❌'} - {reason}\n")</code></pre>

            <p>
                This example demonstrates how logical operators can implement complex business rules for an access control system, combining multiple conditions with appropriate short-circuiting for efficiency.
            </p>
        </section>

        <section class="common_patterns">
            <h3>Common Patterns and Techniques</h3>
            <p>
                Let's explore some common patterns and techniques using comparison and logical operators.
            </p>

            <h4>Chained Comparisons</h4>
            <p>
                Python allows you to chain multiple comparisons, making your code more readable:
            </p>
            
            <pre><code># Traditional way with logical operators
if x > 5 and x < 10:
    print("x is between 5 and 10")

# More readable with chained comparison
if 5 < x < 10:
    print("x is between 5 and 10")

# More complex chains
if 0 <= x <= 100 and 0 <= y <= 100:
    print("Both x and y are in the range [0, 100]")

age = 25
if 18 <= age < 65:
    print("Working age adult")</code></pre>

            <p>
                Each part of a chained comparison is evaluated separately, and they're combined with <code>and</code> operators behind the scenes.
            </p>

            <h4>Conditional Assignment (Ternary Operator)</h4>
            <pre><code># Traditional if-else
if condition:
    x = value1
else:
    x = value2

# Ternary operator equivalent
x = value1 if condition else value2

# Examples
age = 20
status = "adult" if age >= 18 else "minor"
print(status)  # "adult"

# Can be chained for multiple conditions
category = "child" if age < 13 else "teenager" if age < 18 else "adult"
print(category)  # "adult"</code></pre>

            <p>
                The ternary operator is concise, but be careful not to sacrifice readability with overly complex expressions.
            </p>

            <h4>Using <code>any()</code> and <code>all()</code> Functions</h4>
            <p>
                Python provides two built-in functions that work with logical operations across iterables:
            </p>
            
            <pre><code># any() returns True if at least one item is True
print(any([False, False, True, False]))  # True
print(any([]))  # False (empty iterable)

# all() returns True if all items are True
print(all([True, True, True]))  # True
print(all([True, False, True]))  # False
print(all([]))  # True (empty iterable)

# Practical examples
def has_uppercase(password):
    """Check if password has at least one uppercase letter."""
    return any(char.isupper() for char in password)

def all_digits(code):
    """Check if all characters in code are digits."""
    return all(char.isdigit() for char in code)

print(has_uppercase("Hello123"))  # True
print(has_uppercase("hello123"))  # False
print(all_digits("12345"))  # True
print(all_digits("123a45"))  # False</code></pre>

            <h4>Handling None Values Safely</h4>
            <pre><code># Risky - might raise AttributeError if value is None
def get_user_name(user):
    return user.name

# Safer with explicit None check
def get_user_name_safe(user):
    if user is not None:
        return user.name
    return "Guest"

# Pythonic approach with short-circuit evaluation
def get_user_name_pythonic(user):
    return user and user.name or "Guest"

# Alternative with ternary operator
def get_user_name_ternary(user):
    return user.name if user else "Guest"</code></pre>

            <h4>Checking Membership with <code>in</code> and <code>not in</code></h4>
            <pre><code># Check if an item is in a collection
fruits = ["apple", "banana", "cherry"]
if "apple" in fruits:
    print("We have apples!")

# Check if an item is not in a collection
if "orange" not in fruits:
    print("We don't have oranges!")

# Check if substring is in a string
message = "Hello, world!"
if "world" in message:
    print("Found 'world' in the message!")

# Check if a key is in a dictionary
user = {"name": "Alice", "age": 30}
if "email" not in user:
    print("Email address missing!")</code></pre>

            <h4>Real-World Example: Data Processing Pipeline</h4>
            <pre><code>def process_data_entry(entry, required_fields, optional_fields):
    """
    Process a data entry, validating and normalizing fields.
    Returns a tuple of (success, processed_entry, error_message)
    """
    processed = {}
    
    # Check for missing required fields
    missing_fields = [field for field in required_fields if field not in entry]
    if missing_fields:
        return (False, None, f"Missing required fields: {', '.join(missing_fields)}")
    
    # Process all available fields (required + optional that are present)
    for field in required_fields + [f for f in optional_fields if f in entry]:
        value = entry[field]
        
        # Skip empty optional fields
        if field in optional_fields and (value is None or value == ""):
            continue
            
        # Validate and normalize based on field type
        if field == "email":
            if "@" not in value or "." not in value:
                return (False, None, f"Invalid email format: {value}")
            processed[field] = value.lower().strip()
            
        elif field == "age":
            try:
                age = int(value)
                if not (0 <= age <= 120):
                    return (False, None, f"Age out of valid range: {age}")
                processed[field] = age
            except ValueError:
                return (False, None, f"Age must be a number: {value}")
                
        elif field == "country":
            normalized = value.strip().upper()
            if len(normalized) != 2 or not all(c.isalpha() for c in normalized):
                return (False, None, f"Country code must be a 2-letter code: {value}")
            processed[field] = normalized
            
        else:
            # Default processing for other fields
            if isinstance(value, str):
                processed[field] = value.strip()
            else:
                processed[field] = value
    
    # Add derived fields
    if "first_name" in processed and "last_name" in processed:
        processed["full_name"] = f"{processed['first_name']} {processed['last_name']}"
    
    return (True, processed, "Success")

# Example usage
data_entries = [
    {
        "first_name": "Alice", 
        "last_name": "Smith",
        "email": "alice@example.com",
        "age": "28",
        "country": "us"
    },
    {
        "first_name": "Bob",
        "email": "not-an-email",
        "age": "thirty",
        "country": "usa"
    },
    {
        "first_name": "Charlie",
        "last_name": "Brown",
        "email": "charlie@example.com"
        # Missing age and country
    }
]

required_fields = ["first_name", "email"]
optional_fields = ["last_name", "age", "country"]

for i, entry in enumerate(data_entries):
    print(f"\nProcessing entry {i+1}:")
    success, processed, message = process_data_entry(entry, required_fields, optional_fields)
    
    if success:
        print("✅ Successfully processed:")
        for key, value in processed.items():
            print(f"  {key}: {value}")
    else:
        print(f"❌ Error: {message}")</code></pre>

            <p>
                This example demonstrates how comparison and logical operators can be combined to create a sophisticated data validation and processing pipeline, handling various edge cases and providing appropriate error messages.
            </p>
        </section>

        <section class="operator_precedence">
            <h3>Operator Precedence</h3>
            <p>
                When multiple operators appear in an expression, their precedence determines the order of evaluation. Here's the precedence of the operators we've discussed, from highest to lowest:
            </p>
            
            <ol>
                <li>Parentheses <code>()</code></li>
                <li>Comparison operators <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>is</code>, <code>is not</code>, <code>in</code>, <code>not in</code></li>
                <li><code>not</code></li>
                <li><code>and</code></li>
                <li><code>or</code></li>
            </ol>
            
            <pre><code># Precedence examples
print(True or False and False)  # True (and has higher precedence than or)
# Equivalent to: True or (False and False) = True or False = True

print(not True or False)  # False (not has higher precedence than or)
# Equivalent to: (not True) or False = False or False = False

# Using parentheses to override precedence
print((True or False) and False)  # False
print(not (True or False))  # False</code></pre>

            <p>
                When in doubt about operator precedence, use parentheses to make your intentions explicit. This not only ensures the correct evaluation order but also improves code readability.
            </p>
            
            <h4>Confused Precedence: Common Mistakes</h4>
            <pre><code># Common mistake: forgetting that 'not' has higher precedence than 'and'/'or'
x = 5
print(not x > 3 and x < 10)  # False
# Interpreted as: (not (x > 3)) and (x < 10) = False and True = False

# Correct version with parentheses
print(not (x > 3 and x < 10))  # False

# Another common mistake: chaining comparisons incorrectly
y = 15
print(5 < x < 10 < y)  # False (correct: compares each pair)
print(5 < x and x < 10 and 10 < y)  # False (equivalent to above)

# But this is different (and probably not what was intended):
print(5 < x < 10 and 10 < y)  # False
# Interpreted as: (5 < x < 10) and (10 < y) = False and True = False</code></pre>

            <p>
                Remember that Python's comparison operators chain in a way that's different from most other programming languages. Each part of a chained comparison is evaluated separately and combined with logical AND.
            </p>
        </section>

        <section class="best_practices">
            <h3>Best Practices and Common Pitfalls</h3>
            
            <h4>Best Practices</h4>
            <ul>
                <li><strong>Use parentheses for clarity</strong>: Even if precedence gives you the desired result, parentheses make your intentions clear to others (and to your future self).
                <pre><code># Clear intentions with parentheses
if (is_authenticated and is_admin) or has_special_permission:
    grant_access()</code></pre></li>
                
                <li><strong>Simplify complex conditions</strong>: Break down complex boolean expressions into smaller, named parts.
                <pre><code># Hard to understand at a glance
if age >= 18 and (job_status == "employed" or has_student_loan) and not is_convicted:
    approve_loan()

# More readable with named conditions
is_adult = age >= 18
has_income = job_status == "employed" or has_student_loan
has_clean_record = not is_convicted

if is_adult and has_income and has_clean_record:
    approve_loan()</code></pre></li>
                
                <li><strong>Be careful with non-boolean values in conditions</strong>: Remember that Python treats empty collections, zero, None, and empty strings as False.
                <pre><code># Explicit is better than implicit
if len(items) > 0:  # Explicit check
    process_items()
    
if items:  # Implicit check for non-empty collection - Pythonic but be mindful
    process_items()</code></pre></li>
                
                <li><strong>Use De Morgan's Laws to simplify negations</strong>: These laws help rewrite complex negated expressions.
                <pre><code># De Morgan's Laws:
# not (A and B) == (not A) or (not B)
# not (A or B) == (not A) and (not B)

# Complex negation
if not (is_weekend and is_holiday):
    go_to_work()
    
# Simplified with De Morgan's Law
if not is_weekend or not is_holiday:
    go_to_work()</code></pre></li>
                
                <li><strong>Use the <code>in</code> operator for multiple equality checks</strong>
                <pre><code># Instead of this
if color == "red" or color == "green" or color == "blue":
    print("Primary color")
    
# Do this
if color in ("red", "green", "blue"):
    print("Primary color")</code></pre></li>
            </ul>
            
            <h4>Common Pitfalls</h4>
            <ul>
                <li><strong>Using <code>==</code> instead of <code>is</code> with <code>None</code></strong>
                <pre><code># Not ideal - relying on equality comparison
if result == None:
    handle_error()
    
# Better - identity comparison
if result is None:
    handle_error()</code></pre></li>
                
                <li><strong>Confusing <code>=</code> (assignment) with <code>==</code> (comparison)</strong>
                <pre><code># Bug! Assigns 10 to x and returns True if x was successfully assigned
if x = 10:  # This will cause a syntax error in Python
    print("x is 10")
    
# Correct way to compare
if x == 10:
    print("x is 10")</code></pre></li>
                
                <li><strong>Using <code>is</code> for value comparison</strong>
                <pre><code># Might work for some values due to implementation details, but conceptually wrong
if x is 42:  # Don't do this!
    print("x is 42")
    
# Correct way
if x == 42:
    print("x is 42")</code></pre></li>
                
                <li><strong>Not understanding short-circuit evaluation</strong>
                <pre><code># Bug! If x is 0, we try to divide by zero
result = 1 / x and "x is non-zero"

# Better approach
result = "x is non-zero" if x != 0 else "error: division by zero"</code></pre></li>
                
                <li><strong>Redundant comparisons with boolean values</strong>
                <pre><code># Redundant
if is_valid == True:
    process_data()
    
# Cleaner
if is_valid:
    process_data()
    
# Redundant
if is_valid == False:
    show_error()
    
# Cleaner
if not is_valid:
    show_error()</code></pre></li>
            </ul>
        </section>

        <section class="exercises">
            <h3>Practice Exercises</h3>
            <p>
                To solidify your understanding of comparison and logical operators, try these exercises. Solutions will be reviewed in class.
            </p>
            
            <ol>
                <li>
                    <p><strong>Basic Comparison</strong>: Write a function that takes two numbers and returns the larger one. If they are equal, return "Equal".</p>
                </li>
                <li>
                    <p><strong>Categorize BMI</strong>: Write a function that calculates BMI (weight in kg / height in meters squared) and returns a category: "Underweight" (< 18.5), "Normal" (18.5-24.9), "Overweight" (25-29.9), or "Obese" (≥ 30).</p>
                </li>
                <li>
                    <p><strong>Logical AND, OR</strong>: Write a function that determines if a year is a leap year. A leap year is divisible by 4 AND (not divisible by 100 OR divisible by 400).</p>
                </li>
                <li>
                    <p><strong>Short-Circuit Evaluation</strong>: Write a function called <code>safe_divide(a, b)</code> that uses short-circuit evaluation to avoid division by zero. It should return None if b is 0.</p>
                </li>
                <li>
                    <p><strong>Student Grade Classifier</strong>: Write a function that takes a student's score and classifies it as "A" (90-100), "B" (80-89), "C" (70-79), "D" (60-69), or "F" (below 60).</p>
                </li>
                <li>
                    <p><strong>Password Strength Checker</strong>: Write a function that checks if a password is strong. A strong password:
                        <ul>
                            <li>Is at least 8 characters long</li>
                            <li>Contains at least one uppercase letter</li>
                            <li>Contains at least one lowercase letter</li>
                            <li>Contains at least one digit</li>
                            <li>Contains at least one special character from !@#$%^&*()</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <p><strong>Advanced Challenge</strong>: Write a function that determines if a triangle is valid based on three side lengths. A triangle is valid if the sum of any two sides is greater than the third side (this must be true for all three combinations).</p>
                </li>
            </ol>
        </section>

        <section class="real_world">
            <h3>Real-World Applications</h3>
            <p>
                Comparison and logical operators are foundational to programming logic and are used extensively in real-world applications:
            </p>
            
            <ul>
                <li><strong>Form Validation</strong>: Checking if user inputs meet specific criteria</li>
                <li><strong>Access Control</strong>: Determining if users have permission to access resources</li>
                <li><strong>Search Filters</strong>: Combining multiple criteria to filter results</li>
                <li><strong>Business Logic</strong>: Implementing complex rules based on multiple conditions</li>
                <li><strong>Data Cleaning</strong>: Identifying and handling invalid or outlier data</li>
                <li><strong>Game Logic</strong>: Determining win/loss conditions and game state changes</li>
                <li><strong>Recommendation Systems</strong>: Selecting items that match user preferences</li>
            </ul>
            
            <h4>Example: E-commerce Product Filter</h4>
            <pre><code>def filter_products(products, filters):
    """
    Filter a list of products based on user-defined filters.
    
    Parameters:
    - products: list of dictionaries containing product information
    - filters: dictionary with filter criteria
    
    Returns:
    - Filtered list of products
    """
    filtered_products = []
    
    for product in products:
        # Start with the assumption that the product matches all filters
        matches_all_filters = True
        
        # Price range filter
        if "min_price" in filters and product["price"] < filters["min_price"]:
            matches_all_filters = False
            
        if "max_price" in filters and product["price"] > filters["max_price"]:
            matches_all_filters = False
            
        # Category filter
        if "categories" in filters and product["category"] not in filters["categories"]:
            matches_all_filters = False
            
        # Brand filter
        if "brands" in filters and product["brand"] not in filters["brands"]:
            matches_all_filters = False
            
        # Rating filter (minimum rating)
        if "min_rating" in filters and product["rating"] < filters["min_rating"]:
            matches_all_filters = False
            
        # Availability filter
        if "in_stock_only" in filters and filters["in_stock_only"] and product["stock"] <= 0:
            matches_all_filters = False
            
        # Special features filter (all selected features must be present)
        if "features" in filters:
            for feature in filters["features"]:
                if feature not in product["features"]:
                    matches_all_filters = False
                    break
        
        # Text search (search in name and description)
        if "search_text" in filters and filters["search_text"]:
            search_text = filters["search_text"].lower()
            product_text = (product["name"] + " " + product["description"]).lower()
            if search_text not in product_text:
                matches_all_filters = False
        
        # If the product matched all filters, add it to the results
        if matches_all_filters:
            filtered_products.append(product)
    
    # Sort results based on sort criteria
    if "sort_by" in filters:
        if filters["sort_by"] == "price_low_high":
            filtered_products.sort(key=lambda p: p["price"])
        elif filters["sort_by"] == "price_high_low":
            filtered_products.sort(key=lambda p: p["price"], reverse=True)
        elif filters["sort_by"] == "rating":
            filtered_products.sort(key=lambda p: p["rating"], reverse=True)
        elif filters["sort_by"] == "popularity":
            filtered_products.sort(key=lambda p: p["sales_count"], reverse=True)
    
    return filtered_products

# Example usage
products = [
    {
        "id": 1,
        "name": "Laptop Pro X",
        "category": "electronics",
        "brand": "TechMaster",
        "price": 1299.99,
        "rating": 4.5,
        "stock": 10,
        "features": ["SSD", "16GB RAM", "4K Display"],
        "description": "Powerful laptop for professionals and gamers.",
        "sales_count": 253
    },
    {
        "id": 2,
        "name": "Smartphone Y12",
        "category": "electronics",
        "brand": "Globex",
        "price": 799.99,
        "rating": 4.2,
        "stock": 25,
        "features": ["5G", "Dual Camera", "Face Recognition"],
        "description": "Latest smartphone with cutting-edge features.",
        "sales_count": 412
    },
    {
        "id": 3,
        "name": "Coffee Maker Deluxe",
        "category": "appliances",
        "brand": "HomeStyle",
        "price": 89.99,
        "rating": 4.0,
        "stock": 0,
        "features": ["Programmable", "Self-cleaning", "Thermal Carafe"],
        "description": "Start your day with perfect coffee every time.",
        "sales_count": 128
    }
]

# User-selected filters
user_filters = {
    "min_price": 100,
    "max_price": 1500,
    "categories": ["electronics"],
    "min_rating": 4.0,
    "in_stock_only": True,
    "sort_by": "rating"
}

filtered_results = filter_products(products, user_filters)

# Display results
print(f"Found {len(filtered_results)} products matching your filters:")
for product in filtered_results:
    print(f"- {product['name']} (${product['price']:.2f}) - {product['rating']} stars")</code></pre>

            <p>
                This example demonstrates how comparison and logical operators are combined to implement a sophisticated product filtering system similar to what you'd find on major e-commerce websites. Multiple filter criteria are applied, with each one potentially eliminating products that don't match.
            </p>
        </section>

        <section class="conclusion">
            <h3>Conclusion and Next Steps</h3>
            <p>
                We've explored comparison and logical operators in Python, covering their syntax, behavior, and common patterns. These operators form the foundation of decision-making in your code, allowing you to create dynamic, responsive programs that can adapt to different conditions.
            </p>
            <p>
                As you continue your Python journey, you'll find that these operators appear in virtually every aspect of programming, from simple conditional statements to complex algorithms and business logic. Mastering them will significantly enhance your ability to write effective code.
            </p>
            <p>
                Next, we'll build on these concepts as we explore control flow structures like if statements, loops, and functions, which rely heavily on comparison and logical operations to determine execution paths.
            </p>
            <p>
                Remember to practice these concepts by completing the exercises and experimenting with your own examples. The ability to craft precise logical expressions is one of the most important skills you'll develop as a programmer.
            </p>
            <p>
                For further exploration, check out the official Python documentation: <a href="https://docs.python.org/3/reference/expressions.html#comparisons" target="_blank">https://docs.python.org/3/reference/expressions.html#comparisons</a>
            </p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
