<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Full Stack Web Developer Course - Lists and List Comprehensions</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 2 Wednesday: Lists and List Comprehensions</h2>
    </header>

    <main>
        <section class="lesson-intro">
            <h3>Introduction to Lists</h3>
            <p>Welcome to our deep dive into one of Python's most powerful and versatile data structures: lists. Think of lists as the Swiss Army knife in your Python toolkit - they're incredibly flexible, allowing you to store collections of items in a single container that you can manipulate, iterate through, and transform.</p>
            
            <p>Lists in Python are like shelves in a well-organized pantry. You can store different types of items together, rearrange them at will, add new items, or remove ones you no longer need. This flexibility makes lists foundational to Python programming.</p>
        </section>

        <section class="list-basics">
            <h3>List Fundamentals</h3>
            
            <h4>Creating Lists</h4>
            <p>Lists in Python are created using square brackets, with comma-separated values:</p>
            
            <pre><code># Creating empty lists
empty_list = []
another_empty = list()  # Using the list constructor

# Lists with elements
numbers = [1, 2, 3, 4, 5]
mixed_data = [42, "hello", True, 3.14]
nested_list = [1, [2, 3], [4, [5, 6]]]</code></pre>
            
            <p>Notice how Python lists can contain elements of different data types, including other lists. This heterogeneous nature makes lists incredibly flexible for real-world applications.</p>
            
            <h4>List Indexing</h4>
            <p>Like a bookshelf where each position has a specific number, Python lists use zero-based indexing:</p>
            
            <pre><code>fruits = ["apple", "banana", "cherry", "date", "elderberry"]

# Accessing elements
first_fruit = fruits[0]  # "apple"
third_fruit = fruits[2]  # "cherry"

# Negative indexing (counting from the end)
last_fruit = fruits[-1]  # "elderberry"
second_to_last = fruits[-2]  # "date"</code></pre>
            
            <p>The zero-based indexing is similar to how floors are numbered in many countries - the ground floor is floor 0, not floor 1. This can be confusing if you're coming from languages that use 1-based indexing, but you'll quickly get used to it.</p>
            
            <div class="real-world-example">
                <h5>Real-World Analogy: Apartment Building</h5>
                <p>Think of a list as an apartment building. Each apartment (element) has a unique apartment number (index). In Python's system, the first apartment is apartment 0, the second is apartment 1, and so on. Negative indices are like counting from the roof down - apartment -1 is the top floor, apartment -2 is the second from the top, etc.</p>
            </div>
            
            <h4>List Slicing</h4>
            <p>One of Python's most powerful features is slice notation, which allows you to access a range of elements:</p>
            
            <pre><code>numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Basic slicing: list[start:end] (end is exclusive)
first_three = numbers[0:3]  # [0, 1, 2]
middle = numbers[3:7]  # [3, 4, 5, 6]

# Omitting start/end
beginning = numbers[:5]  # [0, 1, 2, 3, 4] - from start to index 4
end_portion = numbers[7:]  # [7, 8, 9] - from index 7 to end

# With step value: list[start:end:step]
every_second = numbers[::2]  # [0, 2, 4, 6, 8] - every 2nd element
reversed_list = numbers[::-1]  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] - reverse</code></pre>
            
            <p>Slicing is like asking for a specific range of books on your bookshelf. The slice <code>[0:3]</code> means "give me items at positions 0, 1, and 2, but stop before position 3."</p>
            
            <div class="practical-usage">
                <h5>Practical Usage: Data Processing</h5>
                <p>Slicing is invaluable when working with large datasets. For example, when analyzing sales data, you might use slicing to isolate quarterly data:</p>
                <pre><code># Monthly sales data for a year
monthly_sales = [45000, 52000, 58000, 60000, 62500, 71000, 
                 73000, 69000, 65000, 58000, 52000, 59000]

# Extract quarterly data
q1_sales = monthly_sales[0:3]  # First quarter
q2_sales = monthly_sales[3:6]  # Second quarter
q3_sales = monthly_sales[6:9]  # Third quarter
q4_sales = monthly_sales[9:]   # Fourth quarter

# Calculate quarterly averages
q1_avg = sum(q1_sales) / len(q1_sales)  # Average sales in Q1</code></pre>
            </div>
        </section>

        <section class="list-operations">
            <h3>Common List Operations</h3>
            
            <h4>Modifying Lists</h4>
            <p>Unlike strings, lists are mutable, meaning you can change their content without creating a new list:</p>
            
            <pre><code>shopping_list = ["milk", "eggs", "bread", "fruit"]

# Changing an element
shopping_list[3] = "apples"  # More specific than just "fruit"
print(shopping_list)  # ["milk", "eggs", "bread", "apples"]

# Adding elements
shopping_list.append("cheese")  # Adds to the end
print(shopping_list)  # ["milk", "eggs", "bread", "apples", "cheese"]

shopping_list.insert(2, "butter")  # Insert at specific position
print(shopping_list)  # ["milk", "eggs", "butter", "bread", "apples", "cheese"]

# Extending with another list
more_items = ["juice", "cereal"]
shopping_list.extend(more_items)  # Adds all items from another list
print(shopping_list)  # ["milk", "eggs", "butter", "bread", "apples", "cheese", "juice", "cereal"]

# Removing elements
shopping_list.remove("eggs")  # Removes first occurrence of value
print(shopping_list)  # ["milk", "butter", "bread", "apples", "cheese", "juice", "cereal"]

last_item = shopping_list.pop()  # Removes and returns last item
print(last_item)  # "cereal"
print(shopping_list)  # ["milk", "butter", "bread", "apples", "cheese", "juice"]

specific_item = shopping_list.pop(1)  # Remove at specific index
print(specific_item)  # "butter"
print(shopping_list)  # ["milk", "bread", "apples", "cheese", "juice"]

# Clearing a list
shopping_list.clear()  # Removes all items
print(shopping_list)  # []</code></pre>
            
            <p>Think of these operations as managing a real shopping list - you can cross items off, add new ones, or even tear off the entire list and start over.</p>
            
            <h4>List Concatenation and Replication</h4>
            <p>Lists can be combined using the <code>+</code> operator and replicated using the <code>*</code> operator:</p>
            
            <pre><code>list1 = [1, 2, 3]
list2 = [4, 5, 6]

# Concatenation
combined = list1 + list2
print(combined)  # [1, 2, 3, 4, 5, 6]

# Replication
repeated = list1 * 3
print(repeated)  # [1, 2, 3, 1, 2, 3, 1, 2, 3]</code></pre>
            
            <p>Concatenation is like putting two bookshelves side by side, while replication is like making multiple copies of the same bookshelf.</p>
            
            <h4>Finding Elements</h4>
            <p>There are several ways to locate and verify elements within a list:</p>
            
            <pre><code>colors = ["red", "green", "blue", "yellow", "green", "purple"]

# Checking membership
if "green" in colors:
    print("Green is in the list!")

# Finding index of an element
first_green_index = colors.index("green")  # Returns 1
# colors.index("black")  # Would raise ValueError as "black" is not in the list

# Counting occurrences
green_count = colors.count("green")  # Returns 2

# Finding all occurrences (more advanced)
green_indices = [i for i, color in enumerate(colors) if color == "green"]
print(green_indices)  # [1, 4]</code></pre>
            
            <div class="real-world-example">
                <h5>Real-World Example: Email Management</h5>
                <p>Imagine you're building an email filtering system. You might use lists to manage categories, search for specific senders, or count messages from particular domains:</p>
                <pre><code># List of email addresses
emails = [
    "alice@example.com", 
    "bob@company.org", 
    "charlie@example.com",
    "dana@company.org", 
    "eve@personal.net"
]

# Find all company emails
company_emails = [email for email in emails if "company.org" in email]
print(company_emails)  # ['bob@company.org', 'dana@company.org']

# Count emails from each domain
domains = [email.split('@')[1] for email in emails]
unique_domains = set(domains)
domain_counts = {domain: domains.count(domain) for domain in unique_domains}
print(domain_counts)  # {'example.com': 2, 'company.org': 2, 'personal.net': 1}</code></pre>
            </div>
        </section>

        <section class="list-methods">
            <h3>Essential List Methods</h3>
            
            <p>Python lists come with built-in methods that provide powerful functionality:</p>
            
            <table>
                <tr>
                    <th>Method</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
                <tr>
                    <td><code>append()</code></td>
                    <td>Adds an element to the end of the list</td>
                    <td><code>fruits.append("fig")</code></td>
                </tr>
                <tr>
                    <td><code>insert()</code></td>
                    <td>Adds an element at a specific position</td>
                    <td><code>fruits.insert(1, "apricot")</code></td>
                </tr>
                <tr>
                    <td><code>extend()</code></td>
                    <td>Adds all elements from another iterable</td>
                    <td><code>fruits.extend(["grape", "kiwi"])</code></td>
                </tr>
                <tr>
                    <td><code>remove()</code></td>
                    <td>Removes the first occurrence of a value</td>
                    <td><code>fruits.remove("banana")</code></td>
                </tr>
                <tr>
                    <td><code>pop()</code></td>
                    <td>Removes and returns element at given position</td>
                    <td><code>last = fruits.pop()</code></td>
                </tr>
                <tr>
                    <td><code>clear()</code></td>
                    <td>Removes all elements</td>
                    <td><code>fruits.clear()</code></td>
                </tr>
                <tr>
                    <td><code>index()</code></td>
                    <td>Returns index of first occurrence</td>
                    <td><code>pos = fruits.index("cherry")</code></td>
                </tr>
                <tr>
                    <td><code>count()</code></td>
                    <td>Counts occurrences of a value</td>
                    <td><code>num = fruits.count("apple")</code></td>
                </tr>
                <tr>
                    <td><code>sort()</code></td>
                    <td>Sorts the list in place</td>
                    <td><code>fruits.sort()</code></td>
                </tr>
                <tr>
                    <td><code>reverse()</code></td>
                    <td>Reverses the list in place</td>
                    <td><code>fruits.reverse()</code></td>
                </tr>
                <tr>
                    <td><code>copy()</code></td>
                    <td>Returns a shallow copy of the list</td>
                    <td><code>new_list = fruits.copy()</code></td>
                </tr>
            </table>
            
            <h4>Sorting Lists</h4>
            <p>Sorting is one of the most common operations performed on lists:</p>
            
            <pre><code>numbers = [42, 13, 7, 55, 21, 101, 8]

# Simple sorting
numbers.sort()  # In-place sorting
print(numbers)  # [7, 8, 13, 21, 42, 55, 101]

# Sorting in reverse
numbers.sort(reverse=True)  # In-place reverse sorting
print(numbers)  # [101, 55, 42, 21, 13, 8, 7]

# Using sorted() to create a new list
original = [42, 13, 7, 55, 21, 101, 8]
sorted_numbers = sorted(original)  # Creates a new sorted list
print(original)  # Unchanged: [42, 13, 7, 55, 21, 101, 8]
print(sorted_numbers)  # [7, 8, 13, 21, 42, 55, 101]

# Custom sorting with key function
students = [
    {"name": "Alice", "grade": 85},
    {"name": "Bob", "grade": 72},
    {"name": "Charlie", "grade": 91},
    {"name": "Diana", "grade": 88}
]

# Sort by grade
students.sort(key=lambda student: student["grade"])
print([student["name"] for student in students])  # ['Bob', 'Alice', 'Diana', 'Charlie']

# Sort by name
students.sort(key=lambda student: student["name"])
print([student["name"] for student in students])  # ['Alice', 'Bob', 'Charlie', 'Diana']</code></pre>
            
            <div class="practical-usage">
                <h5>Practical Application: Data Analysis</h5>
                <p>Sorting is crucial in data analysis. Imagine you're analyzing customer data:</p>
                <pre><code>customers = [
    {"id": 1, "name": "Smith, John", "purchases": 5, "total_spent": 325.50},
    {"id": 2, "name": "Johnson, Mary", "purchases": 12, "total_spent": 842.75},
    {"id": 3, "name": "Williams, David", "purchases": 3, "total_spent": 152.30},
    {"id": 4, "name": "Brown, Linda", "purchases": 8, "total_spent": 597.80},
    {"id": 5, "name": "Jones, Patricia", "purchases": 7, "total_spent": 421.15}
]

# Find top customers by total spent
top_spenders = sorted(customers, key=lambda c: c["total_spent"], reverse=True)
print("Top 3 customers by spending:")
for customer in top_spenders[:3]:
    print(f"{customer['name']}: ${customer['total_spent']:.2f}")

# Find most frequent customers
most_frequent = sorted(customers, key=lambda c: c["purchases"], reverse=True)
print("\nTop 3 customers by purchase frequency:")
for customer in most_frequent[:3]:
    print(f"{customer['name']}: {customer['purchases']} purchases")</code></pre>
            </div>
        </section>

        <section class="list-comprehensions">
            <h3>List Comprehensions: Python's Secret Weapon</h3>
            
            <p>List comprehensions are one of Python's most elegant and powerful features. They provide a concise way to create lists based on existing iterables, combining the functionality of map and filter into a readable one-line expression.</p>
            
            <h4>Basic Syntax</h4>
            <p>The basic syntax of a list comprehension is:</p>
            <pre><code>[expression for item in iterable if condition]</code></pre>
            <p>Where:</p>
            <ul>
                <li><code>expression</code> is the operation to perform on each item</li>
                <li><code>item</code> is the variable representing each element in the iterable</li>
                <li><code>iterable</code> is the collection of items to process</li>
                <li><code>condition</code> (optional) filters which items to include</li>
            </ul>
            
            <h4>Simple Examples</h4>
            <p>Let's look at some basic list comprehensions compared to traditional for loops:</p>
            
            <pre><code># Creating a list of squares using a for loop
squares_loop = []
for i in range(1, 11):
    squares_loop.append(i * i)
print(squares_loop)  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# Same operation with a list comprehension
squares_comp = [i * i for i in range(1, 11)]
print(squares_comp)  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# Creating a list of even numbers using a for loop with conditional
evens_loop = []
for i in range(1, 21):
    if i % 2 == 0:
        evens_loop.append(i)
print(evens_loop)  # [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

# Same operation with a list comprehension
evens_comp = [i for i in range(1, 21) if i % 2 == 0]
print(evens_comp)  # [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</code></pre>
            
            <p>As you can see, list comprehensions condense multiline operations into a single, readable line. They're like a shorthand notation for creating lists, similar to how we use mathematical set notation.</p>
            
            <div class="real-world-example">
                <h5>Real-World Analogy: Recipe Book</h5>
                <p>Think of a list comprehension as a recipe that tells you exactly how to create a new dish from existing ingredients. The recipe specifies which ingredients to use (iterable), how to prepare each ingredient (expression), and which ingredients to include or exclude (condition).</p>
            </div>
            
            <h4>Advanced List Comprehensions</h4>
            <p>List comprehensions can become quite sophisticated, handling complex transformations and multiple conditions:</p>
            
            <pre><code># Using conditional expressions (ternary operator)
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = ["even" if x % 2 == 0 else "odd" for x in numbers]
print(result)  # ['odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even']

# Multiple conditions
filtered = [x for x in range(1, 51) if x % 2 == 0 if x % 5 == 0]
print(filtered)  # [10, 20, 30, 40, 50] - numbers divisible by both 2 and 5

# Equivalent to:
filtered_loop = []
for x in range(1, 51):
    if x % 2 == 0:
        if x % 5 == 0:
            filtered_loop.append(x)

# Nested list comprehensions
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for row in matrix for num in row]
print(flattened)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# Equivalent to:
flattened_loop = []
for row in matrix:
    for num in row:
        flattened_loop.append(num)

# Creating a matrix (2D list) using list comprehensions
matrix = [[i * j for j in range(1, 4)] for i in range(1, 4)]
print(matrix)
# [[1, 2, 3],
#  [2, 4, 6],
#  [3, 6, 9]]</code></pre>
            
            <div class="practical-usage">
                <h5>Practical Usage: Data Cleaning and Transformation</h5>
                <p>List comprehensions excel at data processing tasks, making them invaluable for web development:</p>
                <pre><code># Cleaning and normalizing data from a web form
user_inputs = [
    "  john.doe@example.com  ",
    "jane_smith@company.org",
    "",
    "invalid@email",
    "  admin@site.net  "
]

# Clean and validate email addresses
valid_emails = [
    email.strip().lower() 
    for email in user_inputs 
    if email.strip() and "@" in email and "." in email.split("@")[1]
]
print(valid_emails)
# ['john.doe@example.com', 'jane_smith@company.org', 'admin@site.net']

# Extracting data from HTML (simplified example)
html_snippets = [
    "&lt;div class='user'&gt;Alice&lt;/div&gt;",
    "&lt;div class='admin'&gt;Bob&lt;/div&gt;",
    "&lt;div class='user'&gt;Charlie&lt;/div&gt;",
    "&lt;div class='guest'&gt;Diana&lt;/div&gt;"
]

# Extract names and roles
users = [
    {
        "name": snippet.split('&gt;')[1].split('&lt;')[0],
        "role": snippet.split("class='")[1].split("'")[0]
    }
    for snippet in html_snippets
]

print(users)
# [{'name': 'Alice', 'role': 'user'}, 
#  {'name': 'Bob', 'role': 'admin'}, 
#  {'name': 'Charlie', 'role': 'user'}, 
#  {'name': 'Diana', 'role': 'guest'}]

# Filter for specific roles
admins = [user["name"] for user in users if user["role"] == "admin"]
print(admins)  # ['Bob']</code></pre>
            </div>
        </section>

        <section class="performance-considerations">
            <h3>Performance and Best Practices</h3>
            
            <h4>When to Use List Comprehensions</h4>
            <p>While list comprehensions are powerful, they're not always the best choice:</p>
            
            <div class="checklist">
                <p><strong>Use list comprehensions when:</strong></p>
                <ul>
                    <li>The operation is simple and clearly expressed in one line</li>
                    <li>You're creating a new list from an existing iterable</li>
                    <li>The transformation logic is straightforward</li>
                    <li>Performance is important (they're generally faster than equivalent for loops)</li>
                </ul>
                
                <p><strong>Consider traditional loops when:</strong></p>
                <ul>
                    <li>The operation is complex or requires multiple steps</li>
                    <li>You need to handle exceptions within the loop</li>
                    <li>Readability would suffer with a list comprehension</li>
                    <li>You're not actually creating a new list (use generators instead)</li>
                </ul>
            </div>
            
            <h4>Memory Considerations</h4>
            <p>List comprehensions create the entire result list in memory. For very large datasets, consider using generator expressions instead:</p>
            
            <pre><code># List comprehension - creates entire list in memory
numbers = [x * x for x in range(10000000)]  # Could use a lot of memory

# Generator expression - generates values on demand
numbers_gen = (x * x for x in range(10000000))  # More memory efficient

# Processing large files with generators
def read_large_file(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            yield line.strip()

# Process lines without loading entire file into memory
for line in read_large_file('very_large_log.txt'):
    if 'ERROR' in line:
        print(line)</code></pre>
            
            <div class="real-world-example">
                <h5>Real-World Analogy: Assembly Line vs. Warehouse</h5>
                <p>Think of list comprehensions like building an entire inventory in a warehouse before delivering it (using memory to store everything at once). Generator expressions are more like an assembly line that produces each item just in time as it's needed, without storing the entire inventory.</p>
            </div>
        </section>

        <section class="common-patterns">
            <h3>Common List Patterns in Web Development</h3>
            
            <p>Let's explore some typical patterns you'll encounter when working with Python lists in web development:</p>
            
            <h4>Processing Form Data</h4>
            <pre><code># Processing multiple checkbox selections from a form
selected_options = ["option1", "option3", "option5"]
all_options = ["option1", "option2", "option3", "option4", "option5"]

# Create a list of checkbox states (checked/unchecked)
checkbox_states = [opt in selected_options for opt in all_options]
print(checkbox_states)  # [True, False, True, False, True]

# Create a mapping of options to their selected state
option_map = {opt: opt in selected_options for opt in all_options}
print(option_map)  
# {'option1': True, 'option2': False, 'option3': True, 'option4': False, 'option5': True}</code></pre>
            
            <h4>Working with JSON Data</h4>
            <pre><code>import json

# Sample JSON data from an API response
json_data = '''
{
    "users": [
        {"id": 1, "username": "alice", "active": true, "role": "admin"},
        {"id": 2, "username": "bob", "active": false, "role": "user"},
        {"id": 3, "username": "charlie", "active": true, "role": "user"},
        {"id": 4, "username": "diana", "active": true, "role": "moderator"}
    ]
}
'''

# Parse JSON and extract user information
data = json.loads(json_data)
users = data["users"]

# Get all active usernames
active_users = [user["username"] for user in users if user["active"]]
print(active_users)  # ['alice', 'charlie', 'diana']

# Create a mapping of user IDs to usernames
user_lookup = {user["id"]: user["username"] for user in users}
print(user_lookup)  # {1: 'alice', 2: 'bob', 3: 'charlie', 4: 'diana'}

# Group users by role
users_by_role = {}
for user in users:
    role = user["role"]
    if role not in users_by_role:
        users_by_role[role] = []
    users_by_role[role].append(user["username"])
    
print(users_by_role)  
# {'admin': ['alice'], 'user': ['bob', 'charlie'], 'moderator': ['diana']}</code></pre>
            
            <h4>Building HTML Elements</h4>
            <pre><code># Creating a navigation menu
menu_items = [
    {"text": "Home", "url": "/", "active": True},
    {"text": "Products", "url": "/products", "active": False},
    {"text": "Services", "url": "/services", "active": False},
    {"text": "About", "url": "/about", "active": False},
    {"text": "Contact", "url": "/contact", "active": False}
]

# Generate HTML for menu items
menu_html = [
    f"&lt;li class='{item['active'] and 'active' or ''}'&gt;&lt;a href='{item['url']}'&gt;{item['text']}&lt;/a&gt;&lt;/li&gt;"
    for item in menu_items
]

# Join the HTML items into a complete menu
nav_html = "&lt;ul class='nav'&gt;" + "".join(menu_html) + "&lt;/ul&gt;"
print(nav_html)
# <ul class='nav'><li class='active'><a href='/'>Home</a></li><li class=''><a href='/products'>Products</a></li>...</ul></code></pre>
            
            <h4>Database Query Processing</h4>
            <pre><code># Simulated database query results
query_results = [
    (1, "Product A", 29.99, "Electronics"),
    (2, "Product B", 49.99, "Home & Kitchen"),
    (3, "Product C", 15.50, "Electronics"),
    (4, "Product D", 99.99, "Electronics"),
    (5, "Product E", 35.25, "Clothing")
]

# Transform query results to dictionaries
products = [
    {
        "id": row[0],
        "name": row[1],
        "price": row[2],
        "category": row[3]
    }
    for row in query_results
]

# Filter for electronics products
electronics = [p for p in products if p["category"] == "Electronics"]
print(electronics)

# Calculate average price by category
categories = set(p["category"] for p in products)
avg_prices = {
    category: sum(p["price"] for p in products if p["category"] == category) / 
              sum(1 for p in products if p["category"] == category)
    for category in categories
}
print(avg_prices)
# {'Electronics': 48.49, 'Home & Kitchen': 49.99, 'Clothing': 35.25}</code></pre>
        </section>

        <section class="exercises">
            <h3>Practice Exercises</h3>
            
            <div class="exercise">
                <h4>Exercise 1: List Manipulation</h4>
                <p>Create a function that takes a list of numbers and returns a new list containing:</p>
                <ul>
                    <li>The squares of all even numbers</li>
                    <li>The cubes of all odd numbers</li>
                </ul>
                <p>Example input: <code>[1, 2, 3, 4, 5]</code><br>
                Expected output: <code>[1, 4, 27, 16, 125]</code></p>
                
                <details>
                    <summary>Solution</summary>
                    <pre><code>def transform_numbers(numbers):
    return [num**2 if num % 2 == 0 else num**3 for num in numbers]

result = transform_numbers([1, 2, 3, 4, 5])
print(result)  # [1, 4, 27, 16, 125]</code></pre>
                </details>
            </div>
            
            <div class="exercise">
                <h4>Exercise 2: Data Filtering</h4>
                <p>Given a list of dictionaries representing products:</p>
                <pre><code>products = [
    {"id": 1, "name": "Laptop", "price": 999.99, "in_stock": True, "category": "Electronics"},
    {"id": 2, "name": "Headphones", "price": 149.50, "in_stock": False, "category": "Electronics"},
    {"id": 3, "name": "Coffee Maker", "price": 89.99, "in_stock": True, "category": "Kitchen"},
    {"id": 4, "name": "Desk Chair", "price": 249.95, "in_stock": True, "category": "Furniture"},
    {"id": 5, "name": "Blender", "price": 79.50, "in_stock": True, "category": "Kitchen"},
    {"id": 6, "name": "Smartphone", "price": 799.00, "in_stock": False, "category": "Electronics"}
]</code></pre>
                <p>Write list comprehensions to:</p>
                <ol>
                    <li>Find all in-stock products with prices under $100</li>
                    <li>Create a list of all product names, sorted alphabetically</li>
                    <li>Calculate the total value of all in-stock products</li>
                    <li>Find the most expensive product in each category</li>
                </ol>
                
                <details>
                    <summary>Solution</summary>
                    <pre><code># 1. In-stock products under $100
affordable_products = [p for p in products if p["in_stock"] and p["price"] < 100]
print("Affordable products:", [p["name"] for p in affordable_products])
# ['Coffee Maker', 'Blender']

# 2. All product names, sorted alphabetically
all_names = sorted([p["name"] for p in products])
print("Sorted product names:", all_names)
# ['Blender', 'Coffee Maker', 'Desk Chair', 'Headphones', 'Laptop', 'Smartphone']

# 3. Total value of all in-stock products
total_value = sum(p["price"] for p in products if p["in_stock"])
print(f"Total inventory value: ${total_value:.2f}")
# Total inventory value: $1419.43

# 4. Most expensive product in each category
categories = set(p["category"] for p in products)
most_expensive_by_category = {
    category: max([p for p in products if p["category"] == category], 
                  key=lambda p: p["price"])
    for category in categories
}

print("Most expensive by category:")
for category, product in most_expensive_by_category.items():
    print(f"{category}: {product['name']} (${product['price']:.2f})")
# Electronics: Laptop ($999.99)
# Kitchen: Coffee Maker ($89.99)
# Furniture: Desk Chair ($249.95)</code></pre>
                </details>
            </div>
            
            <div class="exercise">
                <h4>Exercise 3: Web Development Task</h4>
                <p>You're building a simple e-commerce website. Given the following data:</p>
                <pre><code>cart_items = [
    {"product_id": 101, "name": "Product A", "price": 19.99, "quantity": 2},
    {"product_id": 103, "name": "Product B", "price": 29.99, "quantity": 1},
    {"product_id": 107, "name": "Product C", "price": 9.99, "quantity": 3}
]

shipping_options = [
    {"id": "standard", "name": "Standard Shipping", "cost": 4.99, "days": "3-5"},
    {"id": "express", "name": "Express Shipping", "cost": 9.99, "days": "1-2"},
    {"id": "overnight", "name": "Overnight Shipping", "cost": 19.99, "days": "1"}
]

user = {
    "premium_member": True,
    "shipping_addresses": [
        {"id": 1, "address": "123 Main St", "default": True},
        {"id": 2, "address": "456 Oak Ave", "default": False}
    ]
}</code></pre>
                <p>Create list comprehensions to:</p>
                <ol>
                    <li>Calculate the total price for each item (price * quantity)</li>
                    <li>Generate option elements for a shipping method dropdown</li>
                    <li>Get the user's default shipping address</li>
                    <li>Apply a 10% discount for premium members</li>
                </ol>
                
                <details>
                    <summary>Solution</summary>
                    <pre><code># 1. Calculate total price for each item
item_totals = [item["price"] * item["quantity"] for item in cart_items]
print("Item totals:", item_totals)  # [39.98, 29.99, 29.97]

# 2. Generate shipping method dropdown options
shipping_options_html = [
    f'&lt;option value="{option["id"]}"&gt;{option["name"]} (${option["cost"]:.2f}, {option["days"]} days)&lt;/option&gt;'
    for option in shipping_options
]
shipping_dropdown = "&lt;select name='shipping'&gt;" + "".join(shipping_options_html) + "&lt;/select&gt;"
print("Shipping dropdown:", shipping_dropdown)

# 3. Get user's default shipping address
default_address = [addr for addr in user["shipping_addresses"] if addr["default"]][0]
print("Default address:", default_address["address"])  # 123 Main St

# 4. Apply 10% discount for premium members
discount_multiplier = 0.9 if user["premium_member"] else 1.0
discounted_prices = [
    {
        "name": item["name"],
        "original_price": item["price"],
        "quantity": item["quantity"],
        "total": item["price"] * item["quantity"] * discount_multiplier
    }
    for item in cart_items
]
print("Discounted prices:", discounted_prices)
# [{'name': 'Product A', 'original_price': 19.99, 'quantity': 2, 'total': 35.982},
#  {'name': 'Product B', 'original_price': 29.99, 'quantity': 1, 'total': 26.991},
#  {'name': 'Product C', 'original_price': 9.99, 'quantity': 3, 'total': 26.973}]

# Calculate cart total with discount
cart_total = sum(item["price"] * item["quantity"] for item in cart_items) * discount_multiplier
print(f"Cart total with discount: ${cart_total:.2f}")  # $89.946</code></pre>
                </details>
            </div>
        </section>

        <section class="further-learning">
            <h3>Further Topics to Explore</h3>
            
            <ul>
                <li><strong>Generator Expressions:</strong> Memory-efficient alternatives to list comprehensions</li>
                <li><strong>Dictionary Comprehensions:</strong> Similar syntax for creating dictionaries</li>
                <li><strong>Set Comprehensions:</strong> Creating sets with comprehension syntax</li>
                <li><strong>Advanced Sorting:</strong> Using <code>key</code> functions with <code>sort()</code> and <code>sorted()</code></li>
                <li><strong>Functional Programming:</strong> Using <code>map()</code>, <code>filter()</code>, and <code>reduce()</code> with lists</li>
                <li><strong>NumPy Arrays:</strong> High-performance alternatives to lists for numerical operations</li>
                <li><strong>Pandas Series and DataFrames:</strong> Advanced data structures built on NumPy</li>
            </ul>
            
            <p>These topics will become increasingly important as you progress in your Python journey, especially when working with data processing, API responses, and database interactions in web development.</p>
        </section>

        <section class="conclusion">
            <h3>Key Takeaways</h3>
            
            <ul>
                <li>Lists are versatile, mutable sequences that can store elements of different types</li>
                <li>Python provides rich operations for manipulating lists: adding, removing, finding, and transforming elements</li>
                <li>List comprehensions offer a concise, readable way to create new lists from existing iterables</li>
                <li>Understanding lists and list comprehensions is fundamental to effective Python programming</li>
                <li>In web development, lists are commonly used for processing form data, API responses, and database results</li>
            </ul>
            
            <p>As you continue through this course, you'll find that lists and list comprehensions become essential tools in your Python toolkit, allowing you to write cleaner, more efficient code for web development.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
