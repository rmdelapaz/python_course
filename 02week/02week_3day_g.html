<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 2: Wednesday Afternoon - Iterating Through Collections</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Iterating Through Collections</h1>
        <h2>Unleashing the Power of Python Data Structures</h2>
    </header>

    <main>
        <section class="introduction">
            <h3>Why Iteration Matters</h3>
            <p>Welcome to our afternoon session on iterating through collections! This morning, we explored Python's core data structures: lists, tuples, dictionaries, and sets. Now, we'll focus on the real magic—how to effectively work with the data inside these collections.</p>
            
            <p>Iteration is like having a conversation with your data—you speak to each element one by one, listening to what it has to say, and responding appropriately. It's one of the most fundamental skills in programming, and mastering it will dramatically increase your capabilities as a Python developer.</p>
            
            <p>Imagine you have a basket of different fruits. Checking each fruit one by one (is it ripe? is it fresh?) is iteration. In programming, we do this constantly—processing lists of user data, analyzing measurements, transforming text, and much more. Today, we'll explore how to do this efficiently and elegantly in Python.</p>
        </section>

        <section class="basic_iteration">
            <h3>The For Loop: Your Best Friend</h3>
            
            <p>The most common way to iterate through collections in Python is the for loop. Think of a for loop as a friendly tour guide taking you to meet each item in your collection, one by one.</p>
            
            <p>Let's start with the simplest example: iterating through a list of numbers:</p>
            
            <pre><code>
# File: list_iteration.py
# Location: ~/python_examples/week2/

numbers = [1, 2, 3, 4, 5]

# Basic for loop
for number in numbers:
    print(number)
            </code></pre>
            
            <p>This straightforward pattern is like walking through a line of people and shaking each person's hand. Python handles all the complexity of keeping track of where you are in the list—you just need to specify what to do with each item.</p>
            
            <p>Here's what this looks like with different collection types:</p>
            
            <pre><code>
# File: collection_iteration.py
# Location: ~/python_examples/week2/

# Iterating through a tuple
colors = ('red', 'green', 'blue')
for color in colors:
    print(f"The color is {color}")

# Iterating through a set
unique_ids = {1001, 1002, 1003}
for user_id in unique_ids:
    print(f"Processing user {user_id}")
            </code></pre>
            
            <p><strong>Real-world example:</strong> In a customer relationship management (CRM) system, you might iterate through a list of customer records to send personalized emails, calculate total sales, or identify customers who haven't made a purchase in a while.</p>
            
            <h4>When You Need the Index</h4>
            
            <p>Sometimes you need to know not just the item, but its position in the collection. Python's <code>enumerate()</code> function is like a tour guide who tells you "This is stop number 3 on our tour" as they introduce each item.</p>
            
            <pre><code>
# File: enumerate_example.py
# Location: ~/python_examples/week2/

fruits = ["apple", "banana", "cherry", "date"]

# Using enumerate to get both the index and value
for index, fruit in enumerate(fruits):
    print(f"Fruit #{index + 1}: {fruit}")

# Output:
# Fruit #1: apple
# Fruit #2: banana
# Fruit #3: cherry
# Fruit #4: date
            </code></pre>
            
            <p><strong>Analogy:</strong> Enumerate is like reading a book with numbered pages. You can refer both to the content on the page (the item) and the page number itself (the index).</p>
            
            <p><strong>Practical tip:</strong> By default, <code>enumerate()</code> starts counting from 0, which is why we added 1 in the example to get more natural numbering. You can also specify a starting value: <code>enumerate(fruits, start=1)</code>.</p>
        </section>

        <section class="dictionary_iteration">
            <h3>Dancing with Dictionaries</h3>
            
            <p>Dictionaries deserve special attention because they contain key-value pairs. Python offers several ways to iterate through dictionaries, each serving different needs:</p>
            
            <pre><code>
# File: dict_iteration.py
# Location: ~/python_examples/week2/

student_scores = {
    "Alice": 92,
    "Bob": 85,
    "Charlie": 78,
    "Diana": 95
}

# Iterate through keys (default)
for name in student_scores:
    print(name)

# Explicitly iterate through keys
for name in student_scores.keys():
    print(name)

# Iterate through values
for score in student_scores.values():
    print(score)

# Iterate through both keys and values
for name, score in student_scores.items():
    print(f"{name} scored {score} points")
            </code></pre>
            
            <p><strong>Visualization:</strong> Think of a dictionary as a row of lockers, each with a name (the key) and contents (the value). You can choose to:</p>
            <ul>
                <li>Look at just the names on the lockers (<code>keys()</code>)</li>
                <li>Look at just what's inside the lockers without checking names (<code>values()</code>)</li>
                <li>Check both the name and contents of each locker (<code>items()</code>)</li>
            </ul>
            
            <p><strong>Real-world application:</strong> When building a web application, you might have a dictionary of user preferences where keys are setting names and values are the chosen options. When rendering a settings page, you'd iterate through these key-value pairs to display current settings.</p>
            
            <h4>Nested Dictionary Iteration</h4>
            
            <p>In more complex applications, dictionaries are often nested. Iterating through these structures requires multiple levels of for loops:</p>
            
            <pre><code>
# File: nested_dict_iteration.py
# Location: ~/python_examples/week2/

# A nested dictionary of school data
schools = {
    "Lincoln High": {
        "principal": "Ms. Johnson",
        "students": 850,
        "classes": ["Math", "Science", "History"]
    },
    "Washington Middle": {
        "principal": "Mr. Rodriguez",
        "students": 650,
        "classes": ["English", "Art", "Geography"]
    }
}

# Iterating through the nested structure
for school_name, school_data in schools.items():
    print(f"\nSchool: {school_name}")
    print(f"Principal: {school_data['principal']}")
    print(f"Student Count: {school_data['students']}")
    print("Classes offered:")
    
    # Inner loop for the classes list
    for class_name in school_data['classes']:
        print(f"  - {class_name}")
            </code></pre>
            
            <p><strong>Analogy:</strong> Navigating a nested dictionary is like exploring a building with many rooms, where each room might contain cabinets, and each cabinet might contain folders. You need to open each container to access what's inside.</p>
        </section>

        <section class="comprehensions">
            <h3>List Comprehensions: Elegant Iteration</h3>
            
            <p>Python offers a concise and powerful way to iterate and transform collections in a single line: comprehensions. These are like express elevators in a building—they take you from the ground floor (input data) to the top floor (result) in one swift movement, without stopping at each floor in between.</p>
            
            <pre><code>
# File: comprehensions.py
# Location: ~/python_examples/week2/

numbers = [1, 2, 3, 4, 5]

# Traditional way with for loop
squared_numbers = []
for num in numbers:
    squared_numbers.append(num ** 2)
print(squared_numbers)  # [1, 4, 9, 16, 25]

# Same result with list comprehension
squared_numbers = [num ** 2 for num in numbers]
print(squared_numbers)  # [1, 4, 9, 16, 25]
            </code></pre>
            
            <p>List comprehensions can also include conditions, allowing you to filter items:</p>
            
            <pre><code>
# Only square even numbers
even_squares = [num ** 2 for num in numbers if num % 2 == 0]
print(even_squares)  # [4, 16]
            </code></pre>
            
            <p><strong>Practical application:</strong> List comprehensions shine when transforming data. For example, when extracting information from API responses or processing user input fields, you can concisely transform and filter the data in a single expression.</p>
            
            <h4>Dictionary and Set Comprehensions</h4>
            
            <p>The same elegant pattern works for creating dictionaries and sets:</p>
            
            <pre><code>
# Dictionary comprehension - create a mapping of numbers to their squares
number_to_square = {num: num ** 2 for num in numbers}
print(number_to_square)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# Set comprehension - create a set of squares of even numbers
even_squares_set = {num ** 2 for num in numbers if num % 2 == 0}
print(even_squares_set)  # {4, 16}
            </code></pre>
            
            <p><strong>When to use comprehensions:</strong> Comprehensions are ideal for simple transformations and filters. For more complex logic or multiple operations on each item, traditional for loops provide better readability.</p>
            
            <p><strong>Real-world example:</strong> In data analysis, you might use a dictionary comprehension to create a mapping of user IDs to activity counts from a large dataset, or a set comprehension to find all unique categories in product listings.</p>
        </section>

        <section class="advanced_iteration">
            <h3>Advanced Iteration Techniques</h3>
            
            <h4>Iterating Multiple Collections with zip()</h4>
            
            <p>Python's <code>zip()</code> function allows you to iterate through multiple collections simultaneously, pairing up corresponding elements. Think of it as walking two people down the aisle at a wedding ceremony—each person from the first group is paired with a person from the second group.</p>
            
            <pre><code>
# File: zip_example.py
# Location: ~/python_examples/week2/

names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
cities = ["New York", "San Francisco", "Chicago"]

# Iterate through three lists at once
for name, age, city in zip(names, ages, cities):
    print(f"{name} is {age} years old and lives in {city}")

# Creating a dictionary from two lists
name_to_age = dict(zip(names, ages))
print(name_to_age)  # {'Alice': 25, 'Bob': 30, 'Charlie': 35}
            </code></pre>
            
            <p><strong>Important note:</strong> <code>zip()</code> will stop at the end of the shortest collection. If your collections are of different lengths, use <code>itertools.zip_longest()</code> to fill in missing values.</p>
            
            <p><strong>Real-world application:</strong> When importing data from multiple sources or working with parallel data streams (like timestamps and measurements), <code>zip()</code> helps you process related information together.</p>
            
            <h4>Filtering with Conditional Iteration</h4>
            
            <p>Sometimes you need to process only certain elements that meet specific criteria:</p>
            
            <pre><code>
# File: conditional_iteration.py
# Location: ~/python_examples/week2/

scores = [72, 85, 90, 61, 95, 82, 77, 98]

# Processing only passing scores (>= 70)
passing_scores = []
for score in scores:
    if score >= 70:
        passing_scores.append(score)
print(passing_scores)  # [72, 85, 90, 95, 82, 77, 98]

# Alternative using list comprehension
passing_scores = [score for score in scores if score >= 70]
print(passing_scores)  # [72, 85, 90, 95, 82, 77, 98]

# Finding students with perfect scores
perfect_scores = []
students = [
    {"name": "Alice", "score": 95},
    {"name": "Bob", "score": 82},
    {"name": "Charlie", "score": 100},
    {"name": "Diana", "score": 100}
]

for student in students:
    if student["score"] == 100:
        perfect_scores.append(student["name"])
print(perfect_scores)  # ['Charlie', 'Diana']
            </code></pre>
            
            <p><strong>Analogy:</strong> Conditional iteration is like having a bouncer at a club who only lets in people meeting certain criteria. The bouncer checks each person against the rules and either allows them through or turns them away.</p>
        </section>

        <section class="iterate_and_modify">
            <h3>Iterating and Modifying Collections</h3>
            
            <p>One common source of bugs is modifying a collection while iterating through it. This is like trying to remodel a house while giving a house tour—it creates confusion and problems.</p>
            
            <pre><code>
# File: modify_while_iterating.py
# Location: ~/python_examples/week2/

# DON'T DO THIS: Modifying a list while iterating
numbers = [1, 2, 3, 4, 5]
for number in numbers:
    if number % 2 == 0:
        numbers.remove(number)  # This modifies the list we're iterating through!
        
print(numbers)  # Result may not be what you expect: [1, 3, 5]
            </code></pre>
            
            <p>The problem above is that when you remove an item, the indices of all subsequent items shift, which can cause items to be skipped or processed incorrectly.</p>
            
            <p><strong>Better approaches:</strong></p>
            
            <pre><code>
# Approach 1: Create a new list
numbers = [1, 2, 3, 4, 5]
odd_numbers = [num for num in numbers if num % 2 != 0]
print(odd_numbers)  # [1, 3, 5]

# Approach 2: Iterate through a copy
numbers = [1, 2, 3, 4, 5]
for number in numbers[:]:  # The [:] creates a copy
    if number % 2 == 0:
        numbers.remove(number)
print(numbers)  # [1, 3, 5]

# Approach 3: Iterate in reverse (sometimes works)
numbers = [1, 2, 3, 4, 5]
for i in range(len(numbers) - 1, -1, -1):  # Iterate from end to start
    if numbers[i] % 2 == 0:
        numbers.pop(i)
print(numbers)  # [1, 3, 5]
            </code></pre>
            
            <p><strong>Real-world example:</strong> When processing a list of user accounts and needing to delete inactive ones, using one of these safe approaches prevents accidentally skipping accounts during the iteration.</p>
        </section>

        <section class="practical_examples">
            <h3>Practical Iteration Examples</h3>
            
            <h4>Processing a CSV-like Data Structure</h4>
            
            <pre><code>
# File: data_processing.py
# Location: ~/python_examples/week2/

# Simulated CSV data (headers and rows)
headers = ["name", "age", "city", "score"]
data = [
    ["Alice", "24", "New York", "85"],
    ["Bob", "32", "San Francisco", "92"],
    ["Charlie", "19", "Chicago", "78"],
    ["Diana", "45", "Miami", "95"]
]

# Convert to list of dictionaries (common pattern for CSV processing)
records = []
for row in data:
    record = {}
    for i, value in enumerate(row):
        record[headers[i]] = value
    records.append(record)

print(records)
# [{'name': 'Alice', 'age': '24', 'city': 'New York', 'score': '85'}, ...]

# Calculate average score
total_score = 0
for record in records:
    total_score += int(record["score"])
average_score = total_score / len(records)
print(f"Average score: {average_score}")  # Average score: 87.5

# Find people from a specific city
new_yorkers = [record["name"] for record in records if record["city"] == "New York"]
print(f"People from New York: {new_yorkers}")  # People from New York: ['Alice']
            </code></pre>
            
            <h4>Building a Word Frequency Counter</h4>
            
            <pre><code>
# File: word_counter.py
# Location: ~/python_examples/week2/

text = """
Python is a programming language that lets you work quickly and integrate systems effectively.
Python is powerful, and fast; plays well with others; runs everywhere; is friendly & easy to learn.
"""

# Clean and split the text
import re
words = re.findall(r'\w+', text.lower())

# Count word frequencies
word_counts = {}
for word in words:
    if word in word_counts:
        word_counts[word] += 1
    else:
        word_counts[word] = 1

print(word_counts)

# Alternative using dict.get() method
word_counts_alt = {}
for word in words:
    word_counts_alt[word] = word_counts_alt.get(word, 0) + 1

print(word_counts_alt)

# Find the most common words
sorted_words = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)
top_words = sorted_words[:5]  # Top 5 words
print(f"Most common words: {top_words}")
            </code></pre>
            
            <p><strong>Real-world application:</strong> This word frequency counter is a foundational component in text analysis, search engine indexing, and natural language processing. Content recommendation algorithms and SEO tools analyze text in a similar way to identify key topics and themes.</p>
        </section>

        <section class="iteration_best_practices">
            <h3>Iteration Best Practices</h3>
            
            <h4>Choosing the Right Iteration Technique</h4>
            
            <p>Python offers many ways to iterate through collections. Here's a guide to choosing the most appropriate technique:</p>
            
            <table>
                <tr>
                    <th>Technique</th>
                    <th>When to Use</th>
                    <th>Example</th>
                </tr>
                <tr>
                    <td>Basic for loop</td>
                    <td>Simple iteration where you need to process each item</td>
                    <td><code>for item in collection:</code></td>
                </tr>
                <tr>
                    <td>enumerate()</td>
                    <td>When you need both the item and its position</td>
                    <td><code>for index, item in enumerate(collection):</code></td>
                </tr>
                <tr>
                    <td>zip()</td>
                    <td>When iterating through multiple collections in parallel</td>
                    <td><code>for item1, item2 in zip(collection1, collection2):</code></td>
                </tr>
                <tr>
                    <td>dict.items()</td>
                    <td>When you need both keys and values from a dictionary</td>
                    <td><code>for key, value in dictionary.items():</code></td>
                </tr>
                <tr>
                    <td>List comprehension</td>
                    <td>When creating a new list by transforming each item</td>
                    <td><code>[expression for item in collection]</code></td>
                </tr>
                <tr>
                    <td>Filtered comprehension</td>
                    <td>When creating a new collection with only certain items</td>
                    <td><code>[expression for item in collection if condition]</code></td>
                </tr>
            </table>
            
            <h4>Performance Considerations</h4>
            
            <p>When working with large collections, performance becomes important:</p>
            
            <ul>
                <li><strong>List Comprehensions</strong> are generally faster than equivalent for loops for creating new lists</li>
                <li>Avoid repeatedly growing lists with <code>append()</code> if you know the final size in advance</li>
                <li>For very large collections, consider generators (we'll cover these in a future session)</li>
                <li>When checking membership, sets are much faster than lists: <code>if item in my_set</code> vs <code>if item in my_list</code></li>
            </ul>
            
            <p><strong>Real-world example:</strong> When processing log files with millions of entries, using efficient iteration techniques can reduce processing time from hours to minutes.</p>
            
            <h4>Readability First</h4>
            
            <p>While Python offers many elegant shortcuts, readability should be your primary concern:</p>
            
            <ul>
                <li>Choose clear, expressive variable names in your loops</li>
                <li>Break complex nested loops into separate functions</li>
                <li>Add comments explaining the purpose of the iteration, not just the mechanics</li>
                <li>Avoid overly complex comprehensions—if it requires more than a glance to understand, use a regular for loop</li>
            </ul>
            
            <p><strong>Industry practice:</strong> In professional codebases, maintainability is valued over cleverness. A slightly longer but crystal-clear for loop is better than an opaque one-liner that future developers (including yourself) will struggle to understand.</p>
        </section>

        <section class="excercises">
            <h3>Hands-On Exercises</h3>
            
            <p>Let's practice what we've learned with some exercises. Save these in a directory like <code>~/python_examples/week2/exercises/</code>.</p>
            
            <h4>Exercise 1: Student Grade Analysis</h4>
            <p>Create a program that processes student grades, calculates statistics, and identifies students who need additional support.</p>
            
            <pre><code>
# File: grade_analysis.py
# Location: ~/python_examples/week2/exercises/

student_grades = [
    {"name": "Alice", "grades": [85, 92, 78, 90]},
    {"name": "Bob", "grades": [72, 65, 70, 68]},
    {"name": "Charlie", "grades": [95, 97, 93, 98]},
    {"name": "Diana", "grades": [60, 58, 65, 70]},
    {"name": "Eve", "grades": [85, 80, 88, 75]}
]

# Exercise tasks:
# 1. Calculate the average grade for each student
# 2. Determine the class average
# 3. Find students with failing average (below 70)
# 4. Identify the student with the highest average

# Your solution here

# Example solution approach:
student_averages = {}
for student in student_grades:
    average = sum(student["grades"]) / len(student["grades"])
    student_averages[student["name"]] = average
    print(f"{student['name']}'s average: {average:.1f}")

class_average = sum(student_averages.values()) / len(student_averages)
print(f"Class average: {class_average:.1f}")

failing_students = [name for name, avg in student_averages.items() if avg < 70]
print(f"Students needing support: {failing_students}")

top_student = max(student_averages.items(), key=lambda x: x[1])
print(f"Top student: {top_student[0]} with average {top_student[1]:.1f}")
            </code></pre>
            
            <h4>Exercise 2: Inventory Management</h4>
            <p>Write a program that helps manage a store inventory, tracking quantities and values.</p>
            
            <pre><code>
# File: inventory.py
# Location: ~/python_examples/week2/exercises/

inventory = [
    {"id": "A001", "name": "Widget", "quantity": 50, "price": 10.99},
    {"id": "A002", "name": "Gadget", "quantity": 30, "price": 24.99},
    {"id": "B001", "name": "Gizmo", "quantity": 10, "price": 99.99},
    {"id": "C001", "name": "Doohickey", "quantity": 75, "price": 5.99},
    {"id": "B002", "name": "Thingamajig", "quantity": 5, "price": 49.99}
]

# Exercise tasks:
# 1. Calculate the total value of the inventory
# 2. Identify items that need reordering (quantity < 20)
# 3. Group items by category (first letter of ID)
# 4. Apply a 10% price increase to all B-category items

# Your solution here

# Example solution approach:
total_value = sum(item["quantity"] * item["price"] for item in inventory)
print(f"Total inventory value: ${total_value:.2f}")

reorder_items = [item["name"] for item in inventory if item["quantity"] < 20]
print(f"Items to reorder: {reorder_items}")

# Group by category
categories = {}
for item in inventory:
    category = item["id"][0]  # First letter of ID
    if category not in categories:
        categories[category] = []
    categories[category].append(item["name"])
print("Items by category:")
for category, items in categories.items():
    print(f"  {category}: {items}")

# Price increase for B category
for item in inventory:
    if item["id"].startswith("B"):
        item["price"] *= 1.1
print("B category items after price increase:")
for item in inventory:
    if item["id"].startswith("B"):
        print(f"  {item['name']}: ${item['price']:.2f}")
            </code></pre>
            
            <p>Work through these exercises to build your confidence with iteration techniques. Try implementing the solutions first before checking the example approaches.</p>
        </section>

        <section class="conclusion">
            <h3>Bringing It All Together</h3>
            
            <p>We've covered a lot of ground in this session, exploring the many ways Python allows us to iterate through collections. These techniques are fundamental building blocks you'll use in virtually every Python program you write.</p>
            
            <p>Remember these key points:</p>
            
            <ul>
                <li>Python's for loop provides a clean, readable way to process collections item by item</li>
                <li>Special functions like <code>enumerate()</code> and <code>zip()</code> make common iteration patterns more elegant</li>
                <li>Dictionary iteration offers multiple views: keys, values, or both with <code>items()</code></li>
                <li>List comprehensions provide a concise way to transform and filter collections</li>
                <li>Be cautious when modifying collections during iteration</li>
                <li>Choose iteration techniques that prioritize readability</li>
            </ul>
            
            <p>As you progress in your Python journey, you'll find yourself returning to these patterns again and again. The more fluent you become with Python's iteration tools, the more effective you'll be as a developer.</p>
            
            <h4>Next Steps</h4>
            
            <p>In our next session, we'll explore functions—reusable blocks of code that help organize and simplify your programs. You'll see how the iteration techniques you've learned today become even more powerful when combined with well-designed functions.</p>
            
            <p>For additional practice, try implementing the exercises we've provided, and consider creating your own programs that process different types of collections. Experiment with different iteration techniques to see which feels most natural for different scenarios.</p>
            
            <p>Remember, becoming proficient with iteration is like learning to walk—it may take practice at first, but soon it will become second nature, allowing you to focus on solving more complex problems.</p>
        </section>

        <section class="additional_resources">
            <h3>Additional Resources</h3>
            
            <ul>
                <li><a href="https://docs.python.org/3/tutorial/datastructures.html" target="_blank">Python Tutorial: Data Structures</a></li>
                <li><a href="https://realpython.com/iterate-through-dictionary-python/" target="_blank">Real Python: How to Iterate Through a Dictionary in Python</a></li>
                <li><a href="https://realpython.com/list-comprehension-python/" target="_blank">Real Python: Python List Comprehension</a></li>
                <li><a href="https://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/" target="_blank">Trey Hunner: How to Loop With Indexes in Python</a></li>
                <li><a href="https://docs.python.org/3/library/itertools.html" target="_blank">Python itertools Library</a> - Advanced iteration tools we'll explore in future sessions</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
