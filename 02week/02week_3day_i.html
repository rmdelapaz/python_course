<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>For JavaScript Developers: Comparing Python Collections to JavaScript Arrays and Objects</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>For JavaScript Developers: Comparing Python Collections to JavaScript Arrays and Objects</h1>
        <h2>Bridging the Gap Between Two Popular Languages</h2>
    </header>

    <main>
        <section class="introduction">
            <h3>From JavaScript to Python: Understanding the Collection Landscape</h3>
            <p>As a JavaScript developer diving into Python, you'll find many familiar concepts with important nuances. Python's collection types share similarities with JavaScript's arrays and objects but differ in significant ways that affect how you structure and manipulate data.</p>
            
            <p>This guide will help you map your JavaScript knowledge to Python's collection types, highlighting key similarities, important differences, and Python-specific features that might surprise you. We'll cover how Python's lists, tuples, dictionaries, and sets compare to JavaScript's arrays and objects, with practical examples to reinforce the concepts.</p>
            
            <p>Understanding these parallels and distinctions will accelerate your Python learning curve and help you write more idiomatic Python code while leveraging your JavaScript expertise.</p>
        </section>

        <section class="collections_overview">
            <h3>Collection Types at a Glance: JavaScript vs Python</h3>
            
            <p>Here's a high-level comparison of the main collection types in both languages:</p>
            
            <table>
                <tr>
                    <th>JavaScript</th>
                    <th>Python Equivalent(s)</th>
                    <th>Primary Purpose</th>
                </tr>
                <tr>
                    <td>Array</td>
                    <td>List, Tuple</td>
                    <td>Ordered sequence of items</td>
                </tr>
                <tr>
                    <td>Object</td>
                    <td>Dictionary</td>
                    <td>Key-value pairs</td>
                </tr>
                <tr>
                    <td>Set</td>
                    <td>Set</td>
                    <td>Collection of unique values</td>
                </tr>
                <tr>
                    <td>Map</td>
                    <td>Dictionary</td>
                    <td>Key-value pairs with any key type</td>
                </tr>
            </table>
            
            <p>Let's dive deeper into each of these comparisons to understand the nuances.</p>
        </section>

        <section class="arrays_vs_lists">
            <h3>JavaScript Arrays vs Python Lists and Tuples</h3>
            
            <p>JavaScript arrays and Python lists both store ordered collections of items, but there are significant differences in behavior and available methods.</p>
            
            <h4>Key Similarities</h4>
            
            <ul>
                <li>Both are ordered (items have a specific position)</li>
                <li>Both are indexed from 0</li>
                <li>Both can contain mixed data types</li>
                <li>Both are dynamically sized</li>
                <li>Both provide methods for common operations like adding/removing elements</li>
            </ul>
            
            <h4>Side-by-Side Comparison</h4>
            
            <p>Here's how common array operations translate between JavaScript and Python:</p>
            
            <table>
                <tr>
                    <th>Operation</th>
                    <th>JavaScript</th>
                    <th>Python</th>
                </tr>
                <tr>
                    <td>Creating an empty collection</td>
                    <td><code>const arr = [];</code></td>
                    <td><code>arr = []</code></td>
                </tr>
                <tr>
                    <td>Creating with initial values</td>
                    <td><code>const arr = [1, 2, 3, 'four'];</code></td>
                    <td><code>arr = [1, 2, 3, 'four']</code></td>
                </tr>
                <tr>
                    <td>Accessing an element</td>
                    <td><code>arr[0]</code></td>
                    <td><code>arr[0]</code></td>
                </tr>
                <tr>
                    <td>Length/size</td>
                    <td><code>arr.length</code></td>
                    <td><code>len(arr)</code></td>
                </tr>
                <tr>
                    <td>Adding to the end</td>
                    <td><code>arr.push(item)</code></td>
                    <td><code>arr.append(item)</code></td>
                </tr>
                <tr>
                    <td>Removing from the end</td>
                    <td><code>arr.pop()</code></td>
                    <td><code>arr.pop()</code></td>
                </tr>
                <tr>
                    <td>Checking if item exists</td>
                    <td><code>arr.includes(item)</code></td>
                    <td><code>item in arr</code></td>
                </tr>
                <tr>
                    <td>Finding an item's index</td>
                    <td><code>arr.indexOf(item)</code></td>
                    <td><code>arr.index(item)</code></td>
                </tr>
                <tr>
                    <td>Slicing/Extracting portion</td>
                    <td><code>arr.slice(start, end)</code></td>
                    <td><code>arr[start:end]</code></td>
                </tr>
                <tr>
                    <td>Iterating</td>
                    <td><code>for (const item of arr) {...}</code></td>
                    <td><code>for item in arr: ...</code></td>
                </tr>
                <tr>
                    <td>Mapping</td>
                    <td><code>arr.map(x => x * 2)</code></td>
                    <td><code>[x * 2 for x in arr]</code> (list comprehension)</td>
                </tr>
                <tr>
                    <td>Filtering</td>
                    <td><code>arr.filter(x => x > 5)</code></td>
                    <td><code>[x for x in arr if x > 5]</code></td>
                </tr>
                <tr>
                    <td>Reducing</td>
                    <td><code>arr.reduce((a,b) => a+b, 0)</code></td>
                    <td><code>sum(arr)</code> or <code>from functools import reduce; reduce(lambda a,b: a+b, arr)</code></td>
                </tr>
            </table>
            
            <h4>Key Differences</h4>
            
            <p><strong>1. Python distinguishes between mutable Lists and immutable Tuples</strong></p>
            <pre><code>
# File: list_vs_tuple.py
# Location: ~/python_examples/week2/

# Python lists (mutable, like JavaScript arrays)
fruits = ["apple", "banana", "cherry"]
fruits[0] = "apricot"  # OK - lists can be modified
fruits.append("date")  # Adds to the end

# Python tuples (immutable)
coordinates = (10, 20, 30)
# coordinates[0] = 15  # Error - tuples can't be modified
# coordinates.append(40)  # Error - no append method

# JavaScript has no direct equivalent to tuples
</code></pre>
            
            <p><strong>2. Python slicing is more powerful than JavaScript's slice()</strong></p>
            <pre><code>
# File: slicing_examples.py
# Location: ~/python_examples/week2/

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Basic slicing (similar to JavaScript)
first_three = numbers[0:3]  # [0, 1, 2]

# Slicing with step (no direct JS equivalent)
every_second = numbers[::2]  # [0, 2, 4, 6, 8]

# Negative indices (from the end)
last_three = numbers[-3:]  # [7, 8, 9]

# Reversing with slice
reversed_list = numbers[::-1]  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

# JavaScript equivalent would be:
# const reversed = [...numbers].reverse();
</code></pre>
            
            <p><strong>3. Python list comprehensions have no direct JavaScript equivalent</strong></p>
            <pre><code>
# File: comprehensions.py
# Location: ~/python_examples/week2/

numbers = [1, 2, 3, 4, 5]

# Python list comprehension (map equivalent)
doubled = [x * 2 for x in numbers]  # [2, 4, 6, 8, 10]

# Python list comprehension (filter equivalent)
evens = [x for x in numbers if x % 2 == 0]  # [2, 4]

# Python list comprehension (map + filter)
doubled_evens = [x * 2 for x in numbers if x % 2 == 0]  # [4, 8]

# JavaScript equivalents:
# const doubled = numbers.map(x => x * 2);
# const evens = numbers.filter(x => x % 2 === 0);
# const doubledEvens = numbers.filter(x => x % 2 === 0).map(x => x * 2);
</code></pre>
            
            <p><strong>4. Python has no arrow functions, but uses lambda for simple functions</strong></p>
            <pre><code>
# File: lambda_examples.py
# Location: ~/python_examples/week2/

numbers = [1, 2, 3, 4, 5]

# Python's sorted with key function
desc_order = sorted(numbers, reverse=True)  # [5, 4, 3, 2, 1]

# Using lambda (similar to arrow function, but more limited)
custom_sort = sorted(numbers, key=lambda x: abs(x - 3))
# Sorts by distance from 3: [3, 2, 4, 1, 5]

# In JavaScript:
# const customSort = numbers.sort((a, b) => Math.abs(a - 3) - Math.abs(b - 3));
</code></pre>
            
            <h4>When to Use Tuples Instead of Lists</h4>
            <p>As a JavaScript developer, you might wonder when to use tuples since JavaScript has no equivalent. Here are common use cases:</p>
            <ul>
                <li><strong>Immutable data:</strong> When you want to ensure data can't be changed</li>
                <li><strong>Dictionary keys:</strong> Lists can't be dictionary keys, but tuples can</li>
                <li><strong>Function returns:</strong> Returning multiple values from a function</li>
                <li><strong>Data integrity:</strong> Representing fixed structures like coordinates (x, y, z)</li>
            </ul>
            
            <pre><code>
# File: tuple_usage.py
# Location: ~/python_examples/week2/

# Multiple return values
def get_dimensions():
    return (1920, 1080)  # Returns width, height as tuple

width, height = get_dimensions()  # Tuple unpacking
print(f"Width: {width}, Height: {height}")

# Dictionary with tuple keys
locations = {
    (40.7128, -74.0060): "New York",
    (34.0522, -118.2437): "Los Angeles",
    (41.8781, -87.6298): "Chicago"
}

# Find location by coordinates
coords = (40.7128, -74.0060)
print(f"Location: {locations[coords]}")
</code></pre>
            
            <p><strong>Real-world application:</strong> In a web application, you might use tuples to represent configuration settings that shouldn't change during execution, such as screen breakpoints, color scheme values, or API endpoint URLs. This provides a safeguard against accidental modification.</p>
        </section>

        <section class="objects_vs_dictionaries">
            <h3>JavaScript Objects vs Python Dictionaries</h3>
            
            <p>JavaScript objects and Python dictionaries both provide key-value mappings, but with notable differences in syntax, behavior, and capabilities.</p>
            
            <h4>Key Similarities</h4>
            <ul>
                <li>Both store key-value pairs</li>
                <li>Both allow dynamic addition and removal of pairs</li>
                <li>Both provide methods to check for key existence</li>
                <li>Both can be nested (contain other objects/dictionaries as values)</li>
            </ul>
            
            <h4>Side-by-Side Comparison</h4>
            
            <table>
                <tr>
                    <th>Operation</th>
                    <th>JavaScript</th>
                    <th>Python</th>
                </tr>
                <tr>
                    <td>Creating an empty collection</td>
                    <td><code>const obj = {};</code></td>
                    <td><code>obj = {}</code></td>
                </tr>
                <tr>
                    <td>Creating with initial values</td>
                    <td><code>const obj = {name: 'Alice', age: 30};</code></td>
                    <td><code>obj = {'name': 'Alice', 'age': 30}</code></td>
                </tr>
                <tr>
                    <td>Accessing a value</td>
                    <td><code>obj.name</code> or <code>obj['name']</code></td>
                    <td><code>obj['name']</code> (no dot notation for arbitrary keys)</td>
                </tr>
                <tr>
                    <td>Setting a value</td>
                    <td><code>obj.name = 'Bob'</code> or <code>obj['name'] = 'Bob'</code></td>
                    <td><code>obj['name'] = 'Bob'</code></td>
                </tr>
                <tr>
                    <td>Checking if key exists</td>
                    <td><code>'name' in obj</code></td>
                    <td><code>'name' in obj</code></td>
                </tr>
                <tr>
                    <td>Getting keys</td>
                    <td><code>Object.keys(obj)</code></td>
                    <td><code>obj.keys()</code> or <code>list(obj.keys())</code></td>
                </tr>
                <tr>
                    <td>Getting values</td>
                    <td><code>Object.values(obj)</code></td>
                    <td><code>obj.values()</code> or <code>list(obj.values())</code></td>
                </tr>
                <tr>
                    <td>Getting entries</td>
                    <td><code>Object.entries(obj)</code></td>
                    <td><code>obj.items()</code> or <code>list(obj.items())</code></td>
                </tr>
                <tr>
                    <td>Merging objects</td>
                    <td><code>{...obj1, ...obj2}</code></td>
                    <td><code>{**obj1, **obj2}</code> or <code>obj1 | obj2</code> (Python 3.9+)</td>
                </tr>
                <tr>
                    <td>Default value if key missing</td>
                    <td><code>obj.name || 'Unknown'</code></td>
                    <td><code>obj.get('name', 'Unknown')</code></td>
                </tr>
                <tr>
                    <td>Iterating</td>
                    <td><code>for (const [key, value] of Object.entries(obj)) {...}</code></td>
                    <td><code>for key, value in obj.items(): ...</code></td>
                </tr>
            </table>
            
            <h4>Key Differences</h4>
            
            <p><strong>1. Python dictionaries require hashable keys (strings, numbers, tuples, etc.)</strong></p>
            <pre><code>
# File: dictionary_keys.py
# Location: ~/python_examples/week2/

# String keys (like JavaScript objects)
user = {'name': 'Alice', 'age': 30}

# Numeric keys (rarely used in JavaScript)
counts = {1: 'one', 2: 'two', 3: 'three'} 

# Tuple keys (not possible in JavaScript)
coordinates = {(0, 0): 'origin', (1, 0): 'right', (0, 1): 'up'}

# This would cause an error in Python:
# invalid_dict = {[1, 2]: 'value'}  # Lists can't be keys (not hashable)
</code></pre>
            
            <p><strong>2. Python dot notation is only for attributes/methods, not arbitrary dictionary keys</strong></p>
            <pre><code>
# File: dict_access.py
# Location: ~/python_examples/week2/

user = {'name': 'Alice', 'age': 30, 'email-address': 'alice@example.com'}

# Square brackets work for any key
print(user['name'])  # Alice
print(user['email-address'])  # alice@example.com

# Dot notation doesn't work for dictionaries
# print(user.name)  # AttributeError
# print(user.email-address)  # Syntax Error (- isn't valid in identifiers)

# JavaScript would allow both:
# console.log(user.name);  // Alice
# console.log(user['email-address']);  // alice@example.com
</code></pre>
            
            <p><strong>3. Python dictionaries have useful methods with no direct JavaScript equivalents</strong></p>
            <pre><code>
# File: dict_methods.py
# Location: ~/python_examples/week2/

user = {'name': 'Alice', 'age': 30}

# Get with default value
email = user.get('email', 'no email provided')
print(email)  # 'no email provided'

# JavaScript equivalent:
# const email = user.email || 'no email provided';

# Set default and get
role = user.setdefault('role', 'user')
print(role)  # 'user'
print(user)  # {'name': 'Alice', 'age': 30, 'role': 'user'}

# JavaScript has no direct equivalent; would need:
# if (!user.role) user.role = 'user';
# const role = user.role;

# Pop item (remove and return)
age = user.pop('age')
print(age)  # 30
print(user)  # {'name': 'Alice', 'role': 'user'}

# JavaScript would need:
# const age = user.age;
# delete user.age;
</code></pre>
            
            <p><strong>4. Python dictionaries maintain insertion order (since Python 3.7)</strong></p>
            <pre><code>
# File: dict_ordering.py
# Location: ~/python_examples/week2/

# Python 3.7+ dictionaries maintain insertion order
colors = {
    'red': '#FF0000',
    'green': '#00FF00',
    'blue': '#0000FF'
}

# Keys will be returned in the order they were inserted
for color in colors:
    print(color)  # 'red', 'green', 'blue' in that order

# In JavaScript, prior to ES2015, object property order was not guaranteed
# Modern JavaScript does generally preserve insertion order for string/symbol keys
</code></pre>
            
            <p><strong>5. Python dictionary comprehensions provide concise creation</strong></p>
            <pre><code>
# File: dict_comprehensions.py
# Location: ~/python_examples/week2/

names = ['Alice', 'Bob', 'Charlie']

# Dictionary comprehension
name_lengths = {name: len(name) for name in names}
print(name_lengths)  # {'Alice': 5, 'Bob': 3, 'Charlie': 7}

# JavaScript equivalent would be:
# const nameLengths = Object.fromEntries(names.map(name => [name, name.length]));
</code></pre>
            
            <p><strong>Real-world application:</strong> In a web application, you might use dictionaries to maintain a cache of API responses where the URL is the key and the response data is the value. Python's dictionary methods like <code>get()</code> with a default value simplify the logic for checking if a response exists in the cache before making a new request.</p>
        </section>

        <section class="sets_comparison">
            <h3>JavaScript Sets vs Python Sets</h3>
            
            <p>JavaScript and Python both have Set types that store unique values, but with some syntax and feature differences.</p>
            
            <h4>Key Similarities</h4>
            <ul>
                <li>Both guarantee uniqueness of elements</li>
                <li>Both have fast membership testing</li>
                <li>Both provide methods for common set operations</li>
                <li>Both can store mixed types</li>
            </ul>
            
            <h4>Side-by-Side Comparison</h4>
            
            <table>
                <tr>
                    <th>Operation</th>
                    <th>JavaScript</th>
                    <th>Python</th>
                </tr>
                <tr>
                    <td>Creating an empty set</td>
                    <td><code>const mySet = new Set();</code></td>
                    <td><code>my_set = set()</code></td>
                </tr>
                <tr>
                    <td>Creating from values</td>
                    <td><code>const mySet = new Set([1, 2, 3]);</code></td>
                    <td><code>my_set = {1, 2, 3}</code> or <code>my_set = set([1, 2, 3])</code></td>
                </tr>
                <tr>
                    <td>Adding an item</td>
                    <td><code>mySet.add(item)</code></td>
                    <td><code>my_set.add(item)</code></td>
                </tr>
                <tr>
                    <td>Removing an item</td>
                    <td><code>mySet.delete(item)</code></td>
                    <td><code>my_set.remove(item)</code> or <code>my_set.discard(item)</code></td>
                </tr>
                <tr>
                    <td>Checking if item exists</td>
                    <td><code>mySet.has(item)</code></td>
                    <td><code>item in my_set</code></td>
                </tr>
                <tr>
                    <td>Getting size/length</td>
                    <td><code>mySet.size</code></td>
                    <td><code>len(my_set)</code></td>
                </tr>
                <tr>
                    <td>Union</td>
                    <td><code>new Set([...set1, ...set2])</code></td>
                    <td><code>set1 | set2</code> or <code>set1.union(set2)</code></td>
                </tr>
                <tr>
                    <td>Intersection</td>
                    <td><code>new Set([...set1].filter(x => set2.has(x)))</code></td>
                    <td><code>set1 & set2</code> or <code>set1.intersection(set2)</code></td>
                </tr>
                <tr>
                    <td>Difference</td>
                    <td><code>new Set([...set1].filter(x => !set2.has(x)))</code></td>
                    <td><code>set1 - set2</code> or <code>set1.difference(set2)</code></td>
                </tr>
                <tr>
                    <td>Clearing</td>
                    <td><code>mySet.clear()</code></td>
                    <td><code>my_set.clear()</code></td>
                </tr>
                <tr>
                    <td>Iterating</td>
                    <td><code>for (const item of mySet) {...}</code></td>
                    <td><code>for item in my_set: ...</code></td>
                </tr>
            </table>
            
            <h4>Key Differences</h4>
            
            <p><strong>1. Python sets have more built-in operations with operator syntax</strong></p>
            <pre><code>
# File: set_operations.py
# Location: ~/python_examples/week2/

a = {1, 2, 3, 4}
b = {3, 4, 5, 6}

# Union (all elements from both sets)
union = a | b
print(union)  # {1, 2, 3, 4, 5, 6}

# Intersection (elements in both sets)
intersection = a & b
print(intersection)  # {3, 4}

# Difference (elements in a but not in b)
difference = a - b
print(difference)  # {1, 2}

# Symmetric difference (elements in either set but not both)
sym_diff = a ^ b
print(sym_diff)  # {1, 2, 5, 6}

# JavaScript would need helper functions or more verbose syntax for these
</code></pre>
            
            <p><strong>2. Python set comprehensions for concise creation</strong></p>
            <pre><code>
# File: set_comprehensions.py
# Location: ~/python_examples/week2/

numbers = [1, 2, 2, 3, 4, 4, 5]

# Create a set of squares of even numbers
even_squares = {x**2 for x in numbers if x % 2 == 0}
print(even_squares)  # {4, 16}

# JavaScript equivalent:
# const evenSquares = new Set(numbers.filter(x => x % 2 === 0).map(x => x ** 2));
</code></pre>
            
            <p><strong>3. Python sets can only contain hashable items</strong></p>
            <pre><code>
# File: set_hashable.py
# Location: ~/python_examples/week2/

# This works - tuples are hashable
valid_set = {(1, 2), (3, 4), (5, 6)}

# This would cause an error
# invalid_set = {[1, 2], [3, 4]}  # Lists are not hashable

# JavaScript allows any value type in Sets, including objects and arrays
</code></pre>
            
            <p><strong>4. Python sets have additional useful methods</strong></p>
            <pre><code>
# File: set_methods.py
# Location: ~/python_examples/week2/

a = {1, 2, 3}
b = {1, 2, 3, 4, 5}

# Check if a is subset of b
print(a.issubset(b))  # True
print(a <= b)  # True (operator syntax)

# Check if b is superset of a
print(b.issuperset(a))  # True
print(b >= a)  # True (operator syntax)

# Update a set in-place (union)
a |= {4, 5}
print(a)  # {1, 2, 3, 4, 5}

# Remove items from a set in-place (difference)
a -= {4, 5}
print(a)  # {1, 2, 3}

# JavaScript Sets have less built-in functionality
</code></pre>
            
            <p><strong>Real-world application:</strong> In a user permission system, you might use sets to represent and compare user roles and capabilities. For example, checking if a user has sufficient permissions might involve testing if their permission set is a superset of the required permissions set for an action, which is elegantly expressed with <code>user_permissions >= required_permissions</code>.</p>
        </section>

        <section class="practical_examples">
            <h3>Practical Translation Examples</h3>
            
            <p>Let's walk through some common JavaScript patterns and their Python equivalents to solidify these concepts.</p>
            
            <h4>Example 1: Processing a List of Records</h4>
            
            <div class="code-comparison">
                <div class="js-code">
                    <p><strong>JavaScript:</strong></p>
                    <pre><code>
// users.js

const users = [
  { id: 1, name: 'Alice', age: 28, active: true },
  { id: 2, name: 'Bob', age: 22, active: false },
  { id: 3, name: 'Charlie', age: 31, active: true },
  { id: 4, name: 'Diana', age: 25, active: false }
];

// Get active users
const activeUsers = users.filter(user => user.active);

// Get names of users over 25
const olderUserNames = users
  .filter(user => user.age > 25)
  .map(user => user.name);

// Create a map for quick ID lookup
const userMap = users.reduce((map, user) => {
  map[user.id] = user;
  return map;
}, {});

// Get a user by ID
const user = userMap[2]; // Bob's record

console.log(activeUsers);
console.log(olderUserNames);
console.log(user);
                    </code></pre>
                </div>
                <div class="py-code">
                    <p><strong>Python:</strong></p>
                    <pre><code>
# File: users.py
# Location: ~/python_examples/week2/

users = [
    {'id': 1, 'name': 'Alice', 'age': 28, 'active': True},
    {'id': 2, 'name': 'Bob', 'age': 22, 'active': False},
    {'id': 3, 'name': 'Charlie', 'age': 31, 'active': True},
    {'id': 4, 'name': 'Diana', 'age': 25, 'active': False}
]

# Get active users
active_users = [user for user in users if user['active']]

# Get names of users over 25
older_user_names = [user['name'] for user in users if user['age'] > 25]

# Create a dictionary for quick ID lookup
user_map = {user['id']: user for user in users}

# Get a user by ID
user = user_map[2]  # Bob's record

print(active_users)
print(older_user_names)
print(user)
                    </code></pre>
                </div>
            </div>
            
            <h4>Example 2: Handling Nested Data</h4>
            
            <div class="code-comparison">
                <div class="js-code">
                    <p><strong>JavaScript:</strong></p>
                    <pre><code>
// products.js

const products = {
  electronics: {
    smartphone: [
      { brand: 'Apple', model: 'iPhone 13', price: 999 },
      { brand: 'Samsung', model: 'Galaxy S21', price: 899 }
    ],
    laptop: [
      { brand: 'Apple', model: 'MacBook Pro', price: 1299 },
      { brand: 'Dell', model: 'XPS 13', price: 999 }
    ]
  },
  clothing: {
    shirts: [
      { brand: 'Nike', size: 'M', price: 29.99 },
      { brand: 'Adidas', size: 'L', price: 24.99 }
    ]
  }
};

// Find all Apple products
const appleProducts = [];
Object.keys(products).forEach(category => {
  Object.keys(products[category]).forEach(subcategory => {
    products[category][subcategory].forEach(product => {
      if (product.brand === 'Apple') {
        appleProducts.push({
          category,
          subcategory,
          ...product
        });
      }
    });
  });
});

// Calculate total price of all products
let totalPrice = 0;
Object.values(products).forEach(category => {
  Object.values(category).forEach(subcategory => {
    subcategory.forEach(product => {
      totalPrice += product.price;
    });
  });
});

console.log(appleProducts);
console.log(`Total price: $${totalPrice}`);
                    </code></pre>
                </div>
                <div class="py-code">
                    <p><strong>Python:</strong></p>
                    <pre><code>
# File: products.py
# Location: ~/python_examples/week2/

products = {
    'electronics': {
        'smartphone': [
            {'brand': 'Apple', 'model': 'iPhone 13', 'price': 999},
            {'brand': 'Samsung', 'model': 'Galaxy S21', 'price': 899}
        ],
        'laptop': [
            {'brand': 'Apple', 'model': 'MacBook Pro', 'price': 1299},
            {'brand': 'Dell', 'model': 'XPS 13', 'price': 999}
        ]
    },
    'clothing': {
        'shirts': [
            {'brand': 'Nike', 'size': 'M', 'price': 29.99},
            {'brand': 'Adidas', 'size': 'L', 'price': 24.99}
        ]
    }
}

# Find all Apple products
apple_products = []
for category_name, category in products.items():
    for subcategory_name, items in category.items():
        for item in items:
            if item['brand'] == 'Apple':
                # Create a copy and add category info
                product_info = item.copy()
                product_info['category'] = category_name
                product_info['subcategory'] = subcategory_name
                apple_products.append(product_info)

# Alternative using list comprehension (more advanced)
apple_products_alt = [
    {**item, 'category': cat, 'subcategory': subcat}
    for cat, category in products.items()
    for subcat, items in category.items()
    for item in items
    if item['brand'] == 'Apple'
]

# Calculate total price of all products
total_price = 0
for category in products.values():
    for items in category.values():
        for item in items:
            total_price += item['price']

print(apple_products)
print(f"Total price: ${total_price}")
                    </code></pre>
                </div>
            </div>
            
            <h4>Example 3: Handling Unique Values and Set Operations</h4>
            
            <div class="code-comparison">
                <div class="js-code">
                    <p><strong>JavaScript:</strong></p>
                    <pre><code>
// students.js

const mathStudents = ['Alice', 'Bob', 'Charlie', 'Diana'];
const scienceStudents = ['Bob', 'Diana', 'Eve', 'Frank'];
const englishStudents = ['Alice', 'Charlie', 'Grace'];

// Students taking both math and science
const mathAndScience = mathStudents.filter(
  student => scienceStudents.includes(student)
);

// Students taking any subject
const allStudents = [
  ...new Set([...mathStudents, ...scienceStudents, ...englishStudents])
];

// Students taking only math (not science or English)
const onlyMath = mathStudents.filter(
  student => !scienceStudents.includes(student) && 
             !englishStudents.includes(student)
);

console.log('Math and Science:', mathAndScience);
console.log('All Students:', allStudents);
console.log('Only Math:', onlyMath);
                    </code></pre>
                </div>
                <div class="py-code">
                    <p><strong>Python:</strong></p>
                    <pre><code>
# File: students.py
# Location: ~/python_examples/week2/

math_students = {'Alice', 'Bob', 'Charlie', 'Diana'}
science_students = {'Bob', 'Diana', 'Eve', 'Frank'}
english_students = {'Alice', 'Charlie', 'Grace'}

# Students taking both math and science
math_and_science = math_students & science_students

# Students taking any subject
all_students = math_students | science_students | english_students

# Students taking only math (not science or English)
only_math = math_students - (science_students | english_students)

print('Math and Science:', math_and_science)
print('All Students:', all_students)
print('Only Math:', only_math)
                    </code></pre>
                </div>
            </div>
            
            <p><strong>Real-world application:</strong> The set operations example mirrors how you might analyze user engagement across different features of an application. For instance, you could identify users who engage with both your mobile and web platforms (intersection), users who have abandoned one platform entirely (difference), or the total active user base across all platforms (union).</p>
        </section>

        <section class="performance_comparison">
            <h3>Performance Considerations</h3>
            
            <p>As you move from JavaScript to Python, it's useful to understand performance differences between comparable operations:</p>
            
            <table>
                <tr>
                    <th>Operation</th>
                    <th>JavaScript Performance</th>
                    <th>Python Performance</th>
                    <th>Notes</th>
                </tr>
                <tr>
                    <td>Item lookup by index</td>
                    <td>O(1) in Array</td>
                    <td>O(1) in List/Tuple</td>
                    <td>Similar performance</td>
                </tr>
                <tr>
                    <td>Item lookup by value</td>
                    <td>O(n) in Array<br>O(1) in Set</td>
                    <td>O(n) in List/Tuple<br>O(1) in Set</td>
                    <td>Similar performance</td>
                </tr>
                <tr>
                    <td>Property/Key lookup</td>
                    <td>O(1) in Object</td>
                    <td>O(1) in Dictionary</td>
                    <td>Similar performance</td>
                </tr>
                <tr>
                    <td>Iteration</td>
                    <td>Generally slower</td>
                    <td>Generally faster</td>
                    <td>Python's for loops are implemented in C</td>
                </tr>
                <tr>
                    <td>Array/List manipulation</td>
                    <td>Array methods can be inefficient for large datasets</td>
                    <td>List comprehensions are optimized and often faster</td>
                    <td>Python's list comprehensions often outperform equivalent JS array methods</td>
                </tr>
                <tr>
                    <td>String operations</td>
                    <td>Generally good performance</td>
                    <td>String concatenation can be slow for large operations</td>
                    <td>Use ''.join() in Python for concatenating many strings</td>
                </tr>
            </table>
            
            <h4>Performance Tips When Transitioning</h4>
            <ul>
                <li><strong>Use appropriate collections:</strong> In Python, always use sets for membership testing when order doesn't matter</li>
                <li><strong>Leverage comprehensions:</strong> List/dict comprehensions are usually faster than equivalent for loops</li>
                <li><strong>Be cautious with string concatenation:</strong> Use ''.join(items) instead of += for building strings</li>
                <li><strong>Know when to use dictionaries:</strong> If you're using arrays with indexOf in JS, consider dictionaries in Python</li>
                <li><strong>Consider generators for large datasets:</strong> Python generators can help with memory usage</li>
            </ul>
            
            <pre><code>
# File: performance_examples.py
# Location: ~/python_examples/week2/

# Efficient string concatenation
words = ['Python', 'is', 'awesome', 'for', 'data', 'processing']

# Inefficient (like JavaScript's +=)
result = ''
for word in words:
    result += word + ' '
    
# Efficient (Python's way)
better_result = ' '.join(words)

# Efficient membership testing
large_list = list(range(10000))
large_set = set(large_list)

# Slow (like JavaScript array.includes)
def find_in_list(item):
    return item in large_list  # O(n)

# Fast (like JavaScript Set.has)
def find_in_set(item):
    return item in large_set  # O(1)

# Generator for memory efficiency
def first_n_squared(n):
    # Returns a generator, not a list
    return (x**2 for x in range(1, n+1))

# More memory-efficient than:
# def first_n_squared_list(n):
#     return [x**2 for x in range(1, n+1)]
</code></pre>
        </section>

        <section class="common_pitfalls">
            <h3>Common Pitfalls for JavaScript Developers</h3>
            
            <p>When transitioning from JavaScript to Python, be aware of these common stumbling blocks:</p>
            
            <h4>Mutable Default Arguments</h4>
            <pre><code>
# File: mutable_defaults.py
# Location: ~/python_examples/week2/

# WRONG: This doesn't work as expected
def add_to_list(item, my_list=[]):
    my_list.append(item)
    return my_list

print(add_to_list("a"))  # ['a']
print(add_to_list("b"))  # ['a', 'b'] - Surprise! The list persists

# RIGHT: Use None as default and create list inside function
def add_to_list_properly(item, my_list=None):
    if my_list is None:
        my_list = []
    my_list.append(item)
    return my_list

print(add_to_list_properly("a"))  # ['a']
print(add_to_list_properly("b"))  # ['b'] - Each call gets a fresh list
</code></pre>
            
            <h4>Copy vs. Reference Behavior</h4>
            <pre><code>
# File: copy_reference.py
# Location: ~/python_examples/week2/

# Lists and dictionaries are mutable and assigned by reference
original_list = [1, 2, 3]
reference_to_original = original_list  # Creates a reference, not a copy

reference_to_original.append(4)
print(original_list)  # [1, 2, 3, 4] - Original is modified!

# Creating copies
import copy

# Shallow copy
shallow_copy = original_list.copy()  # or list(original_list) or original_list[:]
shallow_copy.append(5)
print(original_list)  # Still [1, 2, 3, 4] - Original unchanged

# Deep copy (for nested structures)
nested = [[1, 2], [3, 4]]
deep_copy = copy.deepcopy(nested)
deep_copy[0][0] = 99
print(nested)  # [[1, 2], [3, 4]] - Original unchanged

# JavaScript behaves similarly, but developers often forget this applies to Python too
</code></pre>
            
            <h4>Truthiness Differences</h4>
            <pre><code>
# File: truthiness.py
# Location: ~/python_examples/week2/

# Python vs JavaScript truthiness differences
# In JavaScript: 0, '', null, undefined, NaN are falsy
# In Python:

# Empty collections are falsy
print(bool([]))     # False (like JavaScript)
print(bool({}))     # False (like JavaScript)
print(bool(set()))  # False

# But zero-like numerics and empty strings are also falsy
print(bool(0))      # False (like JavaScript)
print(bool(0.0))    # False
print(bool(''))     # False (like JavaScript)

# None is falsy (Python's null equivalent)
print(bool(None))   # False

# In Python, all other values are truthy, including:
print(bool('0'))    # True (string containing '0')
print(bool([0]))    # True (list containing 0)
print(bool({0}))    # True (set containing 0)

# Logical operators return the last value evaluated, not just True/False
print([] or "default")  # "default" (similar to JavaScript)
print([1, 2] or "default")  # [1, 2] (similar to JavaScript)
</code></pre>
            
            <h4>String Immutability</h4>
            <pre><code>
# File: string_immutability.py
# Location: ~/python_examples/week2/

# Strings are immutable in Python
greeting = "Hello"

# This doesn't work
# greeting[0] = "h"  # TypeError: 'str' object does not support item assignment

# Instead, create a new string
greeting = "h" + greeting[1:]
print(greeting)  # "hello"

# For more complex string manipulation, use string methods or formatting
name = "Alice"
greeting = f"Hello, {name}!"  # f-strings (like JS template literals)
print(greeting)  # "Hello, Alice!"

# JavaScript strings are also immutable, but this is a common confusion point
</code></pre>
            
            <h4>Function Arguments: Named vs. Positional</h4>
            <pre><code>
# File: function_arguments.py
# Location: ~/python_examples/week2/

# Python supports both positional and named arguments
def create_profile(name, age, city="Unknown", country=None):
    profile = {
        "name": name,
        "age": age,
        "city": city
    }
    if country:
        profile["country"] = country
    return profile

# Positional arguments
profile1 = create_profile("Alice", 30)

# Named arguments (any order)
profile2 = create_profile(age=25, name="Bob", country="USA")

# Mix of positional and named (positional must come first)
profile3 = create_profile("Charlie", 22, country="Canada")

print(profile1)
print(profile2)
print(profile3)

# JavaScript traditionally used object parameter for named arguments:
# function createProfile({ name, age, city = 'Unknown', country = null }) {...}
</code></pre>
        </section>

        <section class="conclusion">
            <h3>Leveraging Your JavaScript Knowledge in Python</h3>
            
            <p>As you dive deeper into Python, your JavaScript experience provides a strong foundation for understanding collections and data manipulation. Here are some final tips for making a smooth transition:</p>
            
            <ul>
                <li><strong>Embrace Pythonic idioms:</strong> Rather than writing JavaScript in Python, learn Python's preferred approaches (comprehensions, built-in functions, etc.)</li>
                <li><strong>Leverage operator syntax:</strong> Python's operators for dictionaries and sets can make your code more readable</li>
                <li><strong>Use the REPL:</strong> Python's interactive interpreter is great for experimenting with collections</li>
                <li><strong>Explore the standard library:</strong> Python's standard library has many powerful tools for working with collections</li>
                <li><strong>Practice with real examples:</strong> Convert JavaScript code you're familiar with to Python to build fluency</li>
            </ul>
            
            <p>Remember that both languages have their strengths. JavaScript's functional programming features and Python's clear, concise syntax each excel in different contexts. By understanding both, you'll have a versatile toolkit for solving a wide range of programming problems.</p>
            
            <p>As you continue your Python journey, you'll discover that the concepts you learned in JavaScript—like iteration, transformation, and filtering—apply in Python as well, just with different syntax and sometimes with more elegant built-in solutions.</p>
        </section>

        <section class="exercises">
            <h3>Exercises for Practice</h3>
            
            <p>Put your knowledge to the test by translating these JavaScript snippets to Python:</p>
            
            <h4>Exercise 1: User Filtering</h4>
            <pre><code>
// Convert this JavaScript code to Python
const users = [
  { name: 'Alice', age: 25, roles: ['admin', 'user'] },
  { name: 'Bob', age: 32, roles: ['user'] },
  { name: 'Charlie', age: 19, roles: ['user', 'moderator'] },
  { name: 'Diana', age: 40, roles: ['user'] }
];

// Get user names who are either admins or over 30
const specialUsers = users
  .filter(user => user.roles.includes('admin') || user.age > 30)
  .map(user => user.name);

console.log(specialUsers);  // ['Alice', 'Bob', 'Diana']
</code></pre>
            
            <h4>Exercise 2: Word Frequency Counter</h4>
            <pre><code>
// Convert this JavaScript code to Python
const text = "the quick brown fox jumps over the lazy dog fox fox";
const words = text.toLowerCase().split(' ');

// Count word frequencies
const wordCounts = {};
for (const word of words) {
  wordCounts[word] = (wordCounts[word] || 0) + 1;
}

// Find the most frequent word
let mostFrequentWord = '';
let highestCount = 0;

for (const [word, count] of Object.entries(wordCounts)) {
  if (count > highestCount) {
    mostFrequentWord = word;
    highestCount = count;
  }
}

console.log(`Most frequent word: "${mostFrequentWord}" (${highestCount} times)`);
</code></pre>
            
            <h4>Exercise 3: Nested Data Transformation</h4>
            <pre><code>
// Convert this JavaScript code to Python
const schools = [
  { 
    name: 'Lincoln High', 
    departments: ['Math', 'Science', 'English'],
    teachers: [
      { name: 'Ms. Johnson', subject: 'Math', students: 32 },
      { name: 'Mr. Davis', subject: 'Science', students: 28 },
      { name: 'Mrs. Garcia', subject: 'English', students: 30 }
    ]
  },
  { 
    name: 'Washington Middle', 
    departments: ['History', 'Art', 'Music'],
    teachers: [
      { name: 'Mr. Brown', subject: 'History', students: 25 },
      { name: 'Ms. Wilson', subject: 'Art', students: 20 },
      { name: 'Mr. Lee', subject: 'Music', students: 22 }
    ]
  }
];

// Create a map of teachers by subject across all schools
const teachersBySubject = {};

schools.forEach(school => {
  school.teachers.forEach(teacher => {
    if (!teachersBySubject[teacher.subject]) {
      teachersBySubject[teacher.subject] = [];
    }
    teachersBySubject[teacher.subject].push({
      name: teacher.name,
      school: school.name,
      students: teacher.students
    });
  });
});

console.log(teachersBySubject);
</code></pre>
            
            <p>Try implementing these exercises yourself to practice the concepts we've covered!</p>
        </section>

        <section class="resources">
            <h3>Further Resources</h3>
            
            <ul>
                <li><a href="https://docs.python.org/3/tutorial/datastructures.html" target="_blank">Python Data Structures Documentation</a></li>
                <li><a href="https://realpython.com/python-data-structures/" target="_blank">Real Python: Python Data Structures</a></li>
                <li><a href="https://realpython.com/python-for-javascript-developers/" target="_blank">Real Python: Python for JavaScript Developers</a></li>
                <li><a href="https://www.w3schools.com/python/python_ref_list.asp" target="_blank">W3Schools: Python List Methods</a></li>
                <li><a href="https://www.w3schools.com/python/python_ref_dictionary.asp" target="_blank">W3Schools: Python Dictionary Methods</a></li>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank">MDN: JavaScript Array Reference</a></li>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">MDN: JavaScript Object Reference</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
