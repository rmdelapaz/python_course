<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Functions: Variable Scope and Namespaces</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Functions: Variable Scope and Namespaces</h1>
        <h2>Understanding the Rules of Variable Visibility and Lifetime</h2>
    </header>

    <main>
        <section class="introduction">
            <h2>Understanding Variable Scope and Namespaces</h2>
            <p>
                Imagine you're working in a large office building. Each department has its own floor with offices, desks, and resources. When you're working on the Marketing floor, you have access to all of Marketing's resources, but you can't just walk over to a desk on the Finance floor and start using their equipment without permission.
            </p>
            <p>
                In Python, variable scope and namespaces work in a similar way. They determine where variables are accessible from, and they help organize your code by keeping related variables together while preventing conflicts.
            </p>
            <p>
                Understanding these concepts is crucial for writing reliable, maintainable Python code, especially when working with functions and more complex programs. In this tutorial, we'll explore what scopes and namespaces are, how they work, and how to use them effectively.
            </p>
        </section>

        <section class="namespaces_basics">
            <h2>Namespaces: Python's Organization System</h2>
            <p>
                A namespace in Python is a container that holds a mapping of names to objects (like variables, functions, and classes). The name of a variable must be unique within its namespace, but the same name can be used in different namespaces without conflict.
            </p>
            <p>
                Think of a namespace as a dictionary where the names of variables are the keys, and the actual objects (values, functions, etc.) they refer to are the values.
            </p>
            <pre><code>
# File: namespace_basics.py
# Location: /python_projects/functions_tutorial/

# Simple illustration of namespaces
print("Demonstration of namespaces in Python:")

# The built-in namespace contains all built-in functions and exceptions
print(f"Type of 'print' in built-in namespace: {type(print)}")
print(f"Type of 'int' in built-in namespace: {type(int)}")
print(f"Type of 'Exception' in built-in namespace: {type(Exception)}")

# The global namespace includes names defined at the module level
x = 10
y = "hello"
def my_function():
    pass

print(f"\nGlobal namespace contains: x={x}, y={y}, my_function={my_function}")

# We can list all names in the current global namespace
import builtins
print("\nSome built-in names:")
builtin_names = dir(builtins)[:10]  # Just show first 10 for brevity
for name in builtin_names:
    print(f"  {name}")

print("\nSome global names:")
global_names = [name for name in dir() if not name.startswith('_')][:10]  # Show first 10 user-defined globals
for name in global_names:
    print(f"  {name}")
</code></pre>
            <p>
                Python automatically creates and manages several namespaces:
            </p>
            <ul>
                <li><strong>Built-in namespace:</strong> Contains built-in functions like <code>print()</code>, <code>len()</code>, and built-in types like <code>int</code> and <code>list</code>.</li>
                <li><strong>Global namespace:</strong> Created when a module is loaded and contains global variables and functions defined in that module.</li>
                <li><strong>Local namespace:</strong> Created when a function is called and contains local variables defined inside the function.</li>
                <li><strong>Enclosing namespace:</strong> Exists when working with nested functions and contains variables from the outer function.</li>
            </ul>
            <p>
                Namespaces help prevent naming conflicts. For example, you can have a variable named <code>count</code> in one function and another variable also named <code>count</code> in a different function. They don't conflict because they exist in different namespaces.
            </p>
        </section>

        <section class="scope_basics">
            <h2>Scope: The Visibility of Variables</h2>
            <p>
                While a namespace defines where a name is stored, scope determines where that name can be accessed from. The scope of a variable is the region of code where the variable can be referenced.
            </p>
            <p>
                Think of scope as a set of rules that determine which namespaces Python searches when you try to access a variable.
            </p>
            <pre><code>
# File: scope_basics.py
# Location: /python_projects/functions_tutorial/

# Global scope
message = "Hello, world!"  # Global variable

def print_message():
    # Local scope
    print(message)  # Can access the global variable

def change_local_message():
    # Local scope
    message = "Hello, local!"  # Creates a new local variable
    print(message)  # Prints the local variable

def change_global_message():
    # Local scope
    global message  # Declare that we want to use the global variable
    message = "Hello, modified world!"  # Modifies the global variable
    print(message)  # Prints the modified global variable

# Call the functions
print("Original global message:", message)
print_message()
change_local_message()
print("Global message after local change:", message)  # Unchanged
change_global_message()
print("Global message after global change:", message)  # Changed
</code></pre>
            <p>
                In this example:
            </p>
            <ul>
                <li>The variable <code>message</code> is initially defined in the global scope.</li>
                <li><code>print_message()</code> can access the global variable because it doesn't define its own variable with the same name.</li>
                <li><code>change_local_message()</code> creates a new local variable also named <code>message</code>, which shadows (hides) the global variable within that function.</li>
                <li><code>change_global_message()</code> uses the <code>global</code> keyword to modify the global variable instead of creating a local one.</li>
            </ul>
            <p>
                It's like having two people named "John" in different departments. If someone says "Get John to help with this," you need to know which department they're talking about to find the right John.
            </p>
        </section>

        <section class="lbge_rule">
            <h2>The LEGB Rule: Python's Scope Resolution</h2>
            <p>
                When you use a variable in Python, the interpreter needs to figure out which namespace to look in to find that variable. It follows a specific order, known as the LEGB rule:
            </p>
            <ol>
                <li><strong>L</strong>ocal: Names defined within the current function</li>
                <li><strong>E</strong>nclosing: Names defined in any enclosing functions (for nested functions)</li>
                <li><strong>G</strong>lobal: Names defined at the module level</li>
                <li><strong>B</strong>uilt-in: Names built into Python (like <code>print</code>, <code>len</code>, etc.)</li>
            </ol>
            <p>
                Python searches for a name in this order, and uses the first occurrence it finds.
            </p>
            <pre><code>
# File: legb_rule.py
# Location: /python_projects/functions_tutorial/

# Built-in scope
# print, len, str, etc. are in the built-in scope

# Global scope
x = "global x"

def outer_function():
    # Enclosing scope (for the inner function)
    x = "outer x"
    
    def inner_function():
        # Local scope
        x = "local x"
        print("Inner function x:", x)  # Uses local x
    
    inner_function()
    print("Outer function x:", x)  # Uses enclosing (outer) x

print("Global x before function call:", x)  # Uses global x
outer_function()
print("Global x after function call:", x)  # Still uses global x

# Example of looking up through the scopes
def demo_scopes():
    # No local variable named 'len'
    
    def inner():
        # No local or enclosing variable named 'len'
        # So Python looks in global, doesn't find it
        # Finally finds 'len' in built-in scope
        return len("Hello")  # Uses built-in len()
    
    return inner()

print("Length from built-in scope:", demo_scopes())
</code></pre>
            <p>
                This hierarchical lookup system is like searching for information in an organization:
            </p>
            <ul>
                <li>First, you check your desk (Local scope)</li>
                <li>If not found, you ask your department (Enclosing scope)</li>
                <li>If still not found, you check company-wide resources (Global scope)</li>
                <li>Finally, you consult industry standards or references (Built-in scope)</li>
            </ul>
        </section>

        <section class="local_variables">
            <h2>Local Variables: The Inner Circle</h2>
            <p>
                Local variables are defined within a function and are only accessible inside that function. They are created when the function is called and destroyed when the function completes execution.
            </p>
            <p>
                Think of local variables as personal items at your desk. They're only available to you while you're working at that desk, and they disappear when you leave.
            </p>
            <pre><code>
# File: local_variables.py
# Location: /python_projects/functions_tutorial/

def calculate_area(length, width):
    """Calculate the area of a rectangle."""
    # length and width are local variables (parameters)
    area = length * width  # area is also a local variable
    print(f"Local variables inside the function: length={length}, width={width}, area={area}")
    return area

# Call the function
rectangle_area = calculate_area(5, 10)
print(f"Result returned from function: {rectangle_area}")

# This would cause an error because area is a local variable
# and not accessible outside the function
try:
    print(area)
except NameError as e:
    print(f"Error: {e}")

# Local variables in different functions don't affect each other
def function1():
    value = 10
    print(f"Value in function1: {value}")

def function2():
    value = 20
    print(f"Value in function2: {value}")

function1()
function2()
function1()  # Still has its own value
</code></pre>
            <p>
                Local variables have several important characteristics:
            </p>
            <ul>
                <li><strong>Lifetime:</strong> They exist only while the function is running</li>
                <li><strong>Independence:</strong> Each function call creates new local variables</li>
                <li><strong>Isolation:</strong> They don't affect variables with the same name in other functions</li>
                <li><strong>Privacy:</strong> They can't be accessed from outside the function</li>
            </ul>
            <p>
                Local variables make functions more robust and independent, reducing the chance of unexpected side effects in your code.
            </p>
        </section>

        <section class="global_variables">
            <h2>Global Variables: The Shared Resources</h2>
            <p>
                Global variables are defined at the module level, outside any function, and can be accessed from anywhere in the module. They have the widest scope and longest lifetime of all variables.
            </p>
            <p>
                Think of global variables as shared resources in an office, like a printer or a conference room. Anyone in the office can access them, but this broad accessibility can sometimes lead to confusion or conflicts.
            </p>
            <pre><code>
# File: global_variables.py
# Location: /python_projects/functions_tutorial/

# Global variables
counter = 0
app_name = "My Application"
DEBUG = True

def increment_counter():
    global counter  # Declare intention to use the global variable
    counter += 1
    print(f"Counter is now: {counter}")

def reset_counter():
    global counter
    counter = 0
    print("Counter has been reset")

def display_app_info():
    # Can read global variables without 'global' declaration
    print(f"App name: {app_name}")
    if DEBUG:
        print("Debug mode is enabled")

# Using global variables
print("Initial state:")
display_app_info()
print(f"Counter starts at: {counter}")

# Modifying global variables
increment_counter()
increment_counter()
reset_counter()
increment_counter()

# Common use case: Constants
PI = 3.14159
MAX_USERS = 100
DEFAULT_TIMEOUT = 30

def calculate_circle_area(radius):
    # Using a global constant (read-only)
    return PI * radius * radius

print(f"\nArea of circle with radius 5: {calculate_circle_area(5)}")
</code></pre>
            <p>
                Global variables have several important characteristics:
            </p>
            <ul>
                <li><strong>Accessibility:</strong> They can be accessed from any function in the module</li>
                <li><strong>Lifetime:</strong> They exist for the duration of the program</li>
                <li><strong>Modification:</strong> To modify them within a function, you must use the <code>global</code> keyword</li>
                <li><strong>Constants:</strong> They're often used for constants (by convention, named in ALL_CAPS)</li>
            </ul>
            <p>
                While global variables can be convenient, they should be used sparingly. Overusing them can make your code harder to understand and maintain, as it becomes difficult to track which functions are modifying which variables.
            </p>
        </section>

        <section class="nonlocal_variables">
            <h2>Nonlocal Variables: Bridging the Gap</h2>
            <p>
                In nested functions, you sometimes need to access or modify variables from the enclosing function. This is where the <code>nonlocal</code> keyword comes in, allowing inner functions to work with variables from their enclosing scope.
            </p>
            <p>
                Think of nonlocal variables as resources shared within a department but not company-wide. A team can access and modify them, but other departments can't see them.
            </p>
            <pre><code>
# File: nonlocal_variables.py
# Location: /python_projects/functions_tutorial/

def create_counter():
    """Create a counter function with its own persistent count."""
    count = 0  # This variable belongs to create_counter's scope
    
    def increment():
        nonlocal count  # Use the count variable from the enclosing scope
        count += 1
        return count
    
    return increment

# Create two independent counters
counter1 = create_counter()
counter2 = create_counter()

print(f"Counter 1 - First call: {counter1()}")   # 1
print(f"Counter 1 - Second call: {counter1()}")  # 2
print(f"Counter 1 - Third call: {counter1()}")   # 3

print(f"Counter 2 - First call: {counter2()}")   # 1
print(f"Counter 2 - Second call: {counter2()}")  # 2

print(f"Counter 1 - Fourth call: {counter1()}")  # 4

# Another example: A function that calculates running average
def create_averager():
    """Create a function that tracks a running average."""
    total = 0
    count = 0
    
    def averager(value):
        nonlocal total, count
        total += value
        count += 1
        return total / count
    
    return averager

avg = create_averager()
print(f"Running average - Add 10: {avg(10)}")     # 10.0
print(f"Running average - Add 20: {avg(20)}")     # 15.0
print(f"Running average - Add 30: {avg(30)}")     # 20.0
</code></pre>
            <p>
                The <code>nonlocal</code> keyword was introduced in Python 3 to address the need for nested functions to work with variables in their enclosing scope. It's particularly useful for:
            </p>
            <ul>
                <li><strong>Closures:</strong> Functions that "remember" the environment they were created in</li>
                <li><strong>State maintenance:</strong> Keeping track of information between function calls</li>
                <li><strong>Factory functions:</strong> Functions that create and return other functions with specific behaviors</li>
            </ul>
            <p>
                Without <code>nonlocal</code>, nested functions could read variables from enclosing scopes but couldn't modify them (they would create new local variables instead).
            </p>
        </section>

        <section class="scope_conflicts">
            <h2>Resolving Name Conflicts</h2>
            <p>
                When the same name is used in different scopes, Python follows the LEGB rule to decide which one to use. Sometimes, you may need to disambiguate or explicitly access variables from specific scopes.
            </p>
            <pre><code>
# File: name_conflicts.py
# Location: /python_projects/functions_tutorial/

# Define variables with the same name in different scopes
x = "global x"

def outer_function():
    x = "outer x"
    
    def inner_function():
        x = "inner x"
        print(f"Inner function - x: {x}")  # Uses local 'x'
    
    inner_function()
    print(f"Outer function - x: {x}")  # Uses enclosing 'x'

outer_function()
print(f"Global scope - x: {x}")  # Uses global 'x'

# Accessing the global variable when a local shadows it
def shadow_demo():
    x = "local x"
    print(f"Local x: {x}")
    print(f"Global x (accessed explicitly): {globals()['x']}")

shadow_demo()

# Modifying the global variable
def modify_global():
    global x
    old_x = x
    x = "modified global x"
    print(f"Changed global x from '{old_x}' to '{x}'")

modify_global()
print(f"Global scope - x is now: {x}")

# Creating a new global variable
def create_global_y():
    global y
    y = "new global y"
    print(f"Created new global variable y: {y}")

create_global_y()
print(f"Global scope - y: {y}")
</code></pre>
            <p>
                Here are some techniques for resolving scope conflicts:
            </p>
            <ul>
                <li><strong>Use the <code>global</code> keyword</strong> to explicitly work with a global variable</li>
                <li><strong>Use the <code>nonlocal</code> keyword</strong> to work with a variable from an enclosing function</li>
                <li><strong>Use the <code>globals()</code> function</strong> to access the global namespace as a dictionary</li>
                <li><strong>Use more distinctive variable names</strong> to avoid conflicts in the first place</li>
            </ul>
            <p>
                In general, it's best to avoid name conflicts by using clear, descriptive variable names and keeping functions focused on a single task. This reduces the need for global variables and makes your code easier to understand.
            </p>
        </section>

        <section class="namespace_lifecycle">
            <h2>Namespace and Variable Lifetime</h2>
            <p>
                Different namespaces have different lifetimes, which affects how long the variables within them exist:
            </p>
            <pre><code>
# File: variable_lifetime.py
# Location: /python_projects/functions_tutorial/

# Global variables exist for the duration of the program
global_var = "I'm a global variable"

def demonstrate_lifetime():
    # Local variables exist only during function execution
    local_var = "I'm a local variable"
    print(f"Inside function: {local_var}")
    
    # Nested function with its own local scope
    def nested():
        nested_var = "I'm a nested local variable"
        print(f"Inside nested function: {nested_var}")
        print(f"Can also access: {local_var} and {global_var}")
    
    nested()
    
    # nested_var doesn't exist here
    try:
        print(nested_var)
    except NameError as e:
        print(f"Error: {e}")
    
    return local_var  # Return the local variable

# Call the function
result = demonstrate_lifetime()
print(f"Function returned: {result}")

# local_var doesn't exist here
try:
    print(local_var)
except NameError as e:
    print(f"Error: {e}")

# global_var still exists
print(f"Global scope at end: {global_var}")

# Function parameters have local scope
def param_demo(param1, param2):
    print(f"Parameters (local variables): {param1}, {param2}")

param_demo("hello", 42)

# param1 and param2 don't exist here
try:
    print(param1)
except NameError as e:
    print(f"Error: {e}")
</code></pre>
            <p>
                The lifetime of different variables depends on their scope:
            </p>
            <ul>
                <li><strong>Global variables:</strong> Live for the entire duration of the program</li>
                <li><strong>Local variables:</strong> Live only while the function is executing</li>
                <li><strong>Enclosing variables:</strong> Live as long as the enclosing function's execution environment exists (might be longer than a single call if returned as a closure)</li>
            </ul>
            <p>
                Understanding variable lifetime is essential for proper resource management and avoiding memory leaks in larger applications.
            </p>
        </section>

        <section class="namespace_techniques">
            <h2>Advanced Scope and Namespace Techniques</h2>
            <p>
                Now that we understand the basics, let's explore some advanced techniques for working with scopes and namespaces:
            </p>

            <h3>Closures: Functions that Remember</h3>
            <pre><code>
# File: closures.py
# Location: /python_projects/functions_tutorial/

def create_multiplier(factor):
    """Create a function that multiplies its input by the given factor."""
    def multiplier(x):
        return x * factor  # 'factor' is from the enclosing scope
    
    return multiplier

# Create specialized multiplier functions
double = create_multiplier(2)
triple = create_multiplier(3)
half = create_multiplier(0.5)

# Use the functions
print(f"Double 7: {double(7)}")      # 14
print(f"Triple 7: {triple(7)}")      # 21
print(f"Half of 7: {half(7)}")       # 3.5

# The closures remember their own values of 'factor'
# even though the create_multiplier function has finished executing
print(f"Double 10: {double(10)}")    # 20
print(f"Triple 10: {triple(10)}")    # 30
</code></pre>
            <p>
                A closure is a function that remembers the values from its enclosing lexical scope, even when the function is executed outside that scope. They're like specialized tools that are configured once and then used many times.
            </p>

            <h3>Function Factories: Creating Customized Functions</h3>
            <pre><code>
# File: function_factories.py
# Location: /python_projects/functions_tutorial/

def create_power_function(exponent):
    """Create a function that raises its input to the given power."""
    def power_function(base):
        return base ** exponent
    
    return power_function

# Create specialized power functions
square = create_power_function(2)
cube = create_power_function(3)
sqrt = create_power_function(0.5)

# Use the functions
print(f"5 squared: {square(5)}")     # 25
print(f"5 cubed: {cube(5)}")         # 125
print(f"Square root of 25: {sqrt(25)}")  # 5.0

# Create a greeting function factory
def create_greeter(greeting):
    """Create a function that greets a person with the given greeting."""
    def greeter(name):
        return f"{greeting}, {name}!"
    
    return greeter

# Create specialized greeting functions
casual_greeter = create_greeter("Hey")
formal_greeter = create_greeter("Good day")
friendly_greeter = create_greeter("Hi there")

# Use the functions
print(casual_greeter("Alice"))    # Hey, Alice!
print(formal_greeter("Sir"))      # Good day, Sir!
print(friendly_greeter("Bob"))    # Hi there, Bob!
</code></pre>
            <p>
                Function factories are higher-order functions that create and return other functions with specific behaviors. They leverage closures to customize the behavior of the created functions. Think of them as specialized manufacturing processes that create custom tools.
            </p>

            <h3>Modules as Namespaces</h3>
            <p>
                In larger applications, you can use modules to create separate namespaces for related functionality:
            </p>
            <pre><code>
# File: math_utils.py
# Location: /python_projects/functions_tutorial/

# This would be in a separate file named math_utils.py
# Variables and functions defined here belong to the math_utils namespace

PI = 3.14159
E = 2.71828

def square(x):
    return x * x

def cube(x):
    return x * x * x

def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
</code></pre>
            <pre><code>
# File: string_utils.py
# Location: /python_projects/functions_tutorial/

# This would be in a separate file named string_utils.py
# Variables and functions defined here belong to the string_utils namespace

def reverse(s):
    return s[::-1]

def capitalize_words(s):
    return ' '.join(word.capitalize() for word in s.split())

def is_palindrome(s):
    s = s.lower().replace(' ', '')
    return s == s[::-1]
</code></pre>
            <pre><code>
# File: main.py
# Location: /python_projects/functions_tutorial/

# This would be the main script that imports the modules

# Import the modules
import math_utils
import string_utils

# Module name serves as a namespace
print(f"PI from math_utils: {math_utils.PI}")
print(f"5 squared: {math_utils.square(5)}")

# Same function names in different modules don't conflict
print(f"Reversed 'Hello': {string_utils.reverse('Hello')}")

# You can also import specific names into your current namespace
from math_utils import factorial
from string_utils import is_palindrome

# Now you can use these functions directly
print(f"5! = {factorial(5)}")
print(f"Is 'radar' a palindrome? {is_palindrome('radar')}")
print(f"Is 'hello' a palindrome? {is_palindrome('hello')}")

# But namespace conflicts can occur if you import everything
# from math_utils import *
# from string_utils import *
# Now if both modules defined a function with the same name,
# the one imported last would overwrite the first one
</code></pre>
            <p>
                Using modules as namespaces has several advantages:
            </p>
            <ul>
                <li>It helps organize code by grouping related functionality</li>
                <li>It prevents naming conflicts between unrelated parts of your application</li>
                <li>It makes your code more reusable and maintainable</li>
                <li>It allows for selective importing of only the needed functionality</li>
            </ul>
        </section>

        <section class="real_world_examples">
            <h2>Real-World Examples of Scope and Namespace Usage</h2>
            <p>
                Let's explore some real-world examples of how scope and namespaces are used in practical Python applications:
            </p>

            <h3>Data Processing Pipeline</h3>
            <pre><code>
# File: data_processing.py
# Location: /python_projects/functions_tutorial/

# Global configuration
INPUT_DIR = "./data/input"
OUTPUT_DIR = "./data/output"
DEFAULT_ENCODING = "utf-8"
MAX_BATCH_SIZE = 1000

def process_data(input_file, output_file=None, encoding=None):
    """Process data from input file and write results to output file."""
    # Use globals for defaults but allow overrides
    encoding = encoding or DEFAULT_ENCODING
    
    if output_file is None:
        # Generate output filename based on input filename
        import os
        input_name = os.path.basename(input_file)
        output_name = f"processed_{input_name}"
        output_file = os.path.join(OUTPUT_DIR, output_name)
    
    # Local function for specialized processing
    def parse_line(line):
        """Parse a single line of data."""
        # Local variables for processing
        parts = line.strip().split(',')
        result = {}
        
        # Process each part
        for i, part in enumerate(parts):
            key = f"field_{i+1}"
            result[key] = part.strip()
        
        return result
    
    # Simulate processing (in a real script, this would actually read/write files)
    print(f"Processing {input_file} (encoding: {encoding})")
    print(f"Output will be written to {output_file}")
    print(f"Using parse_line function to process each line")
    
    # Return a summary
    return {
        "input_file": input_file,
        "output_file": output_file,
        "encoding": encoding,
        "status": "completed"
    }

# Batch processing function
def batch_process_files(file_list):
    """Process multiple files in batches."""
    results = []
    
    for i in range(0, len(file_list), MAX_BATCH_SIZE):
        # Process files in batches
        batch = file_list[i:i+MAX_BATCH_SIZE]
        print(f"Processing batch of {len(batch)} files...")
        
        # Process each file in the batch
        for file in batch:
            result = process_data(file)
            results.append(result)
    
    return results

# Example usage
files_to_process = [
    "./data/input/file1.csv",
    "./data/input/file2.csv",
    "./data/input/file3.csv"
]

summary = batch_process_files(files_to_process)
print(f"Processed {len(summary)} files")
</code></pre>
            <p>
                In this data processing example:
            </p>
            <ul>
                <li>Global constants define configuration settings</li>
                <li>Function parameters allow for customization while providing defaults</li>
                <li>A local function (<code>parse_line</code>) handles specialized processing that's only needed within the main function</li>
                <li>Each function has its own local scope, isolating its variables</li>
            </ul>

            <h3>Web Application Request Handler</h3>
            <pre><code>
# File: web_handlers.py
# Location: /python_projects/functions_tutorial/

# Global application settings
API_VERSION = "v1"
AUTH_REQUIRED = True
MAX_REQUEST_SIZE = 1024 * 1024  # 1 MB

# Global connection pool (shared resource)
db_connection_pool = {"max_connections": 10, "timeout": 30}

def handle_request(request_data, auth_token=None):
    """Process a web API request."""
    # Check authentication if required
    if AUTH_REQUIRED and not auth_token:
        return {"error": "Authentication required", "status": 401}
    
    # Request validation logic
    def validate_request():
        """Validate the request data."""
        # Local validation rules
        required_fields = ["action", "payload"]
        
        # Check required fields
        for field in required_fields:
            if field not in request_data:
                return False, f"Missing required field: {field}"
        
        # Check request size
        import json
        request_size = len(json.dumps(request_data))
        if request_size > MAX_REQUEST_SIZE:
            return False, "Request too large"
        
        return True, None
    
    # Validate the request
    is_valid, error_message = validate_request()
    if not is_valid:
        return {"error": error_message, "status": 400}
    
    # Process the request based on action
    action = request_data["action"]
    payload = request_data["payload"]
    
    def get_database_connection():
        """Get a connection from the pool."""
        # Uses the global connection pool
        nonlocal auth_token  # Using enclosing variable
        print(f"Getting database connection with auth token: {auth_token}")
        # In a real app, this would actually get a connection
        return {"connection_id": 123, "status": "connected"}
    
    # Handle different actions
    if action == "get_user":
        # Get a database connection
        db = get_database_connection()
        
        # Simulate fetching user data
        user_id = payload.get("user_id")
        print(f"Fetching user {user_id} from database using connection {db['connection_id']}")
        
        # Return simulated result
        return {
            "status": 200,
            "data": {
                "user_id": user_id,
                "username": f"user_{user_id}",
                "email": f"user_{user_id}@example.com"
            }
        }
    
    elif action == "update_user":
        # Similar pattern for update operation
        db = get_database_connection()
        
        user_id = payload.get("user_id")
        user_data = payload.get("user_data", {})
        
        print(f"Updating user {user_id} with data: {user_data}")
        
        return {
            "status": 200,
            "data": {
                "user_id": user_id,
                "updated": True
            }
        }
    
    else:
        return {"error": f"Unknown action: {action}", "status": 400}

# Example usage
request1 = {
    "action": "get_user",
    "payload": {"user_id": 123}
}

response1 = handle_request(request1, auth_token="token123")
print(f"Response 1: {response1}")

request2 = {
    "action": "update_user",
    "payload": {
        "user_id": 123,
        "user_data": {"email": "new_email@example.com"}
    }
}

response2 = handle_request(request2, auth_token="token123")
print(f"Response 2: {response2}")
</code></pre>
            <p>
                In this web application example:
            </p>
            <ul>
                <li>Global constants define application-wide settings</li>
                <li>A global connection pool is shared across requests</li>
                <li>Nested functions handle specific subtasks with access to the parent function's variables</li>
                <li>The <code>nonlocal</code> keyword is used to access variables from the enclosing scope</li>
                <li>Different request types are handled within the same function but with different logic</li>
            </ul>
        </section>

        <section class="best_practices">
            <h2>Best Practices for Scope and Namespace Management</h2>
            <p>
                Based on our exploration of scopes and namespaces, here are some best practices to follow:
            </p>

            <h3>Use Local Variables When Possible</h3>
            <pre><code>
# File: prefer_local.py
# Location: /python_projects/functions_tutorial/

# Bad practice: Using global variables unnecessarily
counter = 0

def increment_bad():
    global counter
    counter += 1
    return counter

# Better practice: Using parameters and return values
def increment_good(value):
    return value + 1

# Usage comparison
print(f"Bad practice - First call: {increment_bad()}")
print(f"Bad practice - Second call: {increment_bad()}")

# Using return values and local state instead
count = 0
count = increment_good(count)
print(f"Good practice - First call: {count}")
count = increment_good(count)
print(f"Good practice - Second call: {count}")
</code></pre>
            <p>
                Local variables are clearer, safer, and less prone to unexpected side effects. Prefer them when possible, and use function parameters and return values to pass data in and out of functions.
            </p>

            <h3>Use Global Variables Sparingly and Wisely</h3>
            <pre><code>
# File: wise_globals.py
# Location: /python_projects/functions_tutorial/

# Appropriate uses of global variables:

# 1. Constants (values that don't change)
PI = 3.14159
MAX_ATTEMPTS = 3
DEFAULT_TIMEOUT = 30

# 2. Application-wide configuration
DEBUG_MODE = True
LOG_LEVEL = "INFO"
BASE_URL = "https://api.example.com"

# 3. Shared resources that need to be accessed by multiple functions
cache = {}  # A simple cache shared by multiple functions

def get_data(key):
    """Get data from the cache or compute it if not found."""
    if key in cache:
        print(f"Cache hit for {key}")
        return cache[key]
    
    # Simulate expensive computation
    print(f"Computing value for {key}")
    value = key * 2  # In a real app, this would be a complex calculation
    
    # Store in cache for future use
    cache[key] = value
    return value

# Example usage
print(get_data(5))      # Computes value
print(get_data(10))     # Computes value
print(get_data(5))      # Uses cached value
</code></pre>
            <p>
                Global variables should be used sparingly and for appropriate purposes:
            </p>
            <ul>
                <li>Constants that don't change</li>
                <li>Application-wide configuration settings</li>
                <li>Shared resources that need to be accessed by multiple functions</li>
                <li>Objects that need to persist between function calls</li>
            </ul>

            <h3>Use Modules and Packages for Organization</h3>
            <p>
                For larger applications, organize code into modules and packages with well-defined interfaces:
            </p>
            <pre><code>
# Directory structure example:
# my_app/
#   __init__.py
#   config.py         # Configuration settings
#   database/
#     __init__.py
#     models.py       # Database models
#     connection.py   # Database connection code
#   api/
#     __init__.py
#     routes.py       # API route handlers
#     auth.py         # Authentication code
#   utils/
#     __init__.py
#     formatting.py   # Text formatting utilities
#     validation.py   # Data validation utilities

# File: my_app/config.py
# Global configuration accessible to all modules
DEBUG = True
API_VERSION = "v1"
DATABASE_URI = "postgresql://user:pass@localhost/dbname"

# File: my_app/database/connection.py
# Import from another module
from my_app.config import DATABASE_URI

def get_connection():
    """Get a database connection."""
    print(f"Connecting to: {DATABASE_URI}")
    # Implementation details...
    return {"connected": True}

# File: my_app/api/routes.py
# Import from other modules
from my_app.database.connection import get_connection
from my_app.utils.validation import validate_user_data

def handle_user_request(user_data):
    """Handle a user-related API request."""
    # Validate the data
    is_valid, errors = validate_user_data(user_data)
    if not is_valid:
        return {"errors": errors}
    
    # Get a database connection
    conn = get_connection()
    
    # Process the request
    # Implementation details...
    return {"success": True}
</code></pre>
            <p>
                Using modules and packages offers several benefits:
            </p>
            <ul>
                <li>Keeps related code together</li>
                <li>Creates natural namespaces that prevent naming conflicts</li>
                <li>Makes code more maintainable and reusable</li>
                <li>Provides clear interfaces between different parts of your application</li>
            </ul>

            <h3>Be Explicit About Scope</h3>
            <pre><code>
# File: explicit_scope.py
# Location: /python_projects/functions_tutorial/

# Global variable
total = 0

def update_total(value):
    """Update the global total."""
    # Explicitly declare that we're using the global variable
    global total
    total += value
    return total

def create_counter():
    """Create a counter with its own internal state."""
    # Local variable that will be shared with the inner function
    count = 0
    
    def increment(amount=1):
        # Explicitly declare that we're using the enclosing variable
        nonlocal count
        count += amount
        return count
    
    return increment

# Example usage
print(f"Initial total: {total}")
print(f"After adding 5: {update_total(5)}")
print(f"After adding 10: {update_total(10)}")

counter = create_counter()
print(f"Counter - first increment: {counter()}")
print(f"Counter - increment by 3: {counter(3)}")
print(f"Counter - another increment: {counter()}")
</code></pre>
            <p>
                Being explicit about which scope you're using makes your code clearer and less prone to bugs. Always use <code>global</code> when modifying global variables and <code>nonlocal</code> when modifying variables from enclosing scopes.
            </p>
        </section>

        <section class="common_pitfalls">
            <h2>Common Pitfalls and How to Avoid Them</h2>
            <p>
                Let's look at some common mistakes and how to avoid them:
            </p>

            <h3>Unintended Global Variables</h3>
            <pre><code>
# File: unintended_globals.py
# Location: /python_projects/functions_tutorial/

# Problem: Creating unintended global variables
def calculate_total(items):
    # This creates a global variable (unintended)
    total = 0
    
    for item in items:
        # This modifies the global variable (also unintended)
        total += item
    
    # The variable isn't defined in the function scope yet,
    # so it becomes global
    return total

def better_calculate_total(items):
    # Proper local variable initialization
    total = 0
    
    for item in items:
        # Modifies the local variable
        total += item
    
    return total

# This looks like it works, but it's creating a global variable
result1 = calculate_total([1, 2, 3, 4, 5])
print(f"Result 1: {result1}")  # 15

# The global 'total' now exists and has a value
print(f"Global total exists: {total}")  # 15

# This is the correct approach with a proper local variable
result2 = better_calculate_total([6, 7, 8, 9, 10])
print(f"Result 2: {result2}")  # 40

# The 'total' variable hasn't changed because better_calculate_total
# uses a local variable, not the global one
print(f"Global total is still: {total}")  # 15
</code></pre>
            <p>
                To avoid creating unintended global variables:
            </p>
            <ul>
                <li>Always initialize variables at the top of your function</li>
                <li>Use a linter or static analysis tool that warns about undefined variables</li>
                <li>Enable Python's "Python - Warn about undefined variables" setting in your editor</li>
            </ul>

            <h3>Modifying Mutable Objects Without Knowing It</h3>
            <pre><code>
# File: mutable_objects.py
# Location: /python_projects/functions_tutorial/

# Global mutable object
config = {
    "debug": False,
    "timeout": 30,
    "retries": 3
}

def update_config_bad(timeout):
    # This modifies the global config without using 'global'
    config["timeout"] = timeout  # This works but is unclear
    return config

def update_config_good(timeout):
    # Explicitly state that we're using the global config
    global config
    config["timeout"] = timeout
    return config

def create_user(name, roles=None):
    # Common issue with mutable default arguments
    if roles is None:
        roles = []
    
    user = {
        "name": name,
        "roles": roles
    }
    
    return user

# Using update_config_bad
print(f"Original config: {config}")
update_config_bad(60)
print(f"After update_config_bad: {config}")  # The global config has changed!

# Using update_config_good (clearer intention)
update_config_good(120)
print(f"After update_config_good: {config}")

# Creating users with mutable defaults
user1 = create_user("Alice", ["admin"])
user2 = create_user("Bob")  # Gets an empty roles list
user3 = create_user("Charlie")  # Gets another empty roles list

# Add a role for Bob
user2["roles"].append("editor")

# Each user has their own separate roles list
print(f"User 1: {user1}")
print(f"User 2: {user2}")
print(f"User 3: {user3}")
</code></pre>
            <p>
                When working with mutable objects:
            </p>
            <ul>
                <li>Be explicit about using global mutable objects with the <code>global</code> keyword</li>
                <li>Use the <code>None</code> default + create inside pattern for mutable default arguments</li>
                <li>Consider making a copy of mutable objects when passing them around to prevent unintended modifications</li>
            </ul>

            <h3>Relying Too Much on Closures</h3>
            <pre><code>
# File: closure_overuse.py
# Location: /python_projects/functions_tutorial/

# Problem: Complex closures can be hard to understand
def create_complex_processor(config):
    data_format = config.get("format", "json")
    error_handling = config.get("error_handling", "strict")
    max_items = config.get("max_items", 100)
    
    def process_data(data):
        nonlocal max_items
        
        if len(data) > max_items:
            if error_handling == "strict":
                raise ValueError(f"Too many items: {len(data)} > {max_items}")
            else:
                # Truncate the data
                data = data[:max_items]
        
        # Process based on format
        if data_format == "json":
            # JSON processing logic
            return {"format": "json", "items": len(data)}
        elif data_format == "xml":
            # XML processing logic
            return {"format": "xml", "items": len(data)}
        else:
            # Unknown format
            if error_handling == "strict":
                raise ValueError(f"Unknown format: {data_format}")
            else:
                return {"format": "unknown", "items": 0}
    
    return process_data

# Better approach: Use a class
class DataProcessor:
    def __init__(self, config):
        self.data_format = config.get("format", "json")
        self.error_handling = config.get("error_handling", "strict")
        self.max_items = config.get("max_items", 100)
    
    def process_data(self, data):
        if len(data) > self.max_items:
            if self.error_handling == "strict":
                raise ValueError(f"Too many items: {len(data)} > {self.max_items}")
            else:
                # Truncate the data
                data = data[:self.max_items]
        
        # Process based on format
        if self.data_format == "json":
            # JSON processing logic
            return {"format": "json", "items": len(data)}
        elif self.data_format == "xml":
            # XML processing logic
            return {"format": "xml", "items": len(data)}
        else:
            # Unknown format
            if self.error_handling == "strict":
                raise ValueError(f"Unknown format: {self.data_format}")
            else:
                return {"format": "unknown", "items": 0}

# Using the closure approach
processor1 = create_complex_processor({"format": "json", "max_items": 5})
try:
    result1 = processor1([1, 2, 3, 4, 5, 6, 7])  # Too many items
except ValueError as e:
    print(f"Error with processor1: {e}")

# Using the class approach (more readable for complex cases)
processor2 = DataProcessor({"format": "json", "error_handling": "ignore", "max_items": 5})
result2 = processor2.process_data([1, 2, 3, 4, 5, 6, 7])  # Will truncate
print(f"Result with processor2: {result2}")
</code></pre>
            <p>
                While closures are powerful, they can become complex and hard to maintain. For more complex scenarios, consider using classes instead, which provide:
            </p>
            <ul>
                <li>Clearer structure and organization</li>
                <li>Better support for multiple methods and attributes</li>
                <li>More familiar patterns for other developers</li>
                <li>Inheritance and other object-oriented features when needed</li>
            </ul>
        </section>

        <section class="debugging_scope">
            <h2>Debugging Scope Issues</h2>
            <p>
                Scope-related issues can be tricky to debug. Here are some techniques and tools to help:
            </p>

            <h3>Using the globals() and locals() Functions</h3>
            <pre><code>
# File: debug_scope.py
# Location: /python_projects/functions_tutorial/

x = 10
y = "global"

def inspect_scopes(param):
    z = "local"
    
    print("Global namespace contents:")
    for name, value in sorted(globals().items()):
        if not name.startswith("__"):  # Skip built-in names
            print(f"  {name}: {value}")
    
    print("\nLocal namespace contents:")
    for name, value in sorted(locals().items()):
        print(f"  {name}: {value}")

inspect_scopes("argument value")

# Nested scope inspection
def outer_function(outer_param):
    outer_var = "outer value"
    
    def inner_function(inner_param):
        inner_var = "inner value"
        
        print("\nInner function locals:")
        for name, value in sorted(locals().items()):
            print(f"  {name}: {value}")
        
        # Access variables from different scopes
        print("\nAccessing variables from different scopes:")
        print(f"  inner_var (local): {inner_var}")
        print(f"  inner_param (local): {inner_param}")
        print(f"  outer_var (enclosing): {outer_var}")
        print(f"  outer_param (enclosing): {outer_param}")
        print(f"  x (global): {x}")
        print(f"  y (global): {y}")
    
    inner_function("inner argument")

outer_function("outer argument")
</code></pre>
            <p>
                Python provides the <code>globals()</code> and <code>locals()</code> functions that return dictionaries containing the current global and local namespaces, respectively. These can be invaluable for debugging scope issues.
            </p>

            <h3>Using the dir() Function</h3>
            <pre><code>
# File: dir_function.py
# Location: /python_projects/functions_tutorial/

def explore_namespace():
    a = 1
    b = "hello"
    c = [1, 2, 3]
    
    # Print names in the current namespace
    names = dir()
    print("Names in local namespace:")
    for name in names:
        if not name.startswith("__"):  # Skip built-in names
            print(f"  {name}")

explore_namespace()

# Exploring module namespaces
import math
import os

print("\nNames in math module:")
math_names = [name for name in dir(math) if not name.startswith("__")][:10]  # First 10 names
for name in math_names:
    print(f"  {name}")

print("\nNames in os module:")
os_names = [name for name in dir(os) if not name.startswith("__")][:10]  # First 10 names
for name in os_names:
    print(f"  {name}")
</code></pre>
            <p>
                The <code>dir()</code> function returns a list of names in the current namespace or a list of attributes for the specified object. It's useful for exploring what's available in different namespaces.
            </p>

            <h3>Print Debugging with Scope Information</h3>
            <pre><code>
# File: print_debugging.py
# Location: /python_projects/functions_tutorial/

count = 0

def process_item(item):
    global count
    local_value = item * 2
    count += 1
    
    print(f"[PROCESS_ITEM] Processing item: {item}")
    print(f"[PROCESS_ITEM] Local value: {local_value}")
    print(f"[PROCESS_ITEM] Global count: {count}")
    
    return local_value

def process_list(items):
    results = []
    
    print(f"[PROCESS_LIST] Starting to process {len(items)} items")
    print(f"[PROCESS_LIST] Global count before: {count}")
    
    for index, item in enumerate(items):
        print(f"[PROCESS_LIST] Processing item {index+1}/{len(items)}")
        result = process_item(item)
        results.append(result)
    
    print(f"[PROCESS_LIST] Global count after: {count}")
    print(f"[PROCESS_LIST] Results: {results}")
    
    return results

# Example usage with print debugging
data = [5, 10, 15]
process_list(data)
</code></pre>
            <p>
                When debugging scope issues, it can be helpful to add print statements that include information about which function they're coming from and the values of variables in different scopes.
            </p>
        </section>

        <section class="legb_advanced">
            <h2>Advanced LEGB Rule and Scope Resolution</h2>
            <p>
                Let's dive deeper into Python's LEGB rule and how it resolves names in complex situations:
            </p>
            <pre><code>
# File: legb_advanced.py
# Location: /python_projects/functions_tutorial/

# Built-in scope
# (print, len, dict, etc.)

# Global scope
x = "global x"
y = "global y"
z = "global z"

def outer():
    # Enclosing scope for inner functions
    x = "outer x"  # Shadows global x
    w = "outer w"  # Not in global scope
    
    def middle():
        # Enclosing scope for inner, local scope for outer
        y = "middle y"  # Shadows global y
        w = "middle w"  # Shadows outer w
        
        def inner():
            # Local scope
            z = "inner z"  # Shadows global z
            
            # Accessing variables from different scopes
            print(f"inner: z = {z}")  # Local
            # print(f"inner: w = {w}")  # Enclosing (middle)
            # print(f"inner: x = {x}")  # Enclosing (outer)
            # print(f"inner: y = {y}")  # Enclosing (middle)
        
        inner()
        
        # Accessing variables from different scopes
        print(f"middle: y = {y}")  # Local
        print(f"middle: w = {w}")  # Local
        print(f"middle: x = {x}")  # Enclosing (outer)
        print(f"middle: z = {z}")  # Global
    
    middle()
    
    # Accessing variables from different scopes
    print(f"outer: x = {x}")  # Local
    print(f"outer: w = {w}")  # Local
    print(f"outer: y = {y}")  # Global
    print(f"outer: z = {z}")  # Global

# Call the outer function
print(f"global: x = {x}")
print(f"global: y = {y}")
print(f"global: z = {z}")
print("\nCalling functions with nested scopes:")
outer()

# When variables of the same name exist in multiple scopes,
# Python uses the LEGB rule to determine which one to use
</code></pre>
            <p>
                The LEGB rule becomes particularly important with nested functions and shadowed variables. Python always searches for a name in the most specific scope first, gradually moving outward until it finds the name or reaches the built-in scope.
            </p>
            <p>
                When a variable is "shadowed" (a variable with the same name exists in a more specific scope), Python uses the most specific one according to the LEGB rule.
            </p>
        </section>

        <section class="conclusion">
            <h2>Conclusion: Mastering Scope and Namespaces</h2>
            <p>
                Understanding variable scope and namespaces is crucial for writing robust, maintainable Python code. Let's recap what we've learned:
            </p>
            <ul>
                <li><strong>Namespaces</strong> are containers that hold mappings of names to objects, helping organize your code and prevent naming conflicts.</li>
                <li><strong>Scope</strong> determines where a variable can be accessed from, following the LEGB rule (Local, Enclosing, Global, Built-in).</li>
                <li><strong>Local variables</strong> are only accessible within their function and have the shortest lifetime.</li>
                <li><strong>Global variables</strong> are accessible throughout a module and have the longest lifetime.</li>
                <li><strong>Enclosing variables</strong> are accessible to nested functions and can be modified using the <code>nonlocal</code> keyword.</li>
                <li><strong>The <code>global</code> and <code>nonlocal</code> keywords</strong> let you explicitly specify which scope's variable you want to modify.</li>
                <li><strong>Modules</strong> create separate namespaces, helping organize code and prevent naming conflicts in larger applications.</li>
                <li><strong>Best practices</strong> include preferring local variables, using global variables sparingly, being explicit about scope, and organizing code into modules.</li>
            </ul>
            <p>
                By mastering these concepts and following the best practices we've discussed, you'll be able to write cleaner, more maintainable Python code that's less prone to bugs and easier for others to understand.
            </p>
            <p>
                Remember, good code organization is like a well-designed building—each room has its purpose, resources are available where they're needed, and everyone knows where to find what they're looking for.
            </p>
        </section>

        <section class="practice_exercises">
            <h2>Practice Exercises</h2>
            <p>
                To solidify your understanding of variable scope and namespaces, try these exercises:
            </p>
            <ol>
                <li>Create a function that increments a counter and returns the new value, without using global variables.</li>
                <li>Write a function that generates a sequence of unique IDs, using closure to maintain state between calls.</li>
                <li>Implement a simple caching system that remembers the results of expensive function calls, using a global cache dictionary.</li>
                <li>Create a module that provides utilities for working with dates and times, with appropriate namespacing.</li>
                <li>Write a function with nested functions that demonstrates all levels of the LEGB rule.</li>
            </ol>
            <p>
                These exercises will help you practice the concepts we've covered and develop a deeper understanding of how scope and namespaces work in Python.
            </p>
        </section>

        <section class="further_reading">
            <h2>Further Reading</h2>
            <ul>
                <li><a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" target="_blank">Python Documentation: Scopes and Namespaces</a></li>
                <li><a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" target="_blank">Python Documentation: Resolution of Names</a></li>
                <li><a href="https://realpython.com/python-scope-legb-rule/" target="_blank">Real Python: Python Scope & the LEGB Rule</a></li>
                <li>Book: "Fluent Python" by Luciano Ramalho (Chapter on Functions)</li>
                <li>Book: "Python Cookbook" by David Beazley and Brian K. Jones (Chapter 7: Functions)</li>
                <li>Book: "Effective Python" by Brett Slatkin (Item 20: Use None and Docstrings to Specify Dynamic Default Arguments)</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
