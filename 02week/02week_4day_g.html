<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Functions: Higher-Order Functions</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Functions: Higher-Order Functions</h1>
        <h2>Mastering Functions that Work with Other Functions</h2>
    </header>

    <main>
        <section class="introduction">
            <h2>What Are Higher-Order Functions?</h2>
            <p>
                In the kitchen, we have tools designed to work with other toolsâ€”think of a knife sharpener that takes your knife and makes it better, or a food processor with different attachments for various purposes. Higher-order functions are similar: they are functions that work with other functions, either by taking functions as arguments or by returning functions as results (or both).
            </p>
            <p>
                This concept is a cornerstone of functional programming, a programming paradigm that treats functions as first-class citizens, meaning functions can be assigned to variables, passed as arguments, and returned from other functions, just like any other data type.
            </p>
            <p>
                Python supports functional programming concepts, making higher-order functions a powerful tool in a Python developer's toolkit. They enable elegant, concise solutions to complex problems, promote code reuse, and allow for greater modularity and expressiveness in your code.
            </p>
        </section>

        <section class="first_class_citizens">
            <h2>Functions as First-Class Citizens</h2>
            <p>
                Before diving into higher-order functions, let's understand what it means for functions to be "first-class citizens" in Python. This concept is fundamental to working with higher-order functions.
            </p>

            <h3>Assigning Functions to Variables</h3>
            <pre><code>
# File: functions_as_variables.py
# Location: /python_projects/functions_tutorial/

def greet(name):
    """Return a greeting message."""
    return f"Hello, {name}!"

def farewell(name):
    """Return a farewell message."""
    return f"Goodbye, {name}. See you soon!"

# Assign functions to variables
morning_greeting = greet
evening_farewell = farewell

# Use the functions through the variables
print(morning_greeting("Alice"))  # Output: Hello, Alice!
print(evening_farewell("Bob"))    # Output: Goodbye, Bob. See you soon!

# We can even reassign them
morning_greeting = farewell
print(morning_greeting("Charlie"))  # Output: Goodbye, Charlie. See you soon!

# Functions can be stored in data structures
message_functions = [greet, farewell]
for func in message_functions:
    print(func("Dave"))

# Functions can be stored in dictionaries
function_dict = {
    "welcome": greet,
    "bye": farewell
}

# Access and call a function from a dictionary
print(function_dict["welcome"]("Eve"))  # Output: Hello, Eve!
</code></pre>
            <p>
                In this example, we can see that functions in Python can be:
            </p>
            <ul>
                <li>Assigned to variables</li>
                <li>Reassigned to different variables</li>
                <li>Stored in lists, dictionaries, and other data structures</li>
                <li>Called through these variables and data structures</li>
            </ul>
            <p>
                This behavior is what makes functions "first-class citizens" in Python, and it's the foundation for working with higher-order functions.
            </p>

            <h3>Function Identity and Type</h3>
            <pre><code>
# File: function_identity.py
# Location: /python_projects/functions_tutorial/

def square(x):
    """Return the square of a number."""
    return x * x

# Functions have identity - they are objects with unique IDs
print(f"Function ID: {id(square)}")
print(f"Function type: {type(square)}")

# We can check if variables refer to the same function
func1 = square
func2 = square
func3 = lambda x: x * x  # Different function with same behavior

print(f"func1 and func2 are the same object: {func1 is func2}")  # True
print(f"func1 and func3 are the same object: {func1 is func3}")  # False

# Functions have attributes
print(f"Function name: {square.__name__}")
print(f"Function docstring: {square.__doc__}")
</code></pre>
            <p>
                Functions in Python are objects with their own identity, type, and attributes. This is important to understand because it means we can manipulate functions just like any other object in Python.
            </p>
        </section>

        <section class="functions_as_arguments">
            <h2>Functions That Take Functions as Arguments</h2>
            <p>
                The first type of higher-order function is one that takes one or more functions as arguments. This allows for powerful patterns where the behavior of a function can be customized by passing different function arguments.
            </p>

            <h3>Basic Examples</h3>
            <pre><code>
# File: functions_as_arguments.py
# Location: /python_projects/functions_tutorial/

def apply_operation(func, x, y):
    """Apply the given function to the arguments."""
    return func(x, y)

def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

def power(a, b):
    return a ** b

# Use apply_operation with different functions
print(apply_operation(add, 5, 3))       # Output: 8
print(apply_operation(multiply, 5, 3))  # Output: 15
print(apply_operation(power, 5, 3))     # Output: 125

# We can also use lambda functions
print(apply_operation(lambda a, b: a - b, 5, 3))  # Output: 2

# A more practical example: custom sorting
names = ["Alice", "Bob", "charlie", "David", "eve"]

# Sort by name length
sorted_by_length = sorted(names, key=len)
print(f"Sorted by length: {sorted_by_length}")

# Sort case-insensitive
sorted_case_insensitive = sorted(names, key=str.lower)
print(f"Sorted case-insensitive: {sorted_case_insensitive}")

# Custom key function for sorting
def get_second_letter(s):
    """Return the second letter of a string, or 'z' if the string is too short."""
    return s[1].lower() if len(s) > 1 else 'z'

sorted_by_second_letter = sorted(names, key=get_second_letter)
print(f"Sorted by second letter: {sorted_by_second_letter}")
</code></pre>
            <p>
                In these examples, <code>apply_operation</code> is a higher-order function that takes another function as its first argument. The <code>sorted</code> function is also a higher-order function that takes a <code>key</code> function to determine how elements should be compared for sorting.
            </p>

            <h3>The Map, Filter, and Reduce Pattern</h3>
            <pre><code>
# File: map_filter_reduce.py
# Location: /python_projects/functions_tutorial/

from functools import reduce

# Example data: a list of numbers
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Map: Apply a function to each item in a sequence
squared = list(map(lambda x: x ** 2, numbers))
print(f"Squared numbers: {squared}")

# We can use regular functions too
def cube(x):
    return x ** 3

cubed = list(map(cube, numbers))
print(f"Cubed numbers: {cubed}")

# Filter: Select items from a sequence based on a condition
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(f"Even numbers: {even_numbers}")

# Regular function with filter
def is_prime(n):
    """Check if a number is prime."""
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

prime_numbers = list(filter(is_prime, numbers))
print(f"Prime numbers: {prime_numbers}")

# Reduce: Apply a function cumulatively to items in a sequence
sum_of_numbers = reduce(lambda x, y: x + y, numbers)
print(f"Sum of numbers: {sum_of_numbers}")

# Regular function with reduce
def multiply(x, y):
    return x * y

product_of_numbers = reduce(multiply, numbers)
print(f"Product of numbers: {product_of_numbers}")

# Combining map, filter, and reduce
# Calculate the sum of squares of even numbers
sum_of_squares_of_evens = reduce(
    lambda x, y: x + y,
    map(
        lambda x: x ** 2,
        filter(lambda x: x % 2 == 0, numbers)
    )
)
print(f"Sum of squares of even numbers: {sum_of_squares_of_evens}")

# Equivalent using list comprehension (more Pythonic)
sum_of_squares_of_evens_comprehension = sum(x ** 2 for x in numbers if x % 2 == 0)
print(f"Sum of squares of even numbers (comprehension): {sum_of_squares_of_evens_comprehension}")
</code></pre>
            <p>
                Map, filter, and reduce are three fundamental higher-order functions commonly used in functional programming:
            </p>
            <ul>
                <li><strong>map(function, iterable, ...)</strong>: Applies the function to each item in the iterable and returns an iterator of the results.</li>
                <li><strong>filter(function, iterable)</strong>: Applies the function to each item in the iterable and returns an iterator of the items for which the function returns True.</li>
                <li><strong>reduce(function, iterable[, initializer])</strong>: Applies the function cumulatively to the items of the iterable, from left to right, to reduce the iterable to a single value.</li>
            </ul>
            <p>
                These functions are powerful tools for data processing and manipulation, and they're a core part of the functional programming paradigm. While Python also provides list comprehensions and generator expressions as often more readable alternatives, it's important to understand these higher-order functions.
            </p>

            <h3>Custom Higher-Order Functions</h3>
            <pre><code>
# File: custom_higher_order.py
# Location: /python_projects/functions_tutorial/

def repeat(func, n):
    """Call the given function n times."""
    def wrapper(*args, **kwargs):
        for _ in range(n):
            func(*args, **kwargs)
    return wrapper

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")  # Prints "Hello, Alice!" three times

def timed(func):
    """Measure the execution time of a function."""
    import time
    
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.6f} seconds to run")
        return result
    
    return wrapper

@timed
def slow_function():
    """A deliberately slow function for testing."""
    import time
    time.sleep(1)  # Sleep for 1 second
    return "Done!"

result = slow_function()
print(result)

def validate_inputs(**validators):
    """
    Create a decorator that validates function inputs.
    
    Args:
        validators: A dictionary mapping parameter names to validation functions
    
    Returns:
        A decorator function
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            # Get function signature to map positional args to parameter names
            import inspect
            sig = inspect.signature(func)
            parameters = list(sig.parameters.keys())
            
            # Combine positional and keyword arguments
            arg_dict = {**dict(zip(parameters, args)), **kwargs}
            
            # Validate arguments
            for param_name, validator in validators.items():
                if param_name in arg_dict:
                    if not validator(arg_dict[param_name]):
                        raise ValueError(f"Invalid value for {param_name}: {arg_dict[param_name]}")
            
            # Call the function if all validations pass
            return func(*args, **kwargs)
        
        return wrapper
    
    return decorator

# Define validation functions
def is_positive(n):
    return n > 0

def is_string(s):
    return isinstance(s, str)

def is_in_range(min_val, max_val):
    return lambda x: min_val <= x <= max_val

# Apply the validators to a function
@validate_inputs(
    age=is_positive,
    name=is_string,
    score=is_in_range(0, 100)
)
def register_student(name, age, score):
    print(f"Registered student: {name}, {age} years old, score: {score}")
    return {"name": name, "age": age, "score": score}

# Test with valid inputs
register_student("Alice", 20, 85)

# Test with invalid inputs (would raise ValueError)
try:
    register_student("Bob", -5, 110)
except ValueError as e:
    print(f"Error: {e}")
</code></pre>
            <p>
                These examples demonstrate how to create your own higher-order functions in Python. The <code>repeat</code> and <code>timed</code> functions are simple decorators (a type of higher-order function), while <code>validate_inputs</code> is a more complex decorator factory that returns a decorator customized by the validators passed to it.
            </p>
            <p>
                Decorators are a common use case for higher-order functions in Python, allowing you to modify or enhance the behavior of functions without changing their core implementation.
            </p>
        </section>

        <section class="functions_that_return_functions">
            <h2>Functions That Return Functions</h2>
            <p>
                The second type of higher-order function is one that returns another function. This pattern is used for function factories, currying, and creating closures.
            </p>

            <h3>Function Factories</h3>
            <pre><code>
# File: function_factories.py
# Location: /python_projects/functions_tutorial/

def create_multiplier(factor):
    """Create and return a function that multiplies its argument by factor."""
    def multiplier(x):
        return x * factor
    return multiplier

# Create specific multiplier functions
double = create_multiplier(2)
triple = create_multiplier(3)
half = create_multiplier(0.5)

# Use the generated functions
print(f"Double 5: {double(5)}")       # Output: 10
print(f"Triple 5: {triple(5)}")       # Output: 15
print(f"Half of 5: {half(5)}")        # Output: 2.5

# More complex function factory
def create_power_function(exponent):
    """Create and return a function that raises its argument to the given power."""
    def power_function(base):
        return base ** exponent
    return power_function

# Create specific power functions
square = create_power_function(2)
cube = create_power_function(3)
sqrt = create_power_function(0.5)

# Use the generated functions
print(f"5 squared: {square(5)}")      # Output: 25
print(f"5 cubed: {cube(5)}")          # Output: 125
print(f"Square root of 25: {sqrt(25)}")  # Output: 5.0

# Function factory for formatting text
def create_formatter(prefix, suffix):
    """Create and return a function that adds prefix and suffix to text."""
    def format_text(text):
        return f"{prefix}{text}{suffix}"
    return format_text

# Create specific formatter functions
bold = create_formatter("<b>", "</b>")
italic = create_formatter("<i>", "</i>")
heading = create_formatter("<h1>", "</h1>")

# Use the generated functions
print(bold("Important text"))      # Output: <b>Important text</b>
print(italic("Emphasized text"))   # Output: <i>Emphasized text</i>
print(heading("Main Title"))       # Output: <h1>Main Title</h1>
</code></pre>
            <p>
                Function factories are higher-order functions that create and return specialized functions based on the parameters passed to them. They're useful for creating families of related functions without having to define each one separately.
            </p>
            <p>
                Think of function factories like cookie cuttersâ€”they produce functions with a consistent structure, but each one has a unique behavior based on the parameters used to create it.
            </p>

            <h3>Closures: Functions That Remember</h3>
            <pre><code>
# File: closures.py
# Location: /python_projects/functions_tutorial/

def create_counter(start=0, step=1):
    """
    Create a counter function that remembers its state between calls.
    
    Args:
        start: The initial value of the counter
        step: The amount to increment by on each call
        
    Returns:
        A function that returns the next value each time it's called
    """
    count = start
    
    def counter():
        nonlocal count
        current = count
        count += step
        return current
    
    return counter

# Create counters with different configurations
counter1 = create_counter()  # Starts at 0, increments by 1
counter2 = create_counter(10, 2)  # Starts at 10, increments by 2

# Use the counters
print(counter1())  # 0
print(counter1())  # 1
print(counter1())  # 2

print(counter2())  # 10
print(counter2())  # 12
print(counter2())  # 14

# The counters maintain independent state
print(counter1())  # 3 (continues from previous calls)
print(counter2())  # 16 (continues from previous calls)

# A more practical example: loggers with different verbosity levels
def create_logger(name, min_level):
    """
    Create a logger function with a specific name and minimum log level.
    
    Args:
        name: The name of the logger
        min_level: The minimum level to log (0=DEBUG, 1=INFO, 2=WARNING, 3=ERROR)
        
    Returns:
        A function that logs messages if they meet the minimum level
    """
    levels = ["DEBUG", "INFO", "WARNING", "ERROR"]
    
    def logger(level, message):
        if level >= min_level:
            print(f"[{levels[level]}] {name}: {message}")
    
    return logger

# Create different loggers
debug_logger = create_logger("DevModule", 0)  # Logs everything
production_logger = create_logger("ProdModule", 2)  # Logs only warnings and errors

# Use the loggers
debug_logger(0, "Initializing module")  # Will be logged
debug_logger(1, "Module ready")         # Will be logged
debug_logger(2, "Resource low")         # Will be logged

production_logger(0, "Initializing module")  # Won't be logged
production_logger(1, "Module ready")         # Won't be logged
production_logger(2, "Resource low")         # Will be logged
production_logger(3, "Critical error")       # Will be logged

# A memoization example: function that remembers previous results
def memoize(func):
    """
    Create a function that caches the results of previous calls to avoid recomputation.
    
    Args:
        func: The function to memoize
        
    Returns:
        A function that caches results based on arguments
    """
    cache = {}
    
    def memoized_func(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    
    return memoized_func

# A function that's expensive to compute
def fibonacci(n):
    """Compute the nth Fibonacci number (inefficient recursive version)."""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Memoized version
memoized_fibonacci = memoize(fibonacci)

# Compare performance
import time

print("Computing fibonacci(30) without memoization:")
start = time.time()
result1 = fibonacci(30)
end = time.time()
print(f"Result: {result1}, Time: {end - start:.6f} seconds")

print("Computing fibonacci(30) with memoization:")
start = time.time()
result2 = memoized_fibonacci(30)
end = time.time()
print(f"Result: {result2}, Time: {end - start:.6f} seconds")
</code></pre>
            <p>
                Closures are functions that "remember" the environment they were created in. They capture and carry with them the variables from their containing scope, even after that scope has completed execution.
            </p>
            <p>
                Think of closures like takeout containers from a restaurantâ€”they let you take the "environment" (variables) with you, even after you've left the restaurant (the original function has finished executing).
            </p>
            <p>
                Closures are useful for:
            </p>
            <ul>
                <li>Creating functions with persistent state (like counters)</li>
                <li>Creating configurable functions (like loggers with different settings)</li>
                <li>Implementing memoization and caching strategies</li>
                <li>Data encapsulation and information hiding</li>
            </ul>

            <h3>Currying and Partial Application</h3>
            <pre><code>
# File: currying.py
# Location: /python_projects/functions_tutorial/

# Standard function with multiple parameters
def add(x, y, z):
    return x + y + z

# Curried version of the add function
def curried_add(x):
    def add_y(y):
        def add_z(z):
            return x + y + z
        return add_z
    return add_y

# Using the curried function
add_5 = curried_add(5)          # Returns a function that adds 5 to the sum of its arguments
add_5_and_10 = add_5(10)        # Returns a function that adds 5 and 10 to its argument
result = add_5_and_10(15)       # Returns 5 + 10 + 15 = 30

print(f"Result of curried add: {result}")

# More direct usage
print(curried_add(1)(2)(3))     # Returns 1 + 2 + 3 = 6

# A more practical example: configurable filtering
def filter_by(key, value):
    """Create a function that filters dictionaries by a specific key and value."""
    def filter_function(items):
        return [item for item in items if item.get(key) == value]
    return filter_function

# Sample data
products = [
    {"id": 1, "name": "Laptop", "category": "Electronics", "price": 999.99},
    {"id": 2, "name": "Smartphone", "category": "Electronics", "price": 499.99},
    {"id": 3, "name": "Chair", "category": "Furniture", "price": 149.99},
    {"id": 4, "name": "Desk", "category": "Furniture", "price": 249.99},
    {"id": 5, "name": "Tablet", "category": "Electronics", "price": 299.99}
]

# Create specialized filter functions
electronics_filter = filter_by("category", "Electronics")
furniture_filter = filter_by("category", "Furniture")
affordable_filter = filter_by("price", 149.99)

# Use the filter functions
electronics = electronics_filter(products)
furniture = furniture_filter(products)
affordable = affordable_filter(products)

print(f"Electronics: {[p['name'] for p in electronics]}")  # Laptop, Smartphone, Tablet
print(f"Furniture: {[p['name'] for p in furniture]}")      # Chair, Desk
print(f"Affordable: {[p['name'] for p in affordable]}")    # Chair

# Using partial application from functools
from functools import partial

def format_string(template, *args, **kwargs):
    """Format a string with the given args and kwargs."""
    return template.format(*args, **kwargs)

# Creating specialized formatters using partial application
greet_person = partial(format_string, "Hello, {0}! Welcome to {1}.")
error_message = partial(format_string, "Error: {0}. Code: {1}")
json_template = partial(format_string, '{{"name": "{0}", "age": {1}, "city": "{2}"}}')

# Using the specialized functions
print(greet_person("Alice", "Wonderland"))
print(error_message("File not found", 404))
print(json_template("Bob", 30, "New York"))
</code></pre>
            <p>
                Currying is the technique of transforming a function that takes multiple arguments into a series of functions that each take a single argument. Partial application is a related concept where you fix some arguments of a function, creating a new function that takes fewer arguments.
            </p>
            <p>
                These techniques are useful for:
            </p>
            <ul>
                <li>Creating specialized functions from more general ones</li>
                <li>Simplifying complex function calls</li>
                <li>Enabling function composition</li>
                <li>Supporting point-free programming styles</li>
            </ul>
            <p>
                Think of currying and partial application like pre-mixing ingredients for a recipe. Instead of measuring out all ingredients every time, you prepare common combinations in advance, making the final cooking process simpler and more efficient.
            </p>
        </section>

        <section class="practical_applications">
            <h2>Practical Applications of Higher-Order Functions</h2>
            <p>
                Let's explore some practical, real-world applications of higher-order functions in Python.
            </p>

            <h3>Data Processing Pipeline</h3>
            <pre><code>
# File: data_pipeline.py
# Location: /python_projects/functions_tutorial/

def create_data_pipeline(*transformations):
    """
    Create a data processing pipeline from a series of transformation functions.
    
    Args:
        *transformations: Functions that transform data
        
    Returns:
        A function that applies all transformations in sequence
    """
    def pipeline(data):
        result = data
        for transform in transformations:
            result = transform(result)
        return result
    
    return pipeline

# Sample data: a list of user dictionaries
users = [
    {"id": 1, "name": "Alice", "age": 25, "email": "alice@example.com"},
    {"id": 2, "name": "Bob", "age": 30, "email": "bob@example.com"},
    {"id": 3, "name": "Charlie", "age": 35, "email": "charlie@example.com"},
    {"id": 4, "name": "David", "age": 40, "email": "david@example.com"},
    {"id": 5, "name": "Eve", "age": 45, "email": "eve@example.com"}
]

# Define transformation functions
def filter_adults(users_data):
    """Filter users who are at least 18 years old."""
    return [user for user in users_data if user["age"] >= 18]

def anonymize_data(users_data):
    """Remove sensitive information from user data."""
    return [{"id": user["id"], "age": user["age"]} for user in users_data]

def sort_by_age(users_data):
    """Sort users by age in ascending order."""
    return sorted(users_data, key=lambda user: user["age"])

def add_group(users_data):
    """Add an age group field to each user."""
    result = []
    for user in users_data:
        age_group = "Young" if user["age"] < 30 else "Middle-aged" if user["age"] < 50 else "Senior"
        result.append({**user, "group": age_group})
    return result

# Create different pipelines for different purposes
basic_pipeline = create_data_pipeline(
    filter_adults,
    sort_by_age
)

privacy_pipeline = create_data_pipeline(
    filter_adults,
    anonymize_data,
    sort_by_age
)

analysis_pipeline = create_data_pipeline(
    filter_adults,
    add_group,
    sort_by_age
)

# Use the pipelines
basic_result = basic_pipeline(users)
privacy_result = privacy_pipeline(users)
analysis_result = analysis_pipeline(users)

print("Basic pipeline result:")
for user in basic_result:
    print(f"  {user['name']}, {user['age']} years old")

print("\nPrivacy pipeline result:")
for user in privacy_result:
    print(f"  User {user['id']}, {user['age']} years old")

print("\nAnalysis pipeline result:")
for user in analysis_result:
    print(f"  {user['name']}, {user['age']} years old, Group: {user['group']}")
</code></pre>
            <p>
                This example demonstrates how higher-order functions can be used to create flexible data processing pipelines. The <code>create_data_pipeline</code> function takes transformation functions as arguments and returns a new function that applies those transformations in sequence.
            </p>
            <p>
                This approach has several advantages:
            </p>
            <ul>
                <li>Modularity: Each transformation function does one thing well</li>
                <li>Reusability: Transformation functions can be reused in different pipelines</li>
                <li>Flexibility: Pipelines can be customized for different use cases</li>
                <li>Maintainability: It's easy to add, remove, or modify transformation steps</li>
            </ul>

            <h3>Event-Driven Programming</h3>
            <pre><code>
# File: event_system.py
# Location: /python_projects/functions_tutorial/

class EventEmitter:
    """A simple event emitter that allows subscribing to and emitting events."""
    
    def __init__(self):
        self.listeners = {}
    
    def on(self, event, callback):
        """Subscribe to an event with a callback function."""
        if event not in self.listeners:
            self.listeners[event] = []
        self.listeners[event].append(callback)
    
    def emit(self, event, *args, **kwargs):
        """Emit an event with arguments."""
        if event in self.listeners:
            for callback in self.listeners[event]:
                callback(*args, **kwargs)
    
    def remove_listener(self, event, callback):
        """Remove a specific listener from an event."""
        if event in self.listeners and callback in self.listeners[event]:
            self.listeners[event].remove(callback)

# Create an event emitter
events = EventEmitter()

# Define some event handler functions
def user_logged_in(username):
    print(f"User logged in: {username}")
    print(f"Sending welcome email to {username}")

def log_activity(activity, user):
    print(f"Activity logged: {user} performed {activity}")

def notify_admin(activity, user):
    if activity == "payment":
        print(f"Admin notification: {user} made a payment")

# Subscribe to events
events.on("login", user_logged_in)
events.on("activity", log_activity)
events.on("activity", notify_admin)

# Emit events
events.emit("login", "alice@example.com")
events.emit("activity", "login", "alice@example.com")
events.emit("activity", "payment", "alice@example.com")

# Create a middleware system using higher-order functions
def create_middleware_stack():
    """Create a middleware stack for processing requests."""
    middleware_functions = []
    
    def add(middleware):
        """Add a middleware function to the stack."""
        middleware_functions.append(middleware)
    
    def process(request):
        """Process a request through all middleware functions."""
        result = request
        for middleware in middleware_functions:
            result = middleware(result)
        return result
    
    return add, process

# Create a middleware stack
add_middleware, process_request = create_middleware_stack()

# Define middleware functions
def authenticate(request):
    """Check if the request is authenticated."""
    if "auth_token" in request:
        print(f"Request authenticated with token: {request['auth_token']}")
        return {**request, "authenticated": True}
    else:
        print("Request not authenticated")
        return {**request, "authenticated": False}

def log_request(request):
    """Log the request."""
    print(f"Request logged: {request['path']}")
    return request

def add_timestamp(request):
    """Add a timestamp to the request."""
    import time
    return {**request, "timestamp": time.time()}

# Add middleware to the stack
add_middleware(add_timestamp)
add_middleware(authenticate)
add_middleware(log_request)

# Process a request
request = {
    "path": "/api/data",
    "method": "GET",
    "auth_token": "abc123"
}

result = process_request(request)
print(f"Processed request: {result}")
</code></pre>
            <p>
                This example demonstrates how higher-order functions can be used in event-driven programming. The <code>EventEmitter</code> class allows registering callback functions for events, and the middleware system uses higher-order functions to create a processing pipeline for requests.
            </p>
            <p>
                Event-driven programming with higher-order functions is commonly used in:
            </p>
            <ul>
                <li>Web servers and frameworks</li>
                <li>User interface development</li>
                <li>Game development</li>
                <li>Asynchronous programming</li>
            </ul>

            <h3>Strategy Pattern Implementation</h3>
            <pre><code>
# File: strategy_pattern.py
# Location: /python_projects/functions_tutorial/

class ShoppingCart:
    """A shopping cart that can apply different discount strategies."""
    
    def __init__(self):
        self.items = []
        self.discount_strategy = None
    
    def add_item(self, item, price):
        """Add an item to the cart."""
        self.items.append({"item": item, "price": price})
    
    def set_discount_strategy(self, discount_strategy):
        """Set the discount strategy."""
        self.discount_strategy = discount_strategy
    
    def calculate_total(self):
        """Calculate the total price after applying the discount strategy."""
        subtotal = sum(item["price"] for item in self.items)
        
        if self.discount_strategy:
            discount = self.discount_strategy(self.items, subtotal)
            return subtotal - discount
        
        return subtotal

# Discount strategies

def no_discount(items, subtotal):
    """No discount applied."""
    return 0

def fixed_discount(amount):
    """
    Create a strategy that applies a fixed discount amount.
    
    Args:
        amount: The discount amount
        
    Returns:
        A strategy function
    """
    def strategy(items, subtotal):
        return min(amount, subtotal)  # Don't discount more than the subtotal
    
    return strategy

def percentage_discount(percent):
    """
    Create a strategy that applies a percentage discount.
    
    Args:
        percent: The discount percentage (0-100)
        
    Returns:
        A strategy function
    """
    def strategy(items, subtotal):
        return subtotal * (percent / 100)
    
    return strategy

def bulk_discount(item_count_threshold, discount_percent):
    """
    Create a strategy that applies a discount if the number of items exceeds a threshold.
    
    Args:
        item_count_threshold: The minimum number of items to qualify
        discount_percent: The discount percentage (0-100)
        
    Returns:
        A strategy function
    """
    def strategy(items, subtotal):
        if len(items) >= item_count_threshold:
            return subtotal * (discount_percent / 100)
        return 0
    
    return strategy

# Using the shopping cart with different discount strategies
cart = ShoppingCart()
cart.add_item("Laptop", 999.99)
cart.add_item("Mouse", 24.99)
cart.add_item("Keyboard", 74.99)

# Calculate total with no discount
print(f"Total with no discount: ${cart.calculate_total():.2f}")

# Apply a fixed discount
cart.set_discount_strategy(fixed_discount(100))
print(f"Total with $100 fixed discount: ${cart.calculate_total():.2f}")

# Apply a percentage discount
cart.set_discount_strategy(percentage_discount(15))
print(f"Total with 15% discount: ${cart.calculate_total():.2f}")

# Apply a bulk discount
cart.set_discount_strategy(bulk_discount(3, 10))
print(f"Total with bulk discount (3+ items): ${cart.calculate_total():.2f}")

# Apply a custom discount strategy on the fly
def clearance_discount(items, subtotal):
    """Apply a 20% discount to the most expensive item."""
    if not items:
        return 0
    most_expensive = max(items, key=lambda item: item["price"])
    return most_expensive["price"] * 0.2

cart.set_discount_strategy(clearance_discount)
print(f"Total with clearance discount: ${cart.calculate_total():.2f}")
</code></pre>
            <p>
                This example demonstrates how higher-order functions can be used to implement the strategy pattern, a design pattern that enables selecting an algorithm at runtime. The <code>ShoppingCart</code> class accepts different discount strategy functions, allowing the discount calculation to be customized without modifying the cart's code.
            </p>
            <p>
                This pattern is useful for:
            </p>
            <ul>
                <li>Making behavior configurable at runtime</li>
                <li>Avoiding complex conditional logic</li>
                <li>Separating algorithm implementation from its use</li>
                <li>Enabling easy testing of different strategies</li>
            </ul>

            <h3>Dependency Injection</h3>
            <pre><code>
# File: dependency_injection.py
# Location: /python_projects/functions_tutorial/

def create_user_service(database_client, email_sender, logger):
    """
    Create a user service with injected dependencies.
    
    Args:
        database_client: Function to interact with the database
        email_sender: Function to send emails
        logger: Function to log events
        
    Returns:
        A user service with methods for user management
    """
    def register_user(username, email, password):
        """Register a new user."""
        logger(f"Attempting to register user: {username}")
        
        # Check if user exists
        existing_user = database_client("find_user", {"username": username})
        if existing_user:
            logger(f"Registration failed: Username '{username}' already exists")
            return {"success": False, "error": "Username already exists"}
        
        # Create user
        user = {
            "username": username,
            "email": email,
            "password_hash": f"hashed_{password}"  # In reality, use a proper hash function
        }
        
        result = database_client("create_user", user)
        
        if result.get("success"):
            logger(f"User registered successfully: {username}")
            
            # Send welcome email
            email_sender(
                to=email,
                subject="Welcome to our service",
                body=f"Hello {username},\n\nThank you for registering!"
            )
            
            return {"success": True, "user_id": result.get("user_id")}
        else:
            logger(f"Registration failed: Database error")
            return {"success": False, "error": "Database error"}
    
    def get_user(user_id):
        """Get user details by ID."""
        logger(f"Fetching user with ID: {user_id}")
        
        user = database_client("get_user", {"user_id": user_id})
        
        if user:
            # Don't return the password hash
            return {
                "success": True,
                "user": {
                    "username": user["username"],
                    "email": user["email"]
                }
            }
        else:
            logger(f"User not found: {user_id}")
            return {"success": False, "error": "User not found"}
    
    # Return the service methods
    return {
        "register_user": register_user,
        "get_user": get_user
    }

# Mock implementations for testing
def mock_database_client(operation, data):
    """A mock database client for testing."""
    print(f"Database operation: {operation}")
    print(f"Database data: {data}")
    
    if operation == "find_user" and data.get("username") == "existing_user":
        return {"username": "existing_user", "email": "existing@example.com"}
    
    if operation == "create_user":
        return {"success": True, "user_id": "user123"}
    
    if operation == "get_user" and data.get("user_id") == "user123":
        return {
            "username": "test_user",
            "email": "test@example.com",
            "password_hash": "hashed_password"
        }
    
    return None

def mock_email_sender(to, subject, body):
    """A mock email sender for testing."""
    print(f"Sending email to: {to}")
    print(f"Subject: {subject}")
    print(f"Body: {body}")

def mock_logger(message):
    """A mock logger for testing."""
    print(f"Log: {message}")

# Create a user service with mock dependencies
user_service = create_user_service(
    database_client=mock_database_client,
    email_sender=mock_email_sender,
    logger=mock_logger
)

# Test the service
print("\nTesting user registration (new user):")
result1 = user_service["register_user"]("new_user", "new@example.com", "password123")
print(f"Result: {result1}")

print("\nTesting user registration (existing user):")
result2 = user_service["register_user"]("existing_user", "existing@example.com", "password123")
print(f"Result: {result2}")

print("\nTesting get user:")
result3 = user_service["get_user"]("user123")
print(f"Result: {result3}")
</code></pre>
            <p>
                This example demonstrates how higher-order functions can be used for dependency injection, a technique where a function's dependencies are provided from the outside rather than being created inside the function.
            </p>
            <p>
                Dependency injection offers several benefits:
            </p>
            <ul>
                <li>Improves testability by allowing dependencies to be mocked</li>
                <li>Enhances flexibility by making dependencies configurable</li>
                <li>Reduces coupling between components</li>
                <li>Enables different implementations for different environments (development, testing, production)</li>
            </ul>
        </section>

        <section class="performance_considerations">
            <h2>Performance Considerations</h2>
            <p>
                When working with higher-order functions, it's important to consider performance implications, especially for large datasets or performance-critical applications.
            </p>

            <h3>Function Call Overhead</h3>
            <pre><code>
# File: function_overhead.py
# Location: /python_projects/functions_tutorial/

import time

def measure_performance(func, args, iterations=1000000):
    """Measure the performance of a function."""
    start_time = time.time()
    
    for _ in range(iterations):
        func(*args)
    
    end_time = time.time()
    elapsed = end_time - start_time
    
    print(f"{func.__name__} took {elapsed:.6f} seconds for {iterations} iterations")
    print(f"Average time per call: {elapsed / iterations * 1000000:.2f} microseconds")
    
    return elapsed

# Direct calculation
def direct_square(x):
    return x * x

# Higher-order function
def create_power(n):
    def power(x):
        return x ** n
    return power

# Create a function for squaring
square = create_power(2)

# Compare performance
print("Comparing performance of direct function vs. higher-order function:")
direct_time = measure_performance(direct_square, (5,))
hof_time = measure_performance(square, (5,))

print(f"Overhead ratio: {hof_time / direct_time:.2f}x")

# Using built-in functions and operators
from operator import mul

def square_operator(x):
    return mul(x, x)

print("\nComparing with operator.mul:")
op_time = measure_performance(square_operator, (5,))

print(f"Operator vs. direct ratio: {op_time / direct_time:.2f}x")
print(f"Operator vs. higher-order ratio: {op_time / hof_time:.2f}x")
</code></pre>
            <p>
                This example demonstrates that higher-order functions can introduce some performance overhead due to the extra function call and closure lookups. However, this overhead is usually negligible for most applications.
            </p>
            <p>
                Key performance considerations:
            </p>
            <ul>
                <li>Function call overhead is usually minimal compared to the actual computation</li>
                <li>For performance-critical inner loops, consider inlining very simple functions</li>
                <li>For most applications, the benefits of higher-order functions (clarity, modularity, reusability) outweigh the small performance cost</li>
                <li>Use the <code>operator</code> module for common operations to reduce overhead</li>
            </ul>

            <h3>Memory Usage with Closures</h3>
            <pre><code>
# File: closure_memory.py
# Location: /python_projects/functions_tutorial/

import sys

def calculate_size(obj):
    """Calculate the approximate size of an object in bytes."""
    return sys.getsizeof(obj)

# Regular function
def simple_square(x):
    return x * x

# Function that creates a closure
def create_multiplier(factor):
    def multiply(x):
        return x * factor
    return multiply

# Create multiple closures
multiply_by_2 = create_multiplier(2)
multiply_by_10 = create_multiplier(10)
multiply_by_100 = create_multiplier(100)

# Print sizes
print(f"Size of simple_square function: {calculate_size(simple_square)} bytes")
print(f"Size of multiply_by_2 closure: {calculate_size(multiply_by_2)} bytes")
print(f"Size of multiply_by_10 closure: {calculate_size(multiply_by_10)} bytes")
print(f"Size of multiply_by_100 closure: {calculate_size(multiply_by_100)} bytes")

# Memory considerations with large closures
def create_processor_with_data(data):
    """Create a function that processes data (potentially large)."""
    # data could be a large list or dictionary
    
    def process(item):
        # Process the item using the captured data
        if item in data:
            return data[item]
        return None
    
    return process

# Small dataset
small_data = {"a": 1, "b": 2, "c": 3}
processor_small = create_processor_with_data(small_data)

# Larger dataset
large_data = {str(i): i for i in range(10000)}
processor_large = create_processor_with_data(large_data)

print(f"\nSize of small processor closure: {calculate_size(processor_small)} bytes")
print(f"Size of large processor closure: {calculate_size(processor_large)} bytes")

# Note: sys.getsizeof() doesn't account for the size of referenced objects,
# so the actual memory usage is higher than reported here, especially for
# closures that reference large data structures.
</code></pre>
            <p>
                This example illustrates that closures can have memory implications, especially when they capture large data structures. When a closure is created, it maintains references to the variables it captures, which prevents those variables from being garbage collected as long as the closure exists.
            </p>
            <p>
                Memory usage considerations:
            </p>
            <ul>
                <li>Be mindful of the size of data captured by closures</li>
                <li>Consider using partial application or currying for better memory efficiency when appropriate</li>
                <li>For large datasets, consider passing data as arguments rather than capturing it in the closure</li>
                <li>Use weak references if you need to reference large objects but allow them to be garbage collected</li>
            </ul>
        </section>

        <section class="higher_order_best_practices">
            <h2>Best Practices for Higher-Order Functions</h2>
            <p>
                Based on the examples and considerations we've explored, here are some best practices for working with higher-order functions in Python:
            </p>

            <h3>General Guidelines</h3>
            <ul>
                <li><strong>Keep functions focused:</strong> Each function should have a single responsibility</li>
                <li><strong>Use descriptive names:</strong> Function names should clearly indicate what they do</li>
                <li><strong>Document your functions:</strong> Include docstrings that explain purpose, parameters, and return values</li>
                <li><strong>Handle errors gracefully:</strong> Account for potential errors in functions passed as arguments</li>
                <li><strong>Consider performance:</strong> Be mindful of function call overhead for performance-critical code</li>
                <li><strong>Balance functional and imperative styles:</strong> Use functional patterns where they enhance clarity, but don't force them where imperative code would be clearer</li>
            </ul>

            <h3>Function Argument Guidelines</h3>
            <ul>
                <li><strong>Use type hints:</strong> Include type hints for function parameters to improve readability and enable static type checking</li>
                <li><strong>Validate function arguments:</strong> Check that functions passed as arguments have the expected signature</li>
                <li><strong>Consider using protocols or abstract base classes:</strong> Define expected interfaces for function arguments</li>
                <li><strong>Provide defaults for optional function arguments:</strong> Make your higher-order functions easier to use</li>
            </ul>

            <h3>Function Return Guidelines</h3>
            <ul>
                <li><strong>Preserve function metadata:</strong> Use <code>functools.wraps</code> to maintain function names, docstrings, etc.</li>
                <li><strong>Return consistent interfaces:</strong> Functions that return functions should follow consistent patterns</li>
                <li><strong>Document return types:</strong> Make it clear what kind of function is being returned</li>
                <li><strong>Consider partial application:</strong> Use <code>functools.partial</code> for simple function specialization</li>
            </ul>

            <h3>Code Example: Putting It All Together</h3>
            <pre><code>
# File: higher_order_best_practices.py
# Location: /python_projects/functions_tutorial/

import functools
from typing import Callable, TypeVar, List, Dict, Any, Optional

# Type variables for generic typing
T = TypeVar('T')
U = TypeVar('U')

def map_and_filter(
    items: List[T],
    mapper: Callable[[T], U],
    predicate: Optional[Callable[[U], bool]] = None
) -> List[U]:
    """
    Apply a mapping function to each item and optionally filter the results.
    
    Args:
        items: The input items to process
        mapper: A function to transform each item
        predicate: Optional function to filter the mapped items
        
    Returns:
        A list of transformed (and optionally filtered) items
    """
    # First, map the items
    mapped = [mapper(item) for item in items]
    
    # Then, filter if a predicate is provided
    if predicate:
        return [item for item in mapped if predicate(item)]
    
    return mapped

def create_logger(name: str, level: int = 0):
    """
    Create a logger function with a specific name and level.
    
    Args:
        name: The logger name
        level: The minimum log level (0=DEBUG, 1=INFO, 2=WARNING, 3=ERROR)
        
    Returns:
        A function that logs messages if they meet the minimum level
    """
    levels = ["DEBUG", "INFO", "WARNING", "ERROR"]
    
    @functools.wraps(create_logger)
    def logger(level_num: int, message: str) -> None:
        """Log a message at the specified level."""
        if level_num < 0 or level_num >= len(levels):
            raise ValueError(f"Invalid log level: {level_num}")
        
        if level_num >= level:
            print(f"[{levels[level_num]}] {name}: {message}")
    
    # Add metadata to help with debugging and introspection
    logger.name = name
    logger.min_level = level
    logger.levels = levels
    
    return logger

def compose(*functions: Callable) -> Callable:
    """
    Compose multiple functions into a single function.
    
    The functions are applied from right to left, i.e., compose(f, g, h)(x) is equivalent to f(g(h(x))).
    
    Args:
        *functions: The functions to compose
        
    Returns:
        A function that applies all the given functions in sequence
        
    Raises:
        ValueError: If no functions are provided
    """
    if not functions:
        raise ValueError("At least one function is required")
    
    def composed(*args, **kwargs):
        """The composed function."""
        if len(functions) == 1:
            return functions[0](*args, **kwargs)
        
        result = functions[-1](*args, **kwargs)
        for func in reversed(functions[:-1]):
            result = func(result)
        
        return result
    
    # Create a meaningful name for the composed function
    composed.__name__ = f"composed_{'_'.join(f.__name__ for f in functions)}"
    composed.__doc__ = f"Composed function: {' -> '.join(f.__name__ for f in reversed(functions))}"
    
    return composed

# Example usage
def main():
    """Demonstrate best practices for higher-order functions."""
    print("Demonstrating higher-order function best practices:")
    
    # Using map_and_filter
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    
    # Transform and filter
    squared_evens = map_and_filter(
        numbers,
        mapper=lambda x: x ** 2,
        predicate=lambda x: x % 2 == 0
    )
    
    print(f"Squared even numbers: {squared_evens}")
    
    # Using create_logger
    debug_logger = create_logger("DebugModule", level=0)
    prod_logger = create_logger("ProdModule", level=2)
    
    debug_logger(0, "Debug message")
    debug_logger(1, "Info message")
    
    prod_logger(0, "Debug message")  # Won't be logged
    prod_logger(2, "Warning message")
    
    # Using compose
    def add_one(x):
        return x + 1
    
    def double(x):
        return x * 2
    
    def square(x):
        return x ** 2
    
    # Create different function compositions
    pipeline1 = compose(square, double, add_one)  # square(double(add_one(x)))
    pipeline2 = compose(add_one, square, double)  # add_one(square(double(x)))
    
    print(f"\nPipeline 1 name: {pipeline1.__name__}")
    print(f"Pipeline 1 doc: {pipeline1.__doc__}")
    
    x = 3
    print(f"Pipeline 1 with x={x}: {pipeline1(x)}")  # square(double(add_one(3))) = square(double(4)) = square(8) = 64
    print(f"Pipeline 2 with x={x}: {pipeline2(x)}")  # add_one(square(double(3))) = add_one(square(6)) = add_one(36) = 37

if __name__ == "__main__":
    main()
</code></pre>
            <p>
                This example demonstrates several best practices for working with higher-order functions:
            </p>
            <ul>
                <li>Using type hints to clarify function signatures</li>
                <li>Providing clear docstrings that explain purpose, parameters, and return values</li>
                <li>Using <code>functools.wraps</code> to preserve function metadata</li>
                <li>Adding custom attributes to returned functions to aid in debugging and introspection</li>
                <li>Providing meaningful names and docstrings for generated functions</li>
                <li>Handling edge cases and potential errors</li>
            </ul>
        </section>

        <section class="higher_order_alternatives">
            <h2>Alternatives to Higher-Order Functions</h2>
            <p>
                While higher-order functions are powerful, there are sometimes other approaches that might be more appropriate depending on the situation.
            </p>

            <h3>Classes and Objects</h3>
            <pre><code>
# File: classes_vs_hof.py
# Location: /python_projects/functions_tutorial/

# Higher-order function approach
def create_counter(start=0, step=1):
    """Create a counter function that remembers its state."""
    count = start
    
    def counter():
        nonlocal count
        current = count
        count += step
        return current
    
    return counter

# Class-based approach
class Counter:
    """A counter that remembers its state."""
    
    def __init__(self, start=0, step=1):
        self.count = start
        self.step = step
    
    def __call__(self):
        current = self.count
        self.count += self.step
        return current
    
    def reset(self, value=0):
        """Reset the counter to a specific value."""
        self.count = value

# Compare the approaches
hof_counter = create_counter(10, 2)
class_counter = Counter(10, 2)

print("Higher-order function counter:")
print(f"  Count 1: {hof_counter()}")  # 10
print(f"  Count 2: {hof_counter()}")  # 12
print(f"  Count 3: {hof_counter()}")  # 14

print("\nClass-based counter:")
print(f"  Count 1: {class_counter()}")  # 10
print(f"  Count 2: {class_counter()}")  # 12
print(f"  Count 3: {class_counter()}")  # 14

# The class-based approach allows for additional methods
class_counter.reset(20)
print(f"  After reset: {class_counter()}")  # 20

# For the higher-order function, we'd need to create a new counter
hof_counter = create_counter(20, 2)
print(f"  New counter: {hof_counter()}")  # 20
</code></pre>
            <p>
                In this example, we compare a higher-order function approach with a class-based approach for creating counters. The class-based approach has some advantages:
            </p>
            <ul>
                <li>It can provide additional methods (like <code>reset</code>)</li>
                <li>The state is more explicitly defined as instance attributes</li>
                <li>It can be extended through inheritance</li>
                <li>It might be more familiar to developers from an object-oriented background</li>
            </ul>
            <p>
                However, the higher-order function approach is often more concise and can be more suitable for simple cases where you just need a function with some state.
            </p>

            <h3>List Comprehensions and Generator Expressions</h3>
            <pre><code>
# File: comprehensions_vs_hof.py
# Location: /python_projects/functions_tutorial/

import time

def measure_time(func, *args, **kwargs):
    """Measure the execution time of a function."""
    start_time = time.time()
    result = func(*args, **kwargs)
    end_time = time.time()
    return result, end_time - start_time

# Sample data: a list of numbers
numbers = list(range(1, 1000001))

# Using map and filter (higher-order functions)
def hof_approach(data):
    """Transform data using map and filter."""
    # Get squares of even numbers
    result = list(map(
        lambda x: x ** 2,
        filter(lambda x: x % 2 == 0, data)
    ))
    return result

# Using list comprehensions
def comprehension_approach(data):
    """Transform data using a list comprehension."""
    # Get squares of even numbers
    result = [x ** 2 for x in data if x % 2 == 0]
    return result

# Compare performance
print("Comparing performance of higher-order functions vs. list comprehensions:")

result1, time1 = measure_time(hof_approach, numbers)
print(f"Higher-order functions: {time1:.6f} seconds")

result2, time2 = measure_time(comprehension_approach, numbers)
print(f"List comprehension: {time2:.6f} seconds")

print(f"Results equal: {result1 == result2}")
print(f"Speedup factor: {time1 / time2:.2f}x")

# Using generators for memory efficiency
def gen_approach(data):
    """Transform data using a generator expression."""
    # Create a generator that yields squares of even numbers
    return (x ** 2 for x in data if x % 2 == 0)

# Calculate sum using different approaches
print("\nCalculating sum of squares of even numbers:")

result3, time3 = measure_time(lambda: sum(hof_approach(numbers)))
print(f"Higher-order functions: {time3:.6f} seconds")

result4, time4 = measure_time(lambda: sum(comprehension_approach(numbers)))
print(f"List comprehension: {time4:.6f} seconds")

result5, time5 = measure_time(lambda: sum(gen_approach(numbers)))
print(f"Generator expression: {time5:.6f} seconds")

print(f"Results equal: {result3 == result4 == result5}")
</code></pre>
            <p>
                For many data transformation tasks, list comprehensions and generator expressions can be more readable and efficient alternatives to using higher-order functions like <code>map</code> and <code>filter</code>.
            </p>
            <p>
                Key considerations:
            </p>
            <ul>
                <li>List comprehensions are often more readable and faster than equivalent <code>map</code>/<code>filter</code> chains</li>
                <li>Generator expressions are memory-efficient for large datasets</li>
                <li>Comprehensions are considered more "Pythonic" for many simple transformations</li>
                <li>Higher-order functions can be more appropriate for complex transformations or when you need to reuse the transformation functions</li>
            </ul>

            <h3>Decorators as a Higher-Order Function Alternative</h3>
            <pre><code>
# File: decorators_vs_hof.py
# Location: /python_projects/functions_tutorial/

import functools

# Higher-order function approach

def create_memoized_function(func):
    """Create a memoized version of a function."""
    cache = {}
    
    def memoized(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    
    return memoized

# Decorator approach
def memoize(func):
    """Decorator that memoizes a function."""
    cache = {}
    
    @functools.wraps(func)
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    
    return wrapper

# Original function
def fibonacci(n):
    """Calculate the nth Fibonacci number (inefficient recursive version)."""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Using the higher-order function approach
memoized_fibonacci = create_memoized_function(fibonacci)

# Using the decorator approach
@memoize
def decorated_fibonacci(n):
    """Calculate the nth Fibonacci number (with memoization via decorator)."""
    if n <= 1:
        return n
    return decorated_fibonacci(n-1) + decorated_fibonacci(n-2)

# Compare the approaches
import time

print("Comparing higher-order function vs. decorator approaches:")

# Higher-order function approach
start = time.time()
result1 = memoized_fibonacci(30)
end = time.time()
print(f"Higher-order function approach: {result1} in {end - start:.6f} seconds")

# Decorator approach
start = time.time()
result2 = decorated_fibonacci(30)
end = time.time()
print(f"Decorator approach: {result2} in {end - start:.6f} seconds")

# Original function (for comparison)
start = time.time()
try:
    result3 = fibonacci(30)  # This would take a very long time
    end = time.time()
    print(f"Original function: {result3} in {end - start:.6f} seconds")
except RecursionError:
    print("Original function: RecursionError (too slow without memoization)")
</code></pre>
            <p>
                Decorators are essentially a specialized syntax for applying higher-order functions to function definitions. They provide a more readable and elegant way to enhance or modify the behavior of functions.
            </p>
            <p>
                Key points about decorators vs. higher-order functions:
            </p>
            <ul>
                <li>Decorators are syntactic sugar for higher-order functions that take a function and return an enhanced version</li>
                <li>The <code>@decorator</code> syntax is more concise and clearly shows that the function is being enhanced</li>
                <li>Decorators are often used for cross-cutting concerns like caching, logging, timing, access control, etc.</li>
                <li>The <code>functools.wraps</code> decorator helps preserve the original function's metadata (name, docstring, etc.)</li>
            </ul>

            <h3>Context Managers</h3>
            <pre><code>
# File: context_managers.py
# Location: /python_projects/functions_tutorial/

import time
from contextlib import contextmanager

# Higher-order function approach
def with_timing(func):
    """Create a function that measures and reports execution time."""
    def timed_func(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.6f} seconds")
        return result
    return timed_func

# Context manager approach
@contextmanager
def timing_context(description):
    """Context manager that measures and reports execution time."""
    start_time = time.time()
    try:
        yield
    finally:
        end_time = time.time()
        print(f"{description} took {end_time - start_time:.6f} seconds")

# Function to be timed
def complex_operation(size):
    """A sample complex operation."""
    result = 0
    for i in range(size):
        for j in range(size):
            result += i * j
    return result

# Using the higher-order function approach
timed_operation = with_timing(complex_operation)
result1 = timed_operation(1000)

# Using the context manager approach
with timing_context("Complex operation"):
    result2 = complex_operation(1000)

print(f"Results equal: {result1 == result2}")

# A more practical example: resource management
@contextmanager
def open_file(filename, mode="r"):
    """Context manager for file operations with proper resource cleanup."""
    try:
        file = open(filename, mode)
        print(f"File {filename} opened in mode {mode}")
        yield file
    finally:
        file.close()
        print(f"File {filename} closed")

# Using the context manager for file operations
try:
    with open_file("sample.txt", "w") as f:
        f.write("Hello, world!")
        print("Wrote to file")
except Exception as e:
    print(f"Error: {e}")
</code></pre>
            <p>
                Context managers provide an alternative to higher-order functions for certain types of operations, particularly those that involve setup and teardown actions (like resource management).
            </p>
            <p>
                Key points about context managers:
            </p>
            <ul>
                <li>Context managers handle the enter/exit mechanics of a resource or operation</li>
                <li>They ensure proper cleanup even if exceptions occur</li>
                <li>The <code>with</code> statement provides clear visual indication of the managed context</li>
                <li>Context managers are ideal for file operations, database connections, locks, and other resources</li>
                <li>The <code>contextlib.contextmanager</code> decorator makes it easy to create context managers using generator functions</li>
            </ul>
        </section>

        <section class="functional_programming">
            <h2>Higher-Order Functions in Functional Programming</h2>
            <p>
                Higher-order functions are a cornerstone of functional programming, a paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data.
            </p>

            <h3>Functional Programming Principles</h3>
            <p>
                Key principles of functional programming include:
            </p>
            <ul>
                <li><strong>First-class functions:</strong> Functions can be assigned to variables, passed as arguments, and returned from other functions</li>
                <li><strong>Pure functions:</strong> Functions that always produce the same output for the same input and have no side effects</li>
                <li><strong>Immutability:</strong> Data is not changed once created; new data is created instead</li>
                <li><strong>Function composition:</strong> Building complex functions by combining simpler ones</li>
                <li><strong>Declarative style:</strong> Expressing what to compute rather than how to compute it</li>
            </ul>
            <p>
                While Python is not a purely functional language, it supports many functional programming techniques, and higher-order functions are a key part of this support.
            </p>

            <h3>Function Composition</h3>
            <pre><code>
# File: function_composition.py
# Location: /python_projects/functions_tutorial/

def compose(f, g):
    """Compose two functions: compose(f, g)(x) = f(g(x))."""
    return lambda x: f(g(x))

def pipe(x, *functions):
    """Pipe a value through a series of functions."""
    result = x
    for func in functions:
        result = func(result)
    return result

# Some simple functions to compose
def double(x):
    return x * 2

def increment(x):
    return x + 1

def square(x):
    return x * x

# Compose functions in different ways
f1 = compose(double, increment)     # double(increment(x))
f2 = compose(increment, double)     # increment(double(x))
f3 = compose(square, double)        # square(double(x))

print(f"f1(5) = double(increment(5)) = double(6) = {f1(5)}")
print(f"f2(5) = increment(double(5)) = increment(10) = {f2(5)}")
print(f"f3(5) = square(double(5)) = square(10) = {f3(5)}")

# Compose multiple functions
def compose_multiple(*functions):
    """Compose multiple functions, from right to left."""
    def composed(x):
        result = x
        for f in reversed(functions):
            result = f(result)
        return result
    return composed

f4 = compose_multiple(square, double, increment)  # square(double(increment(x)))
print(f"f4(5) = square(double(increment(5))) = square(double(6)) = square(12) = {f4(5)}")

# Using pipe for more readable composition
result = pipe(5,
    increment,
    double,
    square
)
print(f"pipe(5, increment, double, square) = {result}")
</code></pre>
            <p>
                Function composition is a fundamental technique in functional programming that allows building complex functions from simpler ones. In the above example, we demonstrate different ways to compose functions in Python.
            </p>
            <p>
                The <code>compose</code> function combines two functions, while <code>compose_multiple</code> extends this to any number of functions. The <code>pipe</code> function provides a more readable alternative when working with a specific input value.
            </p>

            <h3>Partial Application and Currying</h3>
            <pre><code>
# File: partial_currying.py
# Location: /python_projects/functions_tutorial/

from functools import partial

# Original function with multiple parameters
def greet(greeting, name, punctuation):
    return f"{greeting}, {name}{punctuation}"

# Partial application: fix some arguments
hello = partial(greet, "Hello")              # Fix the greeting to "Hello"
hello_with_exclamation = partial(greet, "Hello", punctuation="!")  # Fix greeting and punctuation

print(hello("Alice", "!"))                  # "Hello, Alice!"
print(hello_with_exclamation("Bob"))        # "Hello, Bob!"

# Manual currying (transforming a multi-argument function into a series of single-argument functions)
def curried_greet(greeting):
    def with_name(name):
        def with_punctuation(punctuation):
            return f"{greeting}, {name}{punctuation}"
        return with_punctuation
    return with_name

# Using the curried function
curried_hello = curried_greet("Hello")
curried_hello_alice = curried_hello("Alice")
result = curried_hello_alice("!")
print(result)  # "Hello, Alice!"

# More direct usage
print(curried_greet("Hi")("Charlie")("?"))  # "Hi, Charlie?"

# Helper function for automatic currying
def curry(func, arity=None):
    """
    Curry a function with the specified arity (number of arguments).
    
    Args:
        func: The function to curry
        arity: The number of arguments to curry (default: func.__code__.co_argcount)
        
    Returns:
        A curried version of the function
    """
    if arity is None:
        arity = func.__code__.co_argcount
    
    def curried(*args):
        if len(args) >= arity:
            return func(*args)
        return lambda *more_args: curried(*(args + more_args))
    
    return curried

# Using the curry helper
def add3(x, y, z):
    return x + y + z

curried_add3 = curry(add3)
add5 = curried_add3(5)
add5and10 = add5(10)
result = add5and10(15)
print(result)  # 30

# More direct usage
print(curried_add3(1)(2)(3))  # 6
</code></pre>
            <p>
                Partial application and currying are techniques for specializing functions by fixing some of their arguments:
            </p>
            <ul>
                <li><strong>Partial application</strong> fixes a subset of a function's arguments, returning a new function that takes the remaining arguments.</li>
                <li><strong>Currying</strong> transforms a function that takes multiple arguments into a series of functions, each taking a single argument.</li>
            </ul>
            <p>
                These techniques enable more flexible function composition and can make code more modular and reusable.
            </p>

            <h3>Functors and Monads</h3>
            <pre><code>
# File: functors_monads.py
# Location: /python_projects/functions_tutorial/

# A simple Maybe functor implementation
class Maybe:
    """
    A simple Maybe functor that represents a value that might be None.
    Allows operations on the value without checking for None at each step.
    """
    def __init__(self, value):
        self.value = value
    
    def map(self, func):
        """Apply a function to the value if it's not None."""
        if self.value is None:
            return Maybe(None)
        return Maybe(func(self.value))
    
    def flat_map(self, func):
        """Apply a function that returns a Maybe to the value if it's not None."""
        if self.value is None:
            return Maybe(None)
        return func(self.value)
    
    def get_or_else(self, default):
        """Get the value or a default if the value is None."""
        return self.value if self.value is not None else default
    
    def __str__(self):
        return f"Maybe({self.value})"

# Usage examples
def find_user_by_id(user_id):
    """Find a user by ID (dummy implementation)."""
    users = {
        1: {"name": "Alice", "email": "alice@example.com"},
        2: {"name": "Bob", "email": "bob@example.com"}
    }
    return users.get(user_id)

def get_email(user):
    """Get a user's email."""
    return user["email"] if user else None

def send_email(email, message):
    """Send an email (dummy implementation)."""
    if email:
        print(f"Sending email to {email}: {message}")
        return True
    return False

# Traditional approach with multiple checks
def notify_user_traditional(user_id, message):
    """Notify a user by email (traditional approach with checks)."""
    user = find_user_by_id(user_id)
    if user is None:
        print("User not found")
        return False
    
    email = get_email(user)
    if email is None:
        print("Email not found")
        return False
    
    return send_email(email, message)

# Using Maybe to eliminate explicit None checks
def notify_user_maybe(user_id, message):
    """Notify a user by email using Maybe."""
    result = (Maybe(user_id)
        .map(find_user_by_id)
        .map(get_email)
        .map(lambda email: send_email(email, message)))
    
    return result.get_or_else(False)

# Test both approaches
print("Traditional approach:")
result1 = notify_user_traditional(1, "Hello!")
result2 = notify_user_traditional(3, "Hello!")  # Invalid user ID

print("\nMaybe approach:")
result3 = notify_user_maybe(1, "Hello!")
result4 = notify_user_maybe(3, "Hello!")  # Invalid user ID

# A more advanced example with flat_map
def find_manager(user):
    """Find a user's manager (dummy implementation)."""
    managers = {
        "Alice": {"name": "Charlie", "email": "charlie@example.com"},
        "Bob": {"name": "Diana", "email": "diana@example.com"}
    }
    if user is None:
        return None
    return managers.get(user["name"])

def notify_manager(user_id, message):
    """Notify a user's manager using Maybe with flat_map."""
    result = (Maybe(user_id)
        .map(find_user_by_id)
        .flat_map(lambda user: Maybe(find_manager(user)))
        .map(get_email)
        .map(lambda email: send_email(email, message)))
    
    return result.get_or_else(False)

print("\nNotifying manager:")
notify_manager(1, "Report about Alice")
notify_manager(3, "Report about unknown user")  # Invalid user ID
</code></pre>
            <p>
                Functors and monads are advanced functional programming concepts that provide ways to compose operations on wrapped values. While Python doesn't have built-in support for these concepts, they can be implemented using classes with appropriate methods:
            </p>
            <ul>
                <li><strong>Functors</strong> are objects that implement <code>map</code>, allowing functions to be applied to wrapped values</li>
                <li><strong>Monads</strong> extend functors with <code>flat_map</code> (sometimes called <code>bind</code> or <code>then</code>), allowing operations that return wrapped values to be chained</li>
            </ul>
            <p>
                These concepts can help manage complex control flow, handle errors gracefully, and compose operations on potentially absent or invalid values.
            </p>
        </section>

        <section class="advanced_applications">
            <h2>Advanced Applications of Higher-Order Functions</h2>
            <p>
                Let's explore some more advanced applications of higher-order functions in real-world scenarios.
            </p>

            <h3>Domain-Specific Languages (DSLs)</h3>
            <pre><code>
# File: simple_dsl.py
# Location: /python_projects/functions_tutorial/

# A simple DSL for query building
def select(*columns):
    """Start building a query by selecting columns."""
    query = {"columns": columns, "filters": [], "order_by": None, "limit": None}
    
    def from_table(table):
        """Specify the table to query."""
        query["table"] = table
        
        # Return an object with methods for further query building
        return QueryBuilder(query)
    
    return from_table

class QueryBuilder:
    """A query builder that uses method chaining."""
    
    def __init__(self, query):
        self.query = query
    
    def where(self, column, operator, value):
        """Add a filter condition."""
        self.query["filters"].append((column, operator, value))
        return self
    
    def order_by(self, column, direction="ASC"):
        """Set the order by clause."""
        self.query["order_by"] = (column, direction)
        return self
    
    def limit(self, count):
        """Set the limit clause."""
        self.query["limit"] = count
        return self
    
    def build(self):
        """Build the final SQL query string."""
        columns = ", ".join(self.query["columns"])
        sql = f"SELECT {columns} FROM {self.query['table']}"
        
        if self.query["filters"]:
            conditions = []
            for column, operator, value in self.query["filters"]:
                if isinstance(value, str):
                    conditions.append(f"{column} {operator} '{value}'")
                else:
                    conditions.append(f"{column} {operator} {value}")
            
            sql += " WHERE " + " AND ".join(conditions)
        
        if self.query["order_by"]:
            column, direction = self.query["order_by"]
            sql += f" ORDER BY {column} {direction}"
        
        if self.query["limit"] is not None:
            sql += f" LIMIT {self.query['limit']}"
        
        return sql

# Using the DSL
query1 = (select("id", "name", "email")
    .from_table("users")
    .where("age", ">", 18)
    .where("status", "=", "active")
    .order_by("name")
    .limit(10)
    .build())

print(f"Query 1: {query1}")

query2 = (select("product_id", "name", "price")
    .from_table("products")
    .where("category", "=", "Electronics")
    .where("price", "<", 1000)
    .order_by("price", "DESC")
    .build())

print(f"Query 2: {query2}")

# A different kind of DSL using higher-order functions for data validation
def is_required(field_name):
    """Create a validator that checks if a field is present and not empty."""
    def validator(data):
        value = data.get(field_name)
        if value is None or (isinstance(value, str) and not value.strip()):
            return False, f"{field_name} is required"
        return True, None
    return validator

def min_length(field_name, min_len):
    """Create a validator that checks if a field meets a minimum length."""
    def validator(data):
        value = data.get(field_name)
        if value is None or len(value) < min_len:
            return False, f"{field_name} must be at least {min_len} characters"
        return True, None
    return validator

def is_email(field_name):
    """Create a validator that checks if a field is a valid email."""
    def validator(data):
        value = data.get(field_name)
        if value is None or '@' not in value or '.' not in value:
            return False, f"{field_name} must be a valid email"
        return True, None
    return validator

def validate(data, *validators):
    """Validate data against a series of validators."""
    errors = []
    
    for validator in validators:
        is_valid, error = validator(data)
        if not is_valid:
            errors.append(error)
    
    return len(errors) == 0, errors

# Using the validation DSL
user_data = {
    "username": "jdoe",
    "email": "john@example.com",
    "password": "pass"
}

is_valid, errors = validate(
    user_data,
    is_required("username"),
    is_required("email"),
    is_required("password"),
    min_length("username", 3),
    min_length("password", 8),
    is_email("email")
)

if is_valid:
    print("User data is valid")
else:
    print("Validation errors:")
    for error in errors:
        print(f"  - {error}")
</code></pre>
            <p>
                Domain-Specific Languages (DSLs) are specialized languages for particular domains or problems. Higher-order functions can be used to create expressive, fluent APIs that serve as internal DSLs in Python.
            </p>
            <p>
                In the example above, we created two simple DSLs:
            </p>
            <ul>
                <li>A SQL query builder that allows chaining methods to construct queries</li>
                <li>A data validation system that uses higher-order functions to create reusable validators</li>
            </ul>
            <p>
                These DSLs make the code more readable and expressive, closer to the domain language, and less prone to errors.
            </p>

            <h3>Reactive Programming</h3>
            <pre><code>
# File: reactive_example.py
# Location: /python_projects/functions_tutorial/

class Observable:
    """A simple Observable implementation for reactive programming."""
    
    def __init__(self, initial_value=None):
        self.value = initial_value
        self.observers = []
    
    def subscribe(self, observer):
        """Add an observer function that will be called when the value changes."""
        self.observers.append(observer)
        # Call the observer with the current value
        observer(self.value)
        return self  # For method chaining
    
    def unsubscribe(self, observer):
        """Remove an observer function."""
        if observer in self.observers:
            self.observers.remove(observer)
        return self  # For method chaining
    
    def set(self, new_value):
        """Set a new value and notify all observers."""
        if new_value != self.value:
            self.value = new_value
            for observer in self.observers:
                observer(new_value)
        return self  # For method chaining
    
    def map(self, transform_function):
        """
        Create a new Observable that transforms the values of this Observable.
        
        Args:
            transform_function: A function to apply to each value
            
        Returns:
            A new Observable with the transformed values
        """
        result = Observable()
        
        def update(value):
            result.set(transform_function(value))
        
        self.subscribe(update)
        return result
    
    def filter(self, predicate_function):
        """
        Create a new Observable that only emits values that satisfy the predicate.
        
        Args:
            predicate_function: A function that returns True for values to emit
            
        Returns:
            A new Observable with the filtered values
        """
        result = Observable()
        
        def update(value):
            if predicate_function(value):
                result.set(value)
        
        self.subscribe(update)
        return result
    
    def combine(self, other_observable, combiner_function):
        """
        Combine this Observable with another using a combiner function.
        
        Args:
            other_observable: Another Observable to combine with
            combiner_function: A function that takes two values and returns a combined value
            
        Returns:
            A new Observable with the combined values
        """
        result = Observable()
        latest_values = [self.value, other_observable.value]
        
        def update_first(value):
            latest_values[0] = value
            result.set(combiner_function(latest_values[0], latest_values[1]))
        
        def update_second(value):
            latest_values[1] = value
            result.set(combiner_function(latest_values[0], latest_values[1]))
        
        self.subscribe(update_first)
        other_observable.subscribe(update_second)
        
        return result

# Using the reactive programming system
def create_temperature_converter():
    """Create a temperature converter with reactive bindings."""
    # Observable temperature values
    celsius = Observable(0)
    fahrenheit = Observable(32)
    
    # Create bidirectional binding
    c_to_f_binding = celsius.map(lambda c: c * 9/5 + 32)
    f_to_c_binding = fahrenheit.map(lambda f: (f - 32) * 5/9)
    
    # Subscribe to updates
    c_to_f_binding.subscribe(lambda f: fahrenheit.set(f))
    f_to_c_binding.subscribe(lambda c: celsius.set(c))
    
    return celsius, fahrenheit

# Create the converter
celsius, fahrenheit = create_temperature_converter()

# Add observers for display
celsius.subscribe(lambda c: print(f"Celsius: {c:.2f}Â°C"))
fahrenheit.subscribe(lambda f: print(f"Fahrenheit: {f:.2f}Â°F"))

print("\nSetting Celsius to 25Â°C:")
celsius.set(25)

print("\nSetting Fahrenheit to 68Â°F:")
fahrenheit.set(68)

# More advanced example with multiple observables
def create_weather_monitor():
    """Create a weather monitoring system with derived values."""
    temperature = Observable(20)  # Celsius
    humidity = Observable(50)     # Percent
    wind_speed = Observable(10)   # km/h
    
    # Derived values
    feels_like = temperature.combine(
        wind_speed,
        lambda temp, wind: temp - wind * 0.1  # Simplified wind chill calculation
    )
    
    comfort_level = temperature.combine(
        humidity,
        lambda temp, humid: (
            "Comfortable" if 18 <= temp <= 24 and 40 <= humid <= 60
            else "Uncomfortable"
        )
    )
    
    # High temperature warning
    temperature.filter(lambda temp: temp > 30).subscribe(
        lambda temp: print(f"WARNING: High temperature detected: {temp}Â°C")
    )
    
    return {
        "temperature": temperature,
        "humidity": humidity,
        "wind_speed": wind_speed,
        "feels_like": feels_like,
        "comfort_level": comfort_level
    }

# Create the weather monitor
weather = create_weather_monitor()

# Add observers
weather["feels_like"].subscribe(lambda temp: print(f"Feels like: {temp:.1f}Â°C"))
weather["comfort_level"].subscribe(lambda level: print(f"Comfort level: {level}"))

print("\nUpdating temperature to 22Â°C:")
weather["temperature"].set(22)

print("\nIncreasing humidity to 70%:")
weather["humidity"].set(70)

print("\nSetting temperature to 35Â°C (should trigger warning):")
weather["temperature"].set(35)
</code></pre>
            <p>
                Reactive programming is a paradigm focused on data flows and the propagation of changes. Higher-order functions are fundamental to this paradigm, allowing the creation of data streams that can be transformed, filtered, and combined.
            </p>
            <p>
                In the example above, we implemented a simple reactive system with <code>Observable</code> objects that can be transformed and combined using higher-order functions. This approach is useful for:
            </p>
            <ul>
                <li>User interfaces with complex data dependencies</li>
                <li>Real-time data processing</li>
                <li>Event-driven systems</li>
                <li>Bidirectional data binding</li>
            </ul>
            <p>
                Libraries like RxPy (Reactive Extensions for Python) provide more sophisticated implementations of these concepts for real-world applications.
            </p>

            <h3>Aspect-Oriented Programming</h3>
            <pre><code>
# File: aspect_oriented.py
# Location: /python_projects/functions_tutorial/

import functools
import time
import threading
import traceback

# Define aspects as higher-order functions

def log_calls(logger=print):
    """
    Aspect that logs function calls with arguments and return values.
    
    Args:
        logger: Function to use for logging (default: print)
        
    Returns:
        A decorator function
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            logger(f"Calling {func.__name__} with args={args}, kwargs={kwargs}")
            result = func(*args, **kwargs)
            logger(f"{func.__name__} returned {result}")
            return result
        return wrapper
    return decorator

def measure_time(logger=print):
    """
    Aspect that measures and logs function execution time.
    
    Args:
        logger: Function to use for logging (default: print)
        
    Returns:
        A decorator function
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            execution_time = end_time - start_time
            logger(f"{func.__name__} took {execution_time:.6f} seconds")
            return result
        return wrapper
    return decorator

def retry(max_attempts=3, delay=1, exceptions=(Exception,)):
    """
    Aspect that retries a function if it raises specified exceptions.
    
    Args:
        max_attempts: Maximum number of attempts
        delay: Delay between attempts in seconds
        exceptions: Tuple of exceptions to catch and retry
        
    Returns:
        A decorator function
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    attempts += 1
                    if attempts == max_attempts:
                        raise
                    print(f"Attempt {attempts} failed with error: {e}")
                    print(f"Retrying in {delay} seconds...")
                    time.sleep(delay)
        return wrapper
    return decorator

def synchronized(lock=None):
    """
    Aspect that ensures a function is thread-safe using a lock.
    
    Args:
        lock: Lock to use (default: create a new lock)
        
    Returns:
        A decorator function
    """
    def decorator(func):
        nonlocal lock
        if lock is None:
            lock = threading.RLock()
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            with lock:
                return func(*args, **kwargs)
        return wrapper
    return decorator

# Demonstration of aspect-oriented programming

# A simple function to demonstrate aspects
def process_data(data):
    """Process some data (dummy implementation)."""
    time.sleep(0.1)  # Simulate processing
    return data[::-1]  # Reverse the data

# Apply multiple aspects to the function
@log_calls()
@measure_time()
@retry(max_attempts=3, delay=0.5, exceptions=(ValueError, RuntimeError))
@synchronized()
def enhanced_process_data(data):
    """Process data with enhanced aspects."""
    if not data:
        raise ValueError("Empty data")
    
    time.sleep(0.1)  # Simulate processing
    return data[::-1]  # Reverse the data

# Test the enhanced function
try:
    result1 = enhanced_process_data("Hello, world!")
    print(f"Result: {result1}")
    
    # This should trigger a retry and then fail
    result2 = enhanced_process_data("")
    print(f"Result: {result2}")
except Exception as e:
    print(f"Final error: {e}")

# Custom aspect for validation
def validate_args(**validators):
    """
    Aspect that validates function arguments.
    
    Args:
        validators: A dictionary mapping parameter names to validation functions
        
    Returns:
        A decorator function
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Get function signature to map positional args to parameter names
            import inspect
            sig = inspect.signature(func)
            bound_args = sig.bind(*args, **kwargs)
            bound_args.apply_defaults()
            
            # Validate arguments
            for param_name, validator in validators.items():
                if param_name in bound_args.arguments:
                    value = bound_args.arguments[param_name]
                    if not validator(value):
                        raise ValueError(f"Invalid value for {param_name}: {value}")
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

# Define validation functions
def is_positive(x):
    return x > 0

def is_string(s):
    return isinstance(s, str)

def min_length(min_len):
    return lambda s: len(s) >= min_len

# Apply validation aspect
@validate_args(
    name=is_string,
    age=is_positive,
    address=lambda s: is_string(s) and len(s) >= 5
)
def create_user(name, age, address):
    """Create a user with validated arguments."""
    return {"name": name, "age": age, "address": address}

# Test validation
try:
    user1 = create_user("Alice", 30, "123 Main St")
    print(f"Valid user: {user1}")
    
    user2 = create_user("Bob", -5, "Home")
    print(f"This shouldn't print: {user2}")
except ValueError as e:
    print(f"Validation error: {e}")
</code></pre>
            <p>
                Aspect-Oriented Programming (AOP) is a paradigm that aims to increase modularity by separating cross-cutting concerns. Higher-order functions, especially decorators, are an excellent way to implement aspects in Python.
            </p>
            <p>
                In the example above, we implemented several aspects as decorators:
            </p>
            <ul>
                <li><code>log_calls</code>: Logs function calls with arguments and return values</li>
                <li><code>measure_time</code>: Measures and logs function execution time</li>
                <li><code>retry</code>: Retries a function if it raises specified exceptions</li>
                <li><code>synchronized</code>: Ensures a function is thread-safe using a lock</li>
                <li><code>validate_args</code>: Validates function arguments against specified validators</li>
            </ul>
            <p>
                These aspects can be applied to any function without modifying its core logic, promoting separation of concerns and code reuse.
            </p>
        </section>

        <section class="conclusion">
            <h2>Conclusion: The Power of Higher-Order Functions</h2>
            <p>
                Higher-order functions are a powerful and versatile tool in Python programming. They enable:
            </p>
            <ul>
                <li><strong>Abstraction:</strong> Higher-order functions allow you to abstract patterns of computation, making your code more concise and expressive.</li>
                <li><strong>Modularity:</strong> By separating concerns and promoting code reuse, higher-order functions lead to more modular and maintainable code.</li>
                <li><strong>Flexibility:</strong> Functions that work with other functions can be customized at runtime, enabling more adaptable and configurable systems.</li>
                <li><strong>Expressiveness:</strong> Many complex operations can be expressed more clearly using higher-order functions, especially when working with collections and transformations.</li>
            </ul>
            <p>
                Throughout this tutorial, we've explored various aspects of higher-order functions in Python:
            </p>
            <ul>
                <li>Functions that take functions as arguments (<code>map</code>, <code>filter</code>, <code>sorted</code>, etc.)</li>
                <li>Functions that return functions (closures, function factories, decorators)</li>
                <li>Function composition and currying</li>
                <li>Practical applications in data processing, event-driven programming, and more</li>
                <li>Advanced patterns like functors, monads, and reactive programming</li>
            </ul>
            <p>
                While Python supports many functional programming concepts through higher-order functions, it's important to balance functional and imperative approaches. Choose the paradigm that makes your code most readable, maintainable, and efficient for the task at hand.
            </p>
            <p>
                As you continue to develop your Python skills, incorporating higher-order functions into your toolkit will enable you to write more elegant, modular, and robust code. Start with simple patterns like <code>map</code> and <code>filter</code>, and gradually explore more advanced concepts as you become comfortable with the functional programming style.
            </p>
        </section>

        <section class="practice_exercises">
            <h2>Practice Exercises</h2>
            <p>
                To solidify your understanding of higher-order functions, try these exercises:
            </p>
            <ol>
                <li>Implement a <code>memoize</code> decorator that caches the results of a function based on its arguments.</li>
                <li>Create a <code>compose</code> function that can compose any number of functions.</li>
                <li>Implement a <code>curry</code> function that automatically curries a function with a specific arity.</li>
                <li>Build a simple event system with functions for subscribing, unsubscribing, and emitting events.</li>
                <li>Create a validation system for data objects using higher-order functions as validators.</li>
                <li>Implement a pipeline for processing text data with customizable transformation functions.</li>
                <li>Build a simple reactive programming system with observables and transformations.</li>
                <li>Create a set of decorators for common cross-cutting concerns (logging, timing, caching, etc.).</li>
                <li>Implement a retry mechanism with configurable backoff strategy using higher-order functions.</li>
                <li>Build a simple DSL for constructing and executing database queries.</li>
            </ol>
            <p>
                These exercises will help you build proficiency with higher-order functions and understand how they can be applied to solve real-world problems.
            </p>
        </section>

        <section class="further_reading">
            <h2>Further Reading</h2>
            <ul>
                <li>Python Documentation: <a href="https://docs.python.org/3/howto/functional.html" target="_blank">Functional Programming HOWTO</a></li>
                <li>Python Documentation: <a href="https://docs.python.org/3/library/functools.html" target="_blank">functools â€” Higher-order functions and operations on callable objects</a></li>
                <li>Book: "Functional Programming in Python" by David Mertz</li>
                <li>Book: "Fluent Python" by Luciano Ramalho (Chapters on Functions and Closures)</li>
                <li>Book: "Python Cookbook" by David Beazley and Brian K. Jones (Chapter 7: Functions)</li>
                <li>Online Course: "Functional Programming with Python" on various learning platforms</li>
                <li>Library: <a href="https://pypi.org/project/toolz/" target="_blank">Toolz</a> - A functional utility library for Python</li>
                <li>Library: <a href="https://pypi.org/project/fn/" target="_blank">fn.py</a> - Functional programming in Python with a focus on higher-order functions</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
