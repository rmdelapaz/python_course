<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Full Stack Web Developer Course - Importing Modules</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 2: Python Fundamentals (Part 1)</h2>
        <h3>Friday Morning: Importing Modules</h3>
    </header>

    <main>
        <section class="introduction">
            <h3>Introduction to Python Modules</h3>
            <p>Welcome to our session on Python modules! Today, we're going to explore one of the most powerful features in Python that makes it a truly modular and reusable programming language.</p>
            
            <p>Think of modules as the building blocks of Python programming – like LEGO pieces that you can assemble in various ways to create complex structures. Without modules, we'd need to write everything from scratch every time we create a new program. Imagine building a house and having to manufacture each brick by hand rather than using pre-made bricks!</p>
        </section>

        <section class="what-are-modules">
            <h3>What Are Python Modules?</h3>
            
            <p>A module in Python is simply a file containing Python code. That's it! Any Python file with the <code>.py</code> extension is a module. When you write a Python script, you've actually created a module that could be imported and used by other scripts.</p>
            
            <p>Modules serve several key purposes:</p>
            <ul>
                <li><strong>Code Organization</strong>: They help you organize related code into manageable units</li>
                <li><strong>Code Reusability</strong>: Write once, use many times</li>
                <li><strong>Namespace Management</strong>: Prevent naming conflicts between different parts of your program</li>
                <li><strong>Implementation Hiding</strong>: Abstract away complex implementation details</li>
            </ul>
            
            <p><strong>Real-World Analogy:</strong> Think of modules like specialized departments in a company. When you need legal work done, you don't train yourself in law – you consult the legal department. Similarly, when you need mathematical calculations, you import the <code>math</code> module rather than implementing complex algorithms yourself.</p>
        </section>

        <section class="importing-modules">
            <h3>Basic Module Importing</h3>
            
            <p>To use a module in Python, you need to import it into your script. There are several ways to import modules:</p>
            
            <h4>1. Simple Import</h4>
            <p>The most basic way to import a module:</p>
            <pre><code>import math

# Now you can use functions from the math module
result = math.sqrt(16)
print(result)  # Output: 4.0</code></pre>
            
            <p>In this case, you access the module's contents using the dot notation: <code>module_name.function_name()</code>.</p>
            
            <h4>2. Import with an Alias</h4>
            <p>You can give a module a shorter or different name (alias) when importing:</p>
            <pre><code>import math as m

# Now you can use the shorter alias
result = m.sqrt(16)
print(result)  # Output: 4.0</code></pre>
            
            <p>This is particularly useful for modules with long names or to avoid naming conflicts.</p>
            
            <h4>3. Import Specific Items</h4>
            <p>You can import specific functions, classes, or variables from a module:</p>
            <pre><code>from math import sqrt, pi

# Now you can use these directly without the module prefix
result = sqrt(16)
print(result)  # Output: 4.0
print(pi)      # Output: 3.141592653589793</code></pre>
            
            <h4>4. Import All Items (Use with Caution)</h4>
            <p>You can import everything from a module, but this is generally discouraged because it can lead to naming conflicts and make code harder to understand:</p>
            <pre><code>from math import *

# Now you can use any function from math directly
result = sqrt(16)
print(result)  # Output: 4.0</code></pre>
            
            <p><strong>Real-World Example:</strong> If you're building a web application that processes images, you might import the Pillow library like this:</p>
            <pre><code>from PIL import Image, ImageFilter

# Open an image file
img = Image.open('profile_picture.jpg')

# Apply a blur filter
blurred_img = img.filter(ImageFilter.BLUR)

# Save the processed image
blurred_img.save('profile_picture_blurred.jpg')</code></pre>
        </section>

        <section class="standard-library">
            <h3>Python Standard Library Modules</h3>
            
            <p>Python comes with a rich set of built-in modules called the Standard Library. These modules are ready to use without any additional installation. Here are some commonly used ones:</p>
            
            <ul>
                <li><code>math</code>: Mathematical functions</li>
                <li><code>random</code>: Random number generation</li>
                <li><code>datetime</code>: Date and time handling</li>
                <li><code>os</code>: Operating system interfaces</li>
                <li><code>sys</code>: System-specific parameters and functions</li>
                <li><code>json</code>: JSON encoding and decoding</li>
                <li><code>re</code>: Regular expressions</li>
                <li><code>collections</code>: Specialized container datatypes</li>
                <li><code>itertools</code>: Functions for efficient looping</li>
                <li><code>functools</code>: Higher-order functions and operations on callable objects</li>
            </ul>
            
            <p><strong>Example: Using the datetime module</strong></p>
            <pre><code>import datetime

# Get current date and time
now = datetime.datetime.now()
print(f"Current date and time: {now}")

# Create a specific date
birthdate = datetime.date(1990, 1, 1)
print(f"Birthdate: {birthdate}")

# Calculate time difference
time_difference = now.date() - birthdate
print(f"Days lived: {time_difference.days}")</code></pre>
            
            <p><strong>Real-World Application:</strong> The <code>datetime</code> module is essential for building apps that handle appointments, bookings, user registrations, or any feature that involves scheduling or age verification.</p>
        </section>

        <section class="creating-modules">
            <h3>Creating Your Own Modules</h3>
            
            <p>Creating your own module is as simple as writing a Python file. Let's create a simple utility module for our web development project.</p>
            
            <p>File location: <code>/project/utils/string_utils.py</code></p>
            <pre><code># string_utils.py - A module for string manipulation utilities

def reverse_string(text):
    """Return the reversed version of the input string."""
    return text[::-1]

def capitalize_words(text):
    """Capitalize the first letter of each word in the text."""
    return ' '.join(word.capitalize() for word in text.split())

def count_word_frequency(text):
    """Count frequency of each word in the text and return a dictionary."""
    words = text.lower().split()
    frequency = {}
    for word in words:
        # Remove punctuation from word
        word = word.strip('.,?!;:()"\'')
        if word:
            frequency[word] = frequency.get(word, 0) + 1
    return frequency

# This will only run when the module is executed directly
if __name__ == "__main__":
    # Test code
    test_string = "hello world, this is a test string"
    print(f"Original: {test_string}")
    print(f"Reversed: {reverse_string(test_string)}")
    print(f"Capitalized: {capitalize_words(test_string)}")
    print(f"Word frequency: {count_word_frequency(test_string)}")
</code></pre>
            
            <p>Now you can import and use this module in another file:</p>
            
            <p>File location: <code>/project/app.py</code></p>
            <pre><code># Import our custom module
from utils.string_utils import reverse_string, capitalize_words

# Use the imported functions
user_input = input("Enter some text: ")
print(f"Your text capitalized: {capitalize_words(user_input)}")
print(f"Your text reversed: {reverse_string(user_input)}")
</code></pre>
            
            <p><strong>Important Note:</strong> The <code>if __name__ == "__main__":</code> block is a common Python idiom. Code inside this block only runs when the file is executed directly (not when imported). This allows you to include test code or standalone functionality that won't execute when the module is imported by another script.</p>
        </section>

        <section class="module-search">
            <h3>How Python Finds Modules</h3>
            
            <p>When you import a module, Python searches for it in several locations, in this order:</p>
            
            <ol>
                <li>The directory containing the input script (or current directory if interactive)</li>
                <li>The list of directories in the <code>PYTHONPATH</code> environment variable</li>
                <li>The installation-dependent default directories (site-packages, etc.)</li>
            </ol>
            
            <p>You can see the list of directories Python searches by checking the <code>sys.path</code> variable:</p>
            
            <pre><code>import sys
print(sys.path)</code></pre>
            
            <p><strong>Analogy:</strong> Think of module searching like how you look for a book. First, you check your desk, then your bookshelf, then maybe the local library. Python follows a similar hierarchy when looking for modules.</p>
        </section>

        <section class="packages">
            <h3>Understanding Packages</h3>
            
            <p>Packages are a way to organize related modules into a single directory hierarchy. A package is simply a directory that contains a special file called <code>__init__.py</code> (which can be empty) and other Python modules or subpackages.</p>
            
            <p>Here's an example structure for a web application project:</p>
            
            <pre><code>my_web_app/
│
├── __init__.py
├── app.py
│
├── auth/
│   ├── __init__.py
│   ├── user.py
│   └── permissions.py
│
├── database/
│   ├── __init__.py
│   ├── models.py
│   └── queries.py
│
└── utils/
    ├── __init__.py
    ├── string_utils.py
    └── validators.py</code></pre>
            
            <p>With this structure, you can import modules with dot notation:</p>
            
            <pre><code># Import a specific function from a module in a package
from my_web_app.utils.string_utils import capitalize_words

# Import an entire module from a package
from my_web_app.auth import user

# Import a package
import my_web_app.database</code></pre>
            
            <p><strong>Real-World Analogy:</strong> If modules are like individual books, packages are like bookshelves organized by topic. Just as a library organizes books into sections (fiction, non-fiction, reference), packages organize modules into logical groups.</p>
            
            <p><strong>In Production:</strong> Real-world projects might have dozens or hundreds of modules. Packages help maintain organization and prevent namespace collisions. Major web frameworks like Django and Flask use package structures extensively.</p>
        </section>

        <section class="init-files">
            <h3>The Role of __init__.py Files</h3>
            
            <p>The <code>__init__.py</code> file serves several purposes in Python packages:</p>
            
            <ol>
                <li>It marks a directory as a Python package</li>
                <li>It can initialize package-level variables</li>
                <li>It can import specific modules to make them available when the package is imported</li>
                <li>It can define what symbols are exported when using <code>from package import *</code></li>
            </ol>
            
            <p>Here's an example of an <code>__init__.py</code> file for our utils package:</p>
            
            <p>File location: <code>/project/utils/__init__.py</code></p>
            <pre><code># __init__.py for utils package

# Import commonly used functions to make them available directly from the package
from .string_utils import reverse_string, capitalize_words
from .validators import validate_email, validate_phone

# Define what gets imported with "from utils import *"
__all__ = ['reverse_string', 'capitalize_words', 'validate_email', 'validate_phone']

# Package metadata
__version__ = '0.1.0'
__author__ = 'Your Name'</code></pre>
            
            <p>With this setup, users can import functions directly from the package:</p>
            
            <pre><code># Instead of this:
from utils.string_utils import capitalize_words

# You can do this:
from utils import capitalize_words</code></pre>
            
            <p><strong>Note:</strong> The dot before the module name in <code>from .string_utils import ...</code> indicates a relative import. It means "import from a module in the same package."</p>
        </section>

        <section class="virtual-environments">
            <h3>Modules in Virtual Environments</h3>
            
            <p>When working with virtual environments (which we set up earlier this week), each environment has its own set of installed packages. This isolation is crucial for managing dependencies across different projects.</p>
            
            <p>Consider this scenario: Project A needs Django 2.2, while Project B requires Django 3.2. Without virtual environments, this would be impossible to manage on a single system.</p>
            
            <p>When you activate a virtual environment, Python's module search path is modified to look in the environment's package directory first:</p>
            
            <pre><code># Create and activate a virtual environment
# In your terminal or command prompt:

# On Windows
python -m venv my_env
my_env\Scripts\activate

# On macOS/Linux
python -m venv my_env
source my_env/bin/activate

# Install a package in the environment
pip install requests

# Now in Python, you can import the installed package
import requests
</code></pre>
            
            <p><strong>Analogy:</strong> Virtual environments are like separate toolboxes for different projects. Each toolbox contains only the tools (modules) needed for that specific project, avoiding confusion and conflicts between projects.</p>
        </section>

        <section class="practical-examples">
            <h3>Practical Examples: Real-World Module Usage</h3>
            
            <h4>Example 1: Building a Weather App</h4>
            <p>Let's see how modules can be used in a simple weather application:</p>
            
            <pre><code># File: weather_app/weather_service.py

import requests
import json
from datetime import datetime

API_KEY = "your_api_key_here"
BASE_URL = "https://api.openweathermap.org/data/2.5/weather"

def get_weather(city_name):
    """Get current weather for a city."""
    params = {
        "q": city_name,
        "appid": API_KEY,
        "units": "metric"
    }
    
    response = requests.get(BASE_URL, params=params)
    
    if response.status_code == 200:
        return response.json()
    else:
        return None

def format_weather_data(weather_data):
    """Format the weather data for display."""
    if weather_data is None:
        return "Unable to retrieve weather data."
    
    city = weather_data["name"]
    country = weather_data["sys"]["country"]
    temp = weather_data["main"]["temp"]
    feels_like = weather_data["main"]["feels_like"]
    description = weather_data["weather"][0]["description"]
    humidity = weather_data["main"]["humidity"]
    wind_speed = weather_data["wind"]["speed"]
    timestamp = weather_data["dt"]
    
    # Convert timestamp to readable date/time
    date_time = datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')
    
    formatted_data = f"""
Weather for {city}, {country} at {date_time}:
Temperature: {temp}°C (Feels like: {feels_like}°C)
Conditions: {description.capitalize()}
Humidity: {humidity}%
Wind Speed: {wind_speed} m/s
"""
    return formatted_data</code></pre>
            
            <p>Now we can use this module in our main application:</p>
            
            <pre><code># File: weather_app/app.py

from weather_service import get_weather, format_weather_data

def main():
    print("Welcome to the Weather App!")
    city = input("Enter a city name: ")
    
    weather_data = get_weather(city)
    formatted_weather = format_weather_data(weather_data)
    
    print(formatted_weather)

if __name__ == "__main__":
    main()</code></pre>
            
            <h4>Example 2: Data Processing Application</h4>
            <p>Here's how you might use modules in a data processing application:</p>
            
            <pre><code># File: data_processor/data_loader.py

import csv
import json
import os

def load_csv(file_path):
    """Load data from a CSV file into a list of dictionaries."""
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")
    
    data = []
    with open(file_path, 'r', newline='', encoding='utf-8') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            data.append(row)
    
    return data

def load_json(file_path):
    """Load data from a JSON file."""
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")
    
    with open(file_path, 'r', encoding='utf-8') as jsonfile:
        data = json.load(jsonfile)
    
    return data

def save_csv(data, file_path, fieldnames=None):
    """Save a list of dictionaries to a CSV file."""
    if not fieldnames and data:
        fieldnames = data[0].keys()
    
    with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(data)
    
    return True

def save_json(data, file_path):
    """Save data to a JSON file."""
    with open(file_path, 'w', encoding='utf-8') as jsonfile:
        json.dump(data, jsonfile, indent=4)
    
    return True</code></pre>
            
            <pre><code># File: data_processor/data_analyzer.py

def calculate_stats(data, numeric_field):
    """Calculate basic statistics for a numeric field in the data."""
    values = []
    for item in data:
        try:
            values.append(float(item[numeric_field]))
        except (ValueError, KeyError):
            continue
    
    if not values:
        return {
            "count": 0,
            "min": None,
            "max": None,
            "avg": None,
            "sum": None
        }
    
    return {
        "count": len(values),
        "min": min(values),
        "max": max(values),
        "avg": sum(values) / len(values),
        "sum": sum(values)
    }

def filter_data(data, field, value, comparison="equals"):
    """Filter data based on criteria."""
    result = []
    
    for item in data:
        if field not in item:
            continue
            
        if comparison == "equals" and item[field] == value:
            result.append(item)
        elif comparison == "contains" and value in item[field]:
            result.append(item)
        elif comparison == "greater_than" and float(item[field]) > float(value):
            result.append(item)
        elif comparison == "less_than" and float(item[field]) < float(value):
            result.append(item)
    
    return result</code></pre>
            
            <pre><code># File: data_processor/app.py

from data_loader import load_csv, save_json
from data_analyzer import calculate_stats, filter_data

def main():
    # Load sales data from CSV
    try:
        sales_data = load_csv("sales.csv")
        print(f"Loaded {len(sales_data)} sales records")
        
        # Calculate statistics on the amount field
        amount_stats = calculate_stats(sales_data, "amount")
        print(f"Sales Statistics:")
        print(f"  Total: ${amount_stats['sum']:.2f}")
        print(f"  Average: ${amount_stats['avg']:.2f}")
        print(f"  Min: ${amount_stats['min']:.2f}")
        print(f"  Max: ${amount_stats['max']:.2f}")
        
        # Filter for high-value sales
        high_value_sales = filter_data(sales_data, "amount", 1000, "greater_than")
        print(f"Found {len(high_value_sales)} high-value sales")
        
        # Save high-value sales to JSON
        save_json(high_value_sales, "high_value_sales.json")
        print("High-value sales saved to high_value_sales.json")
        
    except FileNotFoundError as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    main()</code></pre>
        </section>

        <section class="best-practices">
            <h3>Best Practices for Module Organization</h3>
            
            <ol>
                <li><strong>Single Responsibility Principle</strong>: Each module should have a single, well-defined purpose.</li>
                <li><strong>Logical Grouping</strong>: Group related functionality into the same module.</li>
                <li><strong>Size Constraints</strong>: If a module grows too large (over 500-1000 lines), consider splitting it.</li>
                <li><strong>Clear Naming</strong>: Module names should clearly indicate their purpose.</li>
                <li><strong>Import Organization</strong>: Keep imports at the top of your file, organized in groups (standard library, third-party, local).</li>
                <li><strong>Avoid Circular Imports</strong>: Design your modules to avoid circular dependencies.</li>
                <li><strong>Use Relative Imports</strong>: In packages, use relative imports for better maintainability.</li>
                <li><strong>Provide Documentation</strong>: Include docstrings explaining the purpose and usage of your module.</li>
            </ol>
            
            <p><strong>Recommended Module Organization Pattern:</strong></p>
            <pre><code># 1. Standard library imports
import os
import sys
import json

# 2. Third-party library imports
import requests
import numpy as np

# 3. Local application imports
from .helpers import format_string
from ..database import models

# 4. Module constants
API_KEY = "your_key_here"
BASE_URL = "https://api.example.com"

# 5. Module classes and functions
class DataProcessor:
    """Process data from the API."""
    ...

def get_data():
    """Retrieve data from the API."""
    ...

# 6. Main block (if applicable)
if __name__ == "__main__":
    ...
</code></pre>
        </section>

        <section class="exercise">
            <h3>Exercise: Creating a Module-Based Project</h3>
            
            <p>Let's put this into practice. Your task is to create a small module-based project called <code>text_analyzer</code> that can analyze text files. Here's the structure:</p>
            
            <pre><code>text_analyzer/
├── __init__.py
├── main.py
├── readers/
│   ├── __init__.py
│   ├── file_reader.py
│   └── web_reader.py
└── analyzers/
    ├── __init__.py
    ├── word_analyzer.py
    └── sentiment_analyzer.py</code></pre>
            
            <p>Key requirements:</p>
            <ol>
                <li>The module should be able to read text from files or web pages</li>
                <li>It should count words, sentences, and paragraphs</li>
                <li>It should calculate readability metrics</li>
                <li>It should provide a simple sentiment analysis</li>
                <li>The main.py should provide a command-line interface to these features</li>
            </ol>
            
            <p>This exercise will help you apply the concepts of module organization, imports, and package structure that we've covered today.</p>
        </section>

        <section class="advanced-topics">
            <h3>Advanced Module Topics to Explore</h3>
            
            <p>As you continue your Python journey, here are some advanced module-related topics to explore:</p>
            
            <ul>
                <li><strong>Dynamic Imports</strong>: Using <code>importlib</code> for runtime module loading</li>
                <li><strong>Module Introspection</strong>: Examining module contents programmatically</li>
                <li><strong>Namespace Packages</strong>: Packages split across multiple directories</li>
                <li><strong>Lazy Imports</strong>: Delaying imports until they're needed for performance</li>
                <li><strong>Module Patching</strong>: For testing and mocking</li>
                <li><strong>Writing Extensions</strong>: Python modules in C/C++ for performance</li>
            </ul>
        </section>

        <section class="conclusion">
            <h3>Conclusion</h3>
            
            <p>Modules are the building blocks that make Python a powerful, flexible language for real-world development. By organizing code into modules and packages, you can create maintainable, reusable software components that scale from simple scripts to enterprise applications.</p>
            
            <p>In our upcoming web development work, modules will be essential for organizing the different components of our applications – from database access to API endpoints to user authentication.</p>
            
            <p>Remember: Well-organized modules lead to clear, maintainable code. As the saying goes, "A place for everything, and everything in its place."</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
