<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Full Stack Web Developer Course - Virtual Environments Best Practices</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 2: Python Fundamentals (Part 1)</h2>
        <h3>Friday Morning: Virtual Environments Best Practices</h3>
    </header>

    <main>
        <section class="introduction">
            <h3>Introduction to Virtual Environments</h3>
            <p>Welcome to our deep dive into Python virtual environments! While we've already set up virtual environments earlier this week, today we'll explore why they're so important and learn best practices for using them effectively in professional development.</p>
            
            <p>Think of virtual environments as isolated workspaces for your Python projects. Just as a chef keeps ingredients for different dishes separate to avoid cross-contamination, virtual environments keep your project dependencies separate to avoid conflicts. This isolation is crucial for creating reproducible, reliable, and shareable Python applications.</p>
        </section>

        <section class="why-virtual-environments">
            <h3>Why Virtual Environments are Essential</h3>
            
            <p>Before diving into best practices, let's understand the core problems that virtual environments solve:</p>
            
            <h4>1. Dependency Isolation</h4>
            <p>Different projects often require different versions of the same package. Without virtual environments, this is impossible to manage in a single Python installation.</p>
            
            <p><strong>Real-World Scenario:</strong> Project A requires Django 2.2 (which supports Python 3.5+), while Project B needs Django 3.2 (which requires Python 3.6+). Without virtual environments, you'd need to constantly uninstall and reinstall different versions, or compromise on one project's requirements.</p>
            
            <h4>2. System Python Protection</h4>
            <p>Your operating system might rely on specific Python packages. Modifying these for your project could break system functionality.</p>
            
            <p><strong>Real-World Scenario:</strong> Many Linux distributions use Python for system utilities. Installing conflicting packages globally could render your package manager or other system tools inoperable.</p>
            
            <h4>3. Clean Dependency Tracking</h4>
            <p>Virtual environments make it easy to track exactly what packages your project needs.</p>
            
            <p><strong>Real-World Scenario:</strong> When a new developer joins your team, they can recreate your exact environment without guessing which packages to install.</p>
            
            <h4>4. Reproducible Builds</h4>
            <p>Ensures that your application works the same way everywhere—development, testing, and production.</p>
            
            <p><strong>Real-World Scenario:</strong> Avoiding the dreaded "it works on my machine" problem when deploying to production or sharing with teammates.</p>
        </section>

        <section class="virtual-environment-tools">
            <h3>Virtual Environment Tools Comparison</h3>
            
            <p>Several tools exist for creating and managing Python virtual environments. Let's compare the most common ones:</p>
            
            <table>
                <tr>
                    <th>Tool</th>
                    <th>Pros</th>
                    <th>Cons</th>
                    <th>Best For</th>
                </tr>
                <tr>
                    <td><code>venv</code></td>
                    <td>
                        <ul>
                            <li>Built into Python 3.3+</li>
                            <li>Simple to use</li>
                            <li>No additional installation</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Basic functionality only</li>
                            <li>No dependency management</li>
                            <li>Windows requires additional steps</li>
                        </ul>
                    </td>
                    <td>Simple projects and learning Python</td>
                </tr>
                <tr>
                    <td><code>virtualenv</code></td>
                    <td>
                        <ul>
                            <li>Works with Python 2 and 3</li>
                            <li>More features than venv</li>
                            <li>Faster environment creation</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Requires separate installation</li>
                            <li>No dependency management</li>
                        </ul>
                    </td>
                    <td>Projects supporting legacy Python</td>
                </tr>
                <tr>
                    <td><code>conda</code></td>
                    <td>
                        <ul>
                            <li>Cross-platform package manager</li>
                            <li>Handles non-Python dependencies</li>
                            <li>Creates isolated environments</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Larger installation footprint</li>
                            <li>Sometimes conflicts with pip</li>
                            <li>Different from standard Python tooling</li>
                        </ul>
                    </td>
                    <td>Data science and scientific computing</td>
                </tr>
                <tr>
                    <td><code>pipenv</code></td>
                    <td>
                        <ul>
                            <li>Combines pip and virtualenv</li>
                            <li>Automatic dependency management</li>
                            <li>Lock files for deterministic builds</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Sometimes slower than alternatives</li>
                            <li>Learning curve for beginners</li>
                        </ul>
                    </td>
                    <td>Application development with dependency locking</td>
                </tr>
                <tr>
                    <td><code>poetry</code></td>
                    <td>
                        <ul>
                            <li>Modern dependency resolution</li>
                            <li>Package building and publishing</li>
                            <li>Intuitive commands</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Newer tool, still evolving</li>
                            <li>More opinionated workflow</li>
                        </ul>
                    </td>
                    <td>Library development and modern applications</td>
                </tr>
            </table>
            
            <p>For the remainder of this course, we'll primarily use <code>venv</code> since it's built into Python and sufficient for our needs. However, we'll note where other tools might offer advantages in specific scenarios.</p>
            
            <p><strong>Analogy:</strong> Virtual environment tools are like different types of kitchen organization systems—some are simple drawer dividers (<code>venv</code>), some are specialized spice racks (<code>virtualenv</code>), and others are complete kitchen remodels with custom cabinets (<code>conda</code>, <code>pipenv</code>, <code>poetry</code>). The best choice depends on what you're cooking and how often.</p>
        </section>

        <section class="venv-review">
            <h3>Quick Review: Creating and Using Virtual Environments with venv</h3>
            
            <p>Let's quickly review the basic commands for working with <code>venv</code>:</p>
            
            <h4>Creating a Virtual Environment</h4>
            <pre><code># On Windows
python -m venv myenv

# On macOS/Linux
python3 -m venv myenv</code></pre>
            
            <h4>Activating a Virtual Environment</h4>
            <pre><code># On Windows
myenv\Scripts\activate

# On macOS/Linux
source myenv/bin/activate</code></pre>
            
            <h4>Deactivating a Virtual Environment</h4>
            <pre><code>deactivate</code></pre>
            
            <h4>Installing Packages in a Virtual Environment</h4>
            <pre><code># Make sure the environment is activated first
pip install package_name

# Install multiple packages
pip install package1 package2 package3

# Install with specific version
pip install package==1.2.3

# Install from requirements file
pip install -r requirements.txt</code></pre>
            
            <h4>Capturing Dependencies</h4>
            <pre><code># Create or update requirements.txt
pip freeze > requirements.txt</code></pre>
            
            <p>Now, let's move beyond the basics to best practices that will make your virtual environment workflow more effective.</p>
        </section>

        <section class="naming-conventions">
            <h3>Virtual Environment Naming and Location</h3>
            
            <h4>Naming Conventions</h4>
            <p>Consistent naming helps you and your team identify environments quickly:</p>
            
            <ul>
                <li><strong>Project-Based Naming</strong>: Name environments after your project, possibly with a suffix indicating purpose or Python version.</li>
                <li><strong>Version-Based Naming</strong>: Include Python version if you work with multiple versions.</li>
            </ul>
            
            <p>Examples of good environment names:</p>
            <ul>
                <li><code>myapp-env</code> - Basic project environment</li>
                <li><code>myapp-3.9</code> - Project environment for Python 3.9</li>
                <li><code>myapp-dev</code> / <code>myapp-prod</code> - Separate environments for development/production settings</li>
            </ul>
            
            <h4>Environment Location</h4>
            <p>Where you place your virtual environments matters:</p>
            
            <h5>Option 1: Inside Project Directory (Recommended for Most Projects)</h5>
            <pre><code>my_project/
├── .git/
├── venv/           # Virtual environment
├── src/
├── tests/
├── requirements.txt
└── README.md</code></pre>
            
            <p><strong>Pros:</strong></p>
            <ul>
                <li>Self-contained project directory</li>
                <li>Clear association between project and environment</li>
                <li>Easy to delete/recreate along with the project</li>
            </ul>
            
            <p><strong>Cons:</strong></p>
            <ul>
                <li>Takes up space in version control (if not properly ignored)</li>
                <li>Can accidentally include environment files in project</li>
            </ul>
            
            <h5>Option 2: Central Environment Directory</h5>
            <pre><code>~/.virtualenvs/
├── project1-env/
├── project2-env/
└── project3-env/</code></pre>
            
            <p><strong>Pros:</strong></p>
            <ul>
                <li>Keeps projects clean</li>
                <li>Easier to manage multiple environments</li>
                <li>No risk of accidentally versioning environment files</li>
            </ul>
            
            <p><strong>Cons:</strong></p>
            <ul>
                <li>Environments can become "orphaned" when projects are deleted</li>
                <li>Less intuitive for beginners</li>
                <li>Requires remembering which environment goes with which project</li>
            </ul>
            
            <h4>Environment Location Best Practices</h4>
            <ul>
                <li><strong>For individual projects</strong>: Inside project directory, add to <code>.gitignore</code></li>
                <li><strong>For many related projects</strong>: Central directory with consistent naming</li>
                <li><strong>For team environments</strong>: Document the convention you choose</li>
            </ul>
        </section>
        
        <section class="dependency-management">
            <h3>Dependency Management Best Practices</h3>
            
            <h4>Use Requirements Files Effectively</h4>
            
            <p>Requirements files (<code>requirements.txt</code>) are the standard way to capture and share dependencies. Here are best practices for using them:</p>
            
            <h5>1. Use Version Pinning</h5>
            <p>Always specify exact versions to ensure reproducible environments:</p>
            
            <pre><code># Not recommended (loose dependencies)
requests
flask
sqlalchemy

# Recommended (pinned versions)
requests==2.28.1
flask==2.2.2
sqlalchemy==1.4.41</code></pre>
            
            <h5>2. Organize Multiple Requirements Files</h5>
            <p>For complex projects, split requirements by environment:</p>
            
            <pre><code># requirements/
# ├── base.txt        - Core dependencies for all environments
# ├── development.txt - Additional tools for development
# ├── production.txt  - Production-specific packages
# └── testing.txt     - Testing-specific packages

# Example of development.txt
-r base.txt           # Include base requirements
pytest==7.1.3
black==22.8.0
flake8==5.0.4</code></pre>
            
            <h5>3. Include Comments</h5>
            <p>Document why certain packages are needed or specific versions are required:</p>
            
            <pre><code># Web framework
flask==2.2.2

# ORM for database access
sqlalchemy==1.4.41

# JWT-based authentication
# Pinned to 2.4.0 because 2.5.0 has a security issue
pyjwt==2.4.0

# Date handling utilities
python-dateutil==2.8.2</code></pre>
            
            <h5>4. Consider Requirements.in Files</h5>
            <p>For more control, separate direct dependencies from their sub-dependencies using <code>pip-tools</code>:</p>
            
            <pre><code># requirements.in - Only direct dependencies
flask>=2.2.0
sqlalchemy>=1.4.0
requests>=2.27.0

# Generate full requirements.txt with pinned versions
# pip-compile requirements.in > requirements.txt</code></pre>
            
            <h4>Beyond requirements.txt</h4>
            <p>Modern Python projects often use more sophisticated dependency management:</p>
            
            <h5>1. Pipenv's Pipfile and Pipfile.lock</h5>
            <pre><code># Install pipenv
pip install pipenv

# Create new environment and Pipfile
pipenv install flask sqlalchemy

# Add development dependencies
pipenv install --dev pytest black

# Generate lock file
pipenv lock</code></pre>
            
            <p>The resulting <code>Pipfile</code> separates direct dependencies from dev dependencies:</p>
            
            <pre><code>[packages]
flask = "*"
sqlalchemy = "*"

[dev-packages]
pytest = "*"
black = "*"

[requires]
python_version = "3.9"</code></pre>
            
            <h5>2. Poetry's pyproject.toml</h5>
            <pre><code># Install poetry
pip install poetry

# Initialize a new project
poetry new myproject
cd myproject

# Add dependencies
poetry add flask sqlalchemy

# Add development dependencies
poetry add --dev pytest black

# The resulting pyproject.toml:
[tool.poetry.dependencies]
python = "^3.9"
flask = "^2.2.2"
sqlalchemy = "^1.4.41"

[tool.poetry.dev-dependencies]
pytest = "^7.1.3"
black = "^22.8.0"</code></pre>
            
            <h4>Dependency Management Best Practices Summary</h4>
            <ul>
                <li><strong>Always pin versions</strong> for reproducible builds</li>
                <li><strong>Document dependencies</strong> with comments</li>
                <li><strong>Separate development dependencies</strong> from production ones</li>
                <li><strong>Regularly update dependencies</strong> for security fixes</li>
                <li><strong>Consider modern tools</strong> for complex projects</li>
            </ul>
        </section>

        <section class="virtual-env-workflows">
            <h3>Virtual Environment Workflows</h3>
            
            <h4>Environment Setup Workflow</h4>
            <p>Follow these steps when setting up a new project:</p>
            
            <ol>
                <li><strong>Create project directory</strong>
                    <pre><code>mkdir myproject
cd myproject</code></pre>
                </li>
                <li><strong>Initialize version control</strong>
                    <pre><code>git init
echo "venv/" >> .gitignore    # Ignore virtual environment directory</code></pre>
                </li>
                <li><strong>Create virtual environment</strong>
                    <pre><code>python -m venv venv</code></pre>
                </li>
                <li><strong>Activate the environment</strong>
                    <pre><code>source venv/bin/activate  # macOS/Linux
venv\Scripts\activate    # Windows</code></pre>
                </li>
                <li><strong>Install initial dependencies</strong>
                    <pre><code>pip install flask sqlalchemy</code></pre>
                </li>
                <li><strong>Freeze dependencies</strong>
                    <pre><code>pip freeze > requirements.txt</code></pre>
                </li>
                <li><strong>Create initial project structure</strong>
                    <pre><code>mkdir src tests
touch README.md</code></pre>
                </li>
                <li><strong>Make initial commit</strong>
                    <pre><code>git add .
git commit -m "Initial project setup with virtual environment"</code></pre>
                </li>
            </ol>
            
            <h4>Joining an Existing Project Workflow</h4>
            <p>When joining a project that already has a defined environment:</p>
            
            <ol>
                <li><strong>Clone the repository</strong>
                    <pre><code>git clone https://github.com/username/project.git
cd project</code></pre>
                </li>
                <li><strong>Create virtual environment</strong>
                    <pre><code>python -m venv venv</code></pre>
                </li>
                <li><strong>Activate the environment</strong>
                    <pre><code>source venv/bin/activate  # macOS/Linux
venv\Scripts\activate    # Windows</code></pre>
                </li>
                <li><strong>Install dependencies</strong>
                    <pre><code>pip install -r requirements.txt</code></pre>
                </li>
                <li><strong>Verify installation</strong>
                    <pre><code>pip list
python -c "import flask; print(flask.__version__)"</code></pre>
                </li>
            </ol>
            
            <h4>Environment Maintenance Workflow</h4>
            <p>Regular maintenance tasks to keep your environment healthy:</p>
            
            <ul>
                <li><strong>Adding new dependencies</strong>
                    <pre><code>pip install new-package
pip freeze > requirements.txt
git add requirements.txt
git commit -m "Add new-package dependency"</code></pre>
                </li>
                <li><strong>Updating dependencies</strong>
                    <pre><code># Careful approach: update one package at a time
pip install --upgrade package-name
pip freeze > requirements.txt

# Bulk update (use with caution!)
pip install --upgrade -r requirements.txt
pip freeze > requirements.txt</code></pre>
                </li>
                <li><strong>Recreating from scratch</strong> (when things get messy)
                    <pre><code>deactivate
rm -rf venv/              # macOS/Linux
rmdir /s /q venv          # Windows
python -m venv venv
source venv/bin/activate  # macOS/Linux
venv\Scripts\activate     # Windows
pip install -r requirements.txt</code></pre>
                </li>
            </ul>
        </section>

        <section class="virtual-env-docker">
            <h3>Virtual Environments and Docker</h3>
            
            <p>As projects grow, you may use Docker alongside or instead of virtual environments. Understanding how they relate is important:</p>
            
            <h4>Differences Between Virtual Environments and Docker</h4>
            <table>
                <tr>
                    <th>Aspect</th>
                    <th>Virtual Environments</th>
                    <th>Docker</th>
                </tr>
                <tr>
                    <td>Isolation level</td>
                    <td>Python packages only</td>
                    <td>Full system isolation (OS, files, network)</td>
                </tr>
                <tr>
                    <td>System dependencies</td>
                    <td>Relies on host system</td>
                    <td>Self-contained, including OS libraries</td>
                </tr>
                <tr>
                    <td>Portability</td>
                    <td>Works only on compatible Python versions</td>
                    <td>Works the same on any Docker-compatible system</td>
                </tr>
                <tr>
                    <td>Resource usage</td>
                    <td>Very lightweight</td>
                    <td>More resource-intensive</td>
                </tr>
                <tr>
                    <td>Learning curve</td>
                    <td>Simple, Python-specific</td>
                    <td>Steeper, requires container knowledge</td>
                </tr>
            </table>
            
            <h4>When to Use Each</h4>
            <ul>
                <li><strong>Use virtual environments when:</strong>
                    <ul>
                        <li>Working on simple Python projects</li>
                        <li>You have a consistent development environment</li>
                        <li>You want minimal overhead</li>
                        <li>There are few or no system-level dependencies</li>
                    </ul>
                </li>
                <li><strong>Use Docker when:</strong>
                    <ul>
                        <li>Your application has complex system dependencies</li>
                        <li>You need to match production environment exactly</li>
                        <li>Your team uses different operating systems</li>
                        <li>You have microservices or multi-container applications</li>
                    </ul>
                </li>
            </ul>
            
            <h4>Using Both Together</h4>
            <p>Many developers use both tools in their workflow:</p>
            <ul>
                <li><strong>Virtual environment</strong> for daily development and testing</li>
                <li><strong>Docker</strong> for integration testing and deployment</li>
            </ul>
            
            <p>A common pattern is to maintain both a <code>requirements.txt</code> and a <code>Dockerfile</code>:</p>
            
            <pre><code># Developer workflow
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
python manage.py runserver

# Integration/deployment workflow
docker build -t myapp .
docker run -p 8000:8000 myapp</code></pre>
            
            <p>Example <code>Dockerfile</code> that uses the same requirements file:</p>
            
            <pre><code>FROM python:3.9-slim

WORKDIR /app

# Copy requirements first (for better caching)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Run the application
CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]</code></pre>
            
            <p><strong>Recommendation:</strong> As you progress in this course, you'll work with both virtual environments and Docker. Learn to use them appropriately for different scenarios, and understand how they complement each other in a professional development workflow.</p>
        </section>

        <section class="advanced-practices">
            <h3>Advanced Virtual Environment Practices</h3>
            
            <h4>Environment Variables and Settings</h4>
            <p>Keep configuration out of your code using environment variables:</p>
            
            <h5>1. Use <code>.env</code> files (with python-dotenv)</h5>
            <pre><code># Install python-dotenv
pip install python-dotenv

# Create .env file (NEVER commit to version control)
echo "DEBUG=True
SECRET_KEY=development-key-only
DATABASE_URL=sqlite:///dev.db" > .env

# Add to .gitignore
echo ".env" >> .gitignore</code></pre>
            
            <p>Using the variables in your code:</p>
            <pre><code># config.py
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

DEBUG = os.getenv("DEBUG", "False").lower() == "true"
SECRET_KEY = os.getenv("SECRET_KEY")
DATABASE_URL = os.getenv("DATABASE_URL")</code></pre>
            
            <h5>2. Environment-specific settings</h5>
            <p>Create different settings files or environment variable sets for different environments:</p>
            
            <pre><code>environments/
├── .env.development
├── .env.testing
└── .env.production</code></pre>
            
            <p>Loading a specific environment:</p>
            <pre><code># Load specific environment
from dotenv import load_dotenv

# Choose environment based on ENV variable
env_file = f".env.{os.getenv('ENV', 'development').lower()}"
load_dotenv(env_file)</code></pre>
            
            <h4>Virtual Environment Helpers</h4>
            <p>Tools to make virtual environment usage more convenient:</p>
            
            <h5>1. direnv</h5>
            <p>Automatically activates environments when entering directories:</p>
            
            <pre><code># Install direnv (macOS)
brew install direnv

# Add to shell configuration
echo 'eval "$(direnv hook bash)"' >> ~/.bashrc  # or .zshrc

# Create .envrc file in project directory
echo 'source venv/bin/activate' > .envrc
direnv allow</code></pre>
            
            <p>Now the environment activates automatically when you <code>cd</code> into the project directory!</p>
            
            <h5>2. virtualenvwrapper</h5>
            <p>Simplifies management of multiple virtual environments:</p>
            
            <pre><code># Install virtualenvwrapper
pip install virtualenvwrapper

# Add to shell configuration
echo 'export WORKON_HOME=$HOME/.virtualenvs
export PROJECT_HOME=$HOME/projects
source /usr/local/bin/virtualenvwrapper.sh' >> ~/.bashrc

# Create and work on environments
mkvirtualenv myproject
workon myproject
deactivate</code></pre>
            
            <h5>3. IDE Integration</h5>
            <p>Most modern IDEs have excellent virtual environment support:</p>
            <ul>
                <li><strong>VS Code</strong>: Automatically detects environments and prompts to use them</li>
                <li><strong>PyCharm</strong>: Built-in virtual environment management</li>
                <li><strong>Jupyter</strong>: Can add environments as kernels with <code>ipykernel</code></li>
            </ul>
            
            <h4>Handling Python Versions</h4>
            <p>Sometimes you need to work with multiple Python versions:</p>
            
            <h5>1. pyenv for Python Version Management</h5>
            <pre><code># Install pyenv (macOS)
brew install pyenv

# Install different Python versions
pyenv install 3.8.12
pyenv install 3.9.7
pyenv install 3.10.2

# Set global default
pyenv global 3.9.7

# Set version for a specific project
cd myproject
pyenv local 3.8.12

# Create virtual environment with specific version
pyenv local 3.10.2
python -m venv venv  # Uses Python 3.10.2</code></pre>
            
            <h5>2. tox for Testing Multiple Python Versions</h5>
            <p>Automatically test your code against multiple Python versions:</p>
            
            <pre><code># Install tox
pip install tox

# Create tox.ini
[tox]
envlist = py38,py39,py310

[testenv]
deps = pytest
commands = pytest</code></pre>
            
            <p>Run tests in all environments with a single command:</p>
            <pre><code>tox</code></pre>
        </section>

        <section class="troubleshooting">
            <h3>Troubleshooting Virtual Environments</h3>
            
            <h4>Common Issues and Solutions</h4>
            
            <h5>1. "Command not found" after activation</h5>
            <p><strong>Symptom:</strong> You activate an environment, but commands like <code>pip</code> or <code>python</code> aren't found.</p>
            <p><strong>Solution:</strong></p>
            <pre><code># Check if the environment has the expected structure
ls -la venv/bin  # macOS/Linux
dir venv\Scripts  # Windows

# If missing, recreate the environment
python3 -m venv --clear venv</code></pre>
            
            <h5>2. Packages installed but not available</h5>
            <p><strong>Symptom:</strong> You install a package with pip, but <code>import</code> fails.</p>
            <p><strong>Solution:</strong></p>
            <pre><code># Check if you have multiple Python installations
which python  # macOS/Linux
where python  # Windows

# Verify the environment is activated (look for "(venv)" in prompt)

# Check where pip is installing packages
pip --version

# Install explicitly to the environment
python -m pip install package_name</code></pre>
            
            <h5>3. Environment activation doesn't work</h5>
            <p><strong>Symptom:</strong> Activation script fails or doesn't change the environment.</p>
            <p><strong>Solution:</strong></p>
            <pre><code># Check activation script permissions
chmod +x venv/bin/activate  # macOS/Linux

# Try absolute path
source /full/path/to/venv/bin/activate  # macOS/Linux
C:\full\path\to\venv\Scripts\activate  # Windows

# Check for script errors
cat venv/bin/activate  # macOS/Linux
type venv\Scripts\activate  # Windows</code></pre>
            
            <h5>4. "pip install" fails for compiled packages</h5>
            <p><strong>Symptom:</strong> Packages with C extensions fail to install with compiler errors.</p>
            <p><strong>Solution:</strong></p>
            <pre><code># Install development tools
# On Ubuntu/Debian
sudo apt-get install python3-dev build-essential

# On macOS
xcode-select --install

# On Windows
# Install Visual Studio Build Tools

# Try binary wheels instead of source
pip install --only-binary=:all: package_name</code></pre>
            
            <h5>5. Virtual environment gets huge</h5>
            <p><strong>Symptom:</strong> Environment directory takes up gigabytes of space.</p>
            <p><strong>Solution:</strong></p>
            <pre><code># Clear pip cache
pip cache purge

# Remove __pycache__ directories
find venv -name __pycache__ -type d -exec rm -rf {} +  # macOS/Linux

# Sometimes it's faster to recreate
pip freeze > requirements.txt
deactivate
rm -rf venv
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt</code></pre>
            
            <h4>Debugging Techniques</h4>
            <ul>
                <li><strong>Check environment paths</strong>
                    <pre><code>python -c "import sys; print(sys.path)"</code></pre>
                </li>
                <li><strong>Verify package installation location</strong>
                    <pre><code>pip show package_name</code></pre>
                </li>
                <li><strong>Check environment interpreter</strong>
                    <pre><code>python -c "import sys; print(sys.executable)"</code></pre>
                </li>
                <li><strong>Run pip with verbosity</strong>
                    <pre><code>pip install -v package_name</code></pre>
                </li>
                <li><strong>Verify active Python version</strong>
                    <pre><code>python --version</code></pre>
                </li>
            </ul>
        </section>

        <section class="team-environments">
            <h3>Virtual Environments in Team Settings</h3>
            
            <h4>Establishing Team Conventions</h4>
            <p>Consistent practices are essential for team productivity:</p>
            
            <ul>
                <li><strong>Document environment setup</strong> in README.md
                    <pre><code># Development Setup

## Prerequisites
- Python 3.9+
- Git

## Environment Setup
1. Clone the repository
   ```
   git clone https://github.com/team/project.git
   cd project
   ```

2. Create a virtual environment
   ```
   python -m venv venv
   source venv/bin/activate  # macOS/Linux
   venv\Scripts\activate     # Windows
   ```

3. Install dependencies
   ```
   pip install -r requirements.txt
   ```

4. Set up environment variables
   ```
   cp .env.example .env
   # Edit .env with your local settings
   ```

5. Run initialization script
   ```
   python setup.py
   ```</code></pre>
                </li>
                <li><strong>Use setup scripts</strong> for complex initialization
                    <pre><code># setup.py
#!/usr/bin/env python
"""Project setup script"""
import os
import subprocess

def main():
    """Run setup steps"""
    print("Setting up development environment...")
    
    # Initialize database
    print("Creating database...")
    if not os.path.exists("instance"):
        os.mkdir("instance")
    subprocess.run(["python", "manage.py", "db", "init"], check=True)
    subprocess.run(["python", "manage.py", "db", "migrate"], check=True)
    subprocess.run(["python", "manage.py", "db", "upgrade"], check=True)
    
    # Create sample data
    print("Creating sample data...")
    subprocess.run(["python", "manage.py", "seed"], check=True)
    
    print("Setup complete! Run 'python manage.py run' to start the application.")

if __name__ == "__main__":
    main()</code></pre>
                </li>
                <li><strong>Standardize linting and formatting</strong> with configuration files
                    <pre><code># .flake8
[flake8]
max-line-length = 100
exclude = venv,.git,__pycache__,build,dist

# pyproject.toml (for black)
[tool.black]
line-length = 100
target-version = ['py39']
include = '\.pyi?$'
exclude = '''
/(
    \.git
  | \.venv
  | venv
  | _build
  | build
  | dist
)/
'''</code></pre>
                </li>
            </ul>
            
            <h4>Git Hooks for Environment Consistency</h4>
            <p>Use Git hooks to enforce standards:</p>
            
            <pre><code># .git/hooks/pre-commit (make executable with chmod +x)
#!/bin/bash

# Check that we're using the project's virtual environment
if [[ $VIRTUAL_ENV != *$(pwd)* ]]; then
    echo "ERROR: Virtual environment not activated or doesn't match project!"
    echo "Activate with: source venv/bin/activate"
    exit 1
fi

# Run linters and tests
echo "Running linters..."
flake8 src tests || exit 1
black --check src tests || exit 1

echo "Running tests..."
pytest -xvs tests/unit || exit 1

echo "Pre-commit checks passed!"</code></pre>
            
            <h4>Continuous Integration (CI) Environment</h4>
            <p>Configure CI systems to replicate your virtual environment setup:</p>
            
            <pre><code># .github/workflows/ci.yml
name: Python CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Lint
      run: |
        flake8 src tests
        black --check src tests
    
    - name: Test
      run: |
        pytest -xvs tests/
</code></pre>
        </section>

        <section class="real-world-example">
            <h3>Real-World Example: Flask Project Structure with Best Practices</h3>
            
            <p>Let's bring together everything we've learned with a practical example of a Flask web application that follows best practices:</p>
            
            <h4>Project Structure</h4>
            <pre><code>flask_app/
├── .env.example            # Example environment variables (template)
├── .flake8                 # Linting configuration
├── .gitignore              # Files to exclude from Git
├── .pre-commit-config.yaml # Pre-commit hooks configuration
├── README.md               # Project documentation
├── pyproject.toml          # Python project configuration (black, etc.)
├── requirements/
│   ├── base.txt            # Core dependencies
│   ├── development.txt     # Development tools
│   ├── production.txt      # Production-specific requirements
│   └── testing.txt         # Testing tools
├── setup.py                # Package installation script
├── src/
│   └── myapp/
│       ├── __init__.py     # Package initialization
│       ├── app.py          # Application factory
│       ├── config.py       # Configuration management
│       ├── models/         # Database models
│       ├── routes/         # API and view routes
│       ├── services/       # Business logic
│       ├── static/         # Static assets (CSS, JS)
│       └── templates/      # Jinja2 templates
├── tests/
│   ├── conftest.py         # Test fixtures
│   ├── unit/               # Unit tests
│   └── integration/        # Integration tests
└── venv/                   # Virtual environment (not in version control)</code></pre>
            
            <h4>Environment Setup Guide</h4>
            <p>Here's how the README.md would guide environment setup:</p>
            
            <pre><code># Flask App Example

A modern Flask application demonstrating Python best practices.

## Development Setup

### Prerequisites
- Python 3.9+
- Git

### Setting Up Your Development Environment

1. Clone the repository:
   ```
   git clone https://github.com/username/flask_app.git
   cd flask_app
   ```

2. Create and activate a virtual environment:
   ```
   python -m venv venv
   source venv/bin/activate  # macOS/Linux
   venv\Scripts\activate     # Windows
   ```

3. Install development dependencies:
   ```
   pip install -r requirements/development.txt
   ```

4. Set up your environment variables:
   ```
   cp .env.example .env
   # Edit .env with your settings
   ```

5. Set up pre-commit hooks:
   ```
   pre-commit install
   ```

6. Initialize the database:
   ```
   flask db init
   flask db migrate
   flask db upgrade
   ```

7. Run the development server:
   ```
   flask run
   ```

The application should now be running at http://127.0.0.1:5000/

### Testing

Run the test suite:
```
pytest
```

Run with coverage report:
```
pytest --cov=src/myapp
```</code></pre>
            
            <h4>Configuration Management</h4>
            <p>Example of the application's config.py:</p>
            
            <pre><code>"""Application configuration."""
import os
from pathlib import Path
from dotenv import load_dotenv

# Load environment variables from .env file
env_path = Path(".") / ".env"
load_dotenv(dotenv_path=env_path)

class Config:
    """Base configuration."""
    
    # Flask
    SECRET_KEY = os.getenv("SECRET_KEY", "dev-key-only-for-development")
    FLASK_ENV = os.getenv("FLASK_ENV", "development")
    DEBUG = os.getenv("DEBUG", "False").lower() == "true"
    
    # Database
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL", "sqlite:///app.db")
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    
    # Security
    SESSION_COOKIE_SECURE = os.getenv("SESSION_COOKIE_SECURE", "False").lower() == "true"
    REMEMBER_COOKIE_SECURE = True
    
class DevelopmentConfig(Config):
    """Development configuration."""
    DEBUG = True
    SQLALCHEMY_ECHO = True

class TestingConfig(Config):
    """Testing configuration."""
    TESTING = True
    SQLALCHEMY_DATABASE_URI = "sqlite:///:memory:"
    WTF_CSRF_ENABLED = False

class ProductionConfig(Config):
    """Production configuration."""
    DEBUG = False
    SESSION_COOKIE_SECURE = True
    
    # Override this in production environment
    if not os.getenv("SECRET_KEY"):
        raise ValueError("SECRET_KEY environment variable is required in production")

# Configuration dictionary
config = {
    "development": DevelopmentConfig,
    "testing": TestingConfig,
    "production": ProductionConfig,
    "default": DevelopmentConfig
}

def get_config():
    """Get the correct configuration based on environment."""
    env = os.getenv("FLASK_ENV", "development")
    return config.get(env, config["default"])</code></pre>
            
            <h4>Application Factory</h4>
            <p>The app.py module uses our configuration system:</p>
            
            <pre><code>"""Flask application factory."""
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

from myapp.config import get_config

# Initialize extensions
db = SQLAlchemy()
migrate = Migrate()

def create_app():
    """Create and configure the Flask application."""
    app = Flask(__name__)
    app.config.from_object(get_config())
    
    # Initialize extensions with app
    db.init_app(app)
    migrate.init_app(app, db)
    
    # Register blueprints
    from myapp.routes import main_bp, api_bp
    app.register_blueprint(main_bp)
    app.register_blueprint(api_bp, url_prefix='/api')
    
    # Register error handlers
    from myapp.errors import register_error_handlers
    register_error_handlers(app)
    
    return app</code></pre>
            
            <p>This example demonstrates:</p>
            <ul>
                <li>Proper virtual environment setup and documentation</li>
                <li>Environment-specific configuration</li>
                <li>Dependency management with separate requirement files</li>
                <li>Application structure that supports clean architecture</li>
                <li>Environment variables for configuration</li>
            </ul>
        </section>

        <section class="conclusions">
            <h3>Conclusion: Virtual Environment Principles to Live By</h3>
            
            <p>As we conclude our exploration of virtual environments, let's distill the key principles that will serve you well throughout your Python development career:</p>
            
            <ol>
                <li><strong>One Project, One Environment</strong>: Always create a dedicated virtual environment for each project.</li>
                <li><strong>Documentation is Key</strong>: Document your environment setup process thoroughly.</li>
                <li><strong>Version Pinning</strong>: Pin your dependency versions for reproducibility.</li>
                <li><strong>Isolation is Protection</strong>: Never install project-specific packages globally.</li>
                <li><strong>Environment Variables for Configuration</strong>: Keep sensitive or environment-specific settings in environment variables, not code.</li>
                <li><strong>Regular Maintenance</strong>: Periodically update dependencies and rebuild environments.</li>
                <li><strong>Use the Right Tool</strong>: Choose the appropriate virtual environment tool for your project's needs.</li>
                <li><strong>Scripts and Automation</strong>: Automate repetitive environment tasks.</li>
                <li><strong>Team Consistency</strong>: Establish and follow team conventions for environments.</li>
                <li><strong>Clean Up Regularly</strong>: Delete unused environments to save disk space.</li>
            </ol>
            
            <p>By internalizing these principles, you'll develop clean, reproducible Python projects that are easier to maintain, share, and deploy.</p>
            
            <p>In our next sessions, we'll build on this foundation as we dive into module organization, packages, and more advanced Python development concepts.</p>
        </section>

        <section class="exercise">
            <h3>Exercise: Environment Health Check Tool</h3>
            
            <p>Let's apply what we've learned by creating a virtual environment "health check" script that you can use to validate your environment setup.</p>
            
            <p>Create a file named <code>env_check.py</code> with the following content:</p>
            
            <pre><code>#!/usr/bin/env python
"""
Virtual Environment Health Check

A utility to verify your virtual environment is properly configured.
"""

import os
import sys
import site
import subprocess
import platform
from pathlib import Path

def header(text):
    """Print a section header."""
    print("\n" + "=" * 60)
    print(f" {text}")
    print("=" * 60)

def check_mark(condition):
    """Return a check mark or X based on condition."""
    return "✅" if condition else "❌"

def main():
    """Run the environment health check."""
    header("VIRTUAL ENVIRONMENT HEALTH CHECK")
    
    # Check if running in a virtual environment
    in_venv = sys.prefix != sys.base_prefix
    print(f"{check_mark(in_venv)} Running in a virtual environment")
    
    if not in_venv:
        print("\n⚠️  WARNING: Not running in a virtual environment!")
        print("    Please activate your virtual environment and try again.")
        print("    Example: source venv/bin/activate")
        sys.exit(1)
    
    # Get environment details
    venv_path = sys.prefix
    python_version = platform.python_version()
    pip_version = subprocess.run(
        [sys.executable, "-m", "pip", "--version"],
        capture_output=True, text=True
    ).stdout.split()[1]
    
    print(f"\nEnvironment path: {venv_path}")
    print(f"Python version: {python_version}")
    print(f"Pip version: {pip_version}")
    
    # Check site-packages location
    site_packages = site.getsitepackages()[0]
    correct_site_packages = Path(site_packages).is_relative_to(Path(venv_path))
    print(f"{check_mark(correct_site_packages)} Site-packages directory: {site_packages}")
    
    # Check activation script
    if os.name == 'nt':  # Windows
        activate_script = Path(venv_path) / "Scripts" / "activate.bat"
    else:  # Unix
        activate_script = Path(venv_path) / "bin" / "activate"
    
    script_exists = activate_script.exists()
    print(f"{check_mark(script_exists)} Activation script: {activate_script}")
    
    # Check for key packages
    header("INSTALLED PACKAGES")
    
    # Get installed packages
    installed_packages = subprocess.run(
        [sys.executable, "-m", "pip", "list"],
        capture_output=True, text=True
    ).stdout.strip().split('\n')[2:]  # Skip header lines
    
    print(f"Total installed packages: {len(installed_packages)}")
    
    # Show top packages (first 10)
    if installed_packages:
        print("\nTop packages:")
        for i, package_line in enumerate(installed_packages[:10]):
            print(f"  {package_line}")
        
        if len(installed_packages) > 10:
            print(f"  ...and {len(installed_packages) - 10} more")
    
    # Check requirements file
    header("PROJECT CONFIGURATION")
    
    # Find requirements files
    req_files = list(Path().glob("requirements*.txt")) + list(Path().glob("requirements/*.txt"))
    if req_files:
        print(f"{check_mark(True)} Found {len(req_files)} requirements files:")
        for req_file in req_files:
            print(f"  - {req_file}")
    else:
        print(f"{check_mark(False)} No requirements files found")
    
    # Check for common environment files
    env_files = list(Path().glob(".env*"))
    if env_files:
        print(f"{check_mark(True)} Found {len(env_files)} environment files:")
        for env_file in env_files:
            print(f"  - {env_file}")
    else:
        print(f"{check_mark(False)} No environment files found")
    
    # Check for .gitignore
    gitignore = Path(".gitignore")
    gitignore_exists = gitignore.exists()
    print(f"{check_mark(gitignore_exists)} .gitignore file")
    
    if gitignore_exists:
        venv_ignored = False
        gitignore_content = gitignore.read_text()
        venv_patterns = ["venv/", "/venv", "venv", "env/", "ENV/"]
        for pattern in venv_patterns:
            if pattern in gitignore_content:
                venv_ignored = True
                break
        print(f"{check_mark(venv_ignored)} Virtual environment ignored in .gitignore")
    
    # Summary
    header("SUMMARY")
    
    if in_venv and correct_site_packages and script_exists:
        print("✅ Your virtual environment appears to be configured correctly!")
    else:
        print("⚠️  Your virtual environment may have issues that need attention.")
    
    if not req_files:
        print("\n⚠️  Recommendation: Create a requirements.txt file to track dependencies.")
    
    if not env_files:
        print("\n⚠️  Recommendation: Consider using .env files for environment variables.")
    
    if gitignore_exists and not venv_ignored:
        print("\n⚠️  Recommendation: Add your virtual environment directory to .gitignore.")
    
    print("\nFor additional checks, consider tools like 'pip-audit' for security vulnerabilities")
    print("or 'pip check' to verify package dependencies.")

if __name__ == "__main__":
    main()
</code></pre>
            
            <h4>Using the Script</h4>
            <p>To use this script:</p>
            
            <ol>
                <li>Save it as <code>env_check.py</code> in your project directory</li>
                <li>Activate your virtual environment</li>
                <li>Run it with <code>python env_check.py</code></li>
            </ol>
            
            <p>The script will perform several checks on your virtual environment and provide recommendations for improvements.</p>
            
            <h4>Script Features</h4>
            <ul>
                <li>Verifies you're running in a virtual environment</li>
                <li>Displays key environment information</li>
                <li>Lists installed packages</li>
                <li>Checks for requirements files</li>
                <li>Verifies .gitignore configuration</li>
                <li>Provides recommendations for best practices</li>
            </ul>
            
            <p>This script demonstrates practical application of the virtual environment concepts we've covered, and gives you a tool you can use in future projects.</p>
        </section>

        <section class="additional-resources">
            <h3>Additional Resources</h3>
            
            <ul>
                <li><a href="https://docs.python.org/3/library/venv.html" target="_blank">Python venv documentation</a></li>
                <li><a href="https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments/" target="_blank">Python Packaging User Guide: Virtual Environments</a></li>
                <li><a href="https://realpython.com/python-virtual-environments-a-primer/" target="_blank">Real Python: Virtual Environments Primer</a></li>
                <li><a href="https://docs.pipenv.org/" target="_blank">Pipenv documentation</a></li>
                <li><a href="https://python-poetry.org/docs/" target="_blank">Poetry documentation</a></li>
                <li><a href="https://github.com/pypa/pipx" target="_blank">pipx: Install and Run Python Applications in Isolated Environments</a></li>
                <li><a href="https://direnv.net/" target="_blank">direnv: Unclutter your .profile</a></li>
                <li><a href="https://virtualenvwrapper.readthedocs.io/" target="_blank">virtualenvwrapper documentation</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>

