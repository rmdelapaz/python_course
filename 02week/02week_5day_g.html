<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Full Stack Web Developer Course - Requirements.txt Files</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 2: Python Fundamentals (Part 1)</h2>
        <h3>Friday Morning: Requirements.txt Files</h3>
    </header>

    <main>
        <section class="introduction">
            <h3>Introduction to requirements.txt Files</h3>
            <p>Welcome to our session on requirements.txt files! In Python development, effectively managing your project's dependencies is crucial for creating reproducible, shareable, and maintainable code. The requirements.txt file is a cornerstone of Python dependency management—a simple yet powerful tool that helps you specify exactly what packages your project needs.</p>
            
            <p>Think of a requirements.txt file as a shopping list for your Python environment. Just as a detailed shopping list ensures you get exactly what you need at the grocery store—no more, no less—a well-crafted requirements.txt file ensures that anyone (including future you) can recreate your Python environment exactly as needed for your project to run successfully.</p>
            
            <p>Today, we'll explore how to create, maintain, and leverage requirements.txt files effectively as part of your Python development workflow. Whether you're working on solo projects or collaborating in large teams, mastering this aspect of dependency management will save you countless hours of troubleshooting and help you create more professional, distributable Python applications.</p>
        </section>

        <section class="why-requirements">
            <h3>Why Use requirements.txt Files?</h3>
            
            <p>Before diving into the technical details, let's understand why requirements.txt files are so important in Python projects:</p>
            
            <h4>1. Environment Reproducibility</h4>
            <p>One of the most challenging aspects of software development is ensuring that code works consistently across different environments. A requirements.txt file serves as a precise record of your dependencies, allowing anyone to recreate your environment exactly.</p>
            
            <p><strong>Real-World Scenario:</strong> Imagine deploying your application to a production server, only to discover it breaks because the server has different package versions installed. With a requirements.txt file, you can ensure the production environment has exactly the same dependencies as your development environment.</p>
            
            <h4>2. Collaboration Facilitation</h4>
            <p>When working in teams, having a standardized way to manage dependencies is essential for smooth collaboration.</p>
            
            <p><strong>Real-World Scenario:</strong> A new developer joins your team and needs to set up the project environment. Instead of asking them to manually install each dependency or providing a lengthy setup document, you can simply direct them to run <code>pip install -r requirements.txt</code>.</p>
            
            <h4>3. Version Control Integration</h4>
            <p>Requirements files are typically plain text and small in size, making them perfect for version control systems like Git.</p>
            
            <p><strong>Real-World Scenario:</strong> When you add a new feature that requires a new dependency, committing the updated requirements.txt file allows other team members to see exactly what changed in the dependency landscape.</p>
            
            <h4>4. Deployment Automation</h4>
            <p>Modern deployment pipelines often automatically install dependencies from requirements.txt during the build process.</p>
            
            <p><strong>Real-World Scenario:</strong> CI/CD pipelines like GitHub Actions, GitLab CI, or Jenkins can automatically install requirements, run tests, and deploy your application—all using your requirements.txt file to ensure consistent environments.</p>
            
            <h4>5. Dependency Documentation</h4>
            <p>A requirements.txt file serves as documentation of what packages your project depends on, making it easier for others to understand your project's external needs.</p>
            
            <p><strong>Real-World Scenario:</strong> When evaluating an open-source project, developers often check the requirements.txt file first to understand what technologies the project uses and whether it might have security concerns or conflicts with their existing environment.</p>
            
            <p><strong>Real-World Analogy:</strong> Think of a requirements.txt file as a recipe. A good recipe doesn't just list ingredients—it specifies exact amounts. Similarly, a good requirements.txt doesn't just list packages—it specifies exact versions to ensure consistent results every time.</p>
        </section>

        <section class="basic-usage">
            <h3>Basic Usage of requirements.txt</h3>
            
            <h4>Creating a requirements.txt File</h4>
            <p>There are several ways to create a requirements.txt file:</p>
            
            <h5>Method 1: Manual Creation</h5>
            <p>You can create a requirements.txt file manually by listing each package on a separate line:</p>
            
            <pre><code># requirements.txt
flask
requests
numpy
pandas</code></pre>
            
            <h5>Method 2: Using pip freeze</h5>
            <p>The more common approach is to let pip generate the file based on your current environment:</p>
            
            <pre><code># Generate requirements.txt from your current environment
pip freeze > requirements.txt</code></pre>
            
            <p>This command captures all installed packages and their exact versions:</p>
            
            <pre><code># requirements.txt generated by pip freeze
flask==2.0.1
requests==2.26.0
numpy==1.21.2
pandas==1.3.3
# ... potentially many more dependencies</code></pre>
            
            <h4>Installing Dependencies from requirements.txt</h4>
            <p>Once you have a requirements.txt file, others can recreate your environment:</p>
            
            <pre><code># Install all packages listed in requirements.txt
pip install -r requirements.txt</code></pre>
            
            <h4>Updating a requirements.txt File</h4>
            <p>When you add or update dependencies, you should update your requirements.txt file:</p>
            
            <pre><code># Install a new package
pip install matplotlib

# Update requirements.txt with the new dependency
pip freeze > requirements.txt</code></pre>
            
            <h4>Basic Syntax and Options</h4>
            <p>A requirements.txt file has a simple syntax, but offers several options:</p>
            
            <h5>Package Names Only</h5>
            <pre><code>flask
requests
numpy</code></pre>
            
            <h5>Specifying Exact Versions</h5>
            <pre><code>flask==2.0.1
requests==2.26.0
numpy==1.21.2</code></pre>
            
            <h5>Specifying Minimum Versions</h5>
            <pre><code>flask>=2.0.0
requests>=2.25.0
numpy>=1.20.0</code></pre>
            
            <h5>Specifying Version Ranges</h5>
            <pre><code>flask>=2.0.0,<3.0.0
requests>=2.25.0,<2.27.0
numpy>=1.20.0,<1.22.0</code></pre>
            
            <h5>Installing from Version Control</h5>
            <pre><code>flask==2.0.1
git+https://github.com/psf/requests.git@v2.26.0
numpy==1.21.2</code></pre>
            
            <h5>Including Comments</h5>
            <pre><code># Web framework
flask==2.0.1

# HTTP library for API requests
requests==2.26.0

# Numerical computing
numpy==1.21.2</code></pre>
            
            <h5>Using Environment Markers</h5>
            <pre><code>flask==2.0.1
requests==2.26.0
numpy==1.21.2
pywin32==301; sys_platform == 'win32'
</code></pre>
        </section>

        <section class="best-practices">
            <h3>Best Practices for requirements.txt Files</h3>
            
            <h4>1. Pin Your Versions</h4>
            <p>Always specify exact versions of packages to ensure reproducibility.</p>
            
            <pre><code># Not recommended
flask
requests
numpy

# Recommended
flask==2.0.1
requests==2.26.0
numpy==1.21.2</code></pre>
            
            <p><strong>Explanation:</strong> Without version pinning, pip will install the latest available version of each package, which might introduce breaking changes over time. Pinning ensures everyone gets exactly the same versions you tested with.</p>
            
            <h4>2. Be Selective About What You Include</h4>
            <p>Only include direct dependencies, not every package in your environment.</p>
            
            <p><strong>Problem with pip freeze:</strong> It includes everything in your environment, including packages you might not need for your project. For example, if you've installed Jupyter Notebook globally, it doesn't mean your web application depends on it.</p>
            
            <p>Consider maintaining your requirements manually or using tools like pip-tools (discussed later).</p>
            
            <h4>3. Organize with Comments</h4>
            <p>Use comments to organize and explain dependencies.</p>
            
            <pre><code># Web Framework
flask==2.0.1
flask-wtf==1.0.0
flask-sqlalchemy==2.5.1

# Data Processing
numpy==1.21.2
pandas==1.3.3
matplotlib==3.4.3

# Testing - not required for production
pytest==6.2.5
pytest-cov==2.12.1</code></pre>
            
            <h4>4. Split Requirements by Environment</h4>
            <p>For larger projects, consider separating requirements by environment:</p>
            
            <p>Project structure:</p>
            <pre><code>requirements/
├── base.txt      # Core dependencies used in all environments
├── development.txt   # Development-specific packages
├── production.txt    # Production-specific packages
└── testing.txt   # Testing-specific packages</code></pre>
            
            <p>Example of <code>requirements/base.txt</code>:</p>
            <pre><code># Core dependencies
flask==2.0.1
sqlalchemy==1.4.25
requests==2.26.0</code></pre>
            
            <p>Example of <code>requirements/development.txt</code>:</p>
            <pre><code># Include base requirements
-r base.txt

# Development tools
flask-debugtoolbar==0.11.0
ipython==7.27.0
black==21.8b0
flake8==3.9.2</code></pre>
            
            <p>Example of <code>requirements/production.txt</code>:</p>
            <pre><code># Include base requirements
-r base.txt

# Production-specific packages
gunicorn==20.1.0
sentry-sdk==1.3.1</code></pre>
            
            <p>Example of <code>requirements/testing.txt</code>:</p>
            <pre><code># Include base requirements
-r base.txt

# Testing tools
pytest==6.2.5
pytest-cov==2.12.1
coverage==5.5</code></pre>
            
            <p>Usage:</p>
            <pre><code># For development
pip install -r requirements/development.txt

# For production
pip install -r requirements/production.txt

# For testing
pip install -r requirements/testing.txt</code></pre>
            
            <h4>5. Include a Header Comment</h4>
            <p>Add documentation at the top of your requirements file:</p>
            
            <pre><code># Requirements for MyProject
# Python 3.9+
# Generated on 2023-05-15
# Usage: pip install -r requirements.txt

flask==2.0.1
# ... more packages ...</code></pre>
            
            <h4>6. Check in Requirements to Version Control</h4>
            <p>Always commit your requirements.txt file(s) to your version control system. This allows others to reproducibly set up the project and provides a history of dependency changes.</p>
            
            <h4>7. Regularly Update and Audit Dependencies</h4>
            <p>Periodically review your dependencies for updates, especially security patches.</p>
            
            <pre><code># Check for outdated packages
pip list --outdated

# Use safety to check for security vulnerabilities
pip install safety
safety check -r requirements.txt</code></pre>
        </section>

        <section class="advanced-techniques">
            <h3>Advanced Techniques for Dependency Management</h3>
            
            <h4>1. Using pip-tools</h4>
            <p>pip-tools provides a more sophisticated approach to dependency management, separating direct dependencies from the complete dependency tree.</p>
            
            <p>Installation:</p>
            <pre><code>pip install pip-tools</code></pre>
            
            <p>Create a <code>requirements.in</code> file with your direct dependencies:</p>
            <pre><code># requirements.in - Direct dependencies only
flask>=2.0.0
requests>=2.25.0
numpy>=1.20.0</code></pre>
            
            <p>Compile it to a pinned <code>requirements.txt</code>:</p>
            <pre><code>pip-compile requirements.in</code></pre>
            
            <p>This generates a requirements.txt with all dependencies (including sub-dependencies) pinned:</p>
            <pre><code># requirements.txt
#
# This file is autogenerated by pip-compile
# To update, run:
#
#    pip-compile requirements.in
#
click==8.0.1
    # via flask
flask==2.0.1
    # via -r requirements.in
itsdangerous==2.0.1
    # via flask
jinja2==3.0.1
    # via flask
markupsafe==2.0.1
    # via jinja2
numpy==1.21.2
    # via -r requirements.in
requests==2.26.0
    # via -r requirements.in
werkzeug==2.0.1
    # via flask</code></pre>
            
            <p>Upgrading dependencies:</p>
            <pre><code># Upgrade all packages
pip-compile --upgrade requirements.in

# Upgrade specific packages
pip-compile --upgrade-package flask requirements.in

# Install the compiled requirements
pip-sync requirements.txt</code></pre>
            
            <h4>2. Using constraints.txt</h4>
            <p>A <code>constraints.txt</code> file allows you to constrain versions without declaring dependencies.</p>
            
            <pre><code># constraints.txt
flask==2.0.1
werkzeug==2.0.1</code></pre>
            
            <p>Usage:</p>
            <pre><code># Install dependencies with constraints
pip install -r requirements.txt -c constraints.txt</code></pre>
            
            <p>This is particularly useful when you need to ensure specific versions of transitive dependencies (dependencies of your dependencies).</p>
            
            <h4>3. Using Hash Verification</h4>
            <p>For enhanced security, you can include hash values for packages:</p>
            
            <pre><code>flask==2.0.1 --hash=sha256:7b2fb8e039275d1d88d09fdf6bd64319f1f3e6c4a82178e18a0a0b70a2f7883b
requests==2.26.0 --hash=sha256:6c1246513ecd5ecd4528a0906f910e8f0f9c6b8ec72030dc9fd154dc1a6efd24</code></pre>
            
            <p>Generate requirements with hashes:</p>
            <pre><code>pip-compile --generate-hashes requirements.in</code></pre>
            
            <p>Install with hash verification:</p>
            <pre><code>pip install --require-hashes -r requirements.txt</code></pre>
            
            <p>This ensures the integrity of packages during installation, preventing supply-chain attacks.</p>
            
            <h4>4. Using setup.py with install_requires</h4>
            <p>For Python packages (not just applications), you can specify dependencies in setup.py:</p>
            
            <pre><code>from setuptools import setup, find_packages

setup(
    name="mypackage",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        "flask>=2.0.0,<3.0.0",
        "requests>=2.25.0",
        "numpy>=1.20.0",
    ],
    extras_require={
        "dev": [
            "pytest>=6.0.0",
            "black>=21.5b2",
        ],
        "docs": [
            "sphinx>=4.0.0",
        ],
    },
)
</code></pre>
            
            <p>You can then generate a requirements.txt from setup.py:</p>
            <pre><code>pip install -e .
pip freeze > requirements.txt</code></pre>
            
            <h4>5. Using pyproject.toml (Poetry or Pipenv)</h4>
            <p>Modern Python projects often use tools like Poetry or Pipenv with pyproject.toml:</p>
            
            <p>Poetry example (pyproject.toml):</p>
            <pre><code>[tool.poetry]
name = "myproject"
version = "0.1.0"
description = "My Python Project"
authors = ["Your Name <your.email@example.com>"]

[tool.poetry.dependencies]
python = "^3.9"
flask = "^2.0.1"
requests = "^2.26.0"
numpy = "^1.21.2"

[tool.poetry.dev-dependencies]
pytest = "^6.2.5"
black = "^21.8b0"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"</code></pre>
            
            <p>Generate requirements.txt from Poetry:</p>
            <pre><code>poetry export -f requirements.txt --output requirements.txt</code></pre>
            
            <p>Pipenv example (Pipfile):</p>
            <pre><code>[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
flask = "==2.0.1"
requests = "==2.26.0"
numpy = "==1.21.2"

[dev-packages]
pytest = "==6.2.5"
black = "==21.8b0"

[requires]
python_version = "3.9"</code></pre>
            
            <p>Generate requirements.txt from Pipenv:</p>
            <pre><code>pipenv lock -r > requirements.txt</code></pre>
        </section>

        <section class="common-issues">
            <h3>Common Issues and Solutions</h3>
            
            <h4>Issue 1: Sub-dependencies Conflicts</h4>
            <p><strong>Problem:</strong> Two packages require different versions of the same dependency.</p>
            
            <p><strong>Example:</strong> PackageA requires requests==2.25.0, but PackageB requires requests==2.26.0.</p>
            
            <p><strong>Solutions:</strong></p>
            <ol>
                <li><strong>Use constraints:</strong> Specify exact versions in constraints.txt</li>
                <li><strong>Try compatible versions:</strong> Test if both packages work with either version</li>
                <li><strong>Use virtual environments:</strong> Create separate environments for conflicting packages</li>
                <li><strong>Contact maintainers:</strong> Report the issue to package maintainers</li>
            </ol>
            
            <h4>Issue 2: Platform-Specific Packages</h4>
            <p><strong>Problem:</strong> Some packages are only needed on specific platforms.</p>
            
            <p><strong>Example:</strong> You need pywin32 on Windows, but not on Linux or macOS.</p>
            
            <p><strong>Solutions:</strong></p>
            <ol>
                <li><strong>Use environment markers:</strong>
                <pre><code>pywin32==301; sys_platform == 'win32'
pyobjc-core==7.3; sys_platform == 'darwin'</code></pre>
                </li>
                <li><strong>Split requirements by platform:</strong>
                <pre><code># requirements_windows.txt
-r requirements.txt
pywin32==301</code></pre>
                </li>
            </ol>
            
            <h4>Issue 3: pip freeze Includes Too Many Packages</h4>
            <p><strong>Problem:</strong> pip freeze outputs all installed packages, not just direct dependencies.</p>
            
            <p><strong>Solutions:</strong></p>
            <ol>
                <li><strong>Use a clean virtual environment:</strong> Create a new environment and install only the packages you need</li>
                <li><strong>Use pip-tools:</strong> Maintain a requirements.in file with direct dependencies</li>
                <li><strong>Manually curate:</strong> Maintain requirements.txt by hand, only adding packages you explicitly install</li>
                <li><strong>Use pipdeptree:</strong> Visualize dependencies to identify direct ones:
                <pre><code>pip install pipdeptree
pipdeptree --packages flask</code></pre>
                </li>
            </ol>
            
            <h4>Issue 4: Version Conflicts During Installation</h4>
            <p><strong>Problem:</strong> pip install -r requirements.txt fails with dependency conflicts.</p>
            
            <p><strong>Solutions:</strong></p>
            <ol>
                <li><strong>Install packages in order:</strong> List the most constrained packages first</li>
                <li><strong>Use --no-dependencies:</strong> Install packages without their dependencies, then resolve manually</li>
                <li><strong>Use constraints:</strong> Specify compatible versions with constraints.txt</li>
                <li><strong>Use pip-tools:</strong> pip-compile can resolve dependencies more effectively</li>
            </ol>
            
            <h4>Issue 5: Outdated Requirements</h4>
            <p><strong>Problem:</strong> Requirements.txt contains outdated or vulnerable packages.</p>
            
            <p><strong>Solutions:</strong></p>
            <ol>
                <li><strong>Regular audits:</strong> Check for outdated packages:
                <pre><code>pip list --outdated</code></pre>
                </li>
                <li><strong>Security scanning:</strong> Check for vulnerabilities:
                <pre><code>pip install safety
safety check -r requirements.txt</code></pre>
                </li>
                <li><strong>Automated updates:</strong> Use tools like Dependabot, PyUp, or pip-upgrader</li>
            </ol>
        </section>

        <section class="real-world-scenario">
            <h3>Real-World Scenario: Managing Dependencies in a Flask Web Application</h3>
            
            <p>Let's walk through a practical example of managing dependencies for a Flask web application project.</p>
            
            <h4>Project Structure</h4>
            <pre><code>flask_project/
├── .gitignore
├── README.md
├── requirements/
│   ├── base.txt
│   ├── development.txt
│   ├── production.txt
│   └── testing.txt
├── app/
│   ├── __init__.py
│   ├── models.py
│   ├── routes.py
│   ├── templates/
│   └── static/
├── config.py
├── run.py
└── tests/</code></pre>
            
            <h4>Initial Dependency Setup</h4>
            <p>Create a virtual environment and install the base packages:</p>
            
            <pre><code># Create and activate virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install initial packages
pip install flask flask-sqlalchemy flask-wtf pytest</code></pre>
            
            <h4>Creating Base Requirements</h4>
            <p>Create <code>requirements/base.txt</code> with core dependencies:</p>
            
            <pre><code># Base requirements for Flask Project
# Python 3.9+

# Web Framework
flask==2.0.1

# Database
flask-sqlalchemy==2.5.1
sqlalchemy==1.4.25

# Forms
flask-wtf==1.0.0
wtforms==2.3.3

# Security
flask-login==0.5.0

# API 
flask-restful==0.3.9
</code></pre>
            
            <h4>Creating Environment-Specific Requirements</h4>
            <p>Create environment-specific requirements files that include the base requirements:</p>
            
            <p><code>requirements/development.txt</code>:</p>
            <pre><code># Development requirements for Flask Project
# Includes base requirements
-r base.txt

# Debugging
flask-debugtoolbar==0.11.0

# Code Quality
black==21.8b0
flake8==3.9.2

# Development Server
watchdog==2.1.5

# Development Database
# SQLite is included in Python standard library
</code></pre>
            
            <p><code>requirements/testing.txt</code>:</p>
            <pre><code># Testing requirements for Flask Project
# Includes base requirements
-r base.txt

# Testing
pytest==6.2.5
pytest-cov==2.12.1
pytest-flask==1.2.0

# Mocking
faker==8.13.2
</code></pre>
            
            <p><code>requirements/production.txt</code>:</p>
            <pre><code># Production requirements for Flask Project
# Includes base requirements
-r base.txt

# WSGI Server
gunicorn==20.1.0

# Monitoring and Logging
sentry-sdk==1.3.1

# Performance
flask-caching==1.10.1
</code></pre>
            
            <h4>Working with Different Environments</h4>
            <p>Install dependencies for specific environments:</p>
            
            <pre><code># For development
pip install -r requirements/development.txt

# For testing
pip install -r requirements/testing.txt

# For production
pip install -r requirements/production.txt</code></pre>
            
            <h4>Adding New Dependencies</h4>
            <p>When adding a new dependency, determine which environment it belongs to:</p>
            
            <pre><code># Install a new package (e.g., for file uploads)
pip install flask-uploads

# Add it to base.txt
echo "flask-uploads==0.2.1  # For file uploads" >> requirements/base.txt</code></pre>
            
            <h4>Updating Dependencies</h4>
            <p>Periodically update dependencies to get security fixes and improvements:</p>
            
            <pre><code># Check for outdated packages
pip list --outdated

# Update a specific package
pip install --upgrade flask-sqlalchemy
# Update base.txt with new version
# Edit requirements/base.txt to update the version

# Or use pip-tools for more controlled updates
pip install pip-tools
pip-compile --upgrade-package flask-sqlalchemy requirements/base.in</code></pre>
            
            <h4>Handling Security Vulnerabilities</h4>
            <p>Check for security vulnerabilities in your dependencies:</p>
            
            <pre><code># Check for security vulnerabilities
pip install safety
safety check -r requirements/base.txt</code></pre>
            
            <p>If vulnerabilities are found, update the affected packages to secure versions.</p>
            
            <h4>CI/CD Pipeline</h4>
            <p>Integrate dependency management into your CI/CD pipeline:</p>
            
            <pre><code># .github/workflows/python-test.yml
name: Python Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements/testing.txt
    
    - name: Check for security vulnerabilities
      run: |
        pip install safety
        safety check -r requirements/base.txt
    
    - name: Run tests
      run: |
        pytest --cov=app</code></pre>
            
            <h4>Deployment</h4>
            <p>When deploying to production, use the production requirements:</p>
            
            <pre><code># On production server
git clone https://github.com/username/flask_project.git
cd flask_project
python -m venv venv
source venv/bin/activate
pip install -r requirements/production.txt

# Start the application with gunicorn
gunicorn wsgi:app</code></pre>
        </section>

        <section class="development-workflow">
            <h3>Development Workflow with requirements.txt</h3>
            
            <p>Here's a comprehensive workflow for managing dependencies in a Python project:</p>
            
            <h4>1. Project Initialization</h4>
            <ol>
                <li>Create a virtual environment:
                    <pre><code>python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate</code></pre>
                </li>
                <li>Create requirements structure:
                    <pre><code>mkdir -p requirements</code></pre>
                </li>
                <li>Install initial dependencies:
                    <pre><code>pip install flask flask-sqlalchemy</code></pre>
                </li>
                <li>Generate initial requirements:
                    <pre><code>pip freeze > requirements/base.txt</code></pre>
                </li>
                <li>Create environment-specific files:
                    <pre><code>echo "-r base.txt" > requirements/development.txt
echo "-r base.txt" > requirements/production.txt
echo "-r base.txt" > requirements/testing.txt</code></pre>
                </li>
                <li>Add additional environment-specific packages:
                    <pre><code>pip install black pytest
echo "black==21.8b0  # Code formatting" >> requirements/development.txt
echo "pytest==6.2.5  # Testing framework" >> requirements/testing.txt</code></pre>
                </li>
            </ol>
            
            <h4>2. Daily Development Workflow</h4>
            <ol>
                <li>Activate virtual environment:
                    <pre><code>source venv/bin/activate  # On Windows: venv\Scripts\activate</code></pre>
                </li>
                <li>Install dependencies for your work:
                    <pre><code># For development
pip install -r requirements/development.txt

# For testing
pip install -r requirements/testing.txt</code></pre>
                </li>
                <li>When adding a new dependency:
                    <pre><code># Install the package
pip install new-package

# Add to appropriate requirements file
echo "new-package==1.0.0  # Purpose of this package" >> requirements/base.txt</code></pre>
                </li>
                <li>Before committing:
                    <pre><code># Check for outdated packages
pip list --outdated

# Check for security vulnerabilities
safety check -r requirements/base.txt</code></pre>
                </li>
            </ol>
            
            <h4>3. Collaboration Workflow</h4>
            <ol>
                <li>When pulling changes with new dependencies:
                    <pre><code>git pull
pip install -r requirements/development.txt</code></pre>
                </li>
                <li>When dependency conflicts arise:
                    <pre><code># Create a new virtual environment to test
python -m venv test_env
source test_env/bin/activate
pip install -r requirements/development.txt</code></pre>
                </li>
                <li>If changes to dependencies are needed, discuss with team and update requirements files accordingly.</li>
            </ol>
            
            <h4>4. Deployment Workflow</h4>
            <ol>
                <li>Prepare for deployment:
                    <pre><code># Ensure production requirements are up to date
python -m pip install -r requirements/production.txt

# Test with production settings
python run.py --prod</code></pre>
                </li>
                <li>Deploy to production:
                    <pre><code># On production server
pip install -r requirements/production.txt</code></pre>
                </li>
                <li>Monitor for dependency issues:
                    <pre><code># Set up alerts for security vulnerabilities
# Integrate with security scanning tools</code></pre>
                </li>
            </ol>
            
            <h4>5. Maintenance Workflow</h4>
            <ol>
                <li>Regular dependency updates:
                    <pre><code># Schedule regular reviews (e.g., monthly)
pip list --outdated
pip install --upgrade flask
# Update version in requirements file</code></pre>
                </li>
                <li>Security patching:
                    <pre><code># Subscribe to security alerts
# Promptly update vulnerable packages</code></pre>
                </li>
                <li>Removing unused dependencies:
                    <pre><code># Periodically review and remove unused packages
# Update requirements files accordingly</code></pre>
                </li>
            </ol>
        </section>

        <section class="advanced-tools">
            <h3>Advanced Tools for Dependency Management</h3>
            
            <p>Beyond basic requirements.txt files, several advanced tools can enhance your dependency management:</p>
            
            <h4>1. pip-tools</h4>
            <p>We mentioned pip-tools earlier, but it deserves more explanation:</p>
            
            <pre><code># Install pip-tools
pip install pip-tools

# Create a requirements.in file
flask
sqlalchemy
requests

# Compile to requirements.txt with pinned versions
pip-compile

# Install dependencies
pip-sync</code></pre>
            
            <p><strong>Key Features:</strong></p>
            <ul>
                <li>Separates direct dependencies (requirements.in) from full dependency tree (requirements.txt)</li>
                <li>Automatically resolves dependencies</li>
                <li>Precise control over updates</li>
                <li>Support for multiple requirements files</li>
                <li>Hash generation for verifiable builds</li>
            </ul>
            
            <h4>2. Poetry</h4>
            <p>Poetry is a modern dependency management tool that replaces pip, virtualenv, and other tools:</p>
            
            <pre><code># Install Poetry
pip install poetry

# Initialize a new project
poetry new myproject
cd myproject

# Add dependencies
poetry add flask sqlalchemy

# Add development dependencies
poetry add --dev pytest black

# Install dependencies
poetry install

# Export to requirements.txt
poetry export -f requirements.txt --output requirements.txt</code></pre>
            
            <p><strong>Key Features:</strong></p>
            <ul>
                <li>Project metadata and dependencies in one file (pyproject.toml)</li>
                <li>Built-in virtual environment management</li>
                <li>Dependency resolution</li>
                <li>Publishing to PyPI</li>
                <li>Lock file for deterministic builds</li>
            </ul>
            
            <h4>3. Pipenv</h4>
            <p>Pipenv combines pip and virtualenv with a lockfile mechanism:</p>
            
            <pre><code># Install Pipenv
pip install pipenv

# Initialize a project
mkdir myproject
cd myproject

# Install packages
pipenv install flask sqlalchemy

# Install development packages
pipenv install --dev pytest black

# Create a virtual environment and install dependencies
pipenv install

# Export to requirements.txt
pipenv lock -r > requirements.txt</code></pre>
            
            <p><strong>Key Features:</strong></p>
            <ul>
                <li>Pipfile and Pipfile.lock for dependency tracking</li>
                <li>Integrated virtual environment management</li>
                <li>Security vulnerability checking</li>
                <li>Environment variable management</li>
                <li>Dependency graphing</li>
            </ul>
            
            <h4>4. conda</h4>
            <p>For scientific computing and data science, conda offers advanced dependency management:</p>
            
            <pre><code># Create a conda environment with dependencies
conda create -n myenv python=3.9 numpy pandas matplotlib

# Export to environment.yml
conda env export > environment.yml

# Create environment from environment.yml
conda env create -f environment.yml</code></pre>
            
            <p><strong>Key Features:</strong></p>
            <ul>
                <li>Handles non-Python dependencies (e.g., C libraries)</li>
                <li>Cross-platform binary packages</li>
                <li>Separate channel system for packages</li>
                <li>Environment management</li>
                <li>Integration with pip for Python-specific packages</li>
            </ul>
            
            <h4>5. pip-audit</h4>
            <p>pip-audit is a tool for auditing Python dependencies for security vulnerabilities:</p>
            
            <pre><code># Install pip-audit
pip install pip-audit

# Audit installed packages
pip-audit

# Audit requirements file
pip-audit -r requirements.txt</code></pre>
            
            <p><strong>Key Features:</strong></p>
            <ul>
                <li>Checks dependencies against vulnerability databases</li>
                <li>Integration with CI/CD pipelines</li>
                <li>Support for various output formats</li>
                <li>Customizable vulnerability handling</li>
            </ul>
            
            <h4>6. pip-review</h4>
            <p>pip-review helps you keep your packages up-to-date:</p>
            
            <pre><code># Install pip-review
pip install pip-review

# Check for updates
pip-review

# Update all packages
pip-review --auto

# Update specific packages
pip-review --interactive</code></pre>
            
            <p><strong>Key Features:</strong></p>
            <ul>
                <li>Interactive updates</li>
                <li>Selective package updating</li>
                <li>Simple interface</li>
            </ul>
            
            <h4>Comparison of Tools</h4>
            <table>
                <tr>
                    <th>Tool</th>
                    <th>Best For</th>
                    <th>Learning Curve</th>
                    <th>Compatibility</th>
                </tr>
                <tr>
                    <td>requirements.txt</td>
                    <td>Simple projects, compatibility</td>
                    <td>Low</td>
                    <td>Universal</td>
                </tr>
                <tr>
                    <td>pip-tools</td>
                    <td>Medium projects, better dependency resolution</td>
                    <td>Low-Medium</td>
                    <td>Compatible with requirements.txt</td>
                </tr>
                <tr>
                    <td>Poetry</td>
                    <td>Modern projects, library development</td>
                    <td>Medium</td>
                    <td>Can export to requirements.txt</td>
                </tr>
                <tr>
                    <td>Pipenv</td>
                    <td>Application development</td>
                    <td>Medium</td>
                    <td>Can export to requirements.txt</td>
                </tr>
                <tr>
                    <td>conda</td>
                    <td>Scientific computing, complex dependencies</td>
                    <td>Medium-High</td>
                    <td>Works alongside pip</td>
                </tr>
            </table>
        </section>

        <section class="exercise">
            <h3>Exercise: Requirements.txt Management for a Web Application</h3>
            
            <p>Let's apply what we've learned with a practical exercise:</p>
            
            <h4>Exercise: Create a Requirements Structure for a Web Application</h4>
            
            <p><strong>Scenario:</strong> You're starting a new Flask web application that will have these features:</p>
            <ul>
                <li>Web interface with forms and templates</li>
                <li>Database integration with SQLAlchemy</li>
                <li>User authentication</li>
                <li>RESTful API</li>
                <li>Background task processing with Celery</li>
            </ul>
            
            <h4>Tasks:</h4>
            
            <ol>
                <li>Create a virtual environment for the project</li>
                <li>Create a directory structure with separate requirements files for different environments</li>
                <li>Populate the requirements files with appropriate packages</li>
                <li>Create a script to install dependencies for different environments</li>
                <li>Add security checking to ensure dependencies are up-to-date and secure</li>
            </ol>
            
            <h4>Step 1: Project Setup</h4>
            
            <pre><code># Create project directory
mkdir flask_project
cd flask_project

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Create directory structure
mkdir -p requirements app/templates app/static tests</code></pre>
            
            <h4>Step 2: Create Requirements Files</h4>
            
            <p>Create these files in the requirements directory:</p>
            
            <p><code>requirements/base.txt</code>:</p>
            <pre><code># Base requirements for Flask Web Application
# Python 3.9+

# Web Framework
flask==2.0.1

# Database
flask-sqlalchemy==2.5.1
sqlalchemy==1.4.25
alembic==1.7.3
flask-migrate==3.1.0

# Forms
flask-wtf==1.0.0
wtforms==2.3.3

# Authentication
flask-login==0.5.0
flask-bcrypt==0.7.1

# API
flask-restful==0.3.9
marshmallow==3.13.0

# Background Tasks
celery==5.1.2
redis==3.5.3

# Utilities
python-dotenv==0.19.0</code></pre>
            
            <p><code>requirements/development.txt</code>:</p>
            <pre><code># Development requirements
-r base.txt

# Debugging
flask-debugtoolbar==0.11.0

# Code Quality
black==21.8b0
flake8==3.9.2
isort==5.9.3

# Documentation
sphinx==4.2.0

# Development Server
watchdog==2.1.5

# REPL
ipython==7.27.0</code></pre>
            
            <p><code>requirements/testing.txt</code>:</p>
            <pre><code># Testing requirements
-r base.txt

# Testing
pytest==6.2.5
pytest-cov==2.12.1
pytest-flask==1.2.0
pytest-sugar==0.9.4

# Mocking
faker==8.13.2
factory-boy==3.2.0</code></pre>
            
            <p><code>requirements/production.txt</code>:</p>
            <pre><code># Production requirements
-r base.txt

# WSGI Server
gunicorn==20.1.0

# Performance
flask-caching==1.10.1

# Monitoring and Logging
sentry-sdk[flask]==1.3.1
prometheus-flask-exporter==0.18.2</code></pre>
            
            <h4>Step 3: Create Installation Script</h4>
            
            <p>Create a script to help with dependency installation:</p>
            
            <p><code>scripts/install_deps.sh</code>:</p>
            <pre><code>#!/bin/bash
# Script to install dependencies for different environments

# Check if virtual environment is activated
if [[ "$VIRTUAL_ENV" == "" ]]; then
    echo "Virtual environment not activated. Please activate it first."
    echo "Run: source venv/bin/activate"
    exit 1
fi

# Process command line arguments
ENV=${1:-development}

case $ENV in
    development|dev)
        REQUIREMENTS="requirements/development.txt"
        ;;
    testing|test)
        REQUIREMENTS="requirements/testing.txt"
        ;;
    production|prod)
        REQUIREMENTS="requirements/production.txt"
        ;;
    *)
        echo "Unknown environment: $ENV"
        echo "Usage: $0 [development|testing|production]"
        exit 1
        ;;
esac

echo "Installing dependencies for $ENV environment..."
pip install -r $REQUIREMENTS

# Check for security vulnerabilities
echo "Checking for security vulnerabilities..."
pip install safety
safety check -r $REQUIREMENTS

echo "Done!"</code></pre>
            
            <p>Make the script executable:</p>
            <pre><code>chmod +x scripts/install_deps.sh</code></pre>
            
            <h4>Step 4: Create a Project Initialization Script</h4>
            
            <p><code>scripts/setup_project.sh</code>:</p>
            <pre><code>#!/bin/bash
# Script to set up a new project environment

# Create virtual environment if it doesn't exist
if [ ! -d "venv" ]; then
    echo "Creating virtual environment..."
    python -m venv venv
fi

# Activate virtual environment
source venv/bin/activate

# Install dependencies
./scripts/install_deps.sh development

# Initialize git repository if it doesn't exist
if [ ! -d ".git" ]; then
    echo "Initializing git repository..."
    git init
    
    # Create .gitignore
    echo "Creating .gitignore..."
    cat > .gitignore << EOL
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
ENV/
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Flask
instance/
.webassets-cache

# Celery
celerybeat-schedule
celerybeat.pid

# Testing
.coverage
htmlcov/
.pytest_cache/

# IDE
.idea/
.vscode/
*.swp
*.swo

# Environment
.env
.env.local

# Logs
logs/
*.log
EOL
    
    # Initial commit
    git add .
    git commit -m "Initial project setup"
fi

echo "Project setup complete!"
echo "Activate the virtual environment with: source venv/bin/activate"</code></pre>
            
            <p>Make the script executable:</p>
            <pre><code>chmod +x scripts/setup_project.sh</code></pre>
            
            <h4>Step 5: Create a Requirements Updating Script</h4>
            
            <p><code>scripts/update_deps.sh</code>:</p>
            <pre><code>#!/bin/bash
# Script to update dependencies

# Check if virtual environment is activated
if [[ "$VIRTUAL_ENV" == "" ]]; then
    echo "Virtual environment not activated. Please activate it first."
    echo "Run: source venv/bin/activate"
    exit 1
fi

# Install pip-tools if not installed
pip install pip-tools

# Check outdated packages
echo "Checking for outdated packages..."
pip list --outdated

# Ask for confirmation
read -p "Do you want to update packages? (y/n) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Update canceled."
    exit 0
fi

# Create requirements.in files if they don't exist
if [ ! -f "requirements/base.in" ]; then
    echo "Creating requirements.in files from current requirements.txt files..."
    
    # Extract direct dependencies from requirements.txt
    grep -v "^-r" requirements/base.txt | grep -v "^#" | grep -v "^$" > requirements/base.in
    grep -v "^-r" requirements/development.txt | grep -v "^#" | grep -v "^$" > requirements/development.in
    echo "-r base.in" > requirements/development.in.tmp
    grep -v "^-r" requirements/development.in >> requirements/development.in.tmp
    mv requirements/development.in.tmp requirements/development.in
    
    # Same for testing and production
    # ... similar commands for testing.in and production.in ...
fi

# Update base requirements
echo "Updating base requirements..."
pip-compile --upgrade requirements/base.in

# Update environment-specific requirements
for env in development testing production; do
    echo "Updating $env requirements..."
    pip-compile --upgrade requirements/${env}.in
done

# Check for security vulnerabilities
echo "Checking for security vulnerabilities..."
pip install safety
safety check -r requirements/base.txt

echo "Dependencies updated successfully!"</code></pre>
            
            <p>Make the script executable:</p>
            <pre><code>chmod +x scripts/update_deps.sh</code></pre>
            
            <h4>Step 6: Create a Basic Flask Application</h4>
            
            <p><code>app/__init__.py</code>:</p>
            <pre><code>from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_login import LoginManager
from flask_wtf.csrf import CSRFProtect

# Initialize extensions
db = SQLAlchemy()
migrate = Migrate()
login_manager = LoginManager()
csrf = CSRFProtect()

def create_app(config_object='app.config.DevelopmentConfig'):
    """Create and configure the Flask application."""
    app = Flask(__name__)
    app.config.from_object(config_object)
    
    # Initialize extensions
    db.init_app(app)
    migrate.init_app(app, db)
    login_manager.init_app(app)
    csrf.init_app(app)
    
    # Register blueprints
    from app.routes import main_bp
    app.register_blueprint(main_bp)
    
    return app</code></pre>
            
            <p><code>app/config.py</code>:</p>
            <pre><code>import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

class Config:
    """Base configuration class."""
    SECRET_KEY = os.environ.get('SECRET_KEY', 'dev-key-please-change')
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL', 'sqlite:///app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

class DevelopmentConfig(Config):
    """Development configuration."""
    DEBUG = True
    SQLALCHEMY_ECHO = True

class TestingConfig(Config):
    """Testing configuration."""
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
    WTF_CSRF_ENABLED = False

class ProductionConfig(Config):
    """Production configuration."""
    DEBUG = False
    TESTING = False</code></pre>
            
            <p><code>app/routes.py</code>:</p>
            <pre><code>from flask import Blueprint, render_template

main_bp = Blueprint('main', __name__)

@main_bp.route('/')
def index():
    return render_template('index.html')</code></pre>
            
            <p><code>app/templates/index.html</code>:</p>
            <pre><code><!DOCTYPE html>
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Flask App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Welcome to Flask App&lt;/h1&gt;
    &lt;p&gt;This is a Flask application with proper dependency management.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
            
            <p><code>run.py</code>:</p>
            <pre><code>from app import create_app

app = create_app()

if __name__ == '__main__':
    app.run()</code></pre>
            
            <h4>Running the Application</h4>
            
            <pre><code># Set up the project
./scripts/setup_project.sh

# Activate virtual environment
source venv/bin/activate

# Run the application
python run.py</code></pre>
            
            <p>This exercise demonstrates:</p>
            <ul>
                <li>Structured requirements management for different environments</li>
                <li>Scripts for automating dependency installation and updates</li>
                <li>Security checking of dependencies</li>
                <li>Integration with a Flask application</li>
                <li>Project initialization and setup automation</li>
            </ul>
            
            <p>By completing this exercise, you've created a robust dependency management system for a Python web application that follows best practices and can scale as the project grows.</p>
        </section>

        <section class="conclusion">
            <h3>Conclusion</h3>
            
            <p>We've explored requirements.txt files from basic usage to advanced techniques, and seen how they fit into the Python dependency management ecosystem. Let's recap the key takeaways:</p>
            
            <ul>
                <li><strong>Importance of Dependency Management</strong>: Well-managed dependencies ensure reproducible environments, easier collaboration, and more reliable applications.</li>
                <li><strong>Best Practices</strong>: Pin your versions, organize requirements by environment, include comments, and regularly audit for security vulnerabilities.</li>
                <li><strong>Advanced Techniques</strong>: Consider tools like pip-tools, Poetry, or Pipenv for more sophisticated dependency management as your projects grow.</li>
                <li><strong>Workflow Integration</strong>: Incorporate dependency management into your development workflow, CI/CD pipelines, and deployment processes.</li>
                <li><strong>Security Awareness</strong>: Regularly check for outdated or vulnerable dependencies to maintain application security.</li>
            </ul>
            
            <p>Mastering requirements.txt and dependency management is a fundamental skill for Python developers. As you build more complex applications, these practices will help you maintain codebases that are easier to work with, share, and deploy.</p>
            
            <p>Remember: "A chain is only as strong as its weakest link." In software, your dependencies are links in that chain. Proper dependency management helps ensure none of those links break unexpectedly.</p>
        </section>

        <section class="additional-resources">
            <h3>Additional Resources</h3>
            
            <ul>
                <li><a href="https://pip.pypa.io/en/stable/user_guide/#requirements-files" target="_blank">pip documentation: Requirements Files</a></li>
                <li><a href="https://packaging.python.org/en/latest/guides/tool-recommendations/" target="_blank">Python Packaging Authority: Tool Recommendations</a></li>
                <li><a href="https://realpython.com/lessons/using-requirement-files/" target="_blank">Real Python: Using Requirement Files</a></li>
                <li><a href="https://github.com/pypa/pip-tools" target="_blank">pip-tools GitHub Repository</a></li>
                <li><a href="https://python-poetry.org/docs/" target="_blank">Poetry Documentation</a></li>
                <li><a href="https://pipenv.pypa.io/en/latest/" target="_blank">Pipenv Documentation</a></li>
                <li><a href="https://github.com/pyupio/safety" target="_blank">safety: Python Vulnerability Scanner</a></li>
                <li><a href="https://github.com/jazzband/pip-tools" target="_blank">pip-tools: A set of tools to keep your pinned Python dependencies fresh</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
