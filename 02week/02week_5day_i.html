<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 2 Friday Afternoon: Review of Python Fundamentals</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Week 2 Friday Afternoon: Review of Python Fundamentals</h1>
        <p>Instructor's Notes: A comprehensive review of Week 2 concepts</p>
    </header>

    <main>
        <section class="intro">
            <h2>Introduction to Our Journey So Far</h2>
            <p>Welcome to our Week 2 comprehensive review! This week has been a foundational journey through the Python landscape. Think of what we've learned as constructing the framework of a house - we've laid the foundation (basic syntax), built the supporting walls (data structures), installed the electrical system (control flow), and designed the rooms (functions).</p>
            
            <p>Today we'll take a step back and examine our construction project as a whole, connecting concepts and reinforcing the key learnings that will support everything else we build as Python developers.</p>
        </section>

        <section class="review_section">
            <h2>Python as a Programming Ecosystem</h2>
            <p>We started our week understanding that Python is more than just a language - it's an ecosystem. Like a thriving forest with interdependent species, Python consists of the core language, its standard library, and a vast community of third-party packages.</p>
            
            <h3>Core Python Philosophy</h3>
            <p>Remember the Zen of Python? These guiding principles shape how we write "Pythonic" code:</p>
            <pre><code>>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
...</code></pre>
            
            <p>In the real world, these principles mean that Python developers value code that is:</p>
            <ul>
                <li><strong>Readable:</strong> Like a well-written novel rather than cryptic shorthand</li>
                <li><strong>Explicit:</strong> Stating intentions clearly rather than hiding them</li>
                <li><strong>Simple:</strong> Solving problems without unnecessary complications</li>
            </ul>
            
            <p><em>Real-world analogy:</em> Think of Python as a well-designed kitchen. All tools are easily accessible, clearly labeled, and designed for specific purposes. Other languages might give you a Swiss Army knife with hidden tools; Python gives you a kitchen where everything has its place and purpose.</p>
        </section>

        <section class="review_section">
            <h2>Variables, Data Types, and Basic Operations</h2>
            
            <p>Variables in Python are like labeled containers. Unlike some languages that make you declare what type of container you need before using it, Python lets you use whatever container size is appropriate for what you're storing.</p>
            
            <h3>Numbers, Strings and Basic Operations</h3>
            <p>We explored how Python handles numbers (integers, floats) and text (strings). Remember these key points:</p>
            
            <ul>
                <li>Integers (like <code>42</code>) are for whole numbers and can be as large as memory allows</li>
                <li>Floats (like <code>3.14</code>) are for decimal values but have precision limitations</li>
                <li>Strings (like <code>"hello"</code>) are for text and have powerful manipulation methods</li>
            </ul>
            
            <p>The way Python handles these types has real-world implications. For example, if you're building a financial application:</p>
            
            <pre><code># Floating point arithmetic can lead to unexpected results
0.1 + 0.2  # Results in 0.30000000000000004, not exactly 0.3

# For financial calculations, use Decimal instead
from decimal import Decimal
Decimal('0.1') + Decimal('0.2')  # Results in Decimal('0.3')</code></pre>
            
            <p><em>Real-world example:</em> A retail point-of-sale system would use Decimal for all price calculations to avoid penny rounding errors that could, at scale, cause significant accounting discrepancies.</p>
        </section>

        <section class="review_section">
            <h2>Control Structures: Decision Making and Repetition</h2>
            
            <p>Control structures are like the traffic lights and road patterns of your code - they direct the flow of execution.</p>
            
            <h3>Conditional Logic</h3>
            <p>We examined how to make decisions in Python using <code>if</code>, <code>elif</code>, and <code>else</code> statements:</p>
            
            <pre><code>weather = "rainy"

if weather == "sunny":
    print("Wear sunscreen")
elif weather == "rainy":
    print("Bring an umbrella")
elif weather == "snowy":
    print("Wear a coat")
else:
    print("Check the forecast again")</code></pre>
            
            <p><em>Real-world application:</em> E-commerce site product recommendations use complex conditional logic to analyze user behavior and suggest relevant products. The logic might evaluate purchase history, browsing patterns, and demographic information to personalize the shopping experience.</p>
            
            <h3>Loops for Repetition</h3>
            <p>We explored how to repeat actions using loops:</p>
            
            <pre><code># For loop - when you know how many iterations you need
for fruit in ["apple", "banana", "cherry"]:
    print(f"I like {fruit}s")

# While loop - when you need to continue until a condition is met
attempts = 0
while attempts < 3:
    password = input("Enter password: ")
    if password == "secret":
        print("Access granted")
        break
    attempts += 1
else:
    print("Too many failed attempts")</code></pre>
            
            <p>Notice how the <code>for</code> loop is ideal when iterating through a collection, while the <code>while</code> loop shines when you need to repeat until a condition changes.</p>
            
            <p><em>Real-world example:</em> Data processing pipelines often use loops to transform large datasets. Imagine processing thousands of customer records, where each record needs validation, transformation, and database insertion.</p>
        </section>

        <section class="review_section">
            <h2>Data Structures: Collections of Information</h2>
            
            <p>Python's built-in data structures are like different types of containers, each optimized for specific use cases.</p>
            
            <h3>Lists</h3>
            <p>Lists are ordered, mutable collections - like a train with cars that can be added, removed, or rearranged:</p>
            
            <pre><code>shopping_list = ["milk", "eggs", "bread"]
shopping_list.append("cheese")  # Add to the end
shopping_list.insert(0, "apples")  # Add at a specific position
print(shopping_list[1])  # Access by index</code></pre>
            
            <p><em>Real-world application:</em> Task management applications use list-like structures to track user tasks, allowing for additions, completions, and reordering of priorities.</p>
            
            <h3>Tuples</h3>
            <p>Tuples are immutable ordered collections - like sealed packages that can't be changed after creation:</p>
            
            <pre><code>coordinates = (34.0522, -118.2437)  # Los Angeles coordinates
name, age = ("Alice", 29)  # Tuple unpacking</code></pre>
            
            <p><em>Real-world application:</em> Geographic information systems use tuples to represent coordinates because latitude and longitude shouldn't be accidentally swapped or modified.</p>
            
            <h3>Dictionaries</h3>
            <p>Dictionaries are key-value mappings - like a phone book where you can look up information by name:</p>
            
            <pre><code>user = {
    "username": "python_lover",
    "email": "dev@example.com",
    "active": True,
    "login_count": 42
}

print(user["email"])  # Access by key
user["last_login"] = "2023-08-25"  # Add new key-value pair</code></pre>
            
            <p><em>Real-world application:</em> Content management systems often store page data in dictionary-like structures, with keys for title, content, author, publication date, etc.</p>
            
            <h3>Sets</h3>
            <p>Sets are unordered collections of unique elements - like a basket that automatically rejects duplicates:</p>
            
            <pre><code>unique_visitors = {"user123", "user456", "user789"}
unique_visitors.add("user123")  # Will not add duplicate
print(len(unique_visitors))  # Still just 3 items

# Set operations
android_users = {"user123", "user456", "user999"}
ios_users = {"user456", "user789", "user888"}

# Users on both platforms
cross_platform = android_users.intersection(ios_users)
# Users on either platform
all_users = android_users.union(ios_users)</code></pre>
            
            <p><em>Real-world application:</em> Analytics platforms use sets to track unique website visitors, ensuring each visitor is counted only once regardless of how many times they access the site.</p>
        </section>

        <section class="review_section">
            <h2>Functions: Reusable Code Blocks</h2>
            
            <p>Functions are like specialized machines in a factory - they take input, perform specific operations, and produce output.</p>
            
            <h3>Defining and Using Functions</h3>
            <pre><code>def calculate_shipping(weight, distance, express=False):
    """
    Calculate shipping cost based on weight, distance, and shipping method.
    
    Args:
        weight (float): Weight in kilograms
        distance (float): Distance in kilometers
        express (bool, optional): Whether express shipping is requested
    
    Returns:
        float: The calculated shipping cost
    """
    base_rate = 5.00
    weight_factor = 2.50 * weight
    distance_factor = 0.01 * distance
    
    if express:
        return (base_rate + weight_factor + distance_factor) * 1.5
    else:
        return base_rate + weight_factor + distance_factor

# Using the function
regular_cost = calculate_shipping(2.5, 150)
express_cost = calculate_shipping(2.5, 150, express=True)</code></pre>
            
            <p>Notice the docstring that explains what the function does, its parameters, and return value. This is essential for making your code maintainable and usable by others (including your future self).</p>
            
            <p><em>Real-world application:</em> E-commerce platforms use similar functions to calculate shipping costs based on product weight, delivery distance, and selected shipping options.</p>
            
            <h3>Lambda Functions</h3>
            <p>Lambda functions are like disposable tools - small, anonymous functions for simple operations:</p>
            
            <pre><code># Sort a list of products by price
products = [
    {"name": "Laptop", "price": 1200},
    {"name": "Phone", "price": 800},
    {"name": "Tablet", "price": 500}
]

# Sort using a lambda function
products_by_price = sorted(products, key=lambda item: item["price"])

# Using lambda with filter
affordable = list(filter(lambda item: item["price"] < 1000, products))</code></pre>
            
            <p><em>Real-world application:</em> Data analysis often uses lambda functions with map/filter/reduce operations to transform datasets without writing numerous small named functions.</p>
        </section>

        <section class="review_section">
            <h2>Modules and Packages: Code Organization</h2>
            
            <p>As your codebase grows, organization becomes crucial. Modules and packages are like filing cabinets for your code.</p>
            
            <h3>Creating and Importing Modules</h3>
            <p>Let's imagine we have these files in our project:</p>
            
            <pre><code># File: utils.py
def format_currency(amount):
    """Format amount as USD currency string"""
    return f"${amount:.2f}"

def calculate_tax(amount, rate=0.08):
    """Calculate tax amount based on rate"""
    return amount * rate</code></pre>

            <pre><code># File: app.py
import utils

# Using functions from the module
price = 42.99
tax = utils.calculate_tax(price)
total = price + tax
formatted_total = utils.format_currency(total)

print(f"Total price: {formatted_total}")</code></pre>
            
            <p><em>Real-world application:</em> Frameworks like Django organize code into functional modules (models, views, controllers) to maintain clean separation of concerns in complex web applications.</p>
            
            <h3>Virtual Environments and Dependencies</h3>
            <p>We explored how virtual environments keep project dependencies isolated:</p>
            
            <pre><code># Creating a virtual environment
python -m venv myproject_env

# Activating it (on Windows)
myproject_env\Scripts\activate

# Activating it (on macOS/Linux)
source myproject_env/bin/activate

# Installing dependencies
pip install requests pandas matplotlib

# Saving dependencies list
pip freeze > requirements.txt</code></pre>
            
            <p><em>Real-world application:</em> Deployment pipelines for production applications use requirements.txt files to ensure consistent environments across development, staging, and production servers.</p>
        </section>

        <section class="review_section">
            <h2>Docker and Dependencies Management</h2>
            
            <p>Going beyond virtual environments, Docker takes isolation to the next level by containerizing not just the Python environment but the entire operating system environment.</p>
            
            <h3>Basic Dockerfile for Python Applications</h3>
            <pre><code># File: Dockerfile
FROM python:3.10

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "app.py"]</code></pre>
            
            <p><em>Real-world application:</em> Microservice architectures use Docker containers to deploy small, focused services that can be developed, updated, and scaled independently of each other.</p>
            
            <h3>Docker Compose for Development Environments</h3>
            <pre><code># File: docker-compose.yml
version: '3'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - .:/app
    environment:
      - FLASK_ENV=development
      - DATABASE_URL=postgresql://user:password@db:5432/app_db
    depends_on:
      - db
  
  db:
    image: postgres:14
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=app_db
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:</code></pre>
            
            <p><em>Real-world application:</em> Development teams use Docker Compose to create consistent environments that match production, eliminating the "it works on my machine" problem.</p>
        </section>

        <section class="review_section">
            <h2>Project Structure Best Practices</h2>
            
            <p>As your projects grow, organization becomes crucial. Let's examine a typical Python project structure:</p>
            
            <pre><code>myproject/
│
├── myproject/          # Main package
│   ├── __init__.py
│   ├── core.py
│   ├── helpers.py
│   └── subpackage/
│       ├── __init__.py
│       └── feature.py
│
├── tests/              # Test files
│   ├── test_core.py
│   └── test_helpers.py
│
├── docs/               # Documentation
│   └── index.md
│
├── .gitignore          # Git ignore file
├── README.md           # Project description
├── requirements.txt    # Dependencies
├── setup.py            # Installation script
└── Dockerfile          # Container definition</code></pre>
            
            <p><em>Real-world application:</em> Open-source libraries follow consistent project structures to make contribution and adoption easier for the community.</p>
            
            <h3>The Importance of README Files</h3>
            <p>A good README.md file typically includes:</p>
            
            <ul>
                <li>Project name and description</li>
                <li>Installation instructions</li>
                <li>Usage examples</li>
                <li>Configuration options</li>
                <li>Contributing guidelines</li>
                <li>License information</li>
            </ul>
            
            <p><em>Real-world application:</em> Documentation-first development approaches write the README before writing code, ensuring the project has a clear purpose and interface.</p>
        </section>

        <section class="review_section">
            <h2>Comparison: Python vs JavaScript Dependencies</h2>
            
            <p>For those coming from JavaScript backgrounds, let's compare dependency management approaches:</p>
            
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Python</th>
                        <th>JavaScript</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Package Manager</td>
                        <td>pip</td>
                        <td>npm/yarn</td>
                    </tr>
                    <tr>
                        <td>Dependencies File</td>
                        <td>requirements.txt</td>
                        <td>package.json</td>
                    </tr>
                    <tr>
                        <td>Lock File</td>
                        <td>Pipfile.lock (with pipenv)</td>
                        <td>package-lock.json / yarn.lock</td>
                    </tr>
                    <tr>
                        <td>Environment Isolation</td>
                        <td>virtualenv, venv</td>
                        <td>node_modules directory</td>
                    </tr>
                    <tr>
                        <td>Version Specification</td>
                        <td>requests>=2.25.1,&lt;3.0.0</td>
                        <td>"express": "^4.17.1"</td>
                    </tr>
                </tbody>
            </table>
            
            <p><em>Real-world application:</em> Full-stack developers working with both Python backends and JavaScript frontends need to understand both dependency systems to maintain project coherence.</p>
        </section>

        <section class="review_section">
            <h2>Practical Exercise: Building a Command-Line Tool</h2>
            
            <p>Let's tie everything together with a practical example: a command-line tool that reads CSV data, performs analysis, and outputs results.</p>
            
            <pre><code># File: data_analyzer.py
import argparse
import csv
from collections import defaultdict
import json
import sys


def read_csv_data(file_path):
    """Read CSV file and return list of dictionaries"""
    try:
        with open(file_path, 'r', newline='') as file:
            reader = csv.DictReader(file)
            return list(reader)
    except FileNotFoundError:
        print(f"Error: File {file_path} not found.")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading file: {e}")
        sys.exit(1)


def analyze_sales_by_category(data):
    """Group sales by category and calculate totals"""
    sales_by_category = defaultdict(float)
    
    for row in data:
        try:
            category = row['Category']
            amount = float(row['Amount'])
            sales_by_category[category] += amount
        except (KeyError, ValueError) as e:
            print(f"Warning: Could not process row - {e}")
            continue
    
    # Convert to regular dict and sort by value
    return dict(sorted(
        sales_by_category.items(), 
        key=lambda item: item[1], 
        reverse=True
    ))


def main():
    # Set up argument parser
    parser = argparse.ArgumentParser(description='Analyze sales data from CSV files')
    parser.add_argument('file', help='CSV file to analyze')
    parser.add_argument('--output', choices=['text', 'json'], default='text',
                      help='Output format (default: text)')
    
    args = parser.parse_args()
    
    # Read and analyze data
    data = read_csv_data(args.file)
    results = analyze_sales_by_category(data)
    
    # Output results in requested format
    if args.output == 'json':
        print(json.dumps(results, indent=2))
    else:
        print("Sales by Category:")
        for category, total in results.items():
            print(f"{category}: ${total:.2f}")


if __name__ == "__main__":
    main()</code></pre>
            
            <p><em>Example usage:</em></p>
            <pre><code># Running the tool
python data_analyzer.py sales_data.csv

# With JSON output format
python data_analyzer.py sales_data.csv --output json</code></pre>
            
            <p>This example incorporates many of the concepts we've learned:</p>
            <ul>
                <li>Functions with docstrings</li>
                <li>Error handling with try/except</li>
                <li>File I/O with context managers</li>
                <li>Data structures (lists, dictionaries, defaultdict)</li>
                <li>Command-line argument parsing</li>
                <li>Module organization with __main__ block</li>
                <li>JSON serialization</li>
            </ul>
            
            <p><em>Real-world application:</em> Data engineers build similar tools for ETL (Extract, Transform, Load) processes to prepare data for analytics platforms and dashboards.</p>
        </section>

        <section class="review_section">
            <h2>Common Pitfalls and Best Practices</h2>
            
            <h3>Mutable Default Arguments</h3>
            <p>One common Python gotcha is using mutable objects as default arguments:</p>
            
            <pre><code># Problematic - the list is created once when the function is defined
def add_user_to_group(user, group=[]):
    group.append(user)
    return group

# First call
team_a = add_user_to_group("Alice")  # Returns ["Alice"]

# Second call - you might expect a new list
team_b = add_user_to_group("Bob")    # Returns ["Alice", "Bob"] - not what you wanted!

# Better approach
def add_user_to_group_fixed(user, group=None):
    if group is None:
        group = []
    group.append(user)
    return group</code></pre>
            
            <p><em>Real-world impact:</em> This subtle bug can cause data leakage between different users or requests in web applications, potentially exposing private information.</p>
            
            <h3>PEP 8 Style Guide</h3>
            <p>Following the PEP 8 style guide makes your code more readable and maintainable:</p>
            
            <ul>
                <li>Use 4 spaces for indentation (not tabs)</li>
                <li>Limit lines to 79 characters</li>
                <li>Use snake_case for functions and variables</li>
                <li>Use CamelCase for classes</li>
                <li>Group imports: standard library, third-party, local</li>
            </ul>
            
            <p><em>Real-world impact:</em> Most professional Python teams enforce PEP 8 compliance through linters and code reviews, so following these conventions makes your code more employable.</p>
        </section>

        <section class="review_section">
            <h2>Next Steps in Your Python Journey</h2>
            
            <p>As we conclude Week 2, you're now equipped with the core building blocks of Python programming. Next week, we'll dive deeper into:</p>
            
            <ul>
                <li>Object-Oriented Programming principles</li>
                <li>Advanced file handling and exception patterns</li>
                <li>Working with external data formats like JSON and CSV</li>
                <li>Leveraging the standard library for common tasks</li>
                <li>Building more complex applications</li>
            </ul>
            
            <p>In the meantime, practice what you've learned by:</p>
            <ol>
                <li>Refactoring your previous assignments to use functions and modules</li>
                <li>Converting a script-based solution to use proper command-line arguments</li>
                <li>Creating a small utility that solves a real problem you have</li>
            </ol>
            
            <p><em>Real-world insight:</em> Professional developers spend more time reading and modifying code than writing new code from scratch. Practice reading other people's code (like open-source projects) to build this crucial skill.</p>
        </section>

        <section class="assignment">
            <h2>Weekend Project: Building a Command-Line Utility</h2>
            
            <p>Your weekend project is to create a command-line tool that demonstrates multiple Python concepts from this week. Choose one of these options or propose your own:</p>
            
            <ol>
                <li><strong>File Organization Tool:</strong> Create a script that organizes files in a directory based on their extension, creation date, or other criteria</li>
                <li><strong>Personal Finance Tracker:</strong> Build a tool to track expenses from CSV bank exports, categorize them, and report spending patterns</li>
                <li><strong>URL Shortener:</strong> Develop a utility that shortens URLs and stores the mappings in a local file database</li>
                <li><strong>Weather Reporter:</strong> Create a tool that fetches weather data for a location and presents it in a readable format</li>
            </ol>
            
            <p>Your project should include:</p>
            <ul>
                <li>Well-organized code with proper modules</li>
                <li>Command-line argument parsing</li>
                <li>Error handling with try/except</li>
                <li>At least one custom data structure (class or complex dictionary)</li>
                <li>File I/O operations</li>
                <li>A clear README explaining how to use your tool</li>
                <li>Comments and docstrings explaining your code</li>
            </ul>
            
            <p>This project will serve as a portfolio piece demonstrating your Python skills!</p>
        </section>
    </main>

    <footer>
        <p>Python Full Stack Web Developer Course - Fundamentals Module</p>
        <p>File location: /week2/friday_afternoon_review.html</p>
    </footer>
</body>
</html>
