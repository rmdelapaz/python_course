<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Running Python Scripts</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Running Python Scripts</h1>
        <h2>Week 2: Python Fundamentals - Executing Python Programs</h2>
    </header>

    <main>
        <section class="session_intro">
            <h3>Session Overview</h3>
            <p>Welcome to our deep dive into running Python scripts! While the REPL is excellent for exploration and experimentation, most real Python development happens in script files. Today, we'll explore various ways to execute Python scripts, pass arguments to them, manage their execution environment, and incorporate them into larger systems. These skills form the foundation of practical Python programming.</p>
        </section>

        <section class="script_basics">
            <h3>Understanding Python Scripts</h3>
            
            <p>Python scripts are text files containing Python code that can be executed as a complete program. Unlike interactive REPL sessions, scripts allow you to save your code, run it repeatedly, automate tasks, and build larger applications.</p>
            
            <h4>What Makes a Python Script</h4>
            
            <ul>
                <li><strong>File extension:</strong> Python scripts typically use the <code>.py</code> extension</li>
                <li><strong>Executable code:</strong> Contains Python code that runs from top to bottom</li>
                <li><strong>Reusability:</strong> Can be run repeatedly with the same or different inputs</li>
                <li><strong>Modularity:</strong> Can be imported into other scripts or the REPL</li>
            </ul>
            
            <h4>Creating Your First Script</h4>
            
            <p>Let's create a simple "Hello World" script:</p>
            
            <ol>
                <li>Open a text editor (VS Code, Sublime Text, Notepad++, etc.)</li>
                <li>Create a new file called <code>hello_world.py</code></li>
                <li>Add the following code:</li>
            </ol>
            
            <pre><code># This is a comment in Python
print("Hello, World!")
print("Welcome to Python programming!")

# Variables and simple calculation
name = "Python Learner"
experience_years = 5
print(f"{name} has {experience_years} years of programming experience.")
print(f"In 2 more years, they will have {experience_years + 2} years of experience.")</code></pre>
            
            <p>This simple script demonstrates several key concepts:</p>
            <ul>
                <li>Comments (lines starting with #)</li>
                <li>Print statements for output</li>
                <li>Variable declarations and usage</li>
                <li>String formatting with f-strings</li>
                <li>Basic arithmetic operations</li>
            </ul>
            
            <div class="analogy_box">
                <h4>Analogy: Scripts vs. Interactive Sessions</h4>
                <p>Think of the difference between Python scripts and REPL sessions like the difference between writing a letter and having a conversation:</p>
                <ul>
                    <li><strong>REPL (Conversation):</strong> Immediate back-and-forth, good for exploration and quick questions, but ephemeral</li>
                    <li><strong>Script (Letter):</strong> Carefully crafted, can be reviewed and edited before "sending," permanently recorded, can be referenced later</li>
                </ul>
                <p>Just as you would choose a letter for important, reusable communication and a conversation for exploration, you choose between scripts and REPL based on your programming needs.</p>
            </div>
        </section>

        <section class="running_basics">
            <h3>Basic Ways to Run Python Scripts</h3>
            
            <h4>Method 1: Command Line Execution</h4>
            
            <p>The most common way to run a Python script is from the command line:</p>
            
            <pre><code># On systems with Python as the default interpreter
python hello_world.py

# On systems with both Python 2 and 3 installed
python3 hello_world.py</code></pre>
            
            <p>This invokes the Python interpreter and passes your script file as an argument. The interpreter reads the file, compiles it to bytecode (an intermediate representation), and then executes it.</p>
            
            <h4>Method 2: Integrated Development Environments (IDEs)</h4>
            
            <p>Most Python IDEs provide a "Run" button or keyboard shortcut to execute the current script:</p>
            <ul>
                <li><strong>VS Code:</strong> Press F5 or use the Run button</li>
                <li><strong>PyCharm:</strong> Right-click in the editor and select "Run" or press Shift+F10</li>
                <li><strong>IDLE:</strong> Press F5 or use the Run menu</li>
            </ul>
            
            <p>IDEs often provide additional features such as:</p>
            <ul>
                <li>Integrated terminal output</li>
                <li>Debugging capabilities</li>
                <li>Variable inspection</li>
                <li>Performance profiling</li>
            </ul>
            
            <h4>Method 3: File Explorer (Windows)</h4>
            
            <p>On Windows, if Python is correctly associated with .py files, you can double-click a Python script in File Explorer to run it. However, this method has limitations:</p>
            <ul>
                <li>The console window may close immediately after execution</li>
                <li>You cannot easily provide command-line arguments</li>
                <li>This method is not suitable for scripts that require user input</li>
            </ul>
            
            <p>For scripts that need to stay open after execution on Windows, add this at the end:</p>
            
            <pre><code>input("Press Enter to exit...")</code></pre>
        </section>

        <section class="script_execution_modes">
            <h3>Advanced Script Execution Modes</h3>
            
            <h4>Making Scripts Executable (Unix/Linux/macOS)</h4>
            
            <p>On Unix-based systems, you can make Python scripts directly executable:</p>
            
            <ol>
                <li>Add a shebang line at the top of your script:</li>
            </ol>
            
            <pre><code>#!/usr/bin/env python3
print("This script is directly executable!")</code></pre>
            
            <p>The shebang line (<code>#!/usr/bin/env python3</code>) tells the system which interpreter to use for executing the script.</p>
            
            <ol start="2">
                <li>Make the script executable using chmod:</li>
            </ol>
            
            <pre><code>chmod +x my_script.py</code></pre>
            
            <ol start="3">
                <li>Run the script directly:</li>
            </ol>
            
            <pre><code>./my_script.py</code></pre>
            
            <p>This approach is common in system automation and DevOps workflows.</p>
            
            <h4>Running as a Module</h4>
            
            <p>Python can run scripts as modules using the <code>-m</code> flag:</p>
            
            <pre><code>python -m my_module</code></pre>
            
            <p>This is different from direct execution in several ways:</p>
            <ul>
                <li>Python adds the current directory to <code>sys.path</code></li>
                <li>The module's <code>__name__</code> is set to <code>__main__</code></li>
                <li>You don't need to include the <code>.py</code> extension</li>
                <li>The module must be importable (e.g., valid Python package structure)</li>
            </ul>
            
            <p>This approach is commonly used for built-in modules with runnable functionality:</p>
            
            <pre><code># Run the HTTP server module
python -m http.server 8000

# Run the unit test discovery module
python -m unittest discover</code></pre>
            
            <h4>Interactive Mode with Scripts</h4>
            
            <p>You can run a script and then drop into an interactive session using the <code>-i</code> flag:</p>
            
            <pre><code>python -i my_script.py</code></pre>
            
            <p>This executes the script and then starts the REPL with all the script's variables and functions available for interactive use. This is extremely useful for debugging and exploring the state after script execution.</p>
        </section>

        <section class="command_line_args">
            <h3>Command-Line Arguments</h3>
            
            <p>Command-line arguments allow users to provide input to scripts at runtime, making them more flexible and reusable.</p>
            
            <h4>Basic Argument Handling with sys.argv</h4>
            
            <p>The simplest way to handle command-line arguments is using the <code>sys.argv</code> list:</p>
            
            <pre><code>import sys

# sys.argv[0] is the script name
# sys.argv[1:] are the arguments passed to the script

if len(sys.argv) > 1:
    name = sys.argv[1]
    print(f"Hello, {name}!")
else:
    print("Hello, stranger! Please provide your name as an argument.")</code></pre>
            
            <p>Save this as <code>greet.py</code> and run it with:</p>
            
            <pre><code>python greet.py Alice</code></pre>
            
            <p>The output will be:</p>
            
            <pre><code>Hello, Alice!</code></pre>
            
            <h4>Advanced Argument Parsing with argparse</h4>
            
            <p>For more complex argument handling, use the <code>argparse</code> module from the standard library:</p>
            
            <pre><code>import argparse

# Create an argument parser
parser = argparse.ArgumentParser(description='A greeting script with options.')

# Add arguments
parser.add_argument('name', help='Name of the person to greet')
parser.add_argument('--title', '-t', help='Title for the person')
parser.add_argument('--repeat', '-r', type=int, default=1, help='Number of times to repeat the greeting')

# Parse arguments
args = parser.parse_args()

# Use the arguments
greeting = f"Hello"
if args.title:
    greeting += f", {args.title}"
greeting += f" {args.name}!"

for _ in range(args.repeat):
    print(greeting)</code></pre>
            
            <p>Save this as <code>advanced_greet.py</code> and run it with various arguments:</p>
            
            <pre><code>python advanced_greet.py Alice --title Dr. --repeat 3
python advanced_greet.py Bob -t Mr. -r 2
python advanced_greet.py --help</code></pre>
            
            <p>The <code>argparse</code> module provides many benefits:</p>
            <ul>
                <li>Automatic help message generation</li>
                <li>Type conversion and validation</li>
                <li>Short and long argument formats</li>
                <li>Required vs. optional arguments</li>
                <li>Default values</li>
            </ul>
            
            <div class="analogy_box">
                <h4>Analogy: Command-Line Arguments as Function Parameters</h4>
                <p>Command-line arguments are like parameters to a function:</p>
                <ul>
                    <li>They allow you to pass data into your script</li>
                    <li>They can have default values</li>
                    <li>They can be required or optional</li>
                    <li>They can be validated or converted to specific types</li>
                </ul>
                <p>Just as a well-designed function has clear parameters, a well-designed script has clear command-line arguments that make it flexible and reusable.</p>
            </div>
        </section>

        <section class="script_execution_env">
            <h3>Script Execution Environment</h3>
            
            <h4>Environment Variables</h4>
            
            <p>Scripts can access environment variables to configure their behavior:</p>
            
            <pre><code>import os

# Access environment variables
db_url = os.environ.get('DATABASE_URL', 'sqlite:///default.db')
debug_mode = os.environ.get('DEBUG', 'False').lower() == 'true'

print(f"Database URL: {db_url}")
print(f"Debug mode: {debug_mode}")

# For development, you can set environment variables before running
# export DATABASE_URL="postgresql://user:pass@localhost/mydb"
# export DEBUG="True"</code></pre>
            
            <p>This approach allows you to change script behavior without modifying code, which is especially useful for:</p>
            <ul>
                <li>Different deployment environments (development, testing, production)</li>
                <li>Sensitive information (API keys, passwords)</li>
                <li>User-specific configuration</li>
            </ul>
            
            <h4>Working Directory and File Paths</h4>
            
            <p>Scripts often need to work with files in specific locations:</p>
            
            <pre><code>import os

# Get the current working directory
current_dir = os.getcwd()
print(f"Current directory: {current_dir}")

# Get the directory containing the script
script_dir = os.path.dirname(os.path.abspath(__file__))
print(f"Script directory: {script_dir}")

# Construct paths relative to the script
data_path = os.path.join(script_dir, 'data', 'input.csv')
print(f"Data file path: {data_path}")

# Check if a file exists
if os.path.exists(data_path):
    print(f"Data file exists: {data_path}")
else:
    print(f"Data file does not exist: {data_path}")</code></pre>
            
            <p>Using <code>__file__</code> to find the script directory makes your code more robust, as it works regardless of the current working directory when the script is launched.</p>
            
            <h4>Exit Codes</h4>
            
            <p>Scripts can communicate their execution status through exit codes:</p>
            
            <pre><code>import sys

def process_data(filename):
    try:
        with open(filename, 'r') as f:
            # Process the file...
            print(f"Successfully processed {filename}")
            return True
    except FileNotFoundError:
        print(f"Error: File not found: {filename}")
        return False
    except Exception as e:
        print(f"Error processing file: {e}")
        return False

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Error: Please provide a filename")
        sys.exit(1)  # Exit with error code 1
    
    filename = sys.argv[1]
    success = process_data(filename)
    
    if success:
        sys.exit(0)  # Exit with success code 0
    else:
        sys.exit(2)  # Exit with error code 2</code></pre>
            
            <p>Exit codes are important for:</p>
            <ul>
                <li>Scripts called from other programs or scripts</li>
                <li>Batch processing and automation</li>
                <li>Error handling in shell scripts</li>
            </ul>
            
            <p>By convention, exit code 0 indicates success, while any non-zero value indicates an error.</p>
        </section>

        <section class="script_modularity">
            <h3>Script Modularity and Reusability</h3>
            
            <h4>The __name__ == "__main__" Pattern</h4>
            
            <p>A common pattern in Python scripts is the <code>if __name__ == "__main__":</code> check:</p>
            
            <pre><code># math_utils.py
def add(a, b):
    """Add two numbers and return the result."""
    return a + b

def multiply(a, b):
    """Multiply two numbers and return the result."""
    return a * b

# This block only runs when the script is executed directly
if __name__ == "__main__":
    print("Testing math utilities:")
    print(f"5 + 3 = {add(5, 3)}")
    print(f"4 * 6 = {multiply(4, 6)}")
    
    # You could also add command-line parsing here
    # import sys
    # a = int(sys.argv[1])
    # b = int(sys.argv[2])
    # print(f"{a} + {b} = {add(a, b)}")
    # print(f"{a} * {b} = {multiply(a, b)}")</code></pre>
            
            <p>This pattern provides dual functionality:</p>
            <ul>
                <li>When run as a script (<code>python math_utils.py</code>), the test code executes</li>
                <li>When imported as a module (<code>import math_utils</code>), only the functions are defined, but the test code doesn't run</li>
            </ul>
            
            <p>This makes your code both executable and importable, which is a cornerstone of Python's reusability.</p>
            
            <h4>Creating Executable Modules</h4>
            
            <p>You can structure a Python package to be both importable and executable:</p>
            
            <pre><code># my_package/__main__.py
"""
This file makes the package directly executable with:
python -m my_package
"""
from .core import main

if __name__ == "__main__":
    main()</code></pre>
            
            <pre><code># my_package/core.py
def main():
    """Main function implementing the core functionality."""
    print("Running the main package functionality!")
    # ... actual code here ...

def helper_function():
    """A helper function used by main()."""
    return "Helper result"</code></pre>
            
            <p>This structure allows for:</p>
            <ul>
                <li>Running as a module: <code>python -m my_package</code></li>
                <li>Importing specific functions: <code>from my_package.core import helper_function</code></li>
                <li>Clean separation between execution logic and core functionality</li>
            </ul>
            
            <h4>Organizing Larger Scripts</h4>
            
            <p>As scripts grow, organize them into functions with a clear entry point:</p>
            
            <pre><code>#!/usr/bin/env python3
"""
A data processing script that demonstrates good organization.
"""
import argparse
import logging
import os
import sys

def setup_logging(verbose=False):
    """Configure logging based on verbosity level."""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(level=level, format='%(levelname)s: %(message)s')

def parse_arguments():
    """Parse and return command-line arguments."""
    parser = argparse.ArgumentParser(description="Process data files.")
    parser.add_argument('input', help='Input file path')
    parser.add_argument('output', help='Output file path')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    return parser.parse_args()

def read_data(input_path):
    """Read and parse the input data file."""
    logging.info(f"Reading data from {input_path}")
    try:
        with open(input_path, 'r') as f:
            return f.readlines()
    except Exception as e:
        logging.error(f"Failed to read input file: {e}")
        sys.exit(1)

def process_data(data):
    """Process the input data and return the results."""
    logging.info(f"Processing {len(data)} lines of data")
    # ... processing logic here ...
    return [line.upper() for line in data]  # Example: convert to uppercase

def write_results(output_path, results):
    """Write the processed results to the output file."""
    logging.info(f"Writing results to {output_path}")
    try:
        with open(output_path, 'w') as f:
            f.writelines(results)
    except Exception as e:
        logging.error(f"Failed to write output file: {e}")
        sys.exit(2)

def main():
    """Main entry point for the script."""
    args = parse_arguments()
    setup_logging(args.verbose)
    
    logging.debug("Starting data processing job")
    
    data = read_data(args.input)
    results = process_data(data)
    write_results(args.output, results)
    
    logging.info("Processing completed successfully")
    return 0

if __name__ == "__main__":
    sys.exit(main())</code></pre>
            
            <p>Benefits of this organization:</p>
            <ul>
                <li>Each function has a single responsibility</li>
                <li>Clear entry point through <code>main()</code></li>
                <li>Proper error handling and logging</li>
                <li>Testable components</li>
                <li>Exit code management</li>
            </ul>
            
            <div class="analogy_box">
                <h4>Analogy: Well-Structured Scripts as Recipes</h4>
                <p>A well-structured script is like a professional recipe:</p>
                <ul>
                    <li>Ingredients (arguments, inputs) are clearly listed at the beginning</li>
                    <li>Each step (function) has a specific purpose and clear instructions</li>
                    <li>Steps are performed in a logical order</li>
                    <li>The recipe can be scaled or adapted for different situations</li>
                    <li>Experienced chefs (developers) can reuse components in other recipes</li>
                </ul>
                <p>Just as a good recipe is easy to follow and adapt, a well-structured script is easy to understand and maintain.</p>
            </div>
        </section>

        <section class="real_world_examples">
            <h3>Real-World Script Examples</h3>
            
            <h4>Data Processing Script</h4>
            
            <p>This script processes CSV data, a common task in data analysis:</p>
            
            <pre><code>#!/usr/bin/env python3
"""
Process sales data to generate a summary report.
"""
import csv
import argparse
from collections import defaultdict
from datetime import datetime

def parse_args():
    parser = argparse.ArgumentParser(description='Generate sales report from CSV data')
    parser.add_argument('input_file', help='Input CSV file path')
    parser.add_argument('output_file', help='Output report file path')
    parser.add_argument('--year', type=int, help='Filter by year')
    return parser.parse_args()

def process_sales_data(input_file, year_filter=None):
    sales_by_region = defaultdict(float)
    sales_by_product = defaultdict(float)
    total_sales = 0.0
    
    with open(input_file, 'r', newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            # Parse the date
            date = datetime.strptime(row['date'], '%Y-%m-%d')
            
            # Apply year filter if specified
            if year_filter and date.year != year_filter:
                continue
                
            # Extract data
            region = row['region']
            product = row['product']
            amount = float(row['amount'])
            
            # Update our aggregations
            sales_by_region[region] += amount
            sales_by_product[product] += amount
            total_sales += amount
    
    return {
        'total_sales': total_sales,
        'sales_by_region': sales_by_region,
        'sales_by_product': sales_by_product,
    }

def write_report(output_file, data):
    with open(output_file, 'w') as f:
        f.write("SALES REPORT\n")
        f.write("=" * 40 + "\n\n")
        
        f.write(f"Total Sales: ${data['total_sales']:.2f}\n\n")
        
        f.write("Sales by Region:\n")
        for region, amount in sorted(data['sales_by_region'].items()):
            f.write(f"  {region}: ${amount:.2f}\n")
        f.write("\n")
        
        f.write("Sales by Product:\n")
        for product, amount in sorted(data['sales_by_product'].items()):
            f.write(f"  {product}: ${amount:.2f}\n")

def main():
    args = parse_args()
    data = process_sales_data(args.input_file, args.year)
    write_report(args.output_file, data)
    print(f"Report written to {args.output_file}")

if __name__ == "__main__":
    main()</code></pre>
            
            <h4>Automation Script</h4>
            
            <p>This script automates a common development workflow:</p>
            
            <pre><code>#!/usr/bin/env python3
"""
Automate the process of updating code, running tests, and deploying if tests pass.
"""
import os
import subprocess
import argparse
import logging
import sys

def setup_logging(verbose=False):
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

def parse_args():
    parser = argparse.ArgumentParser(description='Automate code update and deployment')
    parser.add_argument('repo_dir', help='Repository directory')
    parser.add_argument('--branch', default='main', help='Branch to update')
    parser.add_argument('--deploy', action='store_true', help='Deploy if tests pass')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    return parser.parse_args()

def run_command(command, cwd=None):
    """Run a shell command and return its output and status."""
    logging.debug(f"Running command: {command}")
    try:
        result = subprocess.run(
            command,
            shell=True,
            cwd=cwd,
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        return True, result.stdout
    except subprocess.CalledProcessError as e:
        return False, e.stderr

def update_code(repo_dir, branch):
    """Pull the latest code from the repository."""
    logging.info(f"Updating code in {repo_dir} (branch: {branch})")
    
    # Ensure we're on the right branch
    success, output = run_command(f"git checkout {branch}", cwd=repo_dir)
    if not success:
        logging.error(f"Failed to checkout branch {branch}: {output}")
        return False
    
    # Pull the latest changes
    success, output = run_command("git pull", cwd=repo_dir)
    if not success:
        logging.error(f"Failed to pull latest changes: {output}")
        return False
    
    logging.info("Code updated successfully")
    return True

def run_tests(repo_dir):
    """Run the test suite."""
    logging.info("Running tests...")
    success, output = run_command("python -m pytest", cwd=repo_dir)
    if not success:
        logging.error(f"Tests failed: {output}")
        return False
    
    logging.info("All tests passed!")
    return True

def deploy(repo_dir):
    """Deploy the application."""
    logging.info("Deploying application...")
    success, output = run_command("./deploy.sh", cwd=repo_dir)
    if not success:
        logging.error(f"Deployment failed: {output}")
        return False
    
    logging.info("Deployment successful!")
    return True

def main():
    args = parse_args()
    setup_logging(args.verbose)
    
    # Ensure the repository directory exists
    if not os.path.isdir(args.repo_dir):
        logging.error(f"Directory not found: {args.repo_dir}")
        return 1
    
    # Update the code
    if not update_code(args.repo_dir, args.branch):
        return 2
    
    # Run tests
    if not run_tests(args.repo_dir):
        return 3
    
    # Deploy if requested and tests passed
    if args.deploy:
        if not deploy(args.repo_dir):
            return 4
    else:
        logging.info("Skipping deployment (use --deploy to deploy)")
    
    logging.info("All tasks completed successfully")
    return 0

if __name__ == "__main__":
    sys.exit(main())</code></pre>
            
            <h4>Web API Script</h4>
            
            <p>This script interacts with a web API and processes the results:</p>
            
            <pre><code>#!/usr/bin/env python3
"""
Fetch weather data from an API and display a forecast.
"""
import argparse
import requests
import json
import sys
from datetime import datetime

def parse_args():
    parser = argparse.ArgumentParser(description='Display weather forecast for a location')
    parser.add_argument('location', help='City name or postal code')
    parser.add_argument('--api-key', help='API key (or set WEATHER_API_KEY env var)')
    parser.add_argument('--days', type=int, default=3, help='Number of days to forecast')
    parser.add_argument('--output', choices=['text', 'json'], default='text', 
                        help='Output format')
    return parser.parse_args()

def get_api_key(args):
    """Get API key from args or environment variable."""
    import os
    if args.api_key:
        return args.api_key
    
    api_key = os.environ.get('WEATHER_API_KEY')
    if not api_key:
        sys.stderr.write("Error: API key not provided. Use --api-key or set WEATHER_API_KEY environment variable.\n")
        sys.exit(1)
    
    return api_key

def fetch_weather(location, api_key, days=3):
    """Fetch weather data from the API."""
    url = "https://api.example.com/weather"
    params = {
        'location': location,
        'days': days,
        'key': api_key
    }
    
    try:
        response = requests.get(url, params=params)
        response.raise_for_status()  # Raise exception for 4XX/5XX responses
        return response.json()
    except requests.exceptions.RequestException as e:
        sys.stderr.write(f"Error fetching weather data: {e}\n")
        sys.exit(2)

def format_text_output(data):
    """Format weather data as human-readable text."""
    location = data['location']['name']
    country = data['location']['country']
    current = data['current']
    forecast = data['forecast']['forecastday']
    
    output = [
        f"Weather for {location}, {country}",
        f"Current: {current['temp_c']}°C, {current['condition']['text']}",
        "\nForecast:",
    ]
    
    for day in forecast:
        date = datetime.strptime(day['date'], '%Y-%m-%d').strftime('%a, %b %d')
        output.append(f"  {date}: {day['day']['avgtemp_c']}°C, {day['day']['condition']['text']}")
    
    return '\n'.join(output)

def main():
    args = parse_args()
    api_key = get_api_key(args)
    
    # Fetch the weather data
    data = fetch_weather(args.location, api_key, args.days)
    
    # Output the data in the requested format
    if args.output == 'json':
        print(json.dumps(data, indent=2))
    else:
        print(format_text_output(data))
    
    return 0

if __name__ == "__main__":
    sys.exit(main())</code></pre>
        </section>

        <section class="best_practices">
            <h3>Best Practices for Python Scripts</h3>
            
            <h4>Script Structure</h4>
            
            <ul>
                <li><strong>Shebang line:</strong> Start with <code>#!/usr/bin/env python3</code> for Unix compatibility</li>
                <li><strong>Docstring:</strong> Include a module-level docstring that explains the script's purpose</li>
                <li><strong>Imports:</strong> Place imports at the top of the file, grouped by standard library, third-party, and local modules</li>
                <li><strong>Functions:</strong> Break the script into logical functions with their own docstrings</li>
                <li><strong>Main entry point:</strong> Use the <code>if __name__ == "__main__"</code> pattern</li>
                <li><strong>Exit codes:</strong> Return meaningful exit codes from the main function</li>
            </ul>
            
            <h4>Error Handling</h4>
            
            <ul>
                <li><strong>Input validation:</strong> Validate all inputs, especially user-provided data</li>
                <li><strong>Specific exceptions:</strong> Catch specific exceptions rather than using bare <code>except</code> clauses</li>
                <li><strong>Meaningful errors:</strong> Provide clear error messages that help the user understand what went wrong</li>
                <li><strong>Resource cleanup:</strong> Use <code>with</code> statements to ensure resources are released even if errors occur</li>
            </ul>
            
            <h4>Documentation</h4>
            
            <ul>
                <li><strong>Script header:</strong> Include author, date, purpose, and usage information</li>
                <li><strong>Function docstrings:</strong> Document what each function does, its parameters, and return value</li>
                <li><strong>Complex logic:</strong> Explain any complex or non-obvious code with comments</li>
                <li><strong>Usage examples:</strong> Include examples in the docstring or a separate section</li>
            </ul>
            
            <h4>Testing and Debugging</h4>
            
            <ul>
                <li><strong>Testable code:</strong> Write code that can be unit tested</li>
                <li><strong>Verbose mode:</strong> Include an option for verbose output to help with debugging</li>
                <li><strong>Logging:</strong> Use the <code>logging</code> module instead of <code>print</code> for more control over output</li>
                <li><strong>Dry run mode:</strong> For scripts that modify data, consider adding a "dry run" option that shows what would happen without making changes</li>
            </ul>
            
            <h4>Performance and Scalability</h4>
            
            <ul>
                <li><strong>Memory efficiency:</strong> Process large data incrementally rather than loading it all into memory</li>
                <li><strong>Progress feedback:</strong> For long-running tasks, provide progress updates</li>
                <li><strong>Resource limitations:</strong> Be aware of system limitations (file descriptors, memory, etc.)</li>
                <li><strong>Parallel processing:</strong> Use multithreading or multiprocessing for CPU or I/O-bound tasks</li>
            </ul>
        </section>

        <section class="practical_exercises">
            <h3>Practical Exercises</h3>
            
            <h4>Exercise 1: Basic Script Creation</h4>
            
            <ol>
                <li>Create a script that asks the user for their name and age</li>
                <li>Calculate how many days they have been alive (approximately)</li>
                <li>Tell them how old they will be in 2030</li>
                <li>Make the script executable (on Unix systems) or runnable from the command line</li>
            </ol>
            
            <h4>Exercise 2: Command-Line Tool</h4>
            
            <ol>
                <li>Create a command-line tool that counts words, lines, and characters in a text file</li>
                <li>Use <code>argparse</code> to handle command-line options</li>
                <li>Add options to count only words, only lines, or only characters</li>
                <li>Add a option to exclude common words (e.g., "the", "and", "a")</li>
                <li>Make the script work with multiple input files</li>
            </ol>
            
            <h4>Exercise 3: Data Processing Script</h4>
            
            <ol>
                <li>Create a script that reads a CSV file containing data (e.g., sales records, student grades)</li>
                <li>Process the data (calculate totals, averages, etc.)</li>
                <li>Generate a report in either text or HTML format</li>
                <li>Add command-line options to filter the data</li>
                <li>Handle errors gracefully (file not found, invalid data, etc.)</li>
            </ol>
        </section>

        <section class="next_steps">
            <h3>Wrapping Up and Next Steps</h3>
            
            <p>Today we've covered the essentials of running Python scripts, from basic execution to advanced techniques and best practices. You now have the knowledge to create robust, reusable, and maintainable Python scripts for a wide variety of tasks.</p>
            
            <h4>Key Takeaways</h4>
            
            <ul>
                <li>Python scripts are saved text files with a <code>.py</code> extension that contain executable Python code</li>
                <li>Scripts can be run from the command line, IDEs, or made directly executable</li>
                <li>Command-line arguments make scripts flexible and reusable</li>
                <li>The <code>if __name__ == "__main__"</code> pattern allows code to be both importable and executable</li>
                <li>Well-structured scripts are modular, testable, and handle errors gracefully</li>
                <li>Real-world scripts often involve data processing, automation, or API interactions</li>
            </ul>
            
            <h4>Where to Go from Here</h4>
            
            <ol>
                <li>Practice creating scripts for your own common tasks and workflows</li>
                <li>Explore additional standard library modules that help with script creation (e.g., <code>pathlib</code>, <code>csv</code>, <code>json</code>)</li>
                <li>Learn about packaging and distribution to share your scripts with others</li>
                <li>Dive into testing frameworks to ensure your scripts work correctly</li>
                <li>Explore automation tools that can run your scripts on schedules or in response to events</li>
            </ol>
            
            <h4>Additional Resources</h4>
            
            <ul>
                <li><a href="https://docs.python.org/3/library/argparse.html" target="_blank">Official Python Documentation: argparse module</a></li>
                <li><a href="https://docs.python.org/3/library/__main__.html" target="_blank">Official Python Documentation: __main__ — Top-level script environment</a></li>
                <li><a href="https://realpython.com/python-command-line-arguments/" target="_blank">Real Python: Command-Line Arguments in Python</a></li>
                <li><a href="https://realpython.com/python-application-layouts/" target="_blank">Real Python: Python Application Layouts</a></li>
                <li><a href="https://click.palletsprojects.com/" target="_blank">Click: A Python package for creating command-line interfaces</a></li>
            </ul>
            
            <p>In our next session, we'll build on these concepts as we explore Python's data structures and how to effectively work with them in your scripts and applications.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
