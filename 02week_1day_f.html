<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Strings and String Manipulation</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Strings and String Manipulation</h1>
        <h2>Week 2: Python Fundamentals - Text Processing</h2>
    </header>

    <main>
        <section class="session_intro">
            <h3>Session Overview</h3>
            <p>Welcome to our deep dive into Python strings and string manipulation! Today, we'll explore how Python handles text data and the powerful tools it provides for manipulating strings. Understanding string operations is fundamental to many programming tasks, from simple text processing to complex data extraction and transformation.</p>
        </section>

        <section class="string_basics">
            <h3>String Fundamentals</h3>
            
            <p>Strings in Python are sequences of characters enclosed in quotes. They are immutable, meaning once created, they cannot be changed.</p>
            
            <h4>Creating Strings</h4>
            
            <p>Python offers multiple ways to create strings:</p>
            
            <pre><code># Single quotes
single_quoted = 'Hello, World!'

# Double quotes
double_quoted = "Hello, World!"

# Triple quotes for multi-line strings
multi_line = """This is a string that
spans multiple lines,
which makes it more readable
in the code."""

# Triple single quotes work too
also_multi_line = '''Another
multi-line
string.'''</code></pre>
            
            <p>Single and double quotes are functionally identical. Choose based on the content of your string to avoid escape characters:</p>
            
            <pre><code># When the string contains single quotes
message = "Don't worry about using escape characters here"

# When the string contains double quotes
quote = 'She said, "Python is amazing!"'</code></pre>
            
            <h4>String Immutability</h4>
            
            <p>Python strings are immutable, meaning you cannot change individual characters directly:</p>
            
            <pre><code>name = "Python"
# This will cause an error:
# name[0] = "J"

# Instead, create a new string
new_name = "J" + name[1:]  # Results in "Jython"</code></pre>
            
            <div class="analogy_box">
                <h4>Analogy: Strings as Necklaces of Beads</h4>
                <p>Think of a Python string like a necklace of letter beads:</p>
                <ul>
                    <li>Each character is like a bead on the necklace</li>
                    <li>You can examine each bead (read characters)</li>
                    <li>You can count the beads (get the length)</li>
                    <li>You can make a copy of part of the necklace (slicing)</li>
                    <li>You can join two necklaces (concatenation)</li>
                    <li>But you cannot replace a bead once the necklace is made (immutability)</li>
                    <li>To "change" a necklace, you must create a new one</li>
                </ul>
                <p>This analogy helps explain why string operations always return new strings rather than modifying existing ones.</p>
            </div>
        </section>

        <section class="accessing_characters">
            <h3>Accessing String Characters</h3>
            
            <h4>Indexing</h4>
            
            <p>Python uses zero-based indexing to access individual characters in a string:</p>
            
            <pre><code>message = "Hello, Python!"

# Positive indexing (from the beginning)
first_char = message[0]  # 'H'
fifth_char = message[4]  # 'o'

# Negative indexing (from the end)
last_char = message[-1]   # '!'
second_last = message[-2]  # 'n'</code></pre>
            
            <p>Here's a visual representation of indexing:</p>
            
            <pre>
 H  e  l  l  o  ,     P  y  t  h  o  n  !
 0  1  2  3  4  5  6  7  8  9  10 11 12 13  (Positive indices)
-14-13-12-11-10-9 -8 -7 -6 -5 -4 -3 -2 -1  (Negative indices)
            </pre>
            
            <h4>Slicing</h4>
            
            <p>Slicing allows you to extract a substring by specifying a range of indices:</p>
            
            <pre><code>message = "Hello, Python!"

# Basic slicing [start:end] (end index is exclusive)
hello = message[0:5]    # "Hello"
python = message[7:13]  # "Python"

# Omitting start or end index
beginning = message[:5]  # "Hello" (starts from 0)
end = message[7:]       # "Python!" (goes to the end)

# Using negative indices in slicing
last_word = message[-7:-1]  # "Python"

# Step parameter [start:end:step]
every_other = message[0:14:2]  # "Hlo yhn"
reversed_string = message[::-1]  # "!nohtyP ,olleH"</code></pre>
            
            <p>Remember that slicing always returns a new string without modifying the original.</p>
        </section>

        <section class="string_operations">
            <h3>Basic String Operations</h3>
            
            <h4>String Concatenation</h4>
            
            <p>You can join strings using the + operator:</p>
            
            <pre><code>first_name = "John"
last_name = "Doe"

# Concatenation with + operator
full_name = first_name + " " + last_name  # "John Doe"

# Multiple concatenations
greeting = "Hello, " + full_name + "!"    # "Hello, John Doe!"</code></pre>
            
            <h4>String Repetition</h4>
            
            <p>You can repeat a string using the * operator:</p>
            
            <pre><code># Repeating a string
separator = "-" * 20  # "--------------------"
padding = " " * 5     # "     " (5 spaces)

# Practical example
title = "MENU"
menu_header = separator + "\n" + padding + title + "\n" + separator

print(menu_header)
# Output:
# --------------------
#      MENU
# --------------------</code></pre>
            
            <h4>String Length</h4>
            
            <p>Get the length of a string using the len() function:</p>
            
            <pre><code>message = "Hello, Python!"
length = len(message)  # 14</code></pre>
            
            <h4>Checking Membership</h4>
            
            <p>You can check if a substring exists in a string using the 'in' operator:</p>
            
            <pre><code>message = "Hello, Python!"

contains_python = "Python" in message    # True
contains_java = "Java" in message        # False
not_contains_java = "Java" not in message  # True</code></pre>
        </section>

        <section class="string_methods">
            <h3>String Methods</h3>
            
            <p>Python provides a rich set of built-in methods for string manipulation. Here are some of the most useful ones:</p>
            
            <h4>Case Conversion</h4>
            
            <pre><code>message = "Hello, Python!"

# Case conversion
upper_case = message.upper()      # "HELLO, PYTHON!"
lower_case = message.lower()      # "hello, python!"
title_case = message.title()      # "Hello, Python!"
swapped_case = message.swapcase() # "hELLO, pYTHON!"
capitalized = "python is amazing".capitalize()  # "Python is amazing"</code></pre>
            
            <h4>Stripping Whitespace</h4>
            
            <pre><code># Whitespace includes spaces, tabs, and newlines
text = "   Too much whitespace   \n"

# Remove whitespace from both ends
stripped = text.strip()  # "Too much whitespace"

# Remove from left/right side only
left_stripped = text.lstrip()  # "Too much whitespace   \n"
right_stripped = text.rstrip()  # "   Too much whitespace"

# Strip specific characters
custom_stripped = "###python###".strip('#')  # "python"</code></pre>
            
            <h4>Searching and Replacing</h4>
            
            <pre><code>text = "Python is a great programming language. Python is versatile."

# Find the first occurrence
first_position = text.find("Python")  # 0
second_position = text.find("Python", 1)  # 35

# Find with a specified range
position_in_range = text.find("Python", 10, 40)  # 35

# Find all occurrences
all_positions = [i for i in range(len(text)) if text.startswith("Python", i)]
# [0, 35]

# Count occurrences
count = text.count("Python")  # 2

# Replace
replaced_once = text.replace("Python", "Ruby", 1)
# "Ruby is a great programming language. Python is versatile."

replaced_all = text.replace("Python", "Ruby")
# "Ruby is a great programming language. Ruby is versatile."</code></pre>
            
            <h4>Splitting and Joining</h4>
            
            <pre><code># Splitting a string into a list
sentence = "Python is amazing and powerful"
words = sentence.split()  # ["Python", "is", "amazing", "and", "powerful"]

# Splitting with a specific delimiter
csv_data = "apple,banana,cherry,date"
fruits = csv_data.split(',')  # ["apple", "banana", "cherry", "date"]

# Splitting with limit
limited_split = csv_data.split(',', 2)  # ["apple", "banana", "cherry,date"]

# Joining a list into a string
joined_words = " ".join(words)  # "Python is amazing and powerful"
joined_fruits = ", ".join(fruits)  # "apple, banana, cherry, date"

# Multiple delimiters using string module
import string
text = "Hello! How are you? I'm fine, thank you."
import re
sentences = re.split(r'[.!?]+', text)
# ['Hello', ' How are you', " I'm fine, thank you", '']</code></pre>
            
            <h4>Checking String Properties</h4>
            
            <pre><code># Checking string properties
print("abc123".isalnum())  # True (only letters and numbers)
print("abc".isalpha())     # True (only letters)
print("123".isdigit())     # True (only digits)
print("   ".isspace())     # True (only whitespace)
print("Title Case".istitle())  # True (each word starts with uppercase)
print("UPPER".isupper())   # True (all uppercase)
print("lower".islower())   # True (all lowercase)

# Starting and ending
print("Python".startswith("Py"))  # True
print("Python".endswith("on"))    # True</code></pre>
            
            <h4>Alignment and Padding</h4>
            
            <pre><code># Left, right, and center alignment
left_aligned = "Python".ljust(10)      # "Python    "
right_aligned = "Python".rjust(10)     # "    Python"
centered = "Python".center(10)         # "  Python  "

# With custom fill character
right_aligned_custom = "Python".rjust(10, '-')  # "----Python"
centered_custom = "Python".center(10, '*')      # "**Python**"

# Zero padding for numbers
formatted_number = "42".zfill(5)  # "00042"</code></pre>
        </section>

        <section class="string_formatting">
            <h3>String Formatting</h3>
            
            <p>Python offers several methods for formatting strings by inserting values:</p>
            
            <h4>F-Strings (Python 3.6+)</h4>
            
            <p>F-strings provide a concise and readable way to embed expressions in string literals:</p>
            
            <pre><code>name = "Alice"
age = 30

# Basic f-string
greeting = f"Hello, {name}! You are {age} years old."
# "Hello, Alice! You are 30 years old."

# Expressions in f-strings
greeting = f"Hello, {name.upper()}! In 5 years, you'll be {age + 5}."
# "Hello, ALICE! In 5 years, you'll be 35."

# Formatting specifiers
pi = 3.14159265359
formatted = f"Pi rounded to 2 decimal places: {pi:.2f}"
# "Pi rounded to 2 decimal places: 3.14"

# Padding and alignment
for i in range(1, 4):
    print(f"{i:2} - {i**2:3}")
# " 1 -   1"
# " 2 -   4"
# " 3 -   9"

# Dictionary values
person = {'name': 'Bob', 'age': 25}
formatted = f"His name is {person['name']} and he's {person['age']}."
# "His name is Bob and he's 25."</code></pre>
            
            <h4>str.format() Method</h4>
            
            <p>The format() method is another way to format strings:</p>
            
            <pre><code>name = "Alice"
age = 30

# Basic formatting
greeting = "Hello, {}! You are {} years old.".format(name, age)

# Positional arguments
greeting = "Hello, {0}! You are {1} years old. Goodbye, {0}!".format(name, age)

# Named arguments
greeting = "Hello, {name}! You are {age} years old.".format(name=name, age=age)

# Accessing object attributes and dictionary items
person = {'name': 'Bob', 'age': 25}
formatted = "His name is {0[name]} and he's {0[age]}.".format(person)
# "His name is Bob and he's 25."</code></pre>
            
            <h4>% Formatting (Legacy Style)</h4>
            
            <p>This older style is still found in legacy code:</p>
            
            <pre><code>name = "Alice"
age = 30

# Basic formatting
greeting = "Hello, %s! You are %d years old." % (name, age)

# Named placeholders
greeting = "Hello, %(name)s! You are %(age)d years old." % {'name': name, 'age': age}

# Formatting specifiers
pi = 3.14159
formatted = "Pi rounded to 2 decimal places: %.2f" % pi  # "Pi rounded to 2 decimal places: 3.14"</code></pre>
            
            <div class="analogy_box">
                <h4>Analogy: String Formatting as Filling in a Template</h4>
                <p>Think of string formatting like filling in a template form:</p>
                <ul>
                    <li>F-strings are like having a digital form that can auto-calculate fields</li>
                    <li>The format() method is like a form with numbered blanks you can reference</li>
                    <li>The % operator is like an older paper form with limited field types</li>
                </ul>
                <p>Just as you would choose a template that best fits your needs, you can choose the formatting method that works best for your specific situation, with f-strings generally being the most modern and convenient option.</p>
            </div>
        </section>

        <section class="advanced_operations">
            <h3>Advanced String Operations</h3>
            
            <h4>Regular Expressions</h4>
            
            <p>For complex pattern matching and manipulation, Python's re module provides regular expression support:</p>
            
            <pre><code>import re

text = "Contact us: support@example.com or sales-team@company.co.uk"

# Finding all email addresses
email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
emails = re.findall(email_pattern, text)
# ['support@example.com', 'sales-team@company.co.uk']

# Replacing with regex
censored = re.sub(r'[a-zA-Z0-9._%+-]+@', '***@', text)
# "Contact us: ***@example.com or ***@company.co.uk"

# Splitting with regex
parts = re.split(r'[ :]+', "apple : banana : cherry")
# ['apple', 'banana', 'cherry']

# Validating patterns
def is_valid_email(email):
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))

print(is_valid_email("user@example.com"))  # True
print(is_valid_email("invalid-email"))     # False</code></pre>
            
            <h4>String Translation</h4>
            
            <p>Translate characters using the str.translate() method:</p>
            
            <pre><code># Create a translation table
translation_table = str.maketrans({
    'a': '@',
    'e': '3',
    'i': '1',
    'o': '0',
    's': '$'
})

# Apply translation
text = "Hello, this is a secret message"
leetspeak = text.translate(translation_table)
# "H3ll0, th1$ 1$ @ $3cr3t m3$$@g3"

# Remove characters with translate
remove_punctuation = str.maketrans('', '', '.,;:!?')
cleaned_text = "Hello, World! How are you?".translate(remove_punctuation)
# "Hello World How are you"</code></pre>
            
            <h4>String Comparison</h4>
            
            <pre><code># Case-sensitive comparison
print("Python" == "python")  # False

# Case-insensitive comparison
print("Python".lower() == "python".lower())  # True

# Unicode normalization for comparison
import unicodedata
def normalized_equals(str1, str2):
    """Compare strings ignoring case and combining characters."""
    norm1 = unicodedata.normalize('NFKD', str1.lower())
    norm2 = unicodedata.normalize('NFKD', str2.lower())
    return norm1 == norm2

print(normalized_equals("Caf√©", "cafe"))  # True</code></pre>
            
            <h4>Working with Unicode</h4>
            
            <pre><code># Unicode characters
print("Unicode symbols: ‚ô† ‚ô• ‚ô¶ ‚ô£ ‚òÖ ‚ò∫")

# Converting between characters and code points
character = 'A'
code_point = ord(character)  # 65
back_to_char = chr(code_point)  # 'A'

# Emoji
print("Emoji support: üêç üëç üöÄ")

# Getting the Unicode name
import unicodedata
snake_emoji = "üêç"
print(unicodedata.name(snake_emoji))  # "SNAKE"</code></pre>
        </section>

        <section class="practical_examples">
            <h3>Practical String Manipulation Examples</h3>
            
            <h4>Text Cleaning</h4>
            
            <pre><code>def clean_text(text):
    """Remove extra whitespace, normalize case, and remove punctuation."""
    import re
    
    # Strip whitespace and convert to lowercase
    text = text.strip().lower()
    
    # Replace multiple spaces with a single space
    text = re.sub(r'\s+', ' ', text)
    
    # Remove punctuation
    text = re.sub(r'[^\w\s]', '', text)
    
    return text

dirty_text = "  Hello,   World!  How's   it going? "
cleaned = clean_text(dirty_text)
# "hello world hows it going"</code></pre>
            
            <h4>Word Counter</h4>
            
            <pre><code>def count_words(text):
    """Count word frequency in text."""
    # Clean the text
    text = clean_text(text)
    
    # Split into words
    words = text.split()
    
    # Count frequencies
    word_count = {}
    for word in words:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    
    return word_count

sample_text = """Python is amazing. Python is versatile.
                Python has many libraries for different purposes."""
                
word_frequencies = count_words(sample_text)
# {'python': 3, 'is': 2, 'amazing': 1, 'versatile': 1, 'has': 1, 'many': 1, 
#  'libraries': 1, 'for': 1, 'different': 1, 'purposes': 1}</code></pre>
            
            <h4>Simple Template Engine</h4>
            
            <pre><code>def render_template(template, context):
    """Replace placeholders in a template with values from context."""
    result = template
    for key, value in context.items():
        placeholder = '{{' + key + '}}'
        result = result.replace(placeholder, str(value))
    return result

# Template
email_template = """
Hello {{name}},

Thank you for your purchase of {{product}} on {{date}}.
Your order number is {{order_number}}.

Best regards,
{{company}} Support Team
"""

# Context
order_data = {
    'name': 'Alice Smith',
    'product': 'Python Masterclass',
    'date': '2025-04-15',
    'order_number': 'ORD-12345',
    'company': 'CodeLearners'
}

# Render
email_content = render_template(email_template, order_data)
print(email_content)</code></pre>
            
            <h4>URL Parsing</h4>
            
            <pre><code>def parse_url(url):
    """Extract components from a URL."""
    import re
    
    # Pattern for URL components
    pattern = r'^(https?://)?([^/]+)(/.*)?$'
    match = re.match(pattern, url)
    
    if not match:
        return None
    
    protocol = match.group(1) or ''
    domain = match.group(2)
    path = match.group(3) or ''
    
    # Extract query parameters if present
    query_params = {}
    if '?' in path:
        path_parts = path.split('?', 1)
        path = path_parts[0]
        query_string = path_parts[1]
        
        # Parse query string
        for param in query_string.split('&'):
            if '=' in param:
                key, value = param.split('=', 1)
                query_params[key] = value
    
    return {
        'protocol': protocol.rstrip('://'),
        'domain': domain,
        'path': path,
        'query_params': query_params
    }

url = "https://example.com/products?category=books&sort=price"
components = parse_url(url)
print(components)
# {'protocol': 'https', 'domain': 'example.com', 'path': '/products', 
#  'query_params': {'category': 'books', 'sort': 'price'}}</code></pre>
        </section>

        <section class="performance_tips">
            <h3>Performance Tips for String Operations</h3>
            
            <h4>String Concatenation</h4>
            
            <p>When concatenating many strings, use join() instead of the + operator:</p>
            
            <pre><code># Inefficient (creates a new string object each time)
result = ""
for i in range(1000):
    result += str(i)

# More efficient (builds the list in memory, then joins once)
parts = []
for i in range(1000):
    parts.append(str(i))
result = "".join(parts)

# Even better with a list comprehension
result = "".join(str(i) for i in range(1000))</code></pre>
            
            <h4>String Processing of Large Files</h4>
            
            <pre><code># Process large files line by line instead of loading the whole content
def count_lines(file_path):
    count = 0
    with open(file_path, 'r') as f:
        for line in f:  # Reads one line at a time
            count += 1
    return count</code></pre>
            
            <h4>Avoid Redundant Conversions</h4>
            
            <pre><code># Redundant operations
def inefficient(number):
    return int(str(number) + str(3))

# More efficient
def efficient(number):
    return number * 10 + 3</code></pre>
        </section>

        <section class="exercises">
            <h3>Practice Exercises</h3>
            
            <h4>Exercise 1: String Basics</h4>
            
            <ol>
                <li>Create a string with your full name</li>
                <li>Extract your first and last name using slicing</li>
                <li>Convert your name to uppercase, lowercase, and title case</li>
                <li>Calculate the length of your full name (including spaces)</li>
                <li>Replace your first name with "Mr." or "Ms."</li>
            </ol>
            
            <h4>Exercise 2: String Formatting</h4>
            
            <ol>
                <li>Create variables for a product name, price, and quantity</li>
                <li>Format a nice-looking receipt line using f-strings</li>
                <li>Format the same receipt with str.format()</li>
                <li>Create a table of products with aligned columns</li>
            </ol>
            
            <h4>Exercise 3: Advanced String Processing</h4>
            
            <p>Write a function that accepts a text string and:</p>
            <ol>
                <li>Counts the total number of characters, words, and sentences</li>
                <li>Finds the five most common words</li>
                <li>Computes the average word length</li>
                <li>Returns a dictionary with all these statistics</li>
            </ol>
            
            <h4>Exercise 4: Password Validator</h4>
            
            <p>Create a function that checks if a password meets the following criteria:</p>
            <ul>
                <li>At least 8 characters long</li>
                <li>Contains at least one uppercase letter</li>
                <li>Contains at least one lowercase letter</li>
                <li>Contains at least one digit</li>
                <li>Contains at least one special character (!@#$%^&*)</li>
            </ul>
            <p>The function should return True if the password is valid and False otherwise.</p>
        </section>

        <section class="next_steps">
            <h3>Wrapping Up and Next Steps</h3>
            
            <p>Today we've explored Python's powerful string manipulation capabilities, from basic operations to advanced techniques. Strings are fundamental to nearly all programming tasks, and mastering these concepts will serve you well in your Python journey.</p>
            
            <h4>Key Takeaways</h4>
            
            <ul>
                <li>Strings in Python are immutable sequences of characters</li>
                <li>Python provides a rich set of methods for string manipulation</li>
                <li>Modern string formatting using f-strings offers a clean, readable syntax</li>
                <li>Regular expressions provide powerful pattern matching capabilities</li>
                <li>For performance, use appropriate methods like join() for string concatenation</li>
            </ul>
            
            <h4>Where to Go from Here</h4>
            
            <ol>
                <li>Practice string manipulation by working on text processing projects</li>
                <li>Explore the re module further for advanced pattern matching</li>
                <li>Learn about Unicode and internationalization for handling text in different languages</li>
                <li>Dive into natural language processing libraries like NLTK or spaCy that build on these fundamentals</li>
            </ol>
            
            <h4>Additional Resources</h4>
            
            <ul>
                <li><a href="https://docs.python.org/3/library/string.html" target="_blank">Python Official Documentation: String Methods</a></li>
                <li><a href="https://docs.python.org/3/library/re.html" target="_blank">Python Official Documentation: Regular Expressions</a></li>
                <li><a href="https://realpython.com/python-f-strings/" target="_blank">Real Python: Python 3's f-Strings</a></li>
                <li><a href="https://realpython.com/regex-python/" target="_blank">Real Python: Regular Expressions in Python</a></li>
                <li><a href="https://unicode.org/standard/WhatIsUnicode.html" target="_blank">What is Unicode?</a></li>
            </ul>
            
            <p>In our next session, we'll build on these string manipulation skills as we explore Python's data structures and how to effectively organize and process more complex information.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
