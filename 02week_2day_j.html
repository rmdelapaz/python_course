<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementing Algorithms Using Control Structures</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Implementing Algorithms Using Control Structures</h1>
        <h2>Week 2 Day 2: Control Flow Fundamentals</h2>
    </header>

    <main>
        <section class="intro">
            <h3>Introduction to Algorithm Implementation</h3>
            <p>
                Welcome to your assignment on implementing algorithms using control structures! Algorithms are the heart of computer science and programming. They are step-by-step procedures for solving problems, making decisions, or performing calculations. In this assignment, we'll explore how to translate algorithmic thinking into Python code using the control structures we've learned: conditionals and loops.
            </p>
            <p>
                Think of algorithms as recipes. Just as a chef follows specific steps to create a dish, a programmer uses algorithms to solve problems. The control structures we've learned (if-statements, loops) are the tools that allow us to express the logic of these algorithms in code.
            </p>
            <p>
                The code for this assignment can be found in the <code>/week2/day2/algorithm_implementation.py</code> file in your course repository.
            </p>
        </section>

        <section class="assignment_overview">
            <h3>Assignment Overview</h3>
            <p>
                In this assignment, you'll implement several classic algorithms using the control structures we've covered. Each algorithm will exercise different aspects of conditional statements and loops. We'll start with simpler algorithms and progress to more complex ones, providing detailed explanations and examples along the way.
            </p>
            
            <h4>Objectives</h4>
            <ul>
                <li>Translate algorithmic thinking into Python code</li>
                <li>Apply conditional statements to handle decision-making in algorithms</li>
                <li>Use loops to iterate and process data in algorithms</li>
                <li>Combine these control structures to solve progressively more complex problems</li>
            </ul>
            
            <h4>Assignment Structure</h4>
            <ol>
                <li>Simple numeric algorithms</li>
                <li>Search algorithms</li>
                <li>Sorting algorithms</li>
                <li>Pattern recognition algorithms</li>
                <li>Challenging problems that combine multiple concepts</li>
            </ol>
        </section>

        <section class="simple_numeric">
            <h3>Simple Numeric Algorithms</h3>
            <p>
                Let's start with some basic numeric algorithms that demonstrate conditional statements and loops.
            </p>
            
            <h4>Algorithm 1: Factorial Calculation</h4>
            <p>
                The factorial of a non-negative integer n is the product of all positive integers less than or equal to n. It's denoted as n! and is a fundamental calculation in mathematics and computing.
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement a function that calculates the factorial of a given number n.</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>If n is 0 or 1, return 1 (base case)</li>
                    <li>Otherwise, initialize a result variable to 1</li>
                    <li>Loop from 2 to n (inclusive)</li>
                    <li>For each number, multiply the result by that number</li>
                    <li>Return the final result</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def factorial(n):
    """
    Calculate the factorial of a non-negative integer n.
    
    Args:
        n: A non-negative integer
        
    Returns:
        The factorial of n (n!)
    """
    # Handle base cases and input validation
    if not isinstance(n, int) or n < 0:
        raise ValueError("Input must be a non-negative integer")
    
    if n == 0 or n == 1:
        return 1
    
    # Calculate factorial using a loop
    result = 1
    for i in range(2, n + 1):
        result *= i
    
    return result

# Test cases
print(f"factorial(0) = {factorial(0)}")  # 1
print(f"factorial(1) = {factorial(1)}")  # 1
print(f"factorial(5) = {factorial(5)}")  # 120
print(f"factorial(10) = {factorial(10)}")  # 3628800
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>Conditional statements for handling base cases and input validation</li>
                <li>A <code>for</code> loop for iterating through a range of numbers</li>
                <li>The accumulation pattern, where we build up a result through repeated operations</li>
            </ul>
            <p>
                Notice how we handle edge cases (0 and 1) differently, since their factorials are defined as 1. This is a common pattern in algorithm implementation: identify special cases and handle them separately.
            </p>
            
            <h4>Algorithm 2: Prime Number Check</h4>
            <p>
                A prime number is a natural number greater than 1 that is not divisible by any positive integer other than 1 and itself. Checking whether a number is prime is a classic algorithm with applications in cryptography and number theory.
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement a function that determines whether a given number is prime.</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>If n is less than 2, return False (by definition, primes are greater than 1)</li>
                    <li>If n is 2, return True (2 is prime)</li>
                    <li>If n is even and not 2, return False (even numbers greater than 2 are not prime)</li>
                    <li>Check divisibility from 3 to the square root of n, stepping by 2 (to check only odd numbers)</li>
                    <li>If any number divides n evenly, return False</li>
                    <li>If no divisors are found, return True</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def is_prime(n):
    """
    Check if a number is prime.
    
    Args:
        n: An integer to check
        
    Returns:
        True if n is prime, False otherwise
    """
    # Handle special cases
    if n < 2:
        return False
    
    if n == 2:
        return True
    
    # Even numbers greater than 2 are not prime
    if n % 2 == 0:
        return False
    
    # Check odd divisors up to the square root of n
    # We only need to check up to the square root because
    # if n has a divisor larger than sqrt(n), it must also
    # have a smaller divisor already checked
    sqrt_n = int(n ** 0.5) + 1
    
    for divisor in range(3, sqrt_n, 2):
        if n % divisor == 0:
            return False
    
    return True

# Test cases
for num in [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 17, 19, 20, 23]:
    print(f"{num} is {'prime' if is_prime(num) else 'not prime'}")
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>Multiple conditional statements to handle special cases efficiently</li>
                <li>A <code>for</code> loop with a step parameter to iterate only through odd numbers</li>
                <li>Early return to terminate the function as soon as we know the answer</li>
                <li>Mathematical optimization by only checking divisors up to the square root</li>
            </ul>
            <p>
                The optimization techniques used here significantly improve the algorithm's efficiency. For large numbers, checking every possible divisor would be impractical. By handling even numbers separately and only checking divisors up to the square root, we greatly reduce the number of iterations required.
            </p>
            
            <h4>Algorithm 3: Fibonacci Sequence</h4>
            <p>
                The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. This sequence appears throughout nature and mathematics.
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement a function that generates the first n numbers in the Fibonacci sequence.</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>If n <= 0, return an empty list</li>
                    <li>If n == 1, return [0]</li>
                    <li>If n == 2, return [0, 1]</li>
                    <li>Initialize the sequence with [0, 1]</li>
                    <li>Loop from 2 to n-1</li>
                    <li>For each iteration, calculate the next Fibonacci number by adding the last two numbers</li>
                    <li>Append the new number to the sequence</li>
                    <li>Return the complete sequence</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def fibonacci_sequence(n):
    """
    Generate the first n numbers in the Fibonacci sequence.
    
    Args:
        n: The number of Fibonacci numbers to generate
        
    Returns:
        A list containing the first n Fibonacci numbers
    """
    # Handle edge cases
    if n <= 0:
        return []
    
    if n == 1:
        return [0]
    
    # Initialize the sequence with the first two Fibonacci numbers
    fib_sequence = [0, 1]
    
    # Generate the rest of the sequence
    for i in range(2, n):
        # Next number is the sum of the previous two
        next_fib = fib_sequence[i-1] + fib_sequence[i-2]
        fib_sequence.append(next_fib)
    
    return fib_sequence

# Test cases
print(f"fibonacci_sequence(0) = {fibonacci_sequence(0)}")   # []
print(f"fibonacci_sequence(1) = {fibonacci_sequence(1)}")   # [0]
print(f"fibonacci_sequence(2) = {fibonacci_sequence(2)}")   # [0, 1]
print(f"fibonacci_sequence(10) = {fibonacci_sequence(10)}")  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>Special case handling for small input values</li>
                <li>List manipulation, including initialization and appending</li>
                <li>A pattern where each new value depends on previously computed values</li>
                <li>Using array indexing inside a loop</li>
            </ul>
            <p>
                The Fibonacci sequence is a classic example of a recurrence relation, where each term depends on previous terms. This implementation stores all the Fibonacci numbers in a list, making it memory-efficient for small values of n but potentially memory-intensive for large values.
            </p>
        </section>

        <section class="search_algorithms">
            <h3>Search Algorithms</h3>
            <p>
                Search algorithms are fundamental in computer science, allowing us to find specific items within collections of data. We'll implement two classic search algorithms: linear search and binary search.
            </p>
            
            <h4>Algorithm 4: Linear Search</h4>
            <p>
                Linear search is the simplest search algorithm, where we check each element in a collection one by one until we find the target or exhaust the collection.
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement a function that searches for a target value in a list and returns its index (or -1 if not found).</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>Start from the first element of the list</li>
                    <li>Compare each element with the target value</li>
                    <li>If a match is found, return its index</li>
                    <li>If the end of the list is reached without finding the target, return -1</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def linear_search(arr, target):
    """
    Search for a target value in a list using linear search.
    
    Args:
        arr: A list of elements to search through
        target: The value to search for
        
    Returns:
        The index of the target if found, -1 otherwise
    """
    # Loop through each element in the list
    for i in range(len(arr)):
        # Check if the current element matches the target
        if arr[i] == target:
            return i  # Found the target, return its index
    
    # Target was not found
    return -1

# Test cases
numbers = [5, 10, 15, 20, 25, 30, 35, 40]
print(f"linear_search({numbers}, 25) = {linear_search(numbers, 25)}")  # 4
print(f"linear_search({numbers}, 7) = {linear_search(numbers, 7)}")    # -1
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>A simple <code>for</code> loop to iterate through the array</li>
                <li>Use of an early return to terminate as soon as the target is found</li>
                <li>A default return value (-1) when the target is not found</li>
            </ul>
            <p>
                Linear search is straightforward and works on any list, whether sorted or not. However, it's inefficient for large lists, as it may need to check every element in the worst case.
            </p>
            
            <h4>Algorithm 5: Binary Search</h4>
            <p>
                Binary search is a more efficient algorithm for finding an item in a sorted list. It repeatedly divides the search space in half, making it much faster than linear search for large datasets.
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement a function that searches for a target value in a sorted list using binary search and returns its index (or -1 if not found).</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>Initialize left pointer to 0 and right pointer to the last index of the list</li>
                    <li>While the left pointer is less than or equal to the right pointer:
                        <ol>
                            <li>Calculate the middle index as (left + right) // 2</li>
                            <li>If the middle element is the target, return its index</li>
                            <li>If the middle element is greater than the target, move the right pointer to middle - 1</li>
                            <li>If the middle element is less than the target, move the left pointer to middle + 1</li>
                        </ol>
                    </li>
                    <li>If the left pointer exceeds the right pointer, the target is not in the list, so return -1</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def binary_search(arr, target):
    """
    Search for a target value in a sorted list using binary search.
    
    Args:
        arr: A sorted list of elements to search through
        target: The value to search for
        
    Returns:
        The index of the target if found, -1 otherwise
    """
    # Initialize the left and right pointers
    left = 0
    right = len(arr) - 1
    
    # Continue searching while the pointers haven't crossed
    while left <= right:
        # Calculate the middle index
        # Using (left + right) // 2 can cause integer overflow for large lists
        # This alternative calculation is safer
        middle = left + (right - left) // 2
        
        # Check if the middle element is the target
        if arr[middle] == target:
            return middle  # Found the target, return its index
        
        # Decide which half to search next
        if arr[middle] > target:
            # Target is in the left half
            right = middle - 1
        else:
            # Target is in the right half
            left = middle + 1
    
    # Target was not found
    return -1

# Test cases
sorted_numbers = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
print(f"binary_search({sorted_numbers}, 30) = {binary_search(sorted_numbers, 30)}")  # 5
print(f"binary_search({sorted_numbers}, 7) = {binary_search(sorted_numbers, 7)}")    # -1
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>A <code>while</code> loop that continues until the search space is exhausted</li>
                <li>Conditional statements to decide which half of the list to search next</li>
                <li>A safer way to calculate the middle index to prevent integer overflow</li>
                <li>The "divide and conquer" paradigm, a powerful algorithmic technique</li>
            </ul>
            <p>
                Binary search is much more efficient than linear search for large sorted lists, with a time complexity of O(log n) compared to linear search's O(n). However, it requires the list to be sorted beforehand, which may not always be practical.
            </p>
            <p>
                As an analogy, think of looking up a name in a phone book. You wouldn't start from the first page and check each entry (linear search). Instead, you'd open the book to the middle, see if your target comes before or after that page, and repeat the process with the appropriate half (binary search).
            </p>
        </section>

        <section class="sorting_algorithms">
            <h3>Sorting Algorithms</h3>
            <p>
                Sorting is a fundamental operation in computer science, with applications in data processing, database systems, and more. We'll implement two simple sorting algorithms: selection sort and bubble sort.
            </p>
            
            <h4>Algorithm 6: Selection Sort</h4>
            <p>
                Selection sort is a simple sorting algorithm that repeatedly selects the smallest element from the unsorted portion and puts it at the beginning.
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement a function that sorts a list in ascending order using the selection sort algorithm.</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>Iterate through the list from index 0 to n-1:
                        <ol>
                            <li>Find the minimum element in the unsorted part of the list (from the current index to the end)</li>
                            <li>Swap the minimum element with the element at the current index</li>
                        </ol>
                    </li>
                    <li>After each iteration, the smallest element from the unsorted portion is placed in its correct position</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def selection_sort(arr):
    """
    Sort a list in ascending order using the selection sort algorithm.
    
    Args:
        arr: A list of comparable elements
        
    Returns:
        The sorted list (modifies the original list in-place)
    """
    n = len(arr)
    
    # Iterate through the list
    for i in range(n):
        # Assume the current index has the minimum value
        min_index = i
        
        # Find the minimum element in the remaining unsorted portion
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        
        # Swap the minimum element with the element at position i
        # (Only if they're different, to avoid unnecessary swaps)
        if min_index != i:
            arr[i], arr[min_index] = arr[min_index], arr[i]
    
    return arr  # Return the sorted list (though it's sorted in-place)

# Test cases
unsorted1 = [64, 25, 12, 22, 11]
print(f"selection_sort({unsorted1}) = {selection_sort(unsorted1)}")  # [11, 12, 22, 25, 64]

unsorted2 = [5, 3, 8, 1, 2]
print(f"selection_sort({unsorted2}) = {selection_sort(unsorted2)}")  # [1, 2, 3, 5, 8]
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>Nested loops: outer loop to iterate through positions, inner loop to find the minimum</li>
                <li>Conditional logic to update the minimum index when a smaller element is found</li>
                <li>In-place sorting (modifying the original list) using Python's tuple assignment for swapping</li>
                <li>Optimization to avoid unnecessary swaps</li>
            </ul>
            <p>
                Selection sort is not efficient for large lists, with a time complexity of O(n²), but it's simple to implement and performs well for small lists. It's also more efficient than bubble sort in terms of the number of swaps performed.
            </p>
            
            <h4>Algorithm 7: Bubble Sort</h4>
            <p>
                Bubble sort is another simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they're in the wrong order.
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement a function that sorts a list in ascending order using the bubble sort algorithm.</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>Iterate through the list multiple times, each time bubbling the largest element to the end:
                        <ol>
                            <li>For each pair of adjacent elements, compare them and swap if they're in the wrong order</li>
                            <li>After each complete pass, the largest element will be in its correct position</li>
                            <li>Repeat for n-1 passes, where n is the length of the list</li>
                        </ol>
                    </li>
                    <li>Optimize by tracking whether any swaps were made in a pass; if no swaps are made, the list is already sorted</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def bubble_sort(arr):
    """
    Sort a list in ascending order using the bubble sort algorithm.
    
    Args:
        arr: A list of comparable elements
        
    Returns:
        The sorted list (modifies the original list in-place)
    """
    n = len(arr)
    
    # Optimization: track whether any swaps were made in a pass
    # If no swaps are made, the list is already sorted
    for i in range(n):
        # Flag to track if any swaps were made in this pass
        swapped = False
        
        # Last i elements are already in place, so we don't need to check them
        for j in range(0, n - i - 1):
            # Compare adjacent elements
            if arr[j] > arr[j + 1]:
                # Swap them if they're in the wrong order
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # If no swaps were made in this pass, the list is already sorted
        if not swapped:
            break
    
    return arr  # Return the sorted list (though it's sorted in-place)

# Test cases
unsorted1 = [64, 34, 25, 12, 22, 11, 90]
print(f"bubble_sort({unsorted1}) = {bubble_sort(unsorted1)}")  # [11, 12, 22, 25, 34, 64, 90]

unsorted2 = [5, 1, 4, 2, 8]
print(f"bubble_sort({unsorted2}) = {bubble_sort(unsorted2)}")  # [1, 2, 4, 5, 8]
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>Nested loops: outer loop for passes, inner loop for comparisons</li>
                <li>Comparison-based swapping of adjacent elements</li>
                <li>Optimization using a <code>swapped</code> flag to exit early if the list becomes sorted</li>
                <li>Optimization to reduce the number of comparisons in each pass</li>
            </ul>
            <p>
                Bubble sort is one of the simplest sorting algorithms, but it's not efficient for large lists (O(n²) time complexity). However, it has the advantage of detecting whether the list is already sorted during execution and exiting early.
            </p>
            <p>
                Imagine bubble sort as bubbles rising in water: larger elements "bubble up" to their correct positions at the end of the list, one by one.
            </p>
        </section>

        <section class="pattern_recognition">
            <h3>Pattern Recognition Algorithms</h3>
            <p>
                Pattern recognition algorithms identify specific patterns or structures in data. We'll implement two algorithms: finding palindromes and identifying Armstrong numbers.
            </p>
            
            <h4>Algorithm 8: Palindrome Check</h4>
            <p>
                A palindrome is a word, phrase, number, or other sequence that reads the same backward as forward, such as "radar" or "level".
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement a function that checks if a given string is a palindrome, ignoring case, punctuation, and spaces.</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>Convert the string to lowercase</li>
                    <li>Remove all non-alphanumeric characters (punctuation, spaces)</li>
                    <li>Compare the processed string with its reverse</li>
                    <li>Return True if they match, False otherwise</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def is_palindrome(text):
    """
    Check if a given string is a palindrome, ignoring case, spaces, and punctuation.
    
    Args:
        text: The string to check
        
    Returns:
        True if the string is a palindrome, False otherwise
    """
    # Convert to lowercase
    text = text.lower()
    
    # Remove non-alphanumeric characters
    # This creates a new string with only letters and numbers
    processed_text = ""
    for char in text:
        if char.isalnum():  # Check if the character is a letter or number
            processed_text += char
    
    # Alternative approach using list comprehension and join:
    # processed_text = ''.join(char for char in text if char.isalnum())
    
    # Check if the processed string is equal to its reverse
    return processed_text == processed_text[::-1]

# Test cases
print(f"is_palindrome('radar') = {is_palindrome('radar')}")                          # True
print(f"is_palindrome('A man, a plan, a canal: Panama') = {is_palindrome('A man, a plan, a canal: Panama')}")  # True
print(f"is_palindrome('race a car') = {is_palindrome('race a car')}")                # False
print(f"is_palindrome('Was it a car or a cat I saw?') = {is_palindrome('Was it a car or a cat I saw?')}")      # True
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>String manipulation (lowercase conversion, character filtering)</li>
                <li>Character-by-character processing using a <code>for</code> loop</li>
                <li>Use of the <code>isalnum()</code> method to check for alphanumeric characters</li>
                <li>Python's slice notation with negative step (<code>[::-1]</code>) to reverse a string</li>
            </ul>
            <p>
                The algorithm efficiently handles various edge cases, such as mixed case, punctuation, and spaces, by preprocessing the input before checking for palindrome properties.
            </p>
            
            <h4>Algorithm 9: Armstrong Number Check</h4>
            <p>
                An Armstrong number (also known as a narcissistic number) is a number that is equal to the sum of its own digits each raised to the power of the number of digits. For example, 153 is an Armstrong number because 1³ + 5³ + 3³ = 153.
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement a function that checks if a given number is an Armstrong number.</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>Convert the number to a string to count its digits</li>
                    <li>Calculate the sum of each digit raised to the power of the number of digits</li>
                    <li>Check if the sum equals the original number</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def is_armstrong_number(n):
    """
    Check if a number is an Armstrong number.
    
    An Armstrong number is a number that is equal to the sum of its own digits
    each raised to the power of the number of digits.
    
    Args:
        n: The number to check
        
    Returns:
        True if the number is an Armstrong number, False otherwise
    """
    # Convert to string to count digits and process each digit
    num_str = str(n)
    num_digits = len(num_str)
    
    # Calculate the sum of each digit raised to the power of num_digits
    armstrong_sum = 0
    for digit in num_str:
        armstrong_sum += int(digit) ** num_digits
    
    # Check if the sum equals the original number
    return armstrong_sum == n

# Test cases
armstrong_numbers = [1, 153, 370, 371, 407]
non_armstrong_numbers = [10, 100, 154, 372]

print("Armstrong numbers:")
for num in armstrong_numbers:
    print(f"{num} is {'an Armstrong number' if is_armstrong_number(num) else 'not an Armstrong number'}")

print("\nNon-Armstrong numbers:")
for num in non_armstrong_numbers:
    print(f"{num} is {'an Armstrong number' if is_armstrong_number(num) else 'not an Armstrong number'}")
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>Converting between numeric and string representations of a number</li>
                <li>Using <code>len()</code> to determine the number of digits</li>
                <li>Using a <code>for</code> loop to iterate through each digit</li>
                <li>Accumulating a sum with the exponentiation operator (<code>**</code>)</li>
            </ul>
            <p>
                Armstrong numbers are a fascinating mathematical curiosity that require us to extract individual digits and perform calculations on them. This algorithm efficiently identifies such numbers by leveraging Python's ability to convert between numeric and string representations.
            </p>
        </section>

        <section class="challenging_problems">
            <h3>Challenging Problems</h3>
            <p>
                Let's tackle more complex problems that combine multiple concepts and require deeper algorithmic thinking.
            </p>
            
            <h4>Algorithm 10: Pascal's Triangle</h4>
            <p>
                Pascal's Triangle is a triangular array of binomial coefficients. Each number is the sum of the two numbers directly above it. It has applications in probability, algebra, and combinatorics.
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement a function that generates the first n rows of Pascal's Triangle.</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>Create an empty list to store the rows of the triangle</li>
                    <li>If n <= 0, return an empty list</li>
                    <li>If n >= 1, add the first row [1]</li>
                    <li>For each subsequent row (from 1 to n-1):
                        <ol>
                            <li>Start with [1] (the first element of each row is always 1)</li>
                            <li>For each pair of adjacent elements in the previous row, add them and append to the current row</li>
                            <li>Append 1 (the last element of each row is always 1)</li>
                            <li>Add the completed row to the triangle</li>
                        </ol>
                    </li>
                    <li>Return the completed triangle</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def generate_pascals_triangle(n):
    """
    Generate the first n rows of Pascal's Triangle.
    
    Args:
        n: The number of rows to generate
        
    Returns:
        A list of lists, where each inner list represents a row of Pascal's Triangle
    """
    # Handle edge case
    if n <= 0:
        return []
    
    # Initialize the triangle with the first row
    triangle = [[1]]
    
    # Generate subsequent rows
    for i in range(1, n):
        # The previous row
        prev_row = triangle[i - 1]
        
        # Start the new row with 1
        current_row = [1]
        
        # Calculate the middle values based on the previous row
        for j in range(1, i):
            # Each value is the sum of the two values above it
            current_row.append(prev_row[j - 1] + prev_row[j])
        
        # End the row with 1
        current_row.append(1)
        
        # Add the row to the triangle
        triangle.append(current_row)
    
    return triangle

# Function to print the triangle in a visually appealing way
def print_pascal_triangle(triangle):
    """Print Pascal's Triangle in a readable format."""
    width = len(' '.join(map(str, triangle[-1])))
    
    for row in triangle:
        # Convert numbers to strings and join with spaces
        row_str = ' '.join(map(str, row))
        # Center the row for better visualization
        print(row_str.center(width))

# Test case
rows = 6
pascal_triangle = generate_pascals_triangle(rows)
print(f"Pascal's Triangle ({rows} rows):")
print_pascal_triangle(pascal_triangle)
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>Building a complex data structure (a list of lists)</li>
                <li>Nested loops: outer loop for rows, inner loop for elements within each row</li>
                <li>Accessing elements from a previous iteration to calculate current values</li>
                <li>Special handling for the first and last elements of each row</li>
            </ul>
            <p>
                Pascal's Triangle demonstrates a beautiful mathematical pattern where each element is calculated from the elements above it. This recursive relationship makes it a perfect candidate for implementation with loops.
            </p>
            
            <h4>Algorithm 11: Sieve of Eratosthenes</h4>
            <p>
                The Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers up to a specified limit. It efficiently filters out non-prime numbers by marking multiples of each prime.
            </p>
            
            <div class="algorithm_description">
                <h5>Problem Statement</h5>
                <p>Implement the Sieve of Eratosthenes algorithm to find all prime numbers up to a given limit.</p>
                
                <h5>Algorithm Steps</h5>
                <ol>
                    <li>Create a boolean array "is_prime" of size n+1, initialized as True</li>
                    <li>Set is_prime[0] and is_prime[1] to False (0 and 1 are not prime)</li>
                    <li>For each number p starting from 2 up to the square root of n:
                        <ol>
                            <li>If is_prime[p] is True, p is prime</li>
                            <li>Mark all multiples of p as non-prime by setting is_prime[p*p], is_prime[p*p+p], ... to False</li>
                        </ol>
                    </li>
                    <li>Collect all indices p where is_prime[p] is True, these are the prime numbers</li>
                </ol>
            </div>
            
            <h5>Implementation</h5>
            <pre><code>def sieve_of_eratosthenes(n):
    """
    Find all prime numbers up to n using the Sieve of Eratosthenes algorithm.
    
    Args:
        n: Upper limit for finding primes
        
    Returns:
        A list of all prime numbers less than or equal to n
    """
    # Handle edge cases
    if n < 2:
        return []
    
    # Initialize a boolean array for tracking prime numbers
    # Initially, assume all numbers are prime
    is_prime = [True] * (n + 1)
    
    # 0 and 1 are not prime
    is_prime[0] = is_prime[1] = False
    
    # Process each potential prime number
    # We only need to check up to the square root of n
    for i in range(2, int(n**0.5) + 1):
        # If i is prime, mark all its multiples as non-prime
        if is_prime[i]:
            # Start marking from i*i, as smaller multiples would have been
            # marked by smaller primes already
            for j in range(i*i, n + 1, i):
                is_prime[j] = False
    
    # Collect all prime numbers
    primes = [i for i in range(2, n + 1) if is_prime[i]]
    
    return primes

# Test cases
limit = 50
primes = sieve_of_eratosthenes(limit)
print(f"Prime numbers up to {limit}: {primes}")
print(f"Count: {len(primes)}")
</code></pre>

            <h5>Analysis</h5>
            <p>
                This algorithm demonstrates:
            </p>
            <ul>
                <li>Using a boolean array to track state (whether each number is prime)</li>
                <li>Nested loops with an optimized approach (marking multiples starting from p²)</li>
                <li>Mathematical optimization by only checking up to the square root of n</li>
                <li>List comprehension to collect results based on a condition</li>
            </ul>
            <p>
                The Sieve of Eratosthenes is an efficient algorithm for finding all primes up to a limit, with a time complexity of O(n log log n). It's much faster than testing each number individually for primality, especially for large values of n.
            </p>
            <p>
                Visualize this algorithm as systematically crossing out numbers in a table: first all multiples of 2, then all multiples of 3, and so on. The numbers that remain unmarked are the primes.
            </p>
        </section>

        <section class="submission_guidelines">
            <h3>Submission Guidelines</h3>
            <p>
                For this assignment, you will submit a Python file containing all the implemented algorithms. Make sure to:
            </p>
            <ol>
                <li>Include docstrings for each function explaining what the algorithm does, its parameters, and its return values</li>
                <li>Add comments to explain the key steps in your implementations</li>
                <li>Test your algorithms with various inputs to ensure they work correctly</li>
                <li>Name your submission file <code>algorithm_implementation.py</code></li>
            </ol>
            <p>
                Submit your file through the course platform by the specified deadline. Your assignment will be evaluated based on:
            </p>
            <ul>
                <li>Correctness of your implementations</li>
                <li>Code organization and readability</li>
                <li>Proper use of control structures</li>
                <li>Algorithm efficiency and optimization</li>
                <li>Documentation and comments</li>
            </ul>
        </section>

        <section class="conclusion">
            <h3>Conclusion</h3>
            <p>
                In this assignment, you've implemented a variety of algorithms using Python's control structures. Through these implementations, you've learned how to:
            </p>
            <ul>
                <li>Translate algorithmic thinking into working code</li>
                <li>Use conditionals for decision-making and handling edge cases</li>
                <li>Apply loops for repetitive tasks and iterative calculations</li>
                <li>Combine these control structures to solve complex problems</li>
                <li>Optimize algorithms for better performance</li>
            </ul>
            <p>
                These fundamental skills will serve as a strong foundation as you continue your journey in programming and computer science. The algorithms you've implemented are classics that appear in various forms across different applications and domains.
            </p>
            <p>
                Remember, learning to implement algorithms is not just about solving specific problems—it's about developing a problem-solving mindset that can be applied to any computational challenge you encounter in the future.
            </p>
        </section>

        <section class="additional_resources">
            <h3>Additional Resources</h3>
            <p>
                If you'd like to explore algorithms further, here are some recommended resources:
            </p>
            <ul>
                <li><a href="https://visualgo.net/" target="_blank">VisuAlgo</a> - Visualizations of various algorithms</li>
                <li><a href="https://leetcode.com/" target="_blank">LeetCode</a> - Practice problems with algorithmic challenges</li>
                <li><a href="https://www.geeksforgeeks.org/fundamentals-of-algorithms/" target="_blank">GeeksforGeeks</a> - Comprehensive algorithm tutorials</li>
                <li><a href="https://projecteuler.net/" target="_blank">Project Euler</a> - Mathematical and computational problems</li>
                <li>Book: "Introduction to Algorithms" by Cormen, Leiserson, Rivest, and Stein</li>
                <li>Book: "Algorithms" by Robert Sedgewick and Kevin Wayne</li>
            </ul>
            <p>
                Practice is key to mastering algorithms. Challenge yourself with different problems, experiment with variations of the algorithms we've covered, and always look for ways to improve your solutions.
            </p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
