<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Integration with SQLAlchemy</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Database Integration with SQLAlchemy</h1>
        <p class="subtitle">Week 2 - Wednesday: Full Stack Web Development with Python</p>
    </header>

    <main>
        <section>
            <h2>Introduction to Databases in Web Applications</h2>
            <p>Welcome to our third day of Week 2! Yesterday, we explored Flask, the web framework that we'll use throughout this course. Today, we'll focus on database integration with SQLAlchemy, enabling our application to persistently store and retrieve data.</p>
            
            <p>Databases are a critical component of most web applications. They provide persistent storage for user accounts, content, configuration settings, and other application data. Without a database, our application would lose all its data whenever it restarts.</p>
            
            <h3>Types of Databases</h3>
            <p>There are several types of databases, each with its own strengths and use cases:</p>
            
            <ul>
                <li><strong>Relational Databases (SQL)</strong>: Store data in tables with predefined schemas and relationships between them (PostgreSQL, MySQL, SQLite)</li>
                <li><strong>NoSQL Databases</strong>: Store data in more flexible formats like documents, key-value pairs, or graphs (MongoDB, Redis, Neo4j)</li>
                <li><strong>Time-Series Databases</strong>: Optimized for time-stamped data (InfluxDB, TimescaleDB)</li>
                <li><strong>In-Memory Databases</strong>: Store data in memory for faster access (Redis, Memcached)</li>
            </ul>
            
            <p>For our blog application, we'll use a relational database (PostgreSQL) because:</p>
            <ul>
                <li>The data we're working with naturally fits into a tabular structure</li>
                <li>We need to establish relationships between different types of data (users, posts, comments)</li>
                <li>ACID (Atomicity, Consistency, Isolation, Durability) properties ensure data integrity</li>
                <li>SQL is a powerful and widely-used query language</li>
            </ul>
            
            <h3>Database Access in Python</h3>
            <p>There are several ways to work with databases in Python:</p>
            <ul>
                <li><strong>Raw SQL</strong>: Writing SQL queries directly</li>
                <li><strong>Database API</strong>: Using database-specific Python libraries (psycopg2, sqlite3)</li>
                <li><strong>Object-Relational Mapping (ORM)</strong>: Using a library that maps database tables to Python classes (SQLAlchemy, Django ORM)</li>
            </ul>
            
            <p>In this course, we'll use SQLAlchemy, which is an ORM that allows us to work with databases using Python objects rather than writing SQL queries directly.</p>
        </section>

        <section>
            <h2>Introduction to SQLAlchemy</h2>
            
            <p>SQLAlchemy is a powerful and flexible ORM (Object-Relational Mapping) library for Python. It provides a full suite of well-known enterprise-level persistence patterns, designed for efficient and high-performing database access.</p>
            
            <h3>What is an ORM?</h3>
            <p>An ORM is a programming technique that converts data between incompatible type systems in object-oriented programming languages. This creates a "virtual object database" that can be used from within the programming language.</p>
            
            <p>Instead of writing raw SQL queries like:</p>
            <pre><code>
SELECT * FROM users WHERE username = 'john' AND is_active = True;
            </code></pre>
            
            <p>With an ORM, you can write Python code like:</p>
            <pre><code>
User.query.filter_by(username='john', is_active=True).all()
            </code></pre>
            
            <h3>Benefits of Using an ORM</h3>
            <ul>
                <li><strong>Productivity</strong>: Work with familiar Python constructs instead of writing SQL</li>
                <li><strong>Maintainability</strong>: Changes to your data model require only changes to your Python code</li>
                <li><strong>Database Independence</strong>: Switch between different database systems with minimal code changes</li>
                <li><strong>Security</strong>: Built-in protection against SQL injection attacks</li>
                <li><strong>Type Safety</strong>: Catch data type errors at compile time rather than runtime</li>
            </ul>
            
            <h3>SQLAlchemy Architecture</h3>
            <p>SQLAlchemy consists of two main components:</p>
            <ul>
                <li><strong>Core</strong>: A SQL abstraction toolkit that provides a set of tools for working with databases without the ORM</li>
                <li><strong>ORM</strong>: A higher-level interface that maps Python classes to database tables</li>
            </ul>
            
            <p>In this course, we'll primarily use the ORM, but it's good to be aware of the Core for situations where you need more control or performance.</p>
            
            <h3>Flask-SQLAlchemy</h3>
            <p>Flask-SQLAlchemy is an extension for Flask that simplifies using SQLAlchemy with Flask. It provides useful defaults and extra helpers that make it easier to accomplish common tasks.</p>
            
            <p>Features of Flask-SQLAlchemy include:</p>
            <ul>
                <li>Simple setup and configuration</li>
                <li>Session management integrated with Flask's request lifecycle</li>
                <li>Simplified querying syntax</li>
                <li>Support for multiple databases</li>
                <li>Signals for event handling</li>
            </ul>
        </section>

        <section>
            <h2>Setting Up Flask-SQLAlchemy</h2>
            
            <p>Let's set up Flask-SQLAlchemy in our project:</p>
            
            <h3>Installation</h3>
            <pre><code>
pip install flask-sqlalchemy
            </code></pre>
            
            <p>If you're using PostgreSQL, you'll also need the psycopg2 package:</p>
            <pre><code>
pip install psycopg2-binary
            </code></pre>
            
            <h3>Configuration</h3>
            <p>In your Flask application, you'll need to configure SQLAlchemy with your database connection information:</p>
            
            <pre><code>
# Example with SQLite (for development)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'

# Example with PostgreSQL (for production)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://username:password@localhost/dbname'

# Disable track modifications (reduces overhead)
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Initialize SQLAlchemy
db = SQLAlchemy(app)
            </code></pre>
            
            <p>With the application factory pattern, you would initialize it as follows:</p>
            
            <pre><code>
# app/__init__.py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

# Create extension object
db = SQLAlchemy()

def create_app():
    app = Flask(__name__)
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
    # Initialize the extension with the app
    db.init_app(app)
    
    # Import models to ensure they're known to SQLAlchemy
    from app import models
    
    # ... rest of the application setup ...
    
    return app
            </code></pre>
            
            <h3>Database URLs</h3>
            <p>SQLAlchemy uses database URLs to connect to different types of databases. The format is:</p>
            <pre><code>
dialect+driver://username:password@host:port/database
            </code></pre>
            
            <p>Examples:</p>
            <ul>
                <li><code>sqlite:///app.db</code> - SQLite database stored in the app.db file</li>
                <li><code>postgresql://user:pass@localhost/mydb</code> - PostgreSQL database</li>
                <li><code>mysql://user:pass@localhost/mydb</code> - MySQL database</li>
                <li><code>oracle://user:pass@127.0.0.1:1521/mydb</code> - Oracle database</li>
            </ul>
            
            <p>In production, it's common to store the database URL in an environment variable:</p>
            <pre><code>
import os

app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')
            </code></pre>
        </section>

        <section>
            <h2>Defining Models</h2>
            
            <p>In SQLAlchemy, database tables are represented as Python classes, with each instance of the class representing a row in the table.</p>
            
            <h3>Basic Model Definition</h3>
            <p>Here's how to define a simple User model:</p>
            
            <pre><code>
from app import db
from datetime import datetime

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f'&lt;User {self.username}&gt;'
            </code></pre>
            
            <p>In this example:</p>
            <ul>
                <li><code>db.Model</code> is the base class for all models</li>
                <li><code>db.Column</code> defines a column in the table</li>
                <li>Column attributes like <code>primary_key</code>, <code>unique</code>, and <code>nullable</code> define constraints</li>
                <li>The <code>__repr__</code> method defines how the object is represented when printed</li>
            </ul>
            
            <h3>Column Types</h3>
            <p>SQLAlchemy provides many column types for different kinds of data:</p>
            <ul>
                <li><code>db.Integer</code>: Regular integer</li>
                <li><code>db.String(length)</code>: Variable-length string with a maximum length</li>
                <li><code>db.Text</code>: Unlimited-length text</li>
                <li><code>db.DateTime</code>: Date and time</li>
                <li><code>db.Float</code>: Floating-point number</li>
                <li><code>db.Boolean</code>: Boolean (true/false)</li>
                <li><code>db.PickleType</code>: Stores a pickled Python object</li>
                <li><code>db.LargeBinary</code>: Stores large binary data</li>
            </ul>
            
            <h3>Column Options</h3>
            <p>Common options for columns include:</p>
            <ul>
                <li><code>primary_key</code>: Marks the column as the primary key</li>
                <li><code>unique</code>: Ensures values in the column are unique</li>
                <li><code>nullable</code>: Determines whether NULL values are allowed</li>
                <li><code>default</code>: Default value if none is provided</li>
                <li><code>index</code>: Creates an index on the column for faster queries</li>
                <li><code>server_default</code>: Default value set by the database server</li>
            </ul>
            
            <h3>Model Methods</h3>
            <p>You can add custom methods to your models to encapsulate functionality:</p>
            
            <pre><code>
from werkzeug.security import generate_password_hash, check_password_hash

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
    
    def is_active(self):
        # Custom logic to determine if user is active
        return True
            </code></pre>
            
            <h3>Table Names</h3>
            <p>By default, SQLAlchemy generates table names by converting the class name from CamelCase to snake_case. You can override this with the <code>__tablename__</code> attribute:</p>
            
            <pre><code>
class User(db.Model):
    __tablename__ = 'app_users'  # Custom table name
    # ... column definitions ...
            </code></pre>
        </section>

        <section>
            <h2>Model Relationships</h2>
            
            <p>One of the key features of relational databases is the ability to define relationships between tables. SQLAlchemy provides several ways to define these relationships in your models.</p>
            
            <h3>One-to-Many Relationships</h3>
            <p>A one-to-many relationship exists when one record in a table can be associated with one or more records in another table. For example, one user can have many blog posts.</p>
            
            <pre><code>
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    posts = db.relationship('Post', backref='author', lazy='dynamic')

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    content = db.Column(db.Text, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
            </code></pre>
            
            <p>In this example:</p>
            <ul>
                <li><code>db.relationship</code> defines the relationship on the "one" side</li>
                <li><code>db.ForeignKey</code> creates a foreign key constraint on the "many" side</li>
                <li><code>backref</code> creates a back-reference that allows accessing the user from a post (<code>post.author</code>)</li>
                <li><code>lazy='dynamic'</code> returns a query object instead of loading all related objects at once</li>
            </ul>
            
            <h3>Many-to-Many Relationships</h3>
            <p>A many-to-many relationship exists when records in both tables can be associated with multiple records in the other table. For example, a post can have many tags, and a tag can be used in many posts.</p>
            
            <p>Many-to-many relationships typically require an association table:</p>
            
            <pre><code>
# Association table (no model class needed)
post_tags = db.Table('post_tags',
    db.Column('post_id', db.Integer, db.ForeignKey('post.id'), primary_key=True),
    db.Column('tag_id', db.Integer, db.ForeignKey('tag.id'), primary_key=True)
)

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    content = db.Column(db.Text, nullable=False)
    tags = db.relationship('Tag', secondary=post_tags, backref=db.backref('posts', lazy='dynamic'))

class Tag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)
            </code></pre>
            
            <p>In this example:</p>
            <ul>
                <li><code>db.Table</code> creates an association table without a model class</li>
                <li><code>secondary</code> parameter specifies the association table</li>
                <li>The relationship can be accessed from both sides (<code>post.tags</code> and <code>tag.posts</code>)</li>
            </ul>
            
            <h3>One-to-One Relationships</h3>
            <p>A one-to-one relationship exists when a record in one table can be associated with exactly one record in another table. For example, a user might have one profile.</p>
            
            <pre><code>
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    profile = db.relationship('Profile', backref='user', uselist=False)

class Profile(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    bio = db.Column(db.Text)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True, nullable=False)
            </code></pre>
            
            <p>In this example:</p>
            <ul>
                <li><code>uselist=False</code> ensures that the relationship returns a single object rather than a list</li>
                <li><code>unique=True</code> on the foreign key ensures that each user can have only one profile</li>
            </ul>
            
            <h3>Relationship Options</h3>
            <p>SQLAlchemy's <code>relationship</code> function has many options to control how the relationship behaves:</p>
            <ul>
                <li><code>backref</code>: Creates a back-reference from the related object</li>
                <li><code>lazy</code>: Controls how related objects are loaded ('select', 'joined', 'subquery', 'dynamic')</li>
                <li><code>cascade</code>: Specifies operations that should cascade to related objects</li>
                <li><code>order_by</code>: Specifies the default ordering of related objects</li>
            </ul>
            
            <pre><code>
class User(db.Model):
    # ...
    posts = db.relationship('Post', backref='author', lazy='dynamic',
                            cascade='all, delete-orphan', order_by='Post.created_at.desc()')
            </code></pre>
        </section>

        <section>
            <h2>Creating and Migrating the Database</h2>
            
            <p>Once you've defined your models, you need to create the corresponding tables in the database. There are two main approaches: direct creation and migrations.</p>
            
            <h3>Direct Creation</h3>
            <p>For development or simple applications, you can create tables directly from your models:</p>
            
            <pre><code>
from app import db, create_app

app = create_app()
with app.app_context():
    db.create_all()
            </code></pre>
            
            <p>This command creates tables for all models that don't already exist. However, it doesn't update existing tables if your models change, which can lead to data loss or inconsistencies.</p>
            
            <h3>Database Migrations with Flask-Migrate</h3>
            <p>For production applications, it's better to use database migrations, which allow you to evolve your database schema over time. Flask-Migrate is an extension that integrates Alembic (SQLAlchemy's migration framework) with Flask.</p>
            
            <p>Installation:</p>
            <pre><code>
pip install flask-migrate
            </code></pre>
            
            <p>Setup in your application factory:</p>
            <pre><code>
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

db = SQLAlchemy()
migrate = Migrate()

def create_app():
    app = Flask(__name__)
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
    db.init_app(app)
    migrate.init_app(app, db)
    
    # ... rest of the application setup ...
    
    return app
            </code></pre>
            
            <p>Using Flask-Migrate via the Flask CLI:</p>
            <ol>
                <li>Initialize the migration repository:
                <pre><code>flask db init</code></pre>
                </li>
                
                <li>Create a migration for your current models:
                <pre><code>flask db migrate -m "Initial migration"</code></pre>
                </li>
                
                <li>Apply the migration to the database:
                <pre><code>flask db upgrade</code></pre>
                </li>
                
                <li>When you change your models, create a new migration:
                <pre><code>flask db migrate -m "Add user roles"</code></pre>
                </li>
                
                <li>Apply the new migration:
                <pre><code>flask db upgrade</code></pre>
                </li>
                
                <li>To revert to a previous version:
                <pre><code>flask db downgrade</code></pre>
                </li>
            </ol>
            
            <p>Migrations are essential for managing schema changes in a production environment without losing data.</p>
        </section>

        <section>
            <h2>CRUD Operations with SQLAlchemy</h2>
            
            <p>CRUD stands for Create, Read, Update, and Delete—the four basic operations for persistent storage. Let's explore how to perform these operations with SQLAlchemy.</p>
            
            <h3>Create</h3>
            <p>To create a new record, instantiate a model class, add it to the session, and commit the transaction:</p>
            
            <pre><code>
from app import db
from app.models import User

# Create a new user
new_user = User(username='john', email='john@example.com')
db.session.add(new_user)
db.session.commit()

# Create multiple users at once
users = [
    User(username='alice', email='alice@example.com'),
    User(username='bob', email='bob@example.com')
]
db.session.add_all(users)
db.session.commit()
            </code></pre>
            
            <h3>Read</h3>
            <p>To retrieve records from the database, use query methods:</p>
            
            <pre><code>
# Get all users
all_users = User.query.all()

# Get a user by primary key
user = User.query.get(1)

# Get the first user with a specific username
user = User.query.filter_by(username='john').first()

# More complex filtering with filter()
users = User.query.filter(User.email.endswith('@example.com')).all()

# Order results
users = User.query.order_by(User.username).all()

# Limit results
recent_users = User.query.order_by(User.created_at.desc()).limit(5).all()

# Pagination
page = User.query.paginate(page=1, per_page=10)
users = page.items
            </code></pre>
            
            <h3>Update</h3>
            <p>To update a record, retrieve it, modify its attributes, and commit the transaction:</p>
            
            <pre><code>
# Update a user's email
user = User.query.get(1)
user.email = 'newemail@example.com'
db.session.commit()

# Bulk update
User.query.filter_by(is_active=False).update({User.is_active: True})
db.session.commit()
            </code></pre>
            
            <h3>Delete</h3>
            <p>To delete a record, retrieve it, delete it from the session, and commit the transaction:</p>
            
            <pre><code>
# Delete a user
user = User.query.get(1)
db.session.delete(user)
db.session.commit()

# Bulk delete
User.query.filter(User.created_at < some_date).delete()
db.session.commit()
            </code></pre>
            
            <h3>Working with Sessions</h3>
            <p>The session is a workspace for your database operations:</p>
            <ul>
                <li>Changes to objects in the session are not reflected in the database until you call <code>db.session.commit()</code></li>
                <li>If there's an error, you can call <code>db.session.rollback()</code> to discard changes</li>
                <li>Flask-SQLAlchemy automatically creates a session for each request and removes it at the end</li>
            </ul>
            
            <pre><code>
try:
    user = User(username='john', email='john@example.com')
    db.session.add(user)
    db.session.commit()
except Exception as e:
    db.session.rollback()
    print(f"Error: {e}")
            </code></pre>
        </section>

        <section>
            <h2>Querying Relationships</h2>
            
            <p>SQLAlchemy makes it easy to work with related objects through relationships.</p>
            
            <h3>Accessing Related Objects</h3>
            <p>You can access related objects through the relationship attribute:</p>
            
            <pre><code>
# Get all posts by a user
user = User.query.get(1)
posts = user.posts.all()  # Using lazy='dynamic'

# Get a user's first post
first_post = user.posts.first()

# Get the author of a post
post = Post.query.get(1)
author = post.author
            </code></pre>
            
            <h3>Querying Based on Related Objects</h3>
            <p>You can also use relationships in queries:</p>
            
            <pre><code>
# Get all posts by users with gmail addresses
posts = Post.query.join(Post.author).filter(User.email.endswith('@gmail.com')).all()

# Get all users who have written a post with "Flask" in the title
users = User.query.join(User.posts).filter(Post.title.contains('Flask')).all()

# Get all users who have at least one post
users = User.query.join(User.posts).group_by(User.id).all()
            </code></pre>
            
            <h3>Eager Loading</h3>
            <p>By default, SQLAlchemy loads related objects only when you access them (lazy loading). This can lead to the "N+1 query problem" where accessing related objects for each result in a collection results in many database queries.</p>
            
            <p>You can use eager loading to load related objects in a single query:</p>
            
            <pre><code>
# Load users with their posts in a single query
users = User.query.options(db.joinedload(User.posts)).all()

# Load posts with their authors in a single query
posts = Post.query.options(db.joinedload(Post.author)).all()
            </code></pre>
            
            <h3>Working with Many-to-Many Relationships</h3>
            <p>For many-to-many relationships, you can access related objects in the same way:</p>
            
            <pre><code>
# Add a tag to a post
tag = Tag.query.filter_by(name='Flask').first()
post = Post.query.get(1)
post.tags.append(tag)
db.session.commit()

# Remove a tag from a post
post.tags.remove(tag)
db.session.commit()

# Get all posts with a specific tag
posts = Tag.query.filter_by(name='Flask').first().posts.all()
            </code></pre>
        </section>

        <section>
            <h2>Applying SQLAlchemy to Our Blog Application</h2>
            
            <p>Now let's apply what we've learned to our blog application by implementing its database models.</p>
            
            <h3>User Model</h3>
            <p>First, let's create a comprehensive User model:</p>
            
            <pre><code>
# app/models/user.py
from app import db
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import UserMixin

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(128))
    name = db.Column(db.String(64))
    bio = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_seen = db.Column(db.DateTime, default=datetime.utcnow)
    is_admin = db.Column(db.Boolean, default=False)
    
    # Relationships
    posts = db.relationship('Post', backref='author', lazy='dynamic', cascade='all, delete-orphan')
    comments = db.relationship('Comment', backref='author', lazy='dynamic', cascade='all, delete-orphan')
    
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
    
    def __repr__(self):
        return f'&lt;User {self.username}&gt;'
            </code></pre>
            
            <h3>Post Model</h3>
            <p>Next, let's create a Post model for blog posts:</p>
            
            <pre><code>
# app/models/post.py
from app import db
from datetime import datetime
from slugify import slugify

post_tags = db.Table('post_tags',
    db.Column('post_id', db.Integer, db.ForeignKey('post.id'), primary_key=True),
    db.Column('tag_id', db.Integer, db.ForeignKey('tag.id'), primary_key=True)
)

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    slug = db.Column(db.String(120), unique=True, nullable=False)
    content = db.Column(db.Text, nullable=False)
    summary = db.Column(db.String(200))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    published = db.Column(db.Boolean, default=True)
    
    # Foreign keys
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    
    # Relationships
    comments = db.relationship('Comment', backref='post', lazy='dynamic', cascade='all, delete-orphan')
    tags = db.relationship('Tag', secondary=post_tags, backref=db.backref('posts', lazy='dynamic'))
    
    def __init__(self, *args, **kwargs):
        if 'slug' not in kwargs:
            kwargs['slug'] = slugify(kwargs.get('title', ''))
        super().__init__(*args, **kwargs)
    
    def __repr__(self):
        return f'&lt;Post {self.title}&gt;'

class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Foreign keys
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    post_id = db.Column(db.Integer, db.ForeignKey('post.id'), nullable=False)
    
    def __repr__(self):
        return f'&lt;Comment {self.id}&gt;'

class Tag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)
    slug = db.Column(db.String(70), unique=True, nullable=False)
    
    def __init__(self, *args, **kwargs):
        if 'slug' not in kwargs:
            kwargs['slug'] = slugify(kwargs.get('name', ''))
        super().__init__(*args, **kwargs)
    
    def __repr__(self):
        return f'&lt;Tag {self.name}&gt;'
      </code></pre>
            
      <h3>Query Building</h3>
      <p>SQLAlchemy provides a powerful query building API that allows you to construct complex queries:</p>
      
      <pre><code>
from sqlalchemy import and_, or_, not_

# Complex filtering with and_/or_
recent_posts = Post.query.filter(
and_(
  Post.published == True,
  or_(
      Post.title.contains('Flask'),
      Post.title.contains('Python')
  ),
  not_(Post.author.has(User.username == 'admin'))
)
).order_by(Post.created_at.desc()).all()

# Subqueries
from sqlalchemy import func

# Get users with the most posts
user_post_counts = db.session.query(
User,
func.count(Post.id).label('post_count')
).join(User.posts).group_by(User.id).order_by(func.count(Post.id).desc()).all()

# Get the average number of comments per post
avg_comments = db.session.query(
func.avg(
  db.session.query(func.count(Comment.id))
  .filter(Comment.post_id == Post.id)
  .correlate(Post)
  .scalar_subquery()
)
).scalar()
      </code></pre>
      
      <h3>Hybrid Properties and Expressions</h3>
      <p>Hybrid properties and expressions allow you to define attributes that work both at the Python level and at the SQL level:</p>
      
      <pre><code>
from sqlalchemy.ext.hybrid import hybrid_property, hybrid_method

class Post(db.Model):
# ... other columns ...

@hybrid_property
def is_recent(self):
  return self.created_at > (datetime.utcnow() - timedelta(days=7))

@is_recent.expression
def is_recent(cls):
  return cls.created_at > (datetime.utcnow() - timedelta(days=7))

# Now you can use this in queries
recent_posts = Post.query.filter(Post.is_recent).all()
      </code></pre>
      
      <h3>Event Listeners</h3>
      <p>SQLAlchemy provides an event system that lets you run code at various points in the model lifecycle:</p>
      
      <pre><code>
from sqlalchemy import event

@event.listens_for(Post, 'before_insert')
def set_post_slug(mapper, connection, target):
if not target.slug:
  target.slug = slugify(target.title)

@event.listens_for(db.session, 'before_commit')
def validate_post(session):
for obj in session.new:
  if isinstance(obj, Post):
      if not obj.title or not obj.content:
          raise ValueError("Post must have a title and content")
      </code></pre>
      
      <h3>Custom Query Classes</h3>
      <p>You can create custom query classes to add reusable query methods:</p>
      
      <pre><code>
from flask_sqlalchemy import BaseQuery

class PostQuery(BaseQuery):
def published(self):
  return self.filter(Post.published == True)

def recent(self, days=7):
  return self.filter(Post.created_at > (datetime.utcnow() - timedelta(days=days)))

def with_tag(self, tag_name):
  return self.join(Post.tags).filter(Tag.name == tag_name)

class Post(db.Model):
query_class = PostQuery
# ... column definitions ...

# Now you can use these methods
recent_published_posts = Post.query.published().recent().all()
flask_posts = Post.query.with_tag('Flask').all()
      </code></pre>
    </section>

    <section>
        <h2>Hands-On Exercise: Implementing Our Database</h2>
        
        <p>Let's put our knowledge into practice by implementing the database for our blog application.</p>
        
        <h3>Step 1: Update Dependencies</h3>
        <p>Make sure you have the necessary packages installed:</p>
        
        <pre><code>
pip install flask-sqlalchemy flask-migrate python-slugify
        </code></pre>
        
        <h3>Step 2: Configure SQLAlchemy</h3>
        <p>Update your application factory in app/__init__.py:</p>
        
        <pre><code>
# app/__init__.py
import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

# Initialize extensions
db = SQLAlchemy()
migrate = Migrate()

def create_app(test_config=None):
"""Application factory function."""
# Create and configure the app
app = Flask(__name__, instance_relative_config=True)

# Set default configuration
app.config.from_mapping(
    SECRET_KEY='dev',
    SQLALCHEMY_DATABASE_URI=os.environ.get('DATABASE_URL', 'sqlite:///blog.db'),
    SQLALCHEMY_TRACK_MODIFICATIONS=False,
)

if test_config is None:
    # Load the instance config, if it exists, when not testing
    app.config.from_pyfile('config.py', silent=True)
else:
    # Load the test config if passed in
    app.config.from_mapping(test_config)

# Ensure the instance folder exists
try:
    os.makedirs(app.instance_path)
except OSError:
    pass

# Initialize extensions with app
db.init_app(app)
migrate.init_app(app, db)

# Import models to ensure they're registered with SQLAlchemy
from app.models import user, post

# Register blueprints
from app.views import main, auth
app.register_blueprint(main.bp)
app.register_blueprint(auth.bp)

return app
        </code></pre>
        
        <h3>Step 3: Create Models</h3>
        <p>Create the model files as shown earlier:</p>
        <ul>
            <li>app/models/user.py - User model</li>
            <li>app/models/post.py - Post, Comment, and Tag models</li>
            <li>app/models/__init__.py - Import models for easy access</li>
        </ul>
        
        <h3>Step 4: Initialize and Migrate the Database</h3>
        <p>Run the following commands to set up the database:</p>
        
        <pre><code>
# Set the Flask application
export FLASK_APP=app

# Initialize the migration repository
flask db init

# Create the initial migration
flask db migrate -m "Initial migration"

# Apply the migration
flask db upgrade
        </code></pre>
        
        <h3>Step 5: Create Test Data</h3>
        <p>Create a script to populate the database with test data:</p>
        
        <pre><code>
# app/data.py
from app import db, create_app
from app.models.user import User
from app.models.post import Post, Tag, Comment
from datetime import datetime, timedelta

def create_test_data():
# Create users
admin = User(username='admin', email='admin@example.com', is_admin=True)
admin.set_password('password')

alice = User(username='alice', email='alice@example.com')
alice.set_password('password')

bob = User(username='bob', email='bob@example.com')
bob.set_password('password')

db.session.add_all([admin, alice, bob])
db.session.commit()

# Create tags
tags = [
    Tag(name='Flask'),
    Tag(name='Python'),
    Tag(name='SQLAlchemy'),
    Tag(name='Web Development')
]
db.session.add_all(tags)
db.session.commit()

# Create posts
post1 = Post(
    title='Getting Started with Flask',
    content='Flask is a lightweight WSGI web application framework in Python...',
    author=alice,
    created_at=datetime.utcnow() - timedelta(days=5)
)
post1.tags.extend([tags[0], tags[1], tags[3]])

post2 = Post(
    title='Database Integration with SQLAlchemy',
    content='SQLAlchemy is an SQL toolkit and Object-Relational Mapping (ORM) system for Python...',
    author=bob,
    created_at=datetime.utcnow() - timedelta(days=3)
)
post2.tags.extend([tags[0], tags[2]])

post3 = Post(
    title='Python Web Development Best Practices',
    content='When developing web applications with Python, there are several best practices to follow...',
    author=admin,
    created_at=datetime.utcnow() - timedelta(days=1)
)
post3.tags.extend([tags[1], tags[3]])

db.session.add_all([post1, post2, post3])
db.session.commit()

# Create comments
comment1 = Comment(
    content='Great introduction to Flask!',
    author=bob,
    post=post1
)

comment2 = Comment(
    content='I found this very helpful.',
    author=admin,
    post=post1
)

comment3 = Comment(
    content='Looking forward to more SQLAlchemy tips.',
    author=alice,
    post=post2
)

db.session.add_all([comment1, comment2, comment3])
db.session.commit()

print('Test data has been created!')

if __name__ == '__main__':
app = create_app()
with app.app_context():
    create_test_data()
        </code></pre>
        
        <p>Run the script to populate the database:</p>
        
        <pre><code>
python -m app.data
        </code></pre>
        
        <h3>Step 6: Update Views to Use the Database</h3>
        <p>Now that we have our models and data, update your views to query the database and display the data. Use the examples provided earlier as a guide.</p>
        
        <h3>Challenge: Add Search Functionality</h3>
        <p>Implement a search route that allows users to search for posts by title or content:</p>
        
        <pre><code>
@bp.route('/search')
def search():
query = request.args.get('q', '')
if not query:
    return render_template('search.html', posts=None, query=None)

page = request.args.get('page', 1, type=int)
posts = Post.query.filter(
    Post.published == True,
    or_(
        Post.title.contains(query),
        Post.content.contains(query)
    )
).order_by(Post.created_at.desc()).paginate(
    page=page, per_page=5, error_out=False
)

return render_template('search.html', posts=posts, query=query)
        </code></pre>
    </section>

    <section>
        <h2>Database Best Practices</h2>
        
        <p>As you work with databases in your web applications, keep these best practices in mind:</p>
        
        <h3>Performance</h3>
        <ul>
            <li><strong>Use indexes</strong> for columns frequently used in WHERE clauses, ORDER BY, or as foreign keys</li>
            <li><strong>Eager loading</strong> with joinedload() to avoid N+1 query problems</li>
            <li><strong>Paginat</strong> large result sets to improve response times</li>
            <li><strong>Consider query optimization</strong> for complex queries</li>
            <li><strong>Profile your database queries</strong> to identify bottlenecks</li>
        </ul>
        
        <h3>Security</h3>
        <ul>
            <li><strong>Never store passwords in plain text</strong>; use proper hashing with Werkzeug's utilities</li>
            <li><strong>Use SQLAlchemy's parameterized queries</strong> to prevent SQL injection</li>
            <li><strong>Implement proper access control</strong> in your application</li>
            <li><strong>Sanitize all user input</strong> before storing it in the database</li>
            <li><strong>Use secure connection strings</strong> with passwords stored in environment variables</li>
        </ul>
        
        <h3>Data Integrity</h3>
        <ul>
            <li><strong>Use database constraints</strong> (unique, not null, foreign keys) to enforce rules</li>
            <li><strong>Set up cascading deletes</strong> where appropriate to maintain referential integrity</li>
            <li><strong>Use transactions</strong> for operations that should be atomic</li>
            <li><strong>Implement validation</strong> at the application level</li>
            <li><strong>Use migrations</strong> to evolve your schema safely</li>
        </ul>
        
        <h3>Organization</h3>
        <ul>
            <li><strong>Separate your models</strong> into logical files</li>
            <li><strong>Use descriptive names</strong> for models, columns, and relationships</li>
            <li><strong>Add helpful methods</strong> to your models to encapsulate functionality</li>
            <li><strong>Document your models</strong> with docstrings</li>
            <li><strong>Use mixins</strong> to share functionality between models</li>
        </ul>
    </section>

    <section>
        <h2>Next Steps</h2>
        
        <p>Today, we've covered database integration with SQLAlchemy, learning how to define models, create relationships, and perform CRUD operations. These concepts form the foundation of data management in our Flask application.</p>
        
        <p>Tomorrow, we'll build on this foundation by exploring user authentication with Flask-Login, which will allow users to register, log in, and access secure areas of our application.</p>
        
        <h3>Tomorrow: User Authentication</h3>
        <ul>
            <li>Introduction to authentication concepts</li>
            <li>Setting up Flask-Login</li>
            <li>Creating registration and login forms</li>
            <li>Password hashing and security</li>
            <li>User sessions and cookies</li>
            <li>Access control with decorators</li>
            <li>User management features</li>
        </ul>
        
        <h3>Preparation</h3>
        <p>To prepare for tomorrow's session:</p>
        <ol>
            <li>Review the User model we created today</li>
            <li>Explore the Flask-Login documentation at <a href="https://flask-login.readthedocs.io/" target="_blank">https://flask-login.readthedocs.io/</a></li>
            <li>Make sure your database models are working correctly</li>
        </ol>
    </section>

    <section>
        <h2>Today's Assignment: Database Models</h2>
        
        <p>To reinforce what we've learned today, complete the following exercises:</p>
        
        <h3>Exercise 1: Implement Database Models</h3>
        <ol>
            <li>Create or update the following models for your blog application:</li>
            <ul>
                <li>User model with authentication capabilities</li>
                <li>Post model with title, content, created_at, etc.</li>
                <li>Comment model associated with users and posts</li>
                <li>Tag model with a many-to-many relationship to posts</li>
            </ul>
            <li>Set up the appropriate relationships between models</li>
            <li>Add at least three custom methods to your models that provide useful functionality</li>
        </ol>
        
        <h3>Exercise 2: Database Operations</h3>
        <ol>
            <li>Create a script that populates your database with test data:</li>
            <ul>
                <li>At least 3 users</li>
                <li>At least 5 posts with different authors</li>
                <li>Several comments on different posts</li>
                <li>At least 5 tags applied to different posts</li>
            </ul>
            <li>Write a script that demonstrates various query operations:</li>
            <ul>
                <li>Get all posts by a specific user</li>
                <li>Get all posts with a specific tag</li>
                <li>Get the most commented posts</li>
                <li>Get the most active users (by post or comment count)</li>
            </ul>
        </ol>
        
        <h3>Exercise 3: Database Integration with Flask</h3>
        <ol>
            <li>Update or implement the following routes in your Flask application:</li>
            <ul>
                <li>Home page displaying recent posts</li>
                <li>Post detail page with comments</li>
                <li>User profile page showing their posts</li>
                <li>Tag page showing posts with a specific tag</li>
            </ul>
            <li>Implement pagination for routes that display multiple posts</li>
            <li>Add a search function that searches posts by title or content</li>
        </ol>
        
        <h3>Bonus Challenge: Advanced Queries</h3>
        <ol>
            <li>Implement a "related posts" feature that finds posts similar to the current post based on tags</li>
            <li>Create a "trending" feature that shows posts with the most recent comments</li>
            <li>Implement a simple analytics system that tracks and displays view counts for posts</li>
        </ol>
        
        <p>Submit your code as a GitHub repository before tomorrow's session.</p>
    </section>

    <section>
        <h2>Additional Resources</h2>
        
        <h3>SQLAlchemy Documentation</h3>
        <ul>
            <li><a href="https://docs.sqlalchemy.org/en/14/" target="_blank">SQLAlchemy Documentation</a></li>
            <li><a href="https://flask-sqlalchemy.palletsprojects.com/" target="_blank">Flask-SQLAlchemy Documentation</a></li>
            <li><a href="https://alembic.sqlalchemy.org/en/latest/" target="_blank">Alembic Documentation (used by Flask-Migrate)</a></li>
        </ul>
        
        <h3>Tutorials and Books</h3>
        <ul>
            <li><a href="https://www.sqlalchemy.org/library.html" target="_blank">SQLAlchemy Tutorials and Articles</a></li>
            <li><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iv-database" target="_blank">The Flask Mega-Tutorial Part IV: Database</a> by Miguel Grinberg</li>
            <li>"Essential SQLAlchemy" by Jason Myers and Rick Copeland</li>
            <li>"Flask Web Development" by Miguel Grinberg (Chapters on SQLAlchemy)</li>
        </ul>
        
        <h3>Tools and Extensions</h3>
        <ul>
            <li><a href="https://github.com/sqlalchemy/sqlalchemy" target="_blank">SQLAlchemy on GitHub</a></li>
            <li><a href="https://github.com/pallets/flask-sqlalchemy" target="_blank">Flask-SQLAlchemy on GitHub</a></li>
            <li><a href="https://github.com/miguelgrinberg/flask-migrate" target="_blank">Flask-Migrate on GitHub</a></li>
            <li><a href="https://sqlitebrowser.org/" target="_blank">DB Browser for SQLite</a> - GUI tool for SQLite databases</li>
            <li><a href="https://www.pgadmin.org/" target="_blank">pgAdmin</a> - GUI tool for PostgreSQL databases</li>
        </ul>
    </section>
    
    <section>
        <h2>Conclusion</h2>
        
        <p>Today, we've explored database integration with SQLAlchemy, learning how to define models, create relationships, and perform database operations. These skills are fundamental to building data-driven web applications.</p>
        
        <p>We've seen how SQLAlchemy's ORM allows us to work with database records as Python objects, making our code more intuitive and maintainable. We've also learned about migrations, which enable us to evolve our database schema as our application grows.</p>
        
        <p>The models we've created for our blog application—User, Post, Comment, and Tag—form the foundation of our application's data layer. By defining the relationships between these models, we've established a structure that accurately represents the domain of a blog.</p>
        
        <p>Tomorrow, we'll build on this foundation by implementing user authentication, allowing users to register, log in, and access secure areas of our application. This will bring us one step closer to having a fully functional blog application.</p>
        
        <p>Remember that databases are a crucial component of web applications, and mastering SQLAlchemy will greatly enhance your ability to build sophisticated Flask applications.</p>
    </section>
</main>

<footer>
    <p>&copy; 2025 Full Stack Python Web Development Course</p>
</footer>
</body>
</html>
