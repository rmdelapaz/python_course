<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selecting Appropriate Data Structures for Different Problems</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Selecting Appropriate Data Structures for Different Problems</h1>
        <h2>Choosing the Right Tool for Your Programming Tasks</h2>
    </header>

    <main>
        <section class="introduction">
            <h3>The Art of Choosing Data Structures</h3>
            <p>Welcome to our exploration of selecting appropriate data structures! This skill is fundamental to effective programming and can dramatically impact the efficiency and clarity of your code. In our previous sessions, we've examined various Python data structures: lists, tuples, dictionaries, and sets. Now, we'll focus on when and why to use each one.</p>
            
            <p>Think of data structures as containers for your information. Just as you wouldn't store soup in a colander or try to organize paperwork in a fishing net, selecting the right data structure for your specific needs is crucial. The right choice can make your code faster, more memory-efficient, and easier to understand.</p>
            
            <p>Throughout this session, we'll examine common programming scenarios and identify which data structures best address each situation. We'll also explore the trade-offs between different options, helping you develop intuition for making these important decisions in your own projects.</p>
        </section>

        <section class="data_structure_overview">
            <h3>Python Data Structures at a Glance</h3>
            
            <p>Before we dive into specific use cases, let's briefly recap Python's core data structures and their key characteristics:</p>
            
            <table>
                <tr>
                    <th>Data Structure</th>
                    <th>Ordered?</th>
                    <th>Mutable?</th>
                    <th>Indexable?</th>
                    <th>Allows Duplicates?</th>
                    <th>Key Feature</th>
                </tr>
                <tr>
                    <td>List</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Sequence of items with flexible manipulation</td>
                </tr>
                <tr>
                    <td>Tuple</td>
                    <td>Yes</td>
                    <td>No</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Immutable sequence of items</td>
                </tr>
                <tr>
                    <td>Dictionary</td>
                    <td>Yes*</td>
                    <td>Yes</td>
                    <td>No (key-based)</td>
                    <td>No (keys)</td>
                    <td>Key-value pairs with fast lookup</td>
                </tr>
                <tr>
                    <td>Set</td>
                    <td>No</td>
                    <td>Yes</td>
                    <td>No</td>
                    <td>No</td>
                    <td>Unique items with fast membership testing</td>
                </tr>
            </table>
            <p><small>* In Python 3.7+, dictionaries maintain insertion order, but this is an implementation detail rather than a guarantee of the abstract data type.</small></p>
            
            <p>These characteristics serve as a starting point for our selection process. Next, we'll explore how they translate to real-world programming situations.</p>
        </section>

        <section class="when_to_use_lists">
            <h3>When to Use Lists</h3>
            
            <p>Lists are Python's most versatile and commonly used data structure. They're ideal when you need:</p>
            
            <h4>Ordered Collection of Items</h4>
            <p>When the sequence of elements matters, lists preserve the order you define. This is essential for:</p>
            <ul>
                <li>Processing items in a specific sequence</li>
                <li>Representing steps in a procedure</li>
                <li>Maintaining a ranking or priority order</li>
            </ul>
            
            <pre><code>
# File: top_movies.py
# Location: ~/python_examples/week2/

# Order matters - these are ranked from #1 to #5
top_movies = [
    "The Shawshank Redemption",
    "The Godfather",
    "The Dark Knight",
    "The Godfather Part II",
    "12 Angry Men"
]

# Accessing by position (index)
print(f"The #1 movie is: {top_movies[0]}")
print(f"The #3 movie is: {top_movies[2]}")
            </code></pre>
            
            <h4>Collection That Will Change Size</h4>
            <p>Lists shine when you need to add or remove elements during execution:</p>
            <ul>
                <li>Building a collection dynamically</li>
                <li>Implementing a queue or stack</li>
                <li>Filtering and transforming data</li>
            </ul>
            
            <pre><code>
# File: task_manager.py
# Location: ~/python_examples/week2/

# A simple task queue
tasks = []

# Adding tasks
tasks.append("Answer emails")
tasks.append("Prepare presentation")
tasks.append("Review code")

print(f"Current tasks: {tasks}")

# Completing a task (removing from beginning)
completed_task = tasks.pop(0)
print(f"Completed: {completed_task}")
print(f"Remaining tasks: {tasks}")
            </code></pre>
            
            <h4>Need for Multiple Operations on the Same Collection</h4>
            <p>Lists provide a rich set of methods for manipulation:</p>
            <ul>
                <li>Sorting and reversing</li>
                <li>Slicing and dicing</li>
                <li>Extending with other collections</li>
            </ul>
            
            <pre><code>
# File: data_processing.py
# Location: ~/python_examples/week2/

temperatures = [72, 65, 83, 70, 59, 88, 75]

# Multiple operations on the same list
average = sum(temperatures) / len(temperatures)
print(f"Average temperature: {average:.1f}")

# Sort in place
temperatures.sort()
print(f"Temperatures in ascending order: {temperatures}")

# Find median (middle value)
middle_idx = len(temperatures) // 2
median = temperatures[middle_idx]
print(f"Median temperature: {median}")
            </code></pre>
            
            <p><strong>Real-world example:</strong> Consider a web application's event log. Events arrive in chronological order and need to be processed sequentially. New events are constantly being added, and sometimes older events need to be archived (removed). A list is perfect here, as it maintains order and allows for efficient additions and removals.</p>
            
            <h4>When Not to Use Lists</h4>
            <p>Despite their versatility, lists aren't always the best choice:</p>
            <ul>
                <li>When you frequently need to check if an item exists in a large collection (sets or dictionaries are faster)</li>
                <li>When you need to associate values with keys (use dictionaries)</li>
                <li>When you need to ensure all elements are unique (use sets)</li>
                <li>When the data should never change (use tuples)</li>
            </ul>
        </section>

        <section class="when_to_use_tuples">
            <h3>When to Use Tuples</h3>
            
            <p>Tuples are immutable ordered sequences. They're the right choice when:</p>
            
            <h4>The Data Should Not Change</h4>
            <p>Tuples enforce immutability, making them ideal for:</p>
            <ul>
                <li>Constants and fixed values</li>
                <li>Configuration settings</li>
                <li>Ensuring data integrity</li>
            </ul>
            
            <pre><code>
# File: coordinates.py
# Location: ~/python_examples/week2/

# Geographical coordinates (latitude, longitude)
new_york = (40.7128, -74.0060)
tokyo = (35.6895, 139.6917)
paris = (48.8566, 2.3522)

# These cannot be accidentally changed
# new_york[0] = 41.0  # This would raise an error

# Calculate distance (simplified)
def distance(point1, point2):
    return ((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)**0.5

ny_to_paris = distance(new_york, paris)
print(f"Distance from New York to Paris: {ny_to_paris:.2f} coordinate units")
            </code></pre>
            
            <h4>Heterogeneous Data that Forms a Single Logical Unit</h4>
            <p>Tuples excel at representing "records" with different types of data:</p>
            <ul>
                <li>Database records</li>
                <li>Named coordinates or points</li>
                <li>Person's information (name, age, address, etc.)</li>
            </ul>
            
            <pre><code>
# File: student_records.py
# Location: ~/python_examples/week2/

# Student records as tuples: (name, age, gpa, major)
students = [
    ("Alice Smith", 20, 3.8, "Computer Science"),
    ("Bob Johnson", 22, 3.2, "Mathematics"),
    ("Charlie Brown", 19, 3.9, "Physics"),
    ("Diana Miller", 21, 3.5, "Biology")
]

# Process student records
for student in students:
    name, age, gpa, major = student  # Unpacking
    
    if gpa >= 3.5:
        print(f"{name}, a {major} major, made the Dean's List!")
            </code></pre>
            
            <h4>Dictionary Keys</h4>
            <p>Because tuples are immutable, they can be used as dictionary keys (unlike lists):</p>
            
            <pre><code>
# File: grid_data.py
# Location: ~/python_examples/week2/

# Using coordinate tuples as dictionary keys
grid_values = {
    (0, 0): 100,
    (0, 1): 75,
    (1, 0): 50,
    (1, 1): 25
}

# Retrieve value at a specific coordinate
position = (1, 0)
print(f"Value at position {position}: {grid_values[position]}")
            </code></pre>
            
            <p><strong>Analogy:</strong> Think of tuples as sealed packages that come from a factory with their contents verified and secured. Once sealed, the contents cannot be modified, ensuring that what was packed is exactly what will be delivered.</p>
            
            <h4>When Not to Use Tuples</h4>
            <p>Tuples aren't the best choice when:</p>
            <ul>
                <li>You need to modify the collection after creation</li>
                <li>The collection size will change</li>
                <li>You need to add or remove elements</li>
                <li>You need set operations like unions and intersections</li>
            </ul>
        </section>

        <section class="when_to_use_dictionaries">
            <h3>When to Use Dictionaries</h3>
            
            <p>Dictionaries store key-value pairs and offer extremely fast lookups. They're perfect when:</p>
            
            <h4>You Need Fast Lookups by Key</h4>
            <p>This is the dictionary's superpower—retrieving values by their associated keys:</p>
            <ul>
                <li>Looking up information by ID, name, or other identifier</li>
                <li>Implementing caches or memoization</li>
                <li>Counting occurrences (frequency counting)</li>
            </ul>
            
            <pre><code>
# File: user_database.py
# Location: ~/python_examples/week2/

# User information accessible by username
users = {
    "alice_smith": {
        "name": "Alice Smith",
        "email": "alice@example.com",
        "role": "admin"
    },
    "bob_jones": {
        "name": "Bob Jones",
        "email": "bob@example.com",
        "role": "user"
    },
    "charlie_davis": {
        "name": "Charlie Davis",
        "email": "charlie@example.com",
        "role": "user"
    }
}

# Fast lookup by key
username = "alice_smith"
if username in users:
    user_info = users[username]
    print(f"User found: {user_info['name']}, Role: {user_info['role']}")
else:
    print(f"User {username} not found")
            </code></pre>
            
            <h4>You Need to Map Keys to Values</h4>
            <p>When you have natural pairs of related information:</p>
            <ul>
                <li>Configuration settings (name → value)</li>
                <li>Language translations (word → translation)</li>
                <li>Inventory tracking (item → quantity)</li>
            </ul>
            
            <pre><code>
# File: language_translator.py
# Location: ~/python_examples/week2/

# Simple English to Spanish dictionary
translations = {
    "hello": "hola",
    "goodbye": "adiós",
    "thank you": "gracias",
    "yes": "sí",
    "no": "no",
    "please": "por favor"
}

# Translate a sentence
def translate(text, dictionary):
    words = text.lower().split()
    translated_words = []
    
    for word in words:
        if word in dictionary:
            translated_words.append(dictionary[word])
        else:
            translated_words.append(word)  # Keep untranslated
    
    return " ".join(translated_words)

english_text = "Hello please thank you goodbye"
spanish_text = translate(english_text, translations)
print(f"English: {english_text}")
print(f"Spanish: {spanish_text}")
            </code></pre>
            
            <h4>You Need to Count Occurrences</h4>
            <p>Dictionaries are superb for keeping track of how many times items appear:</p>
            
            <pre><code>
# File: word_counter.py
# Location: ~/python_examples/week2/

text = "the quick brown fox jumps over the lazy dog the fox was quick"
words = text.lower().split()

# Count word frequencies
word_counts = {}
for word in words:
    if word in word_counts:
        word_counts[word] += 1
    else:
        word_counts[word] = 1

# Alternative using get() method
word_counts_alt = {}
for word in words:
    word_counts_alt[word] = word_counts_alt.get(word, 0) + 1

# Print the most frequent words
sorted_words = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)
for word, count in sorted_words[:3]:  # Top 3
    print(f"'{word}' appears {count} times")
            </code></pre>
            
            <p><strong>Real-world application:</strong> Consider an e-commerce platform that needs to check product prices quickly. With thousands of products, searching through a list would be inefficient. A dictionary with product codes as keys and prices as values allows for instant price lookups, crucial for real-time operations.</p>
            
            <h4>When Not to Use Dictionaries</h4>
            <p>Despite their versatility, dictionaries aren't ideal when:</p>
            <ul>
                <li>You need to maintain a specific order (though modern Python dictionaries do preserve insertion order)</li>
                <li>You need to perform operations on all values frequently</li>
                <li>Memory efficiency is a critical concern (dictionaries have some overhead)</li>
                <li>You only care about the presence of items, not associated values (use sets)</li>
            </ul>
        </section>

        <section class="when_to_use_sets">
            <h3>When to Use Sets</h3>
            
            <p>Sets are unordered collections of unique elements with fast membership testing. They excel when:</p>
            
            <h4>You Need to Ensure Uniqueness</h4>
            <p>Sets automatically eliminate duplicates, making them perfect for:</p>
            <ul>
                <li>Removing duplicates from a collection</li>
                <li>Tracking distinct values</li>
                <li>Implementing "have we seen this before?" logic</li>
            </ul>
            
            <pre><code>
# File: unique_visitors.py
# Location: ~/python_examples/week2/

# Log of website visitors by IP address
visitor_ips = [
    "192.168.1.1", "10.0.0.2", "192.168.1.1", "192.168.1.3",
    "10.0.0.2", "172.16.0.1", "192.168.1.1", "10.0.0.4"
]

# Get unique visitors
unique_visitors = set(visitor_ips)
print(f"Total visits: {len(visitor_ips)}")
print(f"Unique visitors: {len(unique_visitors)}")
print(f"Unique IPs: {unique_visitors}")
            </code></pre>
            
            <h4>You Need Fast Membership Testing</h4>
            <p>Checking if an item exists in a set is extremely fast, even for large collections:</p>
            
            <pre><code>
# File: word_filter.py
# Location: ~/python_examples/week2/

# A set of words to filter (e.g., profanity filter)
banned_words = {"bad", "inappropriate", "offensive", "rude"}

def is_acceptable(text):
    """Check if text contains any banned words."""
    words = set(text.lower().split())
    
    # Fast check for intersection
    if words & banned_words:  # Set intersection
        return False
    return True

message1 = "This is a perfectly fine message"
message2 = "This message contains something inappropriate"

print(f"Message 1 acceptable: {is_acceptable(message1)}")
print(f"Message 2 acceptable: {is_acceptable(message2)}")
            </code></pre>
            
            <h4>You Need Set Operations</h4>
            <p>Sets support powerful mathematical operations like unions, intersections, and differences:</p>
            
            <pre><code>
# File: student_groups.py
# Location: ~/python_examples/week2/

# Students in different courses
math_students = {"Alice", "Bob", "Charlie", "Diana", "Eve"}
physics_students = {"Bob", "Diana", "Frank", "Grace"}
cs_students = {"Alice", "Charlie", "Eve", "Frank"}

# Students in both Math and CS (intersection)
math_and_cs = math_students & cs_students
print(f"Taking both Math and CS: {math_and_cs}")

# Students in any science course (union)
science_students = physics_students | cs_students
print(f"Taking at least one science course: {science_students}")

# Math students not taking Physics (difference)
math_not_physics = math_students - physics_students
print(f"Taking Math but not Physics: {math_not_physics}")

# Students taking exactly one of Math or Physics (symmetric difference)
one_subject_only = math_students ^ physics_students
print(f"Taking either Math or Physics (but not both): {one_subject_only}")
            </code></pre>
            
            <p><strong>Analogy:</strong> Think of sets as a VIP list at an exclusive event. The bouncer can instantly check if someone's name is on the list (membership testing), and each person can only be on the list once (uniqueness).</p>
            
            <h4>When Not to Use Sets</h4>
            <p>Sets aren't the right choice when:</p>
            <ul>
                <li>The order of elements matters</li>
                <li>You need to store duplicate items</li>
                <li>You need to associate values with keys</li>
                <li>You need to access elements by position (index)</li>
            </ul>
        </section>

        <section class="composite_examples">
            <h3>Combining Data Structures for Complex Problems</h3>
            
            <p>Real-world problems often require multiple data structures working together. Let's examine some composite examples:</p>
            
            <h4>A Simple Library Management System</h4>
            <p>This example shows how different data structures handle different aspects of the problem:</p>
            
            <pre><code>
# File: library_system.py
# Location: ~/python_examples/week2/

# Book database as a dictionary with ISBN as key
books = {
    "978-1451673319": {
        "title": "Fahrenheit 451",
        "author": "Ray Bradbury",
        "year": 1953,
        "copies": 3
    },
    "978-0061120084": {
        "title": "To Kill a Mockingbird",
        "author": "Harper Lee",
        "year": 1960,
        "copies": 5
    },
    "978-0451524935": {
        "title": "1984",
        "author": "George Orwell",
        "year": 1949,
        "copies": 4
    }
}

# Checked out books with due dates (dictionary of sets)
checked_out = {
    "user1": {("978-1451673319", "2023-06-15")},
    "user2": {("978-0061120084", "2023-06-10"), ("978-0451524935", "2023-06-20")}
}

# Available books (calculated using sets)
def get_available_books():
    all_isbns = set(books.keys())
    checked_out_isbns = set()
    
    for user_checkouts in checked_out.values():
        for isbn, _ in user_checkouts:
            checked_out_isbns.add(isbn)
    
    available_isbns = all_isbns - checked_out_isbns
    
    # Create a list of available book details
    available_books = []
    for isbn in available_isbns:
        book = books[isbn].copy()  # Copy the book details
        book["isbn"] = isbn  # Add the ISBN to the details
        available_books.append(book)
    
    return available_books

# Check out a book
def checkout_book(user_id, isbn, due_date):
    if isbn not in books:
        return False, "Book not found"
    
    # Check if book is already checked out
    for user_checkouts in checked_out.values():
        for checkout_isbn, _ in user_checkouts:
            if checkout_isbn == isbn:
                return False, "Book already checked out"
    
    # Add to user's checkouts
    if user_id not in checked_out:
        checked_out[user_id] = set()
    
    checked_out[user_id].add((isbn, due_date))
    return True, "Book checked out successfully"

# Print available books
print("Available Books:")
for book in get_available_books():
    print(f"- {book['title']} by {book['author']} (ISBN: {book['isbn']})")

# Demonstrate checkout
status, message = checkout_book("user3", "978-0451524935", "2023-07-01")
print(f"\nCheckout result: {message}")
            </code></pre>
            
            <p>In this example:</p>
            <ul>
                <li>A <strong>dictionary</strong> stores the book database, allowing fast lookups by ISBN</li>
                <li>Nested <strong>dictionaries</strong> store book details</li>
                <li>A dictionary of <strong>sets</strong> tracks checked-out books</li>
                <li>Set operations find available books efficiently</li>
            </ul>
            
            <h4>Customer Order Processing System</h4>
            <p>Let's examine another composite example:</p>
            
            <pre><code>
# File: order_processing.py
# Location: ~/python_examples/week2/

# Product catalog (dictionary for fast lookup)
products = {
    "SKU001": {"name": "Desk Lamp", "price": 19.99, "weight": 2.5},
    "SKU002": {"name": "Office Chair", "price": 149.99, "weight": 15.0},
    "SKU003": {"name": "Notebook", "price": 4.99, "weight": 0.5},
    "SKU004": {"name": "Pen Set", "price": 12.99, "weight": 0.3},
    "SKU005": {"name": "Desk Organizer", "price": 24.99, "weight": 1.8}
}

# Orders as a list (to maintain chronological order)
orders = [
    {
        "order_id": "ORD-001",
        "customer_id": "CUST-1234",
        "date": "2023-05-15",
        "items": [("SKU002", 1), ("SKU003", 2)]
    },
    {
        "order_id": "ORD-002",
        "customer_id": "CUST-5678",
        "date": "2023-05-16",
        "items": [("SKU001", 1), ("SKU004", 1), ("SKU005", 1)]
    }
]

# Process orders and calculate totals
def process_orders():
    for order in orders:
        print(f"\nProcessing Order: {order['order_id']}")
        print(f"Customer: {order['customer_id']}")
        print(f"Date: {order['date']}")
        print("Items:")
        
        total_price = 0
        total_weight = 0
        
        for sku, quantity in order["items"]:
            if sku in products:
                product = products[sku]
                item_price = product["price"] * quantity
                item_weight = product["weight"] * quantity
                
                print(f"  - {product['name']} × {quantity}: ${item_price:.2f}")
                
                total_price += item_price
                total_weight += item_weight
            else:
                print(f"  - Unknown product: {sku}")
        
        print(f"Total Price: ${total_price:.2f}")
        print(f"Total Weight: {total_weight:.1f} lbs")

# Find popular products (using a dictionary for counting)
def analyze_popular_products():
    product_counts = {}
    
    for order in orders:
        for sku, quantity in order["items"]:
            if sku in products:
                if sku not in product_counts:
                    product_counts[sku] = 0
                product_counts[sku] += quantity
    
    # Sort by popularity
    popular_products = sorted(
        product_counts.items(),
        key=lambda x: x[1],
        reverse=True
    )
    
    return popular_products

# Process all orders
process_orders()

# Show popular products
print("\nPopular Products:")
for sku, count in analyze_popular_products():
    product = products[sku]
    print(f"- {product['name']}: {count} units sold")
            </code></pre>
            
            <p>This example demonstrates:</p>
            <ul>
                <li>A <strong>dictionary</strong> for the product catalog, enabling fast lookups</li>
                <li>A <strong>list</strong> for orders, maintaining chronological sequence</li>
                <li><strong>Tuples</strong> for order items (SKU and quantity)</li>
                <li>Another <strong>dictionary</strong> for counting product popularity</li>
            </ul>
            
            <p><strong>Real-world insight:</strong> In professional software development, these composite patterns are extremely common. Database records often become dictionaries, collections of unique identifiers become sets, and ordered operations use lists. Mastering when to use each structure and how to combine them effectively is a hallmark of experienced programmers.</p>
        </section>

        <section class="performance_considerations">
            <h3>Performance Considerations</h3>
            
            <p>When selecting a data structure, performance characteristics can be critical, especially for larger datasets:</p>
            
            <table>
                <tr>
                    <th>Operation</th>
                    <th>List</th>
                    <th>Tuple</th>
                    <th>Dictionary</th>
                    <th>Set</th>
                </tr>
                <tr>
                    <td>Access by index</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                    <td>N/A</td>
                    <td>N/A</td>
                </tr>
                <tr>
                    <td>Search (in/contains)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Insert/Add</td>
                    <td>O(1)*</td>
                    <td>N/A</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Delete</td>
                    <td>O(n)</td>
                    <td>N/A</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
            </table>
            <p><small>* Amortized - resizing may occasionally take longer</small></p>
            
            <p>These time complexities tell an important story:</p>
            <ul>
                <li>If you need to frequently check if an item exists in a large collection, a list or tuple will be slow (O(n)), while dictionaries and sets are fast (O(1))</li>
                <li>If you need to access items by position, lists and tuples are optimal</li>
                <li>If you need to delete items frequently, dictionaries and sets outperform lists</li>
            </ul>
            
            <p>Let's demonstrate the practical impact with a simple benchmark:</p>
            
            <pre><code>
# File: data_structure_benchmark.py
# Location: ~/python_examples/week2/

import time
import random

# Generate test data
data_size = 10000
test_data = list(range(data_size))
random.shuffle(test_data)

# Convert to different data structures
test_list = test_data.copy()
test_set = set(test_data)
test_dict = {x: x for x in test_data}

# Test lookup performance
lookup_items = random.sample(test_data, 1000)  # 1000 random lookups

def benchmark_lookup(description, operation, iterations=1000):
    start_time = time.time()
    
    for _ in range(iterations):
        for item in lookup_items:
            operation(item)
    
    end_time = time.time()
    elapsed = end_time - start_time
    print(f"{description}: {elapsed:.6f} seconds")

# Run benchmarks
benchmark_lookup("List lookup", lambda x: x in test_list)
benchmark_lookup("Set lookup", lambda x: x in test_set)
benchmark_lookup("Dict lookup", lambda x: x in test_dict)

# Output will show significant differences in performance
# For example:
# List lookup: 0.123456 seconds
# Set lookup: 0.000123 seconds
# Dict lookup: 0.000135 seconds
            </code></pre>
            
            <p>For large datasets, the difference can be dramatic—the set and dictionary lookups might be hundreds or thousands of times faster than list lookups.</p>
            
            <p><strong>Real-world application:</strong> In a social network application, checking if a user is connected to another user must be extremely fast. Using sets to store connections allows for O(1) lookup times, enabling features like "friend suggestions" or "people you may know" to work efficiently even with millions of users.</p>
        </section>

        <section class="decision_making">
            <h3>A Decision-Making Framework</h3>
            
            <p>Here's a practical framework for selecting the appropriate data structure for your specific needs:</p>
            
            <h4>Step 1: Understand Your Data Access Patterns</h4>
            <p>Start by answering these questions:</p>
            <ul>
                <li>How will you most frequently access the data? (By index, by key, sequentially, randomly?)</li>
                <li>Will you need to add or remove items frequently?</li>
                <li>Does order matter?</li>
                <li>Are duplicates allowed or meaningful?</li>
                <li>Will you need to check membership frequently?</li>
            </ul>
            
            <h4>Step 2: Consider Size and Performance Requirements</h4>
            <ul>
                <li>How large will the dataset be?</li>
                <li>Are there tight performance constraints?</li>
                <li>Is memory usage a concern?</li>
            </ul>
            
            <h4>Step 3: Apply This Decision Tree</h4>
            <p>Based on your answers, use this simplified decision tree:</p>
            <ul>
                <li><strong>If you need key-value mapping</strong> → Use a dictionary</li>
                <li><strong>If you need to ensure uniqueness or do set operations</strong> → Use a set</li>
                <li><strong>If you need a sequence that won't change</strong> → Use a tuple</li>
                <li><strong>If you need a modifiable, ordered sequence</strong> → Use a list</li>
                <li><strong>If you need fast lookups by content, not position</strong> → Use a set or dictionary</li>
            </ul>
            
            <h4>Step 4: Combine as Needed</h4>
            <p>Don't hesitate to create composite structures for complex problems, such as:</p>
            <ul>
                <li>Lists of dictionaries (e.g., database records)</li>
                <li>Dictionaries of sets (e.g., user to connections mapping)</li>
                <li>Dictionaries of lists (e.g., category to items mapping)</li>
            </ul>
            
            <p><strong>Practical example:</strong> Let's apply this framework to a real problem—tracking employee attendance:</p>
            
            <pre><code>
# File: attendance_tracker.py
# Location: ~/python_examples/week2/

# Requirements analysis:
# 1. Need to look up attendance by employee ID (key-value mapping) → Dictionary
# 2. Need to track dates chronologically (ordered sequence) → List
# 3. For each date, need to know if present/absent (no duplicates) → Set
# 4. Employee details won't change (immutable data) → Tuple

# Result: A dictionary of employee records (tuples) with attendance as sets

# Employee records: (name, department, start_date)
employees = {
    "E001": ("Alice Smith", "Engineering", "2020-03-15"),
    "E002": ("Bob Johnson", "Marketing", "2021-07-22"),
    "E003": ("Charlie Davis", "Finance", "2019-11-08"),
    "E004": ("Diana Wilson", "Engineering", "2022-01-10")
}

# Attendance records: {employee_id: {present_dates}}
attendance = {
    "E001": {"2023-05-01", "2023-05-02", "2023-05-03", "2023-05-05"},
    "E002": {"2023-05-01", "2023-05-02", "2023-05-03", "2023-05-04", "2023-05-05"},
    "E003": {"2023-05-01", "2023-05-03", "2023-05-05"},
    "E004": {"2023-05-01", "2023-05-02", "2023-05-04", "2023-05-05"}
}

# Track all workdays
workdays = ["2023-05-01", "2023-05-02", "2023-05-03", "2023-05-04", "2023-05-05"]

# Generate attendance report
def generate_attendance_report():
    print("Attendance Report: May 1-5, 2023\n")
    
    for emp_id, emp_details in employees.items():
        name, department, _ = emp_details
        present_days = attendance.get(emp_id, set())
        absent_days = set(workdays) - present_days
        
        attendance_rate = len(present_days) / len(workdays) * 100
        
        print(f"Employee: {name} ({emp_id}), Department: {department}")
        print(f"Attendance Rate: {attendance_rate:.1f}%")
        
        if absent_days:
            print(f"Absent on: {', '.join(sorted(absent_days))}")
        else:
            print("Perfect attendance!")
        print()

# Find employees with perfect attendance
def find_perfect_attendance():
    perfect_attendance = []
    
    for emp_id, present_days in attendance.items():
        if len(present_days) == len(workdays):
            name = employees[emp_id][0]  # Get employee name
            perfect_attendance.append(name)
    
    return perfect_attendance

# Generate the report
generate_attendance_report()

# List employees with perfect attendance
perfect = find_perfect_attendance()
print(f"Employees with perfect attendance: {', '.join(perfect)}")
            </code></pre>
            
            <p>This example demonstrates how a thoughtful combination of data structures leads to clean, efficient code that matches the problem's requirements.</p>
        </section>

        <section class="exercises">
            <h3>Hands-On Exercises</h3>
            
            <p>Let's practice selecting appropriate data structures with some exercises. For each scenario, consider which data structure(s) would be most appropriate and implement a solution.</p>
            
            <h4>Exercise 1: Contact Management System</h4>
            <p>Implement a simple contact management system that allows adding, searching, and categorizing contacts. Think about how to efficiently look up contacts by different criteria (name, email, phone) and how to organize contacts into groups.</p>
            
            <pre><code>
# File: contact_manager.py
# Location: ~/python_examples/week2/exercises/

# Your solution here

# Example approach:
contacts = {}  # Dictionary with email as key for unique identification

def add_contact(name, email, phone, categories=None):
    if email in contacts:
        print(f"Contact with email {email} already exists")
        return False
    
    categories = set(categories) if categories else set()
    contacts[email] = {"name": name, "phone": phone, "categories": categories}
    return True

def search_by_name(name):
    return [contacts[email] for email in contacts if name.lower() in contacts[email]["name"].lower()]

def add_to_category(email, category):
    if email in contacts:
        contacts[email]["categories"].add(category)
        return True
    return False

def get_contacts_in_category(category):
    return [contacts[email] for email in contacts if category in contacts[email]["categories"]]

# Test the system
add_contact("Alice Smith", "alice@example.com", "555-123-4567", ["work", "friends"])
add_contact("Bob Johnson", "bob@example.com", "555-987-6543", ["family"])
add_contact("Charlie Brown", "charlie@example.com", "555-567-8901", ["work"])

print("Contacts in 'work' category:")
for contact in get_contacts_in_category("work"):
    print(f"- {contact['name']}: {contact['phone']}")

search_result = search_by_name("Alice")
if search_result:
    print(f"\nFound contact: {search_result[0]['name']}")
            </code></pre>
            
            <h4>Exercise 2: Shopping Cart System</h4>
            <p>Design a shopping cart system for an online store. Consider how to track products, quantities, calculate totals, and handle operations like adding, removing, and updating quantities.</p>
            
            <pre><code>
# File: shopping_cart.py
# Location: ~/python_examples/week2/exercises/

# Your solution here

# Example approach:
# Product catalog as a dictionary
products = {
    "P001": {"name": "T-Shirt", "price": 19.99, "category": "Clothing"},
    "P002": {"name": "Jeans", "price": 49.99, "category": "Clothing"},
    "P003": {"name": "Sneakers", "price": 79.99, "category": "Footwear"},
    "P004": {"name": "Backpack", "price": 39.99, "category": "Accessories"},
    "P005": {"name": "Water Bottle", "price": 9.99, "category": "Accessories"}
}

# Shopping cart as a dictionary with product_id -> quantity mapping
class ShoppingCart:
    def __init__(self):
        self.items = {}  # product_id -> quantity
    
    def add_item(self, product_id, quantity=1):
        if product_id not in products:
            print(f"Product {product_id} not found")
            return False
        
        if product_id in self.items:
            self.items[product_id] += quantity
        else:
            self.items[product_id] = quantity
        return True
    
    def remove_item(self, product_id):
        if product_id in self.items:
            del self.items[product_id]
            return True
        return False
    
    def update_quantity(self, product_id, quantity):
        if product_id not in self.items:
            return False
        
        if quantity <= 0:
            return self.remove_item(product_id)
        
        self.items[product_id] = quantity
        return True
    
    def get_total(self):
        total = 0
        for product_id, quantity in self.items.items():
            total += products[product_id]["price"] * quantity
        return total
    
    def view_cart(self):
        if not self.items:
            print("Your cart is empty")
            return
        
        print("Your Shopping Cart:")
        total = 0
        
        for product_id, quantity in self.items.items():
            product = products[product_id]
            item_total = product["price"] * quantity
            total += item_total
            
            print(f"- {product['name']} × {quantity}: ${item_total:.2f}")
        
        print(f"\nTotal: ${total:.2f}")

# Test the cart
cart = ShoppingCart()
cart.add_item("P001", 2)  # 2 T-shirts
cart.add_item("P003", 1)  # 1 pair of sneakers
cart.add_item("P005", 3)  # 3 water bottles

cart.view_cart()

print("\nUpdating quantities...")
cart.update_quantity("P001", 1)  # Reduce to 1 T-shirt
cart.remove_item("P005")  # Remove water bottles

cart.view_cart()
            </code></pre>
            
            <p>Work through these exercises to practice selecting appropriate data structures for different scenarios. Try implementing your own solutions before looking at the examples.</p>
        </section>

        <section class="conclusion">
            <h3>Choosing Wisely: The Art of Data Structure Selection</h3>
            
            <p>Selecting the right data structure is both a science and an art. It requires understanding the strengths and weaknesses of each option, analyzing your specific requirements, and sometimes making trade-offs.</p>
            
            <p>Remember these key principles:</p>
            
            <ul>
                <li><strong>Match the structure to your access patterns</strong> – How you'll use the data is often more important than what the data is</li>
                <li><strong>Consider performance implications</strong> – For large datasets, the difference between O(1) and O(n) operations can be enormous</li>
                <li><strong>Don't sacrifice clarity for optimization</strong> – Readable code with slightly suboptimal data structures is usually better than confusing code with perfectly optimized structures</li>
                <li><strong>Combine structures when necessary</strong> – Complex problems often require composite solutions</li>
                <li><strong>Revise as requirements evolve</strong> – Be willing to refactor when you discover new requirements or patterns</li>
            </ul>
            
            <p>With practice, selecting the right data structure will become intuitive. You'll develop a feel for which tool fits each problem, just as an experienced carpenter knows instinctively whether to reach for a hammer, a saw, or a drill.</p>
            
            <h4>Next Steps</h4>
            
            <p>As we continue our Python journey, we'll explore how these fundamental data structures become even more powerful when combined with:</p>
            
            <ul>
                <li><strong>Functions</strong> – Creating reusable operations that work with your data</li>
                <li><strong>Classes</strong> – Building custom data structures that encapsulate both data and behavior</li>
                <li><strong>Algorithms</strong> – Implementing efficient solutions to complex problems</li>
                <li><strong>External libraries</strong> – Leveraging specialized data structures for specific domains</li>
            </ul>
            
            <p>In our next session, we'll focus on functions – the building blocks of reusable code that operate on these data structures. We'll see how well-designed functions can make your data structures even more powerful and your code more modular and maintainable.</p>
        </section>

        <section class="additional_resources">
            <h3>Additional Resources</h3>
            
            <ul>
                <li><a href="https://docs.python.org/3/tutorial/datastructures.html" target="_blank">Python Documentation: Data Structures</a></li>
                <li><a href="https://realpython.com/python-data-structures/" target="_blank">Real Python: Python Data Structures</a></li>
                <li><a href="https://www.geeksforgeeks.org/choosing-the-right-data-structure-to-solve-problems/" target="_blank">GeeksforGeeks: Choosing the Right Data Structure</a></li>
                <li><a href="https://www.youtube.com/watch?v=D6Q_wHrzxDs" target="_blank">YouTube: Time Complexity of Python Data Structures</a></li>
                <li><a href="https://pythonspeed.com/articles/faster-python-containers/" target="_blank">Python Speed: Faster Python Containers</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
