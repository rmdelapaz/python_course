<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Functions: Parameters and Arguments</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Functions: Parameters and Arguments</h1>
        <h2>Mastering the Input and Output Flow of Python Functions</h2>
    </header>

    <main>
        <section class="introduction">
            <h2>Understanding Parameters and Arguments</h2>
            <p>
                Imagine you're a chef in a restaurant kitchen. You have a special recipe (the function) for making pasta sauce. This recipe requires certain ingredients (parameters) like tomatoes, garlic, and herbs. Each time you make the sauce, you might use different brands or amounts of these ingredients (arguments) depending on what's available or who you're cooking for.
            </p>
            <p>
                In Python, function parameters and arguments work in a similar way. Parameters are the variables listed in the function definition, while arguments are the actual values passed to the function when it's called. Understanding how they work is crucial for writing flexible, reusable functions.
            </p>
        </section>

        <section class="parameters_basics">
            <h2>Function Parameters: The Input Interface</h2>
            <p>
                Parameters act as placeholders for information that will be provided when the function is called. They create a contract that specifies what data the function expects to receive.
            </p>
            <pre><code>
# File: basic_parameters.py
# Location: /python_projects/functions_tutorial/

def greet(name):
    """
    Greet a person by name.
    
    Args:
        name (str): The name of the person to greet
    """
    print(f"Hello, {name}! How are you today?")

# The parameter 'name' is a placeholder for the data we'll provide later
</code></pre>
            <p>
                In this example, <code>name</code> is a parameter. It's like a variable that's only defined inside the function and gets its value when the function is called.
            </p>
            <p>
                Think of parameters as the empty slots in a form that you need to fill in. The function defines what slots exist, and you provide the values when you use the function.
            </p>
        </section>

        <section class="arguments_basics">
            <h2>Function Arguments: Providing the Actual Values</h2>
            <p>
                Arguments are the actual values you provide when calling a function. They fill in the parameters defined in the function.
            </p>
            <pre><code>
# File: basic_arguments.py
# Location: /python_projects/functions_tutorial/

def greet(name):
    print(f"Hello, {name}! How are you today?")

# Calling the function with different arguments
greet("Alice")
greet("Bob")
greet("Charlie")
</code></pre>
            <p>
                Here, "Alice", "Bob", and "Charlie" are arguments. Each time we call the function, we're providing a different value for the <code>name</code> parameter.
            </p>
            <p>
                It's like filling out different copies of the same form, with different information each time. The form (function) stays the same, but the values you enter (arguments) change depending on the specific situation.
            </p>
        </section>

        <section class="multiple_parameters">
            <h2>Working with Multiple Parameters</h2>
            <p>
                Functions can have multiple parameters, allowing them to take in various pieces of information needed for their operation.
            </p>
            <pre><code>
# File: multiple_parameters.py
# Location: /python_projects/functions_tutorial/

def describe_person(name, age, profession):
    """
    Print a description of a person.
    
    Args:
        name (str): The person's name
        age (int): The person's age
        profession (str): The person's job or profession
    """
    print(f"{name} is {age} years old and works as a {profession}.")

# Calling the function with three arguments
describe_person("Maya", 28, "software developer")
describe_person("James", 35, "teacher")
describe_person("Sofia", 42, "doctor")
</code></pre>
            <p>
                When you have multiple parameters, the order of arguments matters. The first argument maps to the first parameter, the second argument to the second parameter, and so on.
            </p>
            <p>
                This is like a recipe that requires multiple ingredients in a specific order. If you mix them up, you might not get the result you want!
            </p>
        </section>

        <section class="parameter_types">
            <h2>Parameter Types: Flexibility in Function Design</h2>
            <p>
                Python offers several types of parameters to make functions more flexible and powerful:
            </p>

            <h3>Required Parameters</h3>
            <p>
                These are the standard parameters that must be provided when calling the function.
            </p>
            <pre><code>
# File: required_parameters.py
# Location: /python_projects/functions_tutorial/

def divide(numerator, denominator):
    """
    Divide two numbers and return the result.
    
    Args:
        numerator (float): The number to be divided
        denominator (float): The number to divide by
        
    Returns:
        float: The result of the division
    """
    if denominator == 0:
        return "Error: Cannot divide by zero."
    return numerator / denominator

# Both arguments must be provided
result = divide(10, 2)
print(result)  # 5.0
</code></pre>

            <h3>Default Parameters</h3>
            <p>
                Default parameters have predefined values that are used if no argument is provided for them.
            </p>
            <pre><code>
# File: default_parameters.py
# Location: /python_projects/functions_tutorial/

def power(base, exponent=2):
    """
    Calculate the power of a number.
    
    Args:
        base (float): The base number
        exponent (int, optional): The exponent (default: 2)
        
    Returns:
        float: The result of base raised to the power of exponent
    """
    return base ** exponent

# Using the default parameter
square = power(5)  # exponent defaults to 2
print(square)  # 25

# Overriding the default parameter
cube = power(5, 3)  # explicitly setting exponent to 3
print(cube)  # 125
</code></pre>
            <p>
                Default parameters are like recipe instructions that say "add salt to taste" – there's a suggested amount, but you can adjust it if needed.
            </p>

            <h3>Keyword Arguments</h3>
            <p>
                Keyword arguments allow you to specify which parameter you're providing a value for by using the parameter name.
            </p>
            <pre><code>
# File: keyword_arguments.py
# Location: /python_projects/functions_tutorial/

def create_profile(name, age, city, country):
    """
    Create a user profile string.
    
    Args:
        name (str): User's name
        age (int): User's age
        city (str): User's city
        country (str): User's country
        
    Returns:
        str: Formatted profile information
    """
    return f"Name: {name}, Age: {age}, Location: {city}, {country}"

# Using positional arguments (order matters)
profile1 = create_profile("Alice", 30, "New York", "USA")

# Using keyword arguments (order doesn't matter)
profile2 = create_profile(age=25, name="Bob", country="Canada", city="Toronto")

print(profile1)
print(profile2)
</code></pre>
            <p>
                Keyword arguments are like filling out a form where you explicitly write the field name next to each value, rather than relying on the order of fields.
            </p>

            <h3>Variable-Length Arguments (*args)</h3>
            <p>
                The <code>*args</code> parameter allows a function to accept any number of positional arguments, which are collected into a tuple.
            </p>
            <pre><code>
# File: args_parameter.py
# Location: /python_projects/functions_tutorial/

def calculate_average(*args):
    """
    Calculate the average of any number of values.
    
    Args:
        *args: Variable number of numeric values
        
    Returns:
        float: The average of all values, or 0 if no values are provided
    """
    if not args:
        return 0
    return sum(args) / len(args)

# Call with different numbers of arguments
print(calculate_average(5, 10, 15, 20))  # 12.5
print(calculate_average(1, 2, 3))  # 2.0
print(calculate_average(42))  # 42.0
print(calculate_average())  # 0
</code></pre>
            <p>
                The <code>*args</code> parameter is like a chef saying "add as many vegetables as you want" – it's flexible and can handle various quantities of inputs.
            </p>

            <h3>Keyword Variable-Length Arguments (**kwargs)</h3>
            <p>
                The <code>**kwargs</code> parameter allows a function to accept any number of keyword arguments, which are collected into a dictionary.
            </p>
            <pre><code>
# File: kwargs_parameter.py
# Location: /python_projects/functions_tutorial/

def create_person(**kwargs):
    """
    Create a dictionary representing a person with any number of attributes.
    
    Args:
        **kwargs: Variable number of keyword arguments representing person attributes
        
    Returns:
        dict: A dictionary containing all the provided attributes
    """
    person = {
        "name": kwargs.get("name", "Unknown"),
        "age": kwargs.get("age", "Unknown")
    }
    
    # Add any additional attributes
    for key, value in kwargs.items():
        if key not in ["name", "age"]:
            person[key] = value
    
    return person

# Call with different keyword arguments
person1 = create_person(name="Alice", age=30, occupation="Engineer")
person2 = create_person(name="Bob", hair_color="brown", hobby="Painting")
person3 = create_person(age=25, height="5'11\"", weight="160lbs")

print(person1)
print(person2)
print(person3)
</code></pre>
            <p>
                The <code>**kwargs</code> parameter is like a customizable form where users can add extra fields that weren't originally planned for – it provides ultimate flexibility.
            </p>
        </section>

        <section class="combining_parameter_types">
            <h2>Combining Parameter Types</h2>
            <p>
                Python allows you to combine different parameter types in a single function, but they must be defined in a specific order:
            </p>
            <ol>
                <li>Required parameters</li>
                <li>Default parameters</li>
                <li>Variable-length arguments (*args)</li>
                <li>Keyword-only arguments</li>
                <li>Keyword variable-length arguments (**kwargs)</li>
            </ol>
            <pre><code>
# File: combined_parameters.py
# Location: /python_projects/functions_tutorial/

def process_order(customer_id, product, quantity=1, *args, shipping="standard", **kwargs):
    """
    Process a customer order with various options.
    
    Args:
        customer_id (str): Required customer identifier
        product (str): Required product name
        quantity (int, optional): Number of items to order (default: 1)
        *args: Additional positional arguments (e.g., gift options)
        shipping (str, optional): Shipping method (keyword-only parameter)
        **kwargs: Additional order details (e.g., gift message, special instructions)
        
    Returns:
        dict: Order details
    """
    order = {
        "customer_id": customer_id,
        "product": product,
        "quantity": quantity,
        "shipping": shipping,
        "extras": args,
        "details": kwargs
    }
    
    return order

# Creating different types of orders
basic_order = process_order("C123", "Laptop")
print(basic_order)

detailed_order = process_order(
    "C456", 
    "Smartphone", 
    2,  # quantity 
    "Gift wrap", "Priority handling",  # *args
    shipping="express",  # keyword-only argument
    gift_message="Happy Birthday!",  # **kwargs
    special_instructions="Leave at the door"  # **kwargs
)
print(detailed_order)
</code></pre>
            <p>
                This example demonstrates how you can create highly flexible functions that can handle various combinations of inputs.
            </p>
            <p>
                It's like a restaurant order form that has required fields (name, main dish), optional fields (sides, drinks), and also a "special requests" section where customers can add anything else they want.
            </p>
        </section>

        <section class="parameter_passing">
            <h2>Parameter Passing: How Values Are Transferred</h2>
            <p>
                Understanding how Python passes arguments to functions is crucial, especially when working with mutable objects like lists and dictionaries.
            </p>

            <h3>Pass by Reference vs. Pass by Value</h3>
            <p>
                Python uses a mechanism that's sometimes described as "pass by object reference" or "pass by assignment." The distinction is important when working with mutable vs. immutable objects.
            </p>

            <h4>Immutable Objects (ints, floats, strings, tuples)</h4>
            <pre><code>
# File: immutable_parameters.py
# Location: /python_projects/functions_tutorial/

def modify_value(x):
    """Try to modify the value of an immutable object."""
    print(f"Inside function (before): x = {x}, id = {id(x)}")
    x = x + 5  # This creates a new object, not modifying the original
    print(f"Inside function (after): x = {x}, id = {id(x)}")

number = 10
print(f"Outside function (before): number = {number}, id = {id(number)}")
modify_value(number)
print(f"Outside function (after): number = {number}, id = {id(number)}")
</code></pre>
            <p>
                When you pass an immutable object like an integer to a function, any modification inside the function creates a new object. The original object outside the function remains unchanged.
            </p>
            <p>
                It's like giving someone a photo. They can draw on a copy of it, but your original photo remains unchanged.
            </p>

            <h4>Mutable Objects (lists, dictionaries, sets)</h4>
            <pre><code>
# File: mutable_parameters.py
# Location: /python_projects/functions_tutorial/

def modify_list(my_list):
    """Modify a mutable object (list)."""
    print(f"Inside function (before): {my_list}, id = {id(my_list)}")
    my_list.append(4)  # Modifies the original list
    print(f"Inside function (after): {my_list}, id = {id(my_list)}")

numbers = [1, 2, 3]
print(f"Outside function (before): {numbers}, id = {id(numbers)}")
modify_list(numbers)
print(f"Outside function (after): {numbers}, id = {id(numbers)}")
</code></pre>
            <p>
                When you pass a mutable object like a list to a function, the function can modify the original object directly. Changes made inside the function are visible outside the function.
            </p>
            <p>
                It's like sharing a Google Doc with someone. When they make changes to the document, you see those changes too, because you're both working on the same document.
            </p>

            <h3>Avoiding Unintended Modifications</h3>
            <p>
                If you want to prevent a function from modifying a mutable object, you can create a copy of the object before passing it to the function:
            </p>
            <pre><code>
# File: avoiding_modifications.py
# Location: /python_projects/functions_tutorial/

def add_greeting(names):
    """Add a greeting to each name in the list."""
    for i in range(len(names)):
        names[i] = f"Hello, {names[i]}!"
    return names

# Original list
original_names = ["Alice", "Bob", "Charlie"]

# Method 1: Create a copy using slicing
names_copy1 = original_names[:]
greeted_names1 = add_greeting(names_copy1)
print(f"Original (after method 1): {original_names}")
print(f"Modified copy: {greeted_names1}")

# Method 2: Create a copy using list() constructor
names_copy2 = list(original_names)
greeted_names2 = add_greeting(names_copy2)
print(f"Original (after method 2): {original_names}")
print(f"Modified copy: {greeted_names2}")

# Method 3: Create a copy using copy module
import copy
names_copy3 = copy.copy(original_names)
greeted_names3 = add_greeting(names_copy3)
print(f"Original (after method 3): {original_names}")
print(f"Modified copy: {greeted_names3}")
</code></pre>
            <p>
                These methods create "shallow copies" of the original list. For nested mutable objects, you might need a "deep copy" using <code>copy.deepcopy()</code>.
            </p>
        </section>

        <section class="common_patterns">
            <h2>Common Parameter Patterns and Use Cases</h2>
            <p>
                Let's look at some common patterns and use cases for function parameters in real-world Python programming:
            </p>

            <h3>Configuration Functions</h3>
            <pre><code>
# File: configuration_function.py
# Location: /python_projects/functions_tutorial/

def configure_application(
    debug=False,
    log_level="INFO",
    data_dir="./data",
    max_connections=100,
    timeout=30
):
    """
    Configure application settings with sensible defaults.
    
    Args:
        debug (bool): Enable debug mode
        log_level (str): Logging level
        data_dir (str): Directory for data files
        max_connections (int): Maximum number of simultaneous connections
        timeout (int): Connection timeout in seconds
        
    Returns:
        dict: Application configuration
    """
    config = {
        "debug": debug,
        "log_level": log_level,
        "data_dir": data_dir,
        "max_connections": max_connections,
        "timeout": timeout
    }
    
    print(f"Application configured with settings: {config}")
    return config

# Default configuration
default_config = configure_application()

# Production configuration
production_config = configure_application(
    debug=False,
    log_level="WARNING",
    max_connections=500,
    timeout=60
)

# Development configuration
dev_config = configure_application(
    debug=True,
    log_level="DEBUG",
    data_dir="./test_data"
)
</code></pre>
            <p>
                This pattern uses default parameters to provide sensible defaults while allowing customization where needed. It's commonly used in configuration settings, UI components, and utility functions.
            </p>

            <h3>Factory Functions</h3>
            <pre><code>
# File: factory_function.py
# Location: /python_projects/functions_tutorial/

def create_user(username, email, role="user", **user_details):
    """
    Factory function to create user objects with varying attributes.
    
    Args:
        username (str): User's username
        email (str): User's email
        role (str): User's role (default: "user")
        **user_details: Additional user details
        
    Returns:
        dict: User object
    """
    user = {
        "username": username,
        "email": email,
        "role": role,
        "active": True,
        "created_at": "2023-11-18T12:00:00Z"  # In a real app, use datetime.now()
    }
    
    # Add additional details
    user.update(user_details)
    
    return user

# Create different types of users
regular_user = create_user("john_doe", "john@example.com")
admin_user = create_user("admin", "admin@example.com", role="admin", access_level=3)
customer = create_user(
    "customer123",
    "customer@example.com",
    role="customer",
    subscription="premium",
    payment_method="credit_card"
)

print(regular_user)
print(admin_user)
print(customer)
</code></pre>
            <p>
                Factory functions use parameters to create different variations of objects or data structures. They're useful for creating test data, initializing complex objects, and implementing design patterns.
            </p>

            <h3>Callback Functions</h3>
            <pre><code>
# File: callback_function.py
# Location: /python_projects/functions_tutorial/

def process_data(data, transform_func=None, filter_func=None):
    """
    Process a list of data with optional transformation and filtering.
    
    Args:
        data (list): List of data items to process
        transform_func (function, optional): Function to transform each item
        filter_func (function, optional): Function to filter items (return True to keep)
        
    Returns:
        list: Processed data
    """
    result = data.copy()
    
    # Apply filter if provided
    if filter_func:
        result = [item for item in result if filter_func(item)]
    
    # Apply transformation if provided
    if transform_func:
        result = [transform_func(item) for item in result]
    
    return result

# Example data
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Define some callback functions
def double(x):
    return x * 2

def is_even(x):
    return x % 2 == 0

def square(x):
    return x * x

# Process data in different ways
print(process_data(numbers))  # No processing, just return a copy
print(process_data(numbers, transform_func=double))  # Double all numbers
print(process_data(numbers, filter_func=is_even))  # Keep only even numbers
print(process_data(numbers, filter_func=is_even, transform_func=square))  # Square even numbers
</code></pre>
            <p>
                Callback functions as parameters allow for flexible, customizable behavior. This pattern is common in event handlers, data processing pipelines, and frameworks like web servers and GUI toolkits.
            </p>
        </section>

        <section class="real_world_examples">
            <h2>Real-World Examples</h2>
            <p>
                Let's examine how parameters and arguments are used in real-world Python applications:
            </p>

            <h3>Web Development</h3>
            <pre><code>
# File: flask_route_example.py
# Location: /python_projects/functions_tutorial/

from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/api/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    """
    Get user details by ID.
    
    Args:
        user_id (int): User ID from URL path
        
    Returns:
        JSON: User details or error message
    """
    # In a real app, you would fetch from a database
    users = {
        1: {"name": "Alice", "email": "alice@example.com"},
        2: {"name": "Bob", "email": "bob@example.com"}
    }
    
    if user_id in users:
        return jsonify(users[user_id])
    else:
        return jsonify({"error": "User not found"}), 404

@app.route('/api/search', methods=['GET'])
def search_items():
    """
    Search for items based on query parameters.
    
    Query params:
        q (str): Search query
        category (str, optional): Filter by category
        max_price (float, optional): Maximum price
        
    Returns:
        JSON: Search results
    """
    # Get query parameters with defaults
    query = request.args.get('q', '')
    category = request.args.get('category', None)
    max_price = request.args.get('max_price', None)
    
    # Convert max_price to float if provided
    if max_price:
        try:
            max_price = float(max_price)
        except ValueError:
            return jsonify({"error": "Invalid max_price parameter"}), 400
    
    # In a real app, you would search a database
    results = [
        {"name": "Widget A", "category": "gadgets", "price": 19.99},
        {"name": "Super Widget", "category": "gadgets", "price": 49.99},
        {"name": "Budget Widget", "category": "gadgets", "price": 9.99},
        {"name": "Premium Tool", "category": "tools", "price": 39.99}
    ]
    
    # Filter results based on parameters
    if query:
        results = [item for item in results if query.lower() in item["name"].lower()]
    
    if category:
        results = [item for item in results if item["category"] == category]
    
    if max_price is not None:
        results = [item for item in results if item["price"] <= max_price]
    
    return jsonify(results)

# In a real app, you would run with: app.run()
</code></pre>
            <p>
                In web frameworks like Flask, function parameters are used to capture URL path variables and query parameters. This allows you to handle different kinds of requests with the same function.
            </p>

            <h3>Data Analysis</h3>
            <pre><code>
# File: data_analysis_example.py
# Location: /python_projects/functions_tutorial/

import pandas as pd
import matplotlib.pyplot as plt

def analyze_sales_data(
    data_file,
    group_by="month",
    metrics=None,
    start_date=None,
    end_date=None,
    plot=True,
    plot_type="line",
    save_plot=False,
    plot_filename="sales_analysis.png"
):
    """
    Analyze sales data with flexible parameters.
    
    Args:
        data_file (str): Path to CSV file with sales data
        group_by (str): How to group data ('day', 'month', 'year', 'product', 'region')
        metrics (list): Metrics to calculate (None for all)
        start_date (str): Filter data from this date (YYYY-MM-DD)
        end_date (str): Filter data until this date (YYYY-MM-DD)
        plot (bool): Whether to generate a plot
        plot_type (str): Type of plot ('line', 'bar', 'pie')
        save_plot (bool): Whether to save the plot to a file
        plot_filename (str): Filename for saved plot
        
    Returns:
        pandas.DataFrame: Analyzed data
    """
    # Default metrics if none specified
    if metrics is None:
        metrics = ["total_sales", "avg_order_value", "units_sold"]
    
    # In a real function, this would load and process actual data
    print(f"Loading data from {data_file}")
    print(f"Grouping by: {group_by}")
    print(f"Calculating metrics: {metrics}")
    
    if start_date:
        print(f"Filtering from date: {start_date}")
    if end_date:
        print(f"Filtering to date: {end_date}")
    
    # Simulated analysis results
    analysis_results = pd.DataFrame({
        "period": ["Jan", "Feb", "Mar", "Apr"],
        "total_sales": [12000, 15000, 18000, 14000],
        "avg_order_value": [75, 80, 82, 78],
        "units_sold": [160, 187, 220, 179]
    })
    
    if plot:
        print(f"Generating {plot_type} plot")
        
        # Create a simple plot (in a real function, this would be more sophisticated)
        if plot_type == "line":
            for metric in metrics:
                if metric in analysis_results.columns:
                    plt.figure(figsize=(10, 6))
                    plt.plot(analysis_results["period"], analysis_results[metric])
                    plt.title(f"{metric} by {group_by}")
                    plt.xlabel(group_by)
                    plt.ylabel(metric)
                    
                    if save_plot:
                        print(f"Saving plot to {plot_filename}")
                        # plt.savefig(plot_filename)
                    
                    # plt.show()
    
    return analysis_results

# Example usage
results = analyze_sales_data(
    data_file="sales_2023.csv",
    group_by="month",
    metrics=["total_sales", "units_sold"],
    start_date="2023-01-01",
    end_date="2023-04-30",
    plot=True,
    plot_type="line",
    save_plot=True,
    plot_filename="q1_sales_analysis.png"
)

print(results)
</code></pre>
            <p>
                In data analysis, functions with many parameters allow analysts to customize analysis workflows while providing sensible defaults for convenience.
            </p>

            <h3>UI Components</h3>
            <pre><code>
# File: button_component.py
# Location: /python_projects/functions_tutorial/

class Button:
    def __init__(
        self,
        text,
        action,
        size="medium",
        color="blue",
        disabled=False,
        icon=None,
        tooltip=None,
        style=None,
        **custom_props
    ):
        """
        Create a button component with flexible styling options.
        
        Args:
            text (str): Button text
            action (function): Callback function when button is clicked
            size (str): Button size ('small', 'medium', 'large')
            color (str): Button color
            disabled (bool): Whether the button is disabled
            icon (str): Optional icon name to display
            tooltip (str): Optional tooltip text
            style (dict): Additional CSS styles
            **custom_props: Additional custom properties
        """
        self.text = text
        self.action = action
        self.size = size
        self.color = color
        self.disabled = disabled
        self.icon = icon
        self.tooltip = tooltip
        self.style = style or {}
        self.custom_props = custom_props
        
        print(f"Button created: {self.text} ({self.size}, {self.color})")
        if self.icon:
            print(f"  With icon: {self.icon}")
        if self.tooltip:
            print(f"  With tooltip: {self.tooltip}")
        if self.disabled:
            print("  Button is disabled")
        if self.custom_props:
            print(f"  Custom properties: {self.custom_props}")
    
    def render(self):
        """Simulate rendering the button (in a real app, this would create HTML or UI elements)."""
        button_class = f"btn btn-{self.size} btn-{self.color}"
        if self.disabled:
            button_class += " disabled"
        
        # In a real component, this would return actual UI elements
        button_html = f'&lt;button class="{button_class}"'
        
        if self.tooltip:
            button_html += f' title="{self.tooltip}"'
        
        if self.style:
            style_str = "; ".join([f"{k}: {v}" for k, v in self.style.items()])
            button_html += f' style="{style_str}"'
        
        button_html += '&gt;'
        
        if self.icon:
            button_html += f'&lt;i class="icon-{self.icon}"&gt;&lt;/i&gt; '
        
        button_html += f'{self.text}&lt;/button&gt;'
        
        return button_html

# Create different types of buttons
save_button = Button(
    "Save",
    action=lambda: print("Save clicked"),
    color="green",
    icon="save",
    tooltip="Save your changes"
)

cancel_button = Button(
    "Cancel",
    action=lambda: print("Cancel clicked"),
    color="red"
)

disabled_button = Button(
    "Submit",
    action=lambda: print("Submit clicked"),
    disabled=True,
    style={"border-radius": "8px", "box-shadow": "2px 2px 5px #ccc"}
)

custom_button = Button(
    "Download",
    action=lambda: print("Download clicked"),
    size="large",
    icon="download",
    data_download_url="/files/report.pdf",
    data_tracking_id="download-btn-123"
)

# Render buttons
print("\nRendered buttons:")
print(save_button.render())
print(cancel_button.render())
print(disabled_button.render())
print(custom_button.render())
</code></pre>
            <p>
                In UI development, flexible parameters allow designers to create reusable components with many customization options. This pattern is common in front-end frameworks and design systems.
            </p>
        </section>

        <section class="best_practices">
            <h2>Best Practices for Working with Parameters and Arguments</h2>
            <p>
                Here are some guidelines to follow when designing and using function parameters:
            </p>

            <h3>Parameter Design</h3>
            <ul>
                <li><strong>Keep required parameters minimal</strong>: Only require what's absolutely necessary; make everything else optional with sensible defaults.</li>
                <li><strong>Order parameters thoughtfully</strong>: Put the most important parameters first, followed by optional ones.</li>
                <li><strong>Group related parameters</strong>: If a function has many parameters, consider grouping them into a single configuration object or dictionary.</li>
                <li><strong>Use clear parameter names</strong>: Choose descriptive names that convey the purpose of each parameter.</li>
                <li><strong>Document parameters thoroughly</strong>: Use docstrings to describe each parameter, including its type, purpose, and default value.</li>
            </ul>

            <h3>Parameter Validation</h3>
            <pre><code>
# File: parameter_validation.py
# Location: /python_projects/functions_tutorial/

def create_user_account(username, email, password, age=None):
    """
    Create a new user account with input validation.
    
    Args:
        username (str): Username (3-20 alphanumeric characters)
        email (str): Valid email address
        password (str): Password (at least 8 characters)
        age (int, optional): User's age (must be at least 13)
        
    Returns:
        dict: User account information or error message
    """
    # Validate username
    if not isinstance(username, str):
        return {"error": "Username must be a string"}
    
    if not (3 <= len(username) <= 20):
        return {"error": "Username must be between 3 and 20 characters"}
    
    if not username.isalnum():
        return {"error": "Username must contain only letters and numbers"}
    
    # Validate email (simple check)
    if not isinstance(email, str):
        return {"error": "Email must be a string"}
    
    if '@' not in email or '.' not in email:
        return {"error": "Invalid email format"}
    
    # Validate password
    if not isinstance(password, str):
        return {"error": "Password must be a string"}
    
    if len(password) < 8:
        return {"error": "Password must be at least 8 characters"}
    
    # Validate age if provided
    if age is not None:
        if not isinstance(age, int):
            return {"error": "Age must be an integer"}
        
        if age < 13:
            return {"error": "User must be at least 13 years old"}
    
    # If all validations pass, create and return the user account
    user = {
        "username": username,
        "email": email,
        "password": "********",  # Don't store actual password in a real app!
        "age": age,
        "status": "active"
    }
    
    return user

# Test with valid input
valid_user = create_user_account("john_doe", "john@example.com", "secure123", 25)
print(valid_user)

# Test with invalid inputs
invalid_username = create_user_account("j", "john@example.com", "secure123")
print(invalid_username)

invalid_email = create_user_account("jane_doe", "invalid-email", "secure123")
print(invalid_email)

invalid_password = create_user_account("jane_doe", "jane@example.com", "123")
print(invalid_password)

invalid_age = create_user_account("young_user", "young@example.com", "secure123", 10)
print(invalid_age)
</code></pre>
            <p>
                Validating parameters helps catch errors early and provides clear feedback to users of your function. It's especially important in APIs, user-facing features, and code that may be used by other developers.
            </p>

            <h3>Advanced Parameter Handling</h3>
            <pre><code>
# File: advanced_parameters.py
# Location: /python_projects/functions_tutorial/

def search_products(
    query=None,
    category=None,
    min_price=None,
    max_price=None,
    sort_by="relevance",
    page=1,
    page_size=20
):
    """
    Search for products with advanced parameter handling.
    
    Args:
        query (str, optional): Search query
        category (str, optional): Product category
        min_price (float, optional): Minimum price
        max_price (float, optional): Maximum price
        sort_by (str): Sort order ('relevance', 'price_low', 'price_high', 'newest')
        page (int): Page number for pagination
        page_size (int): Number of results per page
        
    Returns:
        dict: Search results and metadata
    """
    # Clean and normalize parameters
    if query:
        query = query.strip().lower()
    
    if category:
        category = category.strip().lower()
    
    # Convert string prices to float if needed
    if isinstance(min_price, str):
        try:
            min_price = float(min_price)
        except ValueError:
            min_price = None
    
    if isinstance(max_price, str):
        try:
            max_price = float(max_price)
        except ValueError:
            max_price = None
    
    # Ensure valid pagination parameters
    try:
        page = int(page)
        if page < 1:
            page = 1
    except (ValueError, TypeError):
        page = 1
    
    try:
        page_size = int(page_size)
        if page_size < 1:
            page_size = 20
        if page_size > 100:  # Limit maximum page size
            page_size = 100
    except (ValueError, TypeError):
        page_size = 20
    
    # Validate sort_by parameter
    valid_sort_options = ["relevance", "price_low", "price_high", "newest"]
    if sort_by not in valid_sort_options:
        sort_by = "relevance"
    
    # Build search filters
    filters = {}
    if query:
        filters["query"] = query
    if category:
        filters["category"] = category
    if min_price is not None:
        filters["min_price"] = min_price
    if max_price is not None:
        filters["max_price"] = max_price
    
    # Pagination info
    pagination = {
        "page": page,
        "page_size": page_size,
        "sort_by": sort_by
    }
    
    # In a real function, you would query a database or API here
    # For demonstration, we'll return the processed parameters
    return {
        "filters": filters,
        "pagination": pagination,
        "results": [
            {"id": 1, "name": "Example Product 1", "price": 19.99},
            {"id": 2, "name": "Example Product 2", "price": 29.99}
        ],
        "total_results": 2
    }

# Test with different parameter combinations
search1 = search_products(query="laptop", min_price=500, max_price=1000)
print(search1)

search2 = search_products(category="electronics", sort_by="price_low", page=2)
print(search2)

search3 = search_products(query="  PHONE  ", min_price="300", page_size="25")
print(search3)
</code></pre>
            <p>
                Advanced parameter handling includes normalizing inputs, handling type conversions, validating values, and providing reasonable defaults. This creates robust functions that can handle a wide range of inputs gracefully.
            </p>
        </section>

        <section class="conclusion">
            <h2>Conclusion: The Art of Parameter Design</h2>
            <p>
                Mastering parameters and arguments is essential for creating flexible, reusable, and robust Python functions. Good parameter design follows these principles:
            </p>
            <ul>
                <li><strong>Simplicity</strong>: Make simple things easy and complex things possible.</li>
                <li><strong>Flexibility</strong>: Allow customization where needed without overwhelming users with too many choices.</li>
                <li><strong>Robustness</strong>: Handle various inputs gracefully, with clear error messages for invalid values.</li>
                <li><strong>Convenience</strong>: Provide sensible defaults to reduce the cognitive load on users.</li>
                <li><strong>Consistency</strong>: Follow consistent patterns across related functions.</li>
            </ul>
            <p>
                Remember that well-designed parameters make your functions easier to use, understand, and maintain. They're the interface between your code and its users, so investing time in thoughtful parameter design pays off in code that's more intuitive, adaptable, and resilient.
            </p>
            <p>
                As you continue to develop your Python skills, pay attention to how parameters are used in libraries and frameworks you work with. Study their designs, and consider how you can apply similar patterns in your own code.
            </p>
        </section>

        <section class="practice_exercises">
            <h2>Practice Exercises</h2>
            <p>
                Test your understanding of parameters and arguments with these exercises:
            </p>
            <ol>
                <li>Create a function <code>format_name</code> that takes first name, last name, and optional middle name parameters and returns a properly formatted full name.</li>
                <li>Write a <code>send_email</code> function with parameters for recipient, subject, body, and optional parameters for cc, bcc, attachments, and priority.</li>
                <li>Implement a <code>calculate_statistics</code> function that takes a list of numbers and returns various statistics (mean, median, min, max, etc.) based on optional boolean flags.</li>
                <li>Create a <code>filter_data</code> function that takes a list and variable number of filter functions, applying each filter in sequence.</li>
                <li>Design a <code>create_html_element</code> function that generates HTML tags with flexible attributes and content.</li>
            </ol>
            <p>
                Completing these exercises will help solidify your understanding of how to design and use function parameters effectively.
            </p>
        </section>

        <section class="further_reading">
            <h2>Further Reading</h2>
            <ul>
                <li>Python Documentation: <a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions" target="_blank">Defining Functions</a></li>
                <li>Python Documentation: <a href="https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions" target="_blank">More on Defining Functions</a></li>
                <li>PEP 3102: <a href="https://www.python.org/dev/peps/pep-3102/" target="_blank">Keyword-Only Arguments</a></li>
                <li>Book: "Fluent Python" by Luciano Ramalho (Chapter on Functions)</li>
                <li>Book: "Clean Code" by Robert C. Martin (Chapter on Functions)</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
