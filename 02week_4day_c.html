<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Functions: Return Values</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Functions: Return Values</h1>
        <h2>Understanding Function Outputs and Their Applications</h2>
    </header>

    <main>
        <section class="introduction">
            <h2>The Purpose of Return Values</h2>
            <p>
                Imagine a kitchen appliance that takes ingredients, processes them, but has no way to give you the finished product. It would be rather useless! Similarly, functions in Python need a way to provide their computed results back to the code that called them. This is where return values come in.
            </p>
            <p>
                Return values are how functions communicate their results back to the caller. They allow functions to be useful building blocks that can be composed together to solve complex problems. Without return values, functions would be limited to side effects (like printing to the console or modifying global variables), which would make our code less modular and harder to test.
            </p>
            <p>
                Think of return values as the output of a function machine: you put inputs (arguments) in, the function processes them according to its instructions, and then it returns a result that you can use for further computation or decision-making.
            </p>
        </section>

        <section class="return_basics">
            <h2>Basic Return Value Concepts</h2>
            <p>
                In Python, we use the <code>return</code> statement to specify what value a function should produce as its result. Let's look at some examples to understand the basic concepts:
            </p>

            <h3>Returning Simple Values</h3>
            <pre><code>
# File: simple_returns.py
# Location: /python_projects/functions_tutorial/

def add(a, b):
    """Add two numbers and return the result."""
    return a + b

def is_even(number):
    """Check if a number is even."""
    if number % 2 == 0:
        return True
    else:
        return False

# Using the functions
sum_result = add(5, 3)
print(f"5 + 3 = {sum_result}")

if is_even(10):
    print("10 is even")
else:
    print("10 is odd")
</code></pre>
            <p>
                In these examples, the <code>add</code> function returns the sum of its two arguments, and the <code>is_even</code> function returns a boolean indicating whether the number is even. The calling code can then use these return values in various ways, such as storing them in variables, using them in conditions, or passing them to other functions.
            </p>

            <h3>No Return Value (None)</h3>
            <pre><code>
# File: no_return.py
# Location: /python_projects/functions_tutorial/

def greet(name):
    """Print a greeting without returning anything."""
    print(f"Hello, {name}!")

def do_nothing():
    """A function that does nothing and returns nothing explicitly."""
    pass

# Using these functions
result1 = greet("Alice")
print(f"Return value of greet(): {result1}")

result2 = do_nothing()
print(f"Return value of do_nothing(): {result2}")
</code></pre>
            <p>
                When a function doesn't have a <code>return</code> statement (or has a bare <code>return</code> with no value), it implicitly returns <code>None</code>, which is Python's special value representing "nothing" or "no value". Functions that are designed for their side effects rather than their return values often return <code>None</code>.
            </p>
            <p>
                It's like ordering food at a restaurant: sometimes you care about getting the food back (return value), but other times you just want the chef to do something like turn off the oven (side effect) and don't expect to receive anything in return.
            </p>
        </section>

        <section class="return_flow_control">
            <h2>Return Statements and Flow Control</h2>
            <p>
                A key aspect of the <code>return</code> statement is that it immediately exits the function and sends the specified value back to the caller. This makes <code>return</code> a powerful flow control mechanism within functions.
            </p>

            <h3>Early Returns</h3>
            <pre><code>
# File: early_returns.py
# Location: /python_projects/functions_tutorial/

def find_first_negative(numbers):
    """
    Find the first negative number in a list.
    
    Args:
        numbers: A list of numbers
        
    Returns:
        The first negative number found, or None if no negatives exist
    """
    for number in numbers:
        if number < 0:
            return number  # Early return when a negative is found
            
    # If we get here, no negatives were found
    return None

# Examples
print(find_first_negative([5, 3, -1, 4, -2]))  # -1
print(find_first_negative([1, 2, 3, 4, 5]))    # None
</code></pre>
            <p>
                Early returns are like finding what you're looking for in a store and leaving immediately instead of checking every aisle. They can make functions more efficient and easier to read by avoiding deeply nested conditions.
            </p>

            <h3>Multiple Return Statements</h3>
            <pre><code>
# File: multiple_returns.py
# Location: /python_projects/functions_tutorial/

def classify_number(number):
    """
    Classify a number as positive, negative, or zero.
    
    Args:
        number: A numeric value
        
    Returns:
        A string describing the number
    """
    if number > 0:
        return "positive"
    elif number < 0:
        return "negative"
    else:
        return "zero"

# Testing the function
print(f"5 is {classify_number(5)}")
print(f"-3 is {classify_number(-3)}")
print(f"0 is {classify_number(0)}")
</code></pre>
            <p>
                Multiple return statements allow functions to have different exit points based on conditions. This can make complex decision-making clearer compared to storing the result in a variable and having a single return statement at the end.
            </p>

            <h3>Conditional Returns</h3>
            <pre><code>
# File: conditional_returns.py
# Location: /python_projects/functions_tutorial/

def safe_divide(a, b):
    """
    Safely divide two numbers, handling division by zero.
    
    Args:
        a: Numerator
        b: Denominator
        
    Returns:
        The result of a/b, or an error message if b is zero
    """
    if b == 0:
        return "Error: Division by zero"
    return a / b

# Examples
print(safe_divide(10, 2))   # 5.0
print(safe_divide(10, 0))   # Error: Division by zero
</code></pre>
            <p>
                Conditional returns are useful for handling error cases, input validation, and different processing paths based on the inputs. They're like forks in a road that lead to different destinations.
            </p>
        </section>

        <section class="return_multiple_values">
            <h2>Returning Multiple Values</h2>
            <p>
                Sometimes a function needs to return more than one piece of information. Python provides several elegant ways to handle this:
            </p>

            <h3>Using Tuples (Implicit Packing)</h3>
            <pre><code>
# File: return_tuples.py
# Location: /python_projects/functions_tutorial/

def get_dimensions():
    """Return the width and height of an object."""
    width = 100
    height = 50
    return width, height  # Python automatically packs these into a tuple

# Unpacking the returned tuple
width, height = get_dimensions()
print(f"Width: {width}, Height: {height}")

# Capturing as a single tuple
dimensions = get_dimensions()
print(f"Dimensions: {dimensions}")
print(f"Width is at index 0: {dimensions[0]}")
print(f"Height is at index 1: {dimensions[1]}")
</code></pre>
            <p>
                This is one of Python's most elegant features. When you return multiple values separated by commas, Python automatically packages them into a tuple. The caller can then either unpack the values into separate variables or work with the tuple directly.
            </p>
            <p>
                It's like ordering a combo meal and receiving all the items together in one package, but you can separate them once you receive them.
            </p>

            <h3>Using Lists</h3>
            <pre><code>
# File: return_lists.py
# Location: /python_projects/functions_tutorial/

def get_prime_factors(number):
    """Find all prime factors of a number."""
    factors = []
    
    # Find the prime factors
    divisor = 2
    while number > 1:
        while number % divisor == 0:
            factors.append(divisor)
            number //= divisor
        divisor += 1
    
    return factors

# Using the returned list
factors_of_12 = get_prime_factors(12)
print(f"Prime factors of 12: {factors_of_12}")  # [2, 2, 3]

factors_of_60 = get_prime_factors(60)
print(f"Prime factors of 60: {factors_of_60}")  # [2, 2, 3, 5]
</code></pre>
            <p>
                Lists are useful when returning a collection of similar items where the number of items might vary. Unlike tuples, lists are mutable, so the caller can modify the returned collection if needed.
            </p>

            <h3>Using Dictionaries</h3>
            <pre><code>
# File: return_dictionaries.py
# Location: /python_projects/functions_tutorial/

def analyze_text(text):
    """Analyze text and return various statistics."""
    # Calculate statistics
    character_count = len(text)
    word_count = len(text.split())
    line_count = text.count('\n') + 1
    
    # Return as a dictionary
    return {
        "characters": character_count,
        "words": word_count,
        "lines": line_count
    }

# Using the returned dictionary
sample_text = """Hello world!
This is a sample text.
It has multiple lines."""

stats = analyze_text(sample_text)
print(f"Character count: {stats['characters']}")
print(f"Word count: {stats['words']}")
print(f"Line count: {stats['lines']}")

# You can also use dictionary unpacking
characters, words, lines = stats.values()
print(f"Stats: {characters} chars, {words} words, {lines} lines")
</code></pre>
            <p>
                Dictionaries are excellent for returning named values, especially when the function computes multiple related but different pieces of information. They provide a clear, self-documenting way to access the returned data by name rather than position.
            </p>
            <p>
                Think of a dictionary return value as a labeled container, like a tool box where each compartment has a specific purpose and a label telling you what's inside.
            </p>

            <h3>Using Custom Classes</h3>
            <pre><code>
# File: return_custom_classes.py
# Location: /python_projects/functions_tutorial/

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        return f"Point({self.x}, {self.y})"
    
    def distance_from_origin(self):
        return (self.x ** 2 + self.y ** 2) ** 0.5

def create_point(x, y):
    """Create and return a Point object."""
    return Point(x, y)

def midpoint(point1, point2):
    """Calculate the midpoint between two points."""
    mid_x = (point1.x + point2.x) / 2
    mid_y = (point1.y + point2.y) / 2
    return Point(mid_x, mid_y)

# Using the functions
p1 = create_point(3, 4)
p2 = create_point(6, 8)

print(f"Point 1: {p1}")
print(f"Distance from origin: {p1.distance_from_origin()}")

mid = midpoint(p1, p2)
print(f"Midpoint: {mid}")
</code></pre>
            <p>
                For complex related data with behavior, returning custom class instances offers the most flexibility. It allows you to return not just data but also methods that can operate on that data. This is a core concept in object-oriented programming.
            </p>
            <p>
                Custom classes are like specialized devices that not only contain information but also know how to process it. Instead of returning just coordinates, you're returning a "smart point" that knows how to calculate distances, display itself, etc.
            </p>
        </section>

        <section class="return_patterns">
            <h2>Common Return Value Patterns</h2>
            <p>
                Certain patterns of return values are commonly used in Python programming. Understanding these patterns will help you design more effective functions:
            </p>

            <h3>Status and Data Pattern</h3>
            <pre><code>
# File: status_data_pattern.py
# Location: /python_projects/functions_tutorial/

def fetch_user_data(user_id):
    """
    Fetch user data from a database.
    
    Args:
        user_id: The ID of the user to fetch
        
    Returns:
        tuple: (success, data)
            - success: Boolean indicating whether the operation succeeded
            - data: User data if successful, or error message if failed
    """
    # Simulate a database
    users = {
        101: {"name": "Alice Smith", "email": "alice@example.com"},
        102: {"name": "Bob Johnson", "email": "bob@example.com"}
    }
    
    if user_id in users:
        return True, users[user_id]
    else:
        return False, f"User with ID {user_id} not found"

# Using the function
success, data = fetch_user_data(101)
if success:
    print(f"Found user: {data['name']}")
else:
    print(f"Error: {data}")

success, data = fetch_user_data(103)
if success:
    print(f"Found user: {data['name']}")
else:
    print(f"Error: {data}")
</code></pre>
            <p>
                The status and data pattern returns both a success indicator and the result or error information. This pattern is common in functions that might fail, allowing callers to easily check for success before attempting to use the returned data.
            </p>

            <h3>Option Type Pattern</h3>
            <pre><code>
# File: option_pattern.py
# Location: /python_projects/functions_tutorial/

def find_user_by_email(email, user_database):
    """
    Find a user by email address.
    
    Args:
        email: The email to search for
        user_database: List of user dictionaries
        
    Returns:
        The user dictionary if found, or None if not found
    """
    for user in user_database:
        if user["email"] == email:
            return user
    
    # If we reach here, no user was found
    return None

# Example usage
users = [
    {"id": 1, "name": "Alice", "email": "alice@example.com"},
    {"id": 2, "name": "Bob", "email": "bob@example.com"},
    {"id": 3, "name": "Charlie", "email": "charlie@example.com"}
]

user = find_user_by_email("bob@example.com", users)
if user:
    print(f"Found user: {user['name']}")
else:
    print("User not found")

user = find_user_by_email("david@example.com", users)
if user:
    print(f"Found user: {user['name']}")
else:
    print("User not found")
</code></pre>
            <p>
                The option type pattern returns either a valid result or None, letting the caller check if a value was found before trying to use it. This is particularly useful for search functions and cases where "not found" is a normal outcome rather than an error.
            </p>

            <h3>Builder Pattern</h3>
            <pre><code>
# File: builder_pattern.py
# Location: /python_projects/functions_tutorial/

def create_html_element(tag, content="", **attributes):
    """
    Build an HTML element string.
    
    Args:
        tag: The HTML tag name
        content: The content inside the tag
        **attributes: HTML attributes as keyword arguments
        
    Returns:
        A string containing the HTML element
    """
    # Build the attribute string
    attr_str = ""
    for key, value in attributes.items():
        key = key.replace("_", "-")  # Convert snake_case to kebab-case
        attr_str += f' {key}="{value}"'
    
    # Build and return the HTML element
    return f"&lt;{tag}{attr_str}&gt;{content}&lt;/{tag}&gt;"

# Using the function
paragraph = create_html_element("p", "Hello, world!", class_="greeting", data_user_id="123")
print(paragraph)

link = create_html_element("a", "Visit Example", href="https://example.com", target="_blank")
print(link)

# Building more complex structures by composition
div = create_html_element("div", 
    create_html_element("h1", "Title") + 
    create_html_element("p", "Some content"),
    class_="container"
)
print(div)
</code></pre>
            <p>
                The builder pattern returns something constructed by the function, often with a fluent or composable API. This pattern is common in functions that create or construct objects, strings, or other complex structures.
            </p>

            <h3>Factory Pattern</h3>
            <pre><code>
# File: factory_pattern.py
# Location: /python_projects/functions_tutorial/

class User:
    def __init__(self, user_id, username, email):
        self.user_id = user_id
        self.username = username
        self.email = email
        self.is_active = True
        self.role = "user"
    
    def __str__(self):
        return f"User({self.username}, {self.email}, {self.role})"

def create_user(user_id, username, email):
    """
    Factory function to create a standard user.
    
    Args:
        user_id: Unique user identifier
        username: User's username
        email: User's email address
        
    Returns:
        A new User object
    """
    return User(user_id, username, email)

def create_admin_user(user_id, username, email):
    """
    Factory function to create an admin user.
    
    Args:
        user_id: Unique user identifier
        username: User's username
        email: User's email address
        
    Returns:
        A new User object with admin role
    """
    # Create a standard user first
    user = create_user(user_id, username, email)
    
    # Modify it to be an admin
    user.role = "admin"
    
    return user

# Using the factory functions
regular_user = create_user(1, "john_doe", "john@example.com")
admin_user = create_admin_user(2, "admin", "admin@example.com")

print(regular_user)
print(admin_user)
</code></pre>
            <p>
                The factory pattern returns newly created instances, often with specific configurations. This pattern is useful for creating objects with complex setup requirements or different variations.
            </p>
        </section>

        <section class="return_values_chain">
            <h2>Chaining Functions with Return Values</h2>
            <p>
                One of the most powerful aspects of return values is that they allow us to chain function calls together, with the output of one function becoming the input to another. This enables a compositional programming style that can make code more readable and maintainable.
            </p>

            <h3>Basic Function Chaining</h3>
            <pre><code>
# File: function_chaining.py
# Location: /python_projects/functions_tutorial/

def clean_text(text):
    """Remove extra whitespace and convert to lowercase."""
    return text.strip().lower()

def count_words(text):
    """Count the number of words in a text."""
    words = text.split()
    return len(words)

def analyze_complexity(word_count):
    """Analyze text complexity based on word count."""
    if word_count < 10:
        return "Simple"
    elif word_count < 50:
        return "Moderate"
    else:
        return "Complex"

# Chaining function calls
text = "  The Quick Brown Fox Jumps Over The Lazy Dog   "
cleaned_text = clean_text(text)
word_count = count_words(cleaned_text)
complexity = analyze_complexity(word_count)

print(f"Original: '{text}'")
print(f"Cleaned: '{cleaned_text}'")
print(f"Word count: {word_count}")
print(f"Complexity: {complexity}")

# More concise chaining
complexity = analyze_complexity(count_words(clean_text(text)))
print(f"Complexity (chained): {complexity}")
</code></pre>
            <p>
                Function chaining is like an assembly line, where each station (function) performs a specific operation on the product before passing it to the next station. The final station returns the completed product.
            </p>

            <h3>Data Pipeline Example</h3>
            <pre><code>
# File: data_pipeline.py
# Location: /python_projects/functions_tutorial/

def load_data(filename):
    """Simulate loading data from a file."""
    print(f"Loading data from {filename}...")
    # In a real application, this would read from a file
    data = [
        {"name": "Alice", "age": 25, "score": 85},
        {"name": "Bob", "age": 31, "score": 92},
        {"name": "Charlie", "age": 22, "score": 78},
        {"name": "Diana", "age": 28, "score": 95},
        {"name": "Eve", "age": 19, "score": 88}
    ]
    return data

def filter_data(data, min_age=None, min_score=None):
    """Filter data based on criteria."""
    result = data.copy()
    
    if min_age is not None:
        result = [item for item in result if item["age"] >= min_age]
    
    if min_score is not None:
        result = [item for item in result if item["score"] >= min_score]
    
    return result

def sort_data(data, key="name", reverse=False):
    """Sort data by a specified key."""
    return sorted(data, key=lambda item: item[key], reverse=reverse)

def extract_names(data):
    """Extract just the names from the data."""
    return [item["name"] for item in data]

# Building a data pipeline
raw_data = load_data("students.csv")
filtered_data = filter_data(raw_data, min_age=25, min_score=80)
sorted_data = sort_data(filtered_data, key="score", reverse=True)
names = extract_names(sorted_data)

print("Top performers (age 25+):")
for name in names:
    print(f"- {name}")

# Alternative: one-line pipeline (less readable but more concise)
result = extract_names(
    sort_data(
        filter_data(
            load_data("students.csv"), 
            min_age=25, 
            min_score=80
        ), 
        key="score", 
        reverse=True
    )
)
print("\nSame result with one-line pipeline:", result)
</code></pre>
            <p>
                Data pipelines are a common application of function chaining, where each function in the chain performs a specific transformation or extraction on the data. This approach is highly modular, allowing each processing step to be reused and tested independently.
            </p>
        </section>

        <section class="advanced_return">
            <h2>Advanced Return Value Techniques</h2>
            <p>
                Python provides some advanced techniques for working with return values that can make your functions more powerful and flexible:
            </p>

            <h3>Returning Functions</h3>
            <pre><code>
# File: return_functions.py
# Location: /python_projects/functions_tutorial/

def create_multiplier(factor):
    """
    Create and return a function that multiplies by the given factor.
    
    Args:
        factor: The multiplication factor
        
    Returns:
        A function that multiplies its argument by factor
    """
    def multiplier(x):
        return x * factor
    
    return multiplier

# Create specialized functions using our factory
double = create_multiplier(2)
triple = create_multiplier(3)
quadruple = create_multiplier(4)

# Use the returned functions
print(f"Double 5: {double(5)}")      # 10
print(f"Triple 5: {triple(5)}")      # 15
print(f"Quadruple 5: {quadruple(5)}") # 20
</code></pre>
            <p>
                Functions are first-class objects in Python, which means they can be returned from other functions. This enables powerful patterns like closures, where the returned function "remembers" the environment in which it was created (like the <code>factor</code> value in this example).
            </p>
            <p>
                It's like a factory that produces specialized tools instead of directly producing products. Each tool is customized for a specific task but follows the same basic design.
            </p>

            <h3>Generators with Yield</h3>
            <pre><code>
# File: yield_generators.py
# Location: /python_projects/functions_tutorial/

def count_up_to(limit):
    """
    Generator that yields numbers from 1 up to the limit.
    
    Args:
        limit: Upper bound (inclusive)
        
    Yields:
        Each number in the sequence
    """
    current = 1
    while current <= limit:
        yield current
        current += 1

def fibonacci(n):
    """
    Generate the first n Fibonacci numbers.
    
    Args:
        n: Number of Fibonacci numbers to generate
        
    Yields:
        Each Fibonacci number in the sequence
    """
    a, b = 0, 1
    count = 0
    
    while count < n:
        yield b
        a, b = b, a + b
        count += 1

# Using generators
print("Counting to 5:")
for number in count_up_to(5):
    print(number)

print("\nFirst 8 Fibonacci numbers:")
for number in fibonacci(8):
    print(number)

# Converting to a list
fib_list = list(fibonacci(10))
print("\nFirst 10 Fibonacci numbers as a list:", fib_list)
</code></pre>
            <p>
                Generators use the <code>yield</code> statement instead of <code>return</code> to produce a series of values over time, one at a time. This is memory-efficient for large sequences because the entire sequence doesn't need to be stored in memory at once.
            </p>
            <p>
                Generators are like water faucets that provide values on demand, whereas regular functions with return values are like water bottles that give you all the water at once.
            </p>

            <h3>Context Managers</h3>
            <pre><code>
# File: context_managers.py
# Location: /python_projects/functions_tutorial/

class Timer:
    """A context manager for timing code execution."""
    
    def __init__(self, description):
        self.description = description
    
    def __enter__(self):
        """Called when entering a with block. Returns self for use in the block."""
        import time
        self.start_time = time.time()
        print(f"Starting timer: {self.description}")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Called when exiting a with block."""
        import time
        elapsed = time.time() - self.start_time
        print(f"Finished: {self.description}")
        print(f"Elapsed time: {elapsed:.5f} seconds")
        # Returning False means any exceptions will propagate

def create_timer(description):
    """Create and return a timer context manager."""
    return Timer(description)

# Using the context manager
with create_timer("Calculating prime numbers") as timer:
    # Simulate some work
    primes = []
    for num in range(2, 1000):
        is_prime = all(num % i != 0 for i in range(2, int(num ** 0.5) + 1))
        if is_prime:
            primes.append(num)
    
    print(f"Found {len(primes)} prime numbers")
</code></pre>
            <p>
                Context managers are objects that set up and tear down a context for a block of code. They use the <code>__enter__</code> and <code>__exit__</code> methods to define what happens when entering and exiting the context. Functions can return context managers to provide controlled environments for specific operations.
            </p>
            <p>
                Context managers are like automatic door openers and closers. They handle the entry and exit procedures, ensuring that resources are properly set up before use and cleaned up afterward.
            </p>
        </section>

        <section class="handling_return_values">
            <h2>Handling Return Values Effectively</h2>
            <p>
                Now that we've explored different aspects of return values, let's look at best practices for handling them effectively in your code:
            </p>

            <h3>Unpacking Return Values</h3>
            <pre><code>
# File: unpacking_returns.py
# Location: /python_projects/functions_tutorial/

def get_user_stats(user_id):
    """Get statistics for a user."""
    # Simulate fetching user data
    posts = 42
    followers = 567
    following = 231
    
    return posts, followers, following

# Unpacking all values
posts, followers, following = get_user_stats(123)
print(f"Posts: {posts}")
print(f"Followers: {followers}")
print(f"Following: {following}")

# Unpacking with placeholder for unwanted values
posts, _, _ = get_user_stats(123)
print(f"Just posts: {posts}")

# Unpacking with extended unpacking (Python 3.x)
posts, *social_stats = get_user_stats(123)
print(f"Posts: {posts}")
print(f"Social stats: {social_stats}")  # [567, 231]
</code></pre>
            <p>
                Python's unpacking syntax provides elegant ways to extract the values you need from function returns. The underscore is conventionally used as a "throwaway" variable for values you don't need, and extended unpacking with * can capture multiple values in a list.
            </p>

            <h3>Default Values for Missing Returns</h3>
            <pre><code>
# File: default_for_none.py
# Location: /python_projects/functions_tutorial/

def find_user(user_id, user_database):
    """Find a user by ID in a database."""
    for user in user_database:
        if user["id"] == user_id:
            return user
    return None

# Sample database
users = [
    {"id": 1, "name": "Alice"},
    {"id": 2, "name": "Bob"}
]

# Using the or operator for default values
user = find_user(3, users) or {"id": 0, "name": "Guest"}
print(f"User: {user['name']}")

# Using get() for nested access with defaults
user = find_user(2, users)
description = user and user.get("description", "No description available")
print(f"Description: {description}")
</code></pre>
            <p>
                When functions might return None or when accessing nested attributes that might not exist, using default values can prevent errors and make your code more robust. Python provides several techniques for this, including the <code>or</code> operator and the <code>get()</code> method for dictionaries.
            </p>

            <h3>Error Handling for Return Values</h3>
            <pre><code>
# File: error_handling_returns.py
# Location: /python_projects/functions_tutorial/

def parse_json(json_string):
    """
    Parse a JSON string into a Python object.
    
    Args:
        json_string: A string containing JSON data
        
    Returns:
        The parsed Python object, or None if parsing fails
    """
    import json
    try:
        return json.loads(json_string)
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON: {e}")
        return None

# Valid JSON
valid_json = '{"name": "Alice", "age": 30}'
data = parse_json(valid_json)
if data:
    print(f"Parsed data: {data}")
    print(f"Name: {data.get('name')}")
else:
    print("Failed to parse JSON")

# Invalid JSON
invalid_json = '{"name": "Missing comma" "age": 30}'
data = parse_json(invalid_json)
if data:
    print(f"Parsed data: {data}")
else:
    print("Failed to parse JSON")
</code></pre>
            <p>
                When dealing with functions that might fail, it's important to check return values before using them. Combining error handling inside the function with checks in the calling code creates robust applications that can gracefully handle unexpected situations.
            </p>
        </section>

        <section class="real_world_examples">
            <h2>Real-World Examples of Return Values</h2>
            <p>
                Let's look at some practical, real-world examples of how return values are used in different domains:
            </p>

            <h3>Web Development with Flask</h3>
            <pre><code>
# File: flask_example.py
# Location: /python_projects/functions_tutorial/

from flask import Flask, request, jsonify, render_template

app = Flask(__name__)

def validate_user_input(form_data):
    """
    Validate user registration data.
    
    Args:
        form_data: Dictionary of form fields
        
    Returns:
        tuple: (is_valid, errors)
            - is_valid: Boolean indicating if all data is valid
            - errors: Dictionary of field-specific error messages
    """
    errors = {}
    
    # Check username
    if not form_data.get("username"):
        errors["username"] = "Username is required"
    elif len(form_data["username"]) < 3:
        errors["username"] = "Username must be at least 3 characters"
    
    # Check email
    if not form_data.get("email"):
        errors["email"] = "Email is required"
    elif "@" not in form_data["email"] or "." not in form_data["email"]:
        errors["email"] = "Invalid email format"
    
    # Check password
    if not form_data.get("password"):
        errors["password"] = "Password is required"
    elif len(form_data["password"]) < 8:
        errors["password"] = "Password must be at least 8 characters"
    
    # Check if passwords match
    if form_data.get("password") != form_data.get("confirm_password"):
        errors["confirm_password"] = "Passwords do not match"
    
    is_valid = len(errors) == 0
    return is_valid, errors

@app.route("/register", methods=["POST"])
def register_user():
    """Handle user registration."""
    # Get form data
    form_data = request.form.to_dict()
    
    # Validate the data
    is_valid, errors = validate_user_input(form_data)
    
    if not is_valid:
        # Return the form with error messages
        return render_template("register.html", errors=errors, form_data=form_data)
    
    # Process valid registration
    # (In a real app, you would save the user to a database)
    return render_template("registration_success.html", username=form_data["username"])

@app.route("/api/register", methods=["POST"])
def api_register_user():
    """API endpoint for user registration."""
    # Get JSON data
    data = request.json
    
    # Validate the data
    is_valid, errors = validate_user_input(data)
    
    if not is_valid:
        return jsonify({"success": False, "errors": errors}), 400
    
    # Process valid registration
    # (In a real app, you would save the user to a database)
    return jsonify({"success": True, "message": "Registration successful"})

# In a real app, you would run with: app.run()
</code></pre>
            <p>
                In web development, functions often return values that are used to make decisions about what response to send to the client. The separation of validation logic from request handling makes the code more modular and testable.
            </p>

            <h3>Data Analysis with Pandas</h3>
            <pre><code>
# File: data_analysis_example.py
# Location: /python_projects/functions_tutorial/

import pandas as pd
import numpy as np

def load_and_clean_data(file_path):
    """
    Load data from a CSV file and perform basic cleaning.
    
    Args:
        file_path: Path to the CSV file
        
    Returns:
        pandas.DataFrame: Cleaned data
    """
    # Load data (in a real app, this would read from an actual file)
    # df = pd.read_csv(file_path)
    
    # For this example, we'll create a sample DataFrame
    df = pd.DataFrame({
        'Name': ['Alice', 'Bob', 'Charlie', None, 'Eve'],
        'Age': [25, 31, 22, 28, np.nan],
        'Salary': [60000, np.nan, 55000, 70000, 65000]
    })
    
    # Clean the data
    # Remove rows with all missing values
    df = df.dropna(how='all')
    
    # Fill missing values
    df['Name'] = df['Name'].fillna('Unknown')
    df['Age'] = df['Age'].fillna(df['Age'].mean())
    df['Salary'] = df['Salary'].fillna(df['Salary'].mean())
    
    return df

def analyze_data(df):
    """
    Perform analysis on a DataFrame.
    
    Args:
        df: pandas.DataFrame containing the data
        
    Returns:
        dict: Analysis results
    """
    results = {
        'record_count': len(df),
        'age_statistics': {
            'mean': df['Age'].mean(),
            'min': df['Age'].min(),
            'max': df['Age'].max(),
            'std': df['Age'].std()
        },
        'salary_statistics': {
            'mean': df['Salary'].mean(),
            'min': df['Salary'].min(),
            'max': df['Salary'].max(),
            'std': df['Salary'].std()
        },
        'correlation': df['Age'].corr(df['Salary'])
    }
    
    return results

# Example usage
print("Loading and cleaning data...")
df = load_and_clean_data("employee_data.csv")
print(df)

print("\nAnalyzing data...")
analysis = analyze_data(df)

print("\nAnalysis Results:")
print(f"Number of records: {analysis['record_count']}")
print("\nAge Statistics:")
for key, value in analysis['age_statistics'].items():
    print(f"  {key}: {value:.2f}")
print("\nSalary Statistics:")
for key, value in analysis['salary_statistics'].items():
    print(f"  {key}: {value:.2f}")
print(f"\nCorrelation between Age and Salary: {analysis['correlation']:.2f}")
</code></pre>
            <p>
                In data analysis, functions typically return processed data or analysis results. The separation of data loading, cleaning, and analysis into different functions creates a clear workflow and allows each step to be reused independently.
            </p>

            <h3>Game Development</h3>
            <pre><code>
# File: game_example.py
# Location: /python_projects/functions_tutorial/

import random

class Character:
    def __init__(self, name, health, attack, defense):
        self.name = name
        self.health = health
        self.max_health = health
        self.attack = attack
        self.defense = defense
    
    def __str__(self):
        return f"{self.name} (Health: {self.health}/{self.max_health})"

def create_character(character_type):
    """
    Factory function to create a character of the specified type.
    
    Args:
        character_type: The type of character to create
        
    Returns:
        Character: A new character instance
    """
    if character_type == "warrior":
        return Character("Warrior", 100, 15, 10)
    elif character_type == "mage":
        return Character("Mage", 70, 20, 5)
    elif character_type == "ranger":
        return Character("Ranger", 85, 12, 8)
    else:
        return Character("Unknown", 50, 10, 5)

def calculate_damage(attacker, defender):
    """
    Calculate damage dealt in an attack.
    
    Args:
        attacker: The attacking character
        defender: The defending character
        
    Returns:
        int: Amount of damage dealt
    """
    # Base damage is attacker's attack stat
    base_damage = attacker.attack
    
    # Add some randomness
    random_factor = random.uniform(0.8, 1.2)
    
    # Apply defense reduction
    defense_reduction = defender.defense / 30  # Convert defense to a percentage
    damage_multiplier = 1 - defense_reduction
    
    # Calculate final damage
    damage = int(base_damage * random_factor * damage_multiplier)
    
    # Ensure minimum damage of 1
    return max(1, damage)

def perform_attack(attacker, defender):
    """
    Perform an attack between characters.
    
    Args:
        attacker: The attacking character
        defender: The defending character
        
    Returns:
        tuple: (damage_dealt, is_defender_defeated)
    """
    damage = calculate_damage(attacker, defender)
    
    # Apply damage
    defender.health = max(0, defender.health - damage)
    
    # Check if defender is defeated
    is_defeated = defender.health == 0
    
    return damage, is_defeated

# Example usage in a simple battle simulation
player = create_character("warrior")
enemy = create_character("mage")

print(f"Battle begins: {player} vs {enemy}")

while player.health > 0 and enemy.health > 0:
    # Player's turn
    damage, enemy_defeated = perform_attack(player, enemy)
    print(f"{player.name} attacks for {damage} damage!")
    print(f"{enemy.name}'s health: {enemy.health}/{enemy.max_health}")
    
    if enemy_defeated:
        print(f"{enemy.name} has been defeated!")
        break
    
    # Enemy's turn
    damage, player_defeated = perform_attack(enemy, player)
    print(f"{enemy.name} attacks for {damage} damage!")
    print(f"{player.name}'s health: {player.health}/{player.max_health}")
    
    if player_defeated:
        print(f"{player.name} has been defeated!")
        break
    
    print("---")

print("Battle over!")
</code></pre>
            <p>
                In game development, functions often return values that represent game state changes, calculations, or new game objects. These return values are then used to update the game state and drive the game logic.
            </p>
        </section>

        <section class="testing_return_values">
            <h2>Testing Functions with Return Values</h2>
            <p>
                Return values make functions easier to test because they produce clear outputs that can be verified. Let's look at how to test functions with different types of return values:
            </p>

            <h3>Unit Testing Basic Return Values</h3>
            <pre><code>
# File: test_return_values.py
# Location: /python_projects/functions_tutorial/

import unittest

# Function to test
def calculate_discount(price, discount_percent):
    """Calculate the discounted price."""
    if discount_percent < 0 or discount_percent > 100:
        return None  # Invalid discount percentage
    
    discount_amount = price * (discount_percent / 100)
    return price - discount_amount

class TestCalculateDiscount(unittest.TestCase):
    def test_zero_discount(self):
        """Test that zero discount returns the original price."""
        result = calculate_discount(100, 0)
        self.assertEqual(result, 100)
    
    def test_full_discount(self):
        """Test that 100% discount returns zero."""
        result = calculate_discount(100, 100)
        self.assertEqual(result, 0)
    
    def test_partial_discount(self):
        """Test a partial discount calculation."""
        result = calculate_discount(100, 25)
        self.assertEqual(result, 75)
    
    def test_invalid_discount(self):
        """Test that invalid discount percentages return None."""
        result1 = calculate_discount(100, -10)
        self.assertIsNone(result1)
        
        result2 = calculate_discount(100, 110)
        self.assertIsNone(result2)

# Run the tests
if __name__ == "__main__":
    unittest.main(argv=['first-arg-is-ignored'], exit=False)
</code></pre>
            <p>
                Unit tests verify that functions return the expected values for different inputs. This is a key part of ensuring that your code works correctly and continues to work as it evolves.
            </p>

            <h3>Testing Complex Return Values</h3>
            <pre><code>
# File: test_complex_returns.py
# Location: /python_projects/functions_tutorial/

import unittest

# Function to test
def parse_name(full_name):
    """
    Parse a full name into its components.
    
    Args:
        full_name: A string containing a person's name
        
    Returns:
        dict: Parsed name components
    """
    parts = full_name.strip().split()
    
    if not parts:
        return {"first": "", "middle": "", "last": ""}
    
    result = {}
    
    if len(parts) == 1:
        result = {"first": parts[0], "middle": "", "last": ""}
    elif len(parts) == 2:
        result = {"first": parts[0], "middle": "", "last": parts[1]}
    else:
        result = {
            "first": parts[0],
            "middle": " ".join(parts[1:-1]),
            "last": parts[-1]
        }
    
    return result

class TestParseName(unittest.TestCase):
    def test_empty_name(self):
        """Test parsing an empty name."""
        result = parse_name("")
        expected = {"first": "", "middle": "", "last": ""}
        self.assertEqual(result, expected)
    
    def test_single_name(self):
        """Test parsing a single name."""
        result = parse_name("John")
        expected = {"first": "John", "middle": "", "last": ""}
        self.assertEqual(result, expected)
    
    def test_first_last(self):
        """Test parsing a first and last name."""
        result = parse_name("John Smith")
        expected = {"first": "John", "middle": "", "last": "Smith"}
        self.assertEqual(result, expected)
    
    def test_full_name(self):
        """Test parsing a full name with middle name."""
        result = parse_name("John Adam Smith")
        expected = {"first": "John", "middle": "Adam", "last": "Smith"}
        self.assertEqual(result, expected)
    
    def test_multiple_middle_names(self):
        """Test parsing a name with multiple middle names."""
        result = parse_name("John Adam James Smith")
        expected = {"first": "John", "middle": "Adam James", "last": "Smith"}
        self.assertEqual(result, expected)

# Run the tests
if __name__ == "__main__":
    unittest.main(argv=['first-arg-is-ignored'], exit=False)
</code></pre>
            <p>
                When testing functions that return complex data structures like dictionaries or objects, it's important to check all the expected components of the return value. This ensures that the function is producing correctly structured data.
            </p>
        </section>

        <section class="best_practices">
            <h2>Best Practices for Return Values</h2>
            <p>
                Based on the patterns and examples we've explored, here are some best practices for working with return values in Python:
            </p>

            <h3>Design Guidelines</h3>
            <ul>
                <li><strong>Be consistent:</strong> Use consistent return types and patterns across related functions.</li>
                <li><strong>Return early for errors or edge cases:</strong> This makes code clearer and more efficient.</li>
                <li><strong>Avoid returning different types:</strong> Try to maintain a consistent return type for a function, or document clearly when different types might be returned.</li>
                <li><strong>Return results, not side effects:</strong> Functions should generally compute and return values rather than modifying global state.</li>
                <li><strong>Document return values:</strong> Always clearly document what a function returns, including possible return types and edge cases.</li>
            </ul>

            <h3>Documentation Example</h3>
            <pre><code>
# File: documented_returns.py
# Location: /python_projects/functions_tutorial/

def divide_safely(a, b):
    """
    Divide two numbers with error handling.
    
    Args:
        a (float): The numerator
        b (float): The denominator
        
    Returns:
        float or str: 
            - If the division is valid, returns the result as a float
            - If b is zero, returns an error message as a string
    
    Examples:
        >>> divide_safely(10, 2)
        5.0
        >>> divide_safely(10, 0)
        'Error: Division by zero'
    """
    if b == 0:
        return "Error: Division by zero"
    return a / b

# Example usage
results = [
    divide_safely(10, 2),
    divide_safely(10, 0)
]

for result in results:
    if isinstance(result, float):
        print(f"Result: {result}")
    else:
        print(result)
</code></pre>
            <p>
                Good documentation is especially important when a function might return different types or when the return value has a complex structure. It helps other developers (and your future self) understand how to use the function correctly.
            </p>

            <h3>Advanced Pattern: Result Object</h3>
            <pre><code>
# File: result_object_pattern.py
# Location: /python_projects/functions_tutorial/

class Result:
    """
    A class to represent the result of an operation.
    Provides a consistent interface for success and failure.
    """
    
    def __init__(self, success, value=None, error=None):
        self.success = success
        self.value = value
        self.error = error
    
    @classmethod
    def ok(cls, value):
        """Create a successful result with a value."""
        return cls(True, value=value)
    
    @classmethod
    def fail(cls, error):
        """Create a failed result with an error message."""
        return cls(False, error=error)
    
    def __bool__(self):
        """Allow using the result in boolean context to check success."""
        return self.success
    
    def __str__(self):
        if self.success:
            return f"Result.ok({self.value})"
        return f"Result.fail({self.error})"

def divide(a, b):
    """
    Divide two numbers with a result object.
    
    Args:
        a: Numerator
        b: Denominator
        
    Returns:
        Result: A result object containing either the quotient or an error
    """
    try:
        if b == 0:
            return Result.fail("Division by zero")
        return Result.ok(a / b)
    except Exception as e:
        return Result.fail(str(e))

def calculate_average(numbers):
    """
    Calculate the average of a list of numbers.
    
    Args:
        numbers: A list of numbers
        
    Returns:
        Result: A result object containing either the average or an error
    """
    try:
        if not numbers:
            return Result.fail("Cannot calculate average of empty list")
        return Result.ok(sum(numbers) / len(numbers))
    except Exception as e:
        return Result.fail(str(e))

# Example usage
results = [
    divide(10, 2),
    divide(10, 0),
    calculate_average([1, 2, 3, 4, 5]),
    calculate_average([])
]

for result in results:
    if result:
        print(f"Success: {result.value}")
    else:
        print(f"Error: {result.error}")

# Using with if statements
result = divide(10, 2)
if result:
    value = result.value
    print(f"Result is {value}")
else:
    print(f"Operation failed: {result.error}")
</code></pre>
            <p>
                The Result object pattern provides a consistent interface for handling both successful operations and failures. It's similar to patterns in other languages like Rust's Result or Haskell's Either. This approach makes error handling more explicit and consistent across functions.
            </p>
        </section>

        <section class="conclusion">
            <h2>Conclusion: The Power of Return Values</h2>
            <p>
                Return values are the lifeblood of functional programming and a core mechanism for creating modular, reusable code. They allow functions to be composed together, tested independently, and used as building blocks for complex applications.
            </p>
            <p>
                By mastering return values in Python, you unlock the ability to:
            </p>
            <ul>
                <li>Create functions that are pure, predictable, and testable</li>
                <li>Build complex operations by composing simpler functions</li>
                <li>Express rich information through structured return values</li>
                <li>Handle errors and edge cases gracefully</li>
                <li>Create APIs that are intuitive and flexible</li>
            </ul>
            <p>
                As you continue your journey in Python programming, pay attention to how return values are used in the libraries and frameworks you work with. You'll notice patterns and conventions that you can adopt in your own code to make it more effective and maintainable.
            </p>
            <p>
                Remember, good functions are like good tools: they do one thing well, they're reliable, and they're designed to work well with other tools. Return values are what allow functions to connect together into powerful combinations, just as standardized connections allow physical tools to work together.
            </p>
        </section>

        <section class="practice_exercises">
            <h2>Practice Exercises</h2>
            <p>
                Apply what you've learned with these exercises:
            </p>
            <ol>
                <li>Create a function named <code>get_stats</code> that takes a list of numbers and returns a dictionary with the minimum, maximum, sum, and average of the numbers.</li>
                <li>Write a function named <code>validate_password</code> that checks if a password meets certain criteria (e.g., length, containing digits and special characters) and returns a tuple of <code>(is_valid, reason)</code> where <code>reason</code> is None for valid passwords or an error message for invalid ones.</li>
                <li>Implement a function named <code>find_factors</code> that returns all factors of a given number.</li>
                <li>Create a function named <code>parse_csv</code> that takes a string containing CSV data and returns a list of dictionaries representing each row, with keys from the header row.</li>
                <li>Write a function named <code>generate_fibonacci</code> that uses yield to create a generator for Fibonacci numbers.</li>
            </ol>
            <p>
                These exercises will give you practice with different types of return values and patterns for effective function design.
            </p>
        </section>

        <section class="further_reading">
            <h2>Further Reading</h2>
            <ul>
                <li>Python Documentation: <a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions" target="_blank">Defining Functions</a></li>
                <li>Python Documentation: <a href="https://docs.python.org/3/library/typing.html" target="_blank">Type Hints</a> - For annotating return types</li>
                <li>Book: "Fluent Python" by Luciano Ramalho - Contains excellent chapters on functions</li>
                <li>Article: <a href="https://realpython.com/python-return-statement/" target="_blank">The Python return Statement: Usage and Best Practices</a></li>
                <li>Article: <a href="https://www.python.org/dev/peps/pep-0484/" target="_blank">PEP 484  Type Hints</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
