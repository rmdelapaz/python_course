<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Functions: Anonymous Functions (Lambda)</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Functions: Anonymous Functions (Lambda)</h1>
        <h2>Understanding and Using Python's Compact Function Syntax</h2>
    </header>

    <main>
        <section class="introduction">
            <h2>What Are Lambda Functions?</h2>
            <p>
                In programming, sometimes we need to create small, one-time-use functions. Writing a full function definition with <code>def</code> can feel excessive for these simple operations. This is where lambda functions come in.
            </p>
            <p>
                Lambda functions (also called anonymous functions) are small, unnamed functions defined with the <code>lambda</code> keyword. They're designed for situations where you need a simple function for a short period, often as an argument to another function.
            </p>
            <p>
                Think of regular functions as specialized tools with their own toolbox and name, while lambda functions are like disposable toolsâ€”simple, single-purpose, and meant to be used immediately without the overhead of naming and storing them.
            </p>
        </section>

        <section class="lambda_syntax">
            <h2>Basic Syntax and Structure</h2>
            <p>
                The syntax of a lambda function is deliberately simple:
            </p>
            <pre><code>
# File: lambda_syntax.py
# Location: /python_projects/functions_tutorial/

# Basic lambda syntax
lambda parameters: expression

# Simple example - a lambda that squares a number
square = lambda x: x ** 2

# Using the lambda function
result = square(5)
print(f"5 squared is: {result}")  # Output: 5 squared is: 25

# Equivalent function using def
def square_function(x):
    return x ** 2

# Compare the results
print(f"Using lambda: {square(7)}")
print(f"Using def: {square_function(7)}")
</code></pre>
            <p>
                The key components of a lambda function are:
            </p>
            <ul>
                <li><strong>The <code>lambda</code> keyword</strong>: Signals the start of a lambda function</li>
                <li><strong>Parameters</strong>: Input arguments (optional, can have multiple)</li>
                <li><strong>Colon (<code>:</code>)</strong>: Separates the parameters from the expression</li>
                <li><strong>Expression</strong>: A single expression that is evaluated and returned</li>
            </ul>
            <p>
                Unlike regular functions defined with <code>def</code>, lambda functions:
            </p>
            <ul>
                <li>Can only contain a single expression (no multiple statements)</li>
                <li>Automatically return the result of that expression (no explicit <code>return</code> statement)</li>
                <li>Don't have a name (unless you assign them to a variable)</li>
                <li>Can't include docstrings or annotations</li>
            </ul>
        </section>

        <section class="lambda_examples">
            <h2>Practical Lambda Examples</h2>
            <p>
                Let's explore some common use cases for lambda functions:
            </p>

            <h3>Multiple Parameters</h3>
            <pre><code>
# File: lambda_multiple_params.py
# Location: /python_projects/functions_tutorial/

# Lambda with multiple parameters
add = lambda x, y: x + y
print(f"5 + 3 = {add(5, 3)}")  # Output: 5 + 3 = 8

# Lambda with default parameter values
greet = lambda name, greeting="Hello": f"{greeting}, {name}!"
print(greet("Alice"))           # Output: Hello, Alice!
print(greet("Bob", "Welcome"))  # Output: Welcome, Bob!

# Lambda with arbitrary number of arguments
sum_all = lambda *args: sum(args)
print(f"Sum of 1, 2, 3: {sum_all(1, 2, 3)}")           # Output: Sum of 1, 2, 3: 6
print(f"Sum of 10, 20, 30, 40: {sum_all(10, 20, 30, 40)}") # Output: Sum of 10, 20, 30, 40: 100

# Lambda with keyword arguments
format_person = lambda **kwargs: f"Person: {kwargs}"
print(format_person(name="Alice", age=30, job="Engineer"))
# Output: Person: {'name': 'Alice', 'age': 30, 'job': 'Engineer'}
</code></pre>
            <p>
                Lambda functions can take any number and type of parameters that regular functions can, including default values, *args, and **kwargs.
            </p>

            <h3>Conditional Logic in Lambdas</h3>
            <pre><code>
# File: lambda_conditional.py
# Location: /python_projects/functions_tutorial/

# Conditional expression (ternary operator) in a lambda
is_even = lambda x: "Even" if x % 2 == 0 else "Odd"
print(f"5 is {is_even(5)}")     # Output: 5 is Odd
print(f"6 is {is_even(6)}")     # Output: 6 is Even

# More complex conditional
classify_number = lambda x: "Positive" if x > 0 else "Zero" if x == 0 else "Negative"
print(f"10 is {classify_number(10)}")    # Output: 10 is Positive
print(f"0 is {classify_number(0)}")      # Output: 0 is Zero
print(f"-5 is {classify_number(-5)}")    # Output: -5 is Negative

# Using logical operators for conditions
in_range = lambda x, min_val, max_val: min_val <= x <= max_val
print(f"Is 15 between 10 and 20? {in_range(15, 10, 20)}")  # Output: True
print(f"Is 25 between 10 and 20? {in_range(25, 10, 20)}")  # Output: False

# Using or/and for default values
get_value = lambda x, default: x or default
print(f"Value: {get_value('Hello', 'Default')}")  # Output: Value: Hello
print(f"Value: {get_value('', 'Default')}")       # Output: Value: Default
print(f"Value: {get_value(0, 'Default')}")        # Output: Value: Default
</code></pre>
            <p>
                While lambdas can't use if-statements (which are statements, not expressions), they can use conditional expressions (also known as the ternary operator) and logical operations to implement simple conditions.
            </p>

            <h3>Working with Data Structures</h3>
            <pre><code>
# File: lambda_data_structures.py
# Location: /python_projects/functions_tutorial/

# List of dictionaries
people = [
    {"name": "Alice", "age": 25, "job": "Engineer"},
    {"name": "Bob", "age": 30, "job": "Designer"},
    {"name": "Charlie", "age": 22, "job": "Developer"},
    {"name": "Diana", "age": 35, "job": "Manager"}
]

# Get name of each person using map and lambda
names = list(map(lambda person: person["name"], people))
print(f"Names: {names}")  # Output: Names: ['Alice', 'Bob', 'Charlie', 'Diana']

# Filter people over 25 using filter and lambda
older_than_25 = list(filter(lambda person: person["age"] > 25, people))
print("People older than 25:")
for person in older_than_25:
    print(f"  {person['name']}, {person['age']}")

# Sort people by age using sorted and lambda
sorted_by_age = sorted(people, key=lambda person: person["age"])
print("People sorted by age:")
for person in sorted_by_age:
    print(f"  {person['name']}, {person['age']}")

# Get the oldest person using max and lambda
oldest = max(people, key=lambda person: person["age"])
print(f"Oldest person: {oldest['name']}, {oldest['age']}")

# Group people by job using a dictionary comprehension and lambda
jobs = {}
for person in people:
    job = person["job"]
    if job not in jobs:
        jobs[job] = []
    jobs[job].append(person["name"])

print("People grouped by job:")
for job, names in jobs.items():
    print(f"  {job}: {', '.join(names)}")
</code></pre>
            <p>
                Lambda functions are especially useful for operations on data structures, particularly when used with higher-order functions like <code>map()</code>, <code>filter()</code>, and <code>sorted()</code>.
            </p>
        </section>

        <section class="common_use_cases">
            <h2>Common Use Cases for Lambda Functions</h2>
            <p>
                Lambda functions shine in several specific scenarios. Let's explore the most common use cases:
            </p>

            <h3>Sorting with Custom Keys</h3>
            <pre><code>
# File: lambda_sorting.py
# Location: /python_projects/functions_tutorial/

# Sorting strings by length
words = ["apple", "banana", "cherry", "date", "elderberry", "fig"]
sorted_by_length = sorted(words, key=lambda word: len(word))
print(f"Words sorted by length: {sorted_by_length}")
# Output: Words sorted by length: ['fig', 'date', 'apple', 'cherry', 'banana', 'elderberry']

# Sorting strings by their second letter
sorted_by_second_letter = sorted(words, key=lambda word: word[1] if len(word) > 1 else "")
print(f"Words sorted by second letter: {sorted_by_second_letter}")
# Output: Words sorted by second letter: ['date', 'banana', 'apple', 'elderberry', 'fig', 'cherry']

# Sorting tuples by their second element
pairs = [(1, 'one'), (3, 'three'), (2, 'two'), (4, 'four')]
sorted_by_second = sorted(pairs, key=lambda pair: pair[1])
print(f"Pairs sorted by second element: {sorted_by_second}")
# Output: Pairs sorted by second element: [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]

# Sorting dictionaries
books = [
    {"title": "Python Basics", "author": "Smith", "year": 2018},
    {"title": "Advanced Python", "author": "Jones", "year": 2020},
    {"title": "Python Cookbook", "author": "Brown", "year": 2015}
]

# Sort books by year
books_by_year = sorted(books, key=lambda book: book["year"])
print("Books sorted by year:")
for book in books_by_year:
    print(f"  {book['title']} ({book['year']})")

# Sort books by author, then by year
books_by_author_then_year = sorted(books, key=lambda book: (book["author"], book["year"]))
print("Books sorted by author, then year:")
for book in books_by_author_then_year:
    print(f"  {book['author']}: {book['title']} ({book['year']})")
</code></pre>
            <p>
                Lambda functions are perfect for providing custom sorting keys to the <code>sorted()</code> function and the <code>.sort()</code> method. Instead of writing a separate function just for comparison, you can define the sorting logic inline.
            </p>

            <h3>Filtering with filter()</h3>
            <pre><code>
# File: lambda_filtering.py
# Location: /python_projects/functions_tutorial/

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Filter even numbers
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(f"Even numbers: {even_numbers}")  # Output: Even numbers: [2, 4, 6, 8, 10]

# Filter numbers greater than 5
greater_than_5 = list(filter(lambda x: x > 5, numbers))
print(f"Numbers > 5: {greater_than_5}")  # Output: Numbers > 5: [6, 7, 8, 9, 10]

# Filter prime numbers
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

prime_numbers = list(filter(is_prime, numbers))
print(f"Prime numbers: {prime_numbers}")  # Output: Prime numbers: [2, 3, 5, 7]

# Note: For complex filtering logic like this, a regular function is more readable
# than a lambda, but we could still write it as:
prime_numbers_lambda = list(filter(
    lambda n: n >= 2 and all(n % i != 0 for i in range(2, int(n**0.5) + 1)),
    numbers
))
print(f"Prime numbers (lambda): {prime_numbers_lambda}")

# Filtering dictionaries
employees = [
    {"name": "Alice", "department": "Engineering", "salary": 75000},
    {"name": "Bob", "department": "Marketing", "salary": 65000},
    {"name": "Charlie", "department": "Engineering", "salary": 85000},
    {"name": "Diana", "department": "HR", "salary": 70000},
    {"name": "Eve", "department": "Marketing", "salary": 60000}
]

# Filter engineers
engineers = list(filter(lambda emp: emp["department"] == "Engineering", employees))
print("Engineers:")
for engineer in engineers:
    print(f"  {engineer['name']}, {engineer['salary']}")

# Filter employees with salary > 70000
high_earners = list(filter(lambda emp: emp["salary"] > 70000, employees))
print("High earners:")
for earner in high_earners:
    print(f"  {earner['name']}, {earner['department']}, {earner['salary']}")
</code></pre>
            <p>
                The <code>filter()</code> function is a natural companion for lambda functions. It takes a function and an iterable, returning an iterator of all items for which the function returns True. Lambda functions provide a concise way to specify filtering conditions.
            </p>

            <h3>Transforming with map()</h3>
            <pre><code>
# File: lambda_mapping.py
# Location: /python_projects/functions_tutorial/

numbers = [1, 2, 3, 4, 5]

# Square all numbers
squared = list(map(lambda x: x**2, numbers))
print(f"Squared: {squared}")  # Output: Squared: [1, 4, 9, 16, 25]

# Convert to strings with formatting
formatted = list(map(lambda x: f"Number: {x}", numbers))
print(f"Formatted: {formatted}")  # Output: Formatted: ['Number: 1', 'Number: 2', ...]

# Apply multiple operations
transformed = list(map(lambda x: (x**2) + 1, numbers))
print(f"Transformed: {transformed}")  # Output: Transformed: [2, 5, 10, 17, 26]

# Map with multiple iterables
first = [1, 2, 3]
second = [10, 20, 30]
sums = list(map(lambda x, y: x + y, first, second))
print(f"Sums: {sums}")  # Output: Sums: [11, 22, 33]

# Map with dictionaries
employees = [
    {"name": "Alice", "salary": 75000},
    {"name": "Bob", "salary": 65000},
    {"name": "Charlie", "salary": 85000}
]

# Give everyone a 10% raise
def give_raise(employee):
    employee["salary"] = int(employee["salary"] * 1.1)
    return employee

employees_with_raise = list(map(give_raise, employees))
print("Employees after raise:")
for emp in employees_with_raise:
    print(f"  {emp['name']}: ${emp['salary']}")

# Or using lambda (note: this creates new dictionaries)
original_employees = [
    {"name": "Diana", "salary": 70000},
    {"name": "Eve", "salary": 60000}
]

new_employees = list(map(
    lambda emp: {"name": emp["name"], "salary": int(emp["salary"] * 1.1)},
    original_employees
))
print("New employees with raise:")
for emp in new_employees:
    print(f"  {emp['name']}: ${emp['salary']}")
</code></pre>
            <p>
                The <code>map()</code> function applies a given function to each item in an iterable, returning an iterator of results. Lambda functions make it easy to define simple transformations inline, without cluttering your code with small helper functions.
            </p>

            <h3>Reducing with functools.reduce()</h3>
            <pre><code>
# File: lambda_reducing.py
# Location: /python_projects/functions_tutorial/

from functools import reduce

numbers = [1, 2, 3, 4, 5]

# Calculate the sum of all numbers
sum_result = reduce(lambda x, y: x + y, numbers)
print(f"Sum: {sum_result}")  # Output: Sum: 15

# Calculate the product of all numbers
product_result = reduce(lambda x, y: x * y, numbers)
print(f"Product: {product_result}")  # Output: Product: 120

# Find the maximum number
max_result = reduce(lambda x, y: x if x > y else y, numbers)
print(f"Maximum: {max_result}")  # Output: Maximum: 5

# Find the minimum number
min_result = reduce(lambda x, y: x if x < y else y, numbers)
print(f"Minimum: {min_result}")  # Output: Minimum: 1

# Concatenate strings
words = ["Hello", " ", "World", "!"]
concatenated = reduce(lambda x, y: x + y, words)
print(f"Concatenated: '{concatenated}'")  # Output: Concatenated: 'Hello World!'

# More complex reduction: flatten a list of lists
nested_list = [[1, 2], [3, 4], [5, 6]]
flattened = reduce(lambda x, y: x + y, nested_list)
print(f"Flattened: {flattened}")  # Output: Flattened: [1, 2, 3, 4, 5, 6]

# Accumulating into a dictionary
purchases = [
    {"product": "apple", "price": 0.5},
    {"product": "banana", "price": 0.3},
    {"product": "apple", "price": 0.5},
    {"product": "orange", "price": 0.8},
    {"product": "banana", "price": 0.3}
]

# Count purchases by product
counts = reduce(
    lambda acc, item: {**acc, item["product"]: acc.get(item["product"], 0) + 1},
    purchases,
    {}  # Initial value
)
print("Purchase counts:")
for product, count in counts.items():
    print(f"  {product}: {count}")
</code></pre>
            <p>
                The <code>reduce()</code> function from the <code>functools</code> module applies a function of two arguments cumulatively to the items of an iterable. Lambda functions work well with <code>reduce()</code> for operations like summing, finding maxima/minima, or building up complex data structures.
            </p>

            <h3>Creating Function Factories</h3>
            <pre><code>
# File: lambda_factories.py
# Location: /python_projects/functions_tutorial/

# Creating a multiplier factory
def create_multiplier(factor):
    return lambda x: x * factor

# Create specialized multiplier functions
double = create_multiplier(2)
triple = create_multiplier(3)
half = create_multiplier(0.5)

# Use the generated functions
print(f"Double 10: {double(10)}")  # Output: Double 10: 20
print(f"Triple 10: {triple(10)}")  # Output: Triple 10: 30
print(f"Half of 10: {half(10)}")   # Output: Half of 10: 5.0

# Creating a filter factory
def filter_by_property(property_name, property_value):
    return lambda item: item.get(property_name) == property_value

# Sample data
products = [
    {"id": 1, "name": "Apple", "category": "Fruit", "price": 0.5},
    {"id": 2, "name": "Banana", "category": "Fruit", "price": 0.3},
    {"id": 3, "name": "Carrot", "category": "Vegetable", "price": 0.4},
    {"id": 4, "name": "Broccoli", "category": "Vegetable", "price": 0.8}
]

# Create specialized filter functions
is_fruit = filter_by_property("category", "Fruit")
is_vegetable = filter_by_property("category", "Vegetable")
is_cheap = lambda product: product["price"] < 0.5

# Use the filters
fruits = list(filter(is_fruit, products))
vegetables = list(filter(is_vegetable, products))
cheap_products = list(filter(is_cheap, products))

print(f"Fruits: {[product['name'] for product in fruits]}")
print(f"Vegetables: {[product['name'] for product in vegetables]}")
print(f"Cheap products: {[product['name'] for product in cheap_products]}")

# Creating a formatter factory
def create_formatter(template):
    return lambda **kwargs: template.format(**kwargs)

# Create specialized formatters
greeting_formatter = create_formatter("Hello, {name}! Welcome to {place}.")
product_formatter = create_formatter("Product: {name}, Price: ${price:.2f}")

# Use the formatters
greeting = greeting_formatter(name="Alice", place="Wonderland")
product_info = product_formatter(name="Widget", price=19.99)

print(greeting)      # Output: Hello, Alice! Welcome to Wonderland.
print(product_info)  # Output: Product: Widget, Price: $19.99
</code></pre>
            <p>
                Lambda functions are excellent for creating function factoriesâ€”higher-order functions that generate specialized functions on demand. This pattern enables you to create families of related functions with shared behavior but customized for specific use cases.
            </p>
        </section>

        <section class="lambda_in_functional">
            <h2>Lambda Functions in Functional Programming</h2>
            <p>
                Lambda functions are a key component of functional programming in Python. Let's see how they can be used in functional programming patterns:
            </p>

            <h3>Higher-Order Functions</h3>
            <pre><code>
# File: lambda_higher_order.py
# Location: /python_projects/functions_tutorial/

# Higher-order function that applies a function twice
def apply_twice(func, arg):
    """Apply a function to an argument, then apply it again to the result."""
    return func(func(arg))

# Using lambda with the higher-order function
result1 = apply_twice(lambda x: x * 2, 3)
print(f"Applying 'double' twice to 3: {result1}")  # Output: 12 (3 -> 6 -> 12)

result2 = apply_twice(lambda x: x + 10, 5)
print(f"Applying 'add 10' twice to 5: {result2}")  # Output: 25 (5 -> 15 -> 25)

# Higher-order function that returns different functions based on a condition
def get_operation(operation_name):
    """Return a function corresponding to the named operation."""
    if operation_name == "add":
        return lambda x, y: x + y
    elif operation_name == "subtract":
        return lambda x, y: x - y
    elif operation_name == "multiply":
        return lambda x, y: x * y
    elif operation_name == "divide":
        return lambda x, y: x / y if y != 0 else "Error: Division by zero"
    else:
        return lambda x, y: "Unknown operation"

# Get the desired operation function
add_func = get_operation("add")
multiply_func = get_operation("multiply")
unknown_func = get_operation("power")

# Use the functions
print(f"5 + 3 = {add_func(5, 3)}")             # Output: 5 + 3 = 8
print(f"5 * 3 = {multiply_func(5, 3)}")        # Output: 5 * 3 = 15
print(f"5 ^ 3 = {unknown_func(5, 3)}")         # Output: 5 ^ 3 = Unknown operation

# Composing functions
def compose(f, g):
    """Return a function that applies f after g."""
    return lambda x: f(g(x))

# Simple functions to compose
square = lambda x: x ** 2
add_one = lambda x: x + 1

# Compose them in different orders
square_then_add_one = compose(add_one, square)
add_one_then_square = compose(square, add_one)

print(f"square_then_add_one(5): {square_then_add_one(5)}")  # 5Â² + 1 = 26
print(f"add_one_then_square(5): {add_one_then_square(5)}")  # (5 + 1)Â² = 36
</code></pre>
            <p>
                In functional programming, functions are first-class citizens that can be passed around, returned, and manipulated like any other value. Lambda functions excel in this paradigm due to their concise syntax and ease of creation.
            </p>

            <h3>Function Composition and Currying</h3>
            <pre><code>
# File: lambda_composition.py
# Location: /python_projects/functions_tutorial/

# Function composition with multiple functions
def compose(*functions):
    """
    Compose any number of functions, applying them from right to left.
    compose(f, g, h)(x) is equivalent to f(g(h(x)))
    """
    def inner(x):
        result = x
        for func in reversed(functions):
            result = func(result)
        return result
    return inner

# Functions to compose
add_one = lambda x: x + 1
double = lambda x: x * 2
square = lambda x: x ** 2

# Create composed functions
pipeline1 = compose(square, double, add_one)  # square(double(add_one(x)))
pipeline2 = compose(add_one, double, square)  # add_one(double(square(x)))

# Test the compositions
print(f"pipeline1(3): {pipeline1(3)}")  # square(double(add_one(3))) = square(double(4)) = square(8) = 64
print(f"pipeline2(3): {pipeline2(3)}")  # add_one(double(square(3))) = add_one(double(9)) = add_one(18) = 19

# Simple currying implementation
def curry(func, arity):
    """
    Transform a function to take one argument at a time.
    """
    def curried(*args):
        if len(args) >= arity:
            return func(*args)
        return lambda *more_args: curried(*(args + more_args))
    return curried

# Regular function with multiple parameters
def add_multiply_divide(a, b, c):
    return (a + b) * c

# Curry the function to take one argument at a time
curried_func = curry(add_multiply_divide, 3)

# Use the curried function
result1 = curried_func(5)(10)(2)  # (5 + 10) * 2 = 30
result2 = curried_func(2)(3)(4)   # (2 + 3) * 4 = 20

print(f"result1: {result1}")
print(f"result2: {result2}")

# Another way to implement currying using lambda
curry_add = lambda x: lambda y: lambda z: x + y + z

# Use the curried add function
add_5_10_15 = curry_add(5)(10)(15)
print(f"5 + 10 + 15 = {add_5_10_15}")  # 30
</code></pre>
            <p>
                Function composition and currying are advanced functional programming techniques that work well with lambda functions. Composition allows you to build complex operations from simple ones, while currying transforms functions to take one argument at a time, creating specialized versions along the way.
            </p>

            <h3>Implementing Functional Programming Utilities</h3>
            <pre><code>
# File: lambda_functional_utils.py
# Location: /python_projects/functions_tutorial/

# Implementing our own versions of map, filter, and reduce

def our_map(func, iterable):
    """Implement map functionality."""
    return [func(item) for item in iterable]

def our_filter(func, iterable):
    """Implement filter functionality."""
    return [item for item in iterable if func(item)]

def our_reduce(func, iterable, initial=None):
    """Implement reduce functionality."""
    it = iter(iterable)
    
    if initial is None:
        try:
            initial = next(it)
        except StopIteration:
            raise TypeError("reduce() of empty sequence with no initial value")
    
    result = initial
    for item in it:
        result = func(result, item)
    
    return result

# Test data
numbers = [1, 2, 3, 4, 5]

# Test our implementations with lambda functions
squared = our_map(lambda x: x**2, numbers)
evens = our_filter(lambda x: x % 2 == 0, numbers)
total = our_reduce(lambda x, y: x + y, numbers)

print(f"Squared: {squared}")  # [1, 4, 9, 16, 25]
print(f"Evens: {evens}")      # [2, 4]
print(f"Total: {total}")      # 15

# More complex example: implementing a partial function
def partial(func, *fixed_args, **fixed_kwargs):
    """
    Return a new function with some arguments fixed.
    Similar to functools.partial
    """
    def new_func(*args, **kwargs):
        new_kwargs = {**fixed_kwargs, **kwargs}
        return func(*fixed_args, *args, **new_kwargs)
    return new_func

# Use partial with a regular function
def format_string(prefix, text, suffix):
    return f"{prefix}{text}{suffix}"

# Create specialized functions
add_brackets = partial(format_string, "[", suffix="]")
add_quotes = partial(format_string, '"', suffix='"')

print(f"With brackets: {add_brackets('Hello')}")  # With brackets: [Hello]
print(f"With quotes: {add_quotes('Hello')}")      # With quotes: "Hello"

# Use partial with a lambda
power_function = lambda base, exponent: base ** exponent
square = partial(power_function, exponent=2)
cube = partial(power_function, exponent=3)

print(f"Square of 4: {square(4)}")  # Square of 4: 16
print(f"Cube of 4: {cube(4)}")      # Cube of 4: 64
</code></pre>
            <p>
                Lambda functions integrate seamlessly with functional programming utilities like map, filter, and reduce, whether you're using the built-in functions or implementing your own versions. They also work well with utilities like partial application, which creates new functions by fixing some arguments of existing functions.
            </p>
        </section>

        <section class="lambda_gui">
            <h2>Lambda Functions in GUI Programming</h2>
            <p>
                Lambda functions are particularly useful in GUI (Graphical User Interface) programming, where you need to associate small callback functions with events like button clicks or menu selections.
            </p>
            <pre><code>
# File: lambda_tkinter.py
# Location: /python_projects/functions_tutorial/

# Example with Tkinter (Python's built-in GUI library)
import tkinter as tk
from tkinter import messagebox

def create_gui_example():
    root = tk.Tk()
    root.title("Lambda Function Demo")
    root.geometry("300x200")
    
    counter = {"value": 0}  # Use a dictionary to store a mutable value
    
    # Label to display the counter
    label = tk.Label(root, text=f"Counter: {counter['value']}")
    label.pack(pady=10)
    
    # Buttons with lambda functions as callbacks
    button1 = tk.Button(
        root, 
        text="Increment", 
        command=lambda: update_counter(1)
    )
    button1.pack(pady=5)
    
    button2 = tk.Button(
        root, 
        text="Decrement", 
        command=lambda: update_counter(-1)
    )
    button2.pack(pady=5)
    
    button3 = tk.Button(
        root, 
        text="Reset", 
        command=lambda: update_counter(value=-counter['value'])
    )
    button3.pack(pady=5)
    
    button4 = tk.Button(
        root, 
        text="Show Message", 
        command=lambda: messagebox.showinfo("Info", f"Current count: {counter['value']}")
    )
    button4.pack(pady=5)
    
    # Define the function to update the counter
    def update_counter(value):
        counter['value'] += value
        label.config(text=f"Counter: {counter['value']}")
    
    # Start the main loop
    # root.mainloop()  # Commented out so the example doesn't launch a window
    
    print("In a real application, this would create a window with buttons.")
    print("Each button would use a lambda to handle its click event.")
    
    return root  # Return the root window for reference

# Create the GUI (but don't run the main loop)
gui_example = create_gui_example()
</code></pre>
            <p>
                In GUI programming, lambda functions are often used to:
            </p>
            <ul>
                <li>Create small event handlers directly in the widget definition</li>
                <li>Customize callbacks by passing parameters to event handlers</li>
                <li>Update labels, text fields, or other elements based on user interaction</li>
                <li>Create simple state changes without defining separate functions</li>
            </ul>
            <p>
                Without lambda functions, you would need to define a separate function for each button's click event, making the code more verbose and potentially harder to understand.
            </p>
        </section>

        <section class="web_development">
            <h2>Lambda Functions in Web Development</h2>
            <p>
                In web development with frameworks like Flask or Django, lambda functions can be useful for various tasks:
            </p>
            <pre><code>
# File: lambda_web_dev.py
# Location: /python_projects/functions_tutorial/

# Example with Flask (a popular Python web framework)
from flask import Flask, request, jsonify

# Initialize Flask app
app = Flask(__name__)

# Sample data
products = [
    {"id": 1, "name": "Laptop", "price": 999.99, "category": "Electronics"},
    {"id": 2, "name": "Smartphone", "price": 699.99, "category": "Electronics"},
    {"id": 3, "name": "Headphones", "price": 149.99, "category": "Audio"},
    {"id": 4, "name": "Monitor", "price": 299.99, "category": "Electronics"},
    {"id": 5, "name": "Speaker", "price": 199.99, "category": "Audio"}
]

# Route with lambda for filtering products
@app.route('/products/filter')
def filter_products():
    # Get query parameters
    category = request.args.get('category')
    max_price = request.args.get('max_price')
    
    # Start with all products
    filtered_products = products
    
    # Apply filters using lambda functions
    if category:
        filtered_products = list(filter(
            lambda product: product['category'] == category,
            filtered_products
        ))
    
    if max_price:
        try:
            max_price_float = float(max_price)
            filtered_products = list(filter(
                lambda product: product['price'] <= max_price_float,
                filtered_products
            ))
        except ValueError:
            return jsonify({"error": "Invalid max price"}), 400
    
    return jsonify(filtered_products)

# Route with lambda for sorting products
@app.route('/products/sort')
def sort_products():
    # Get query parameter
    sort_by = request.args.get('sort_by', 'id')
    
    # Define sorting keys using a dictionary with lambda functions
    sort_options = {
        'id': lambda p: p['id'],
        'name': lambda p: p['name'],
        'price': lambda p: p['price'],
        'category': lambda p: p['category']
    }
    
    # Check if sort_by is valid
    if sort_by not in sort_options:
        return jsonify({"error": f"Invalid sort option. Available options: {list(sort_options.keys())}"}), 400
    
    # Sort products using the selected lambda
    sorted_products = sorted(products, key=sort_options[sort_by])
    
    return jsonify(sorted_products)

# Run the Flask app (commented out for this example)
if __name__ == '__main__':
    # app.run(debug=True)
    print("In a real application, this would start a Flask web server.")
    print("The endpoints would use lambdas for filtering and sorting products.")
</code></pre>
            <p>
                In web development, lambda functions can be particularly useful for:
            </p>
            <ul>
                <li>Processing request parameters with custom logic</li>
                <li>Filtering database queries or in-memory data</li>
                <li>Transforming API responses before sending them to clients</li>
                <li>Creating dynamic sorting and filtering options</li>
                <li>Simplifying form validation and data processing</li>
            </ul>
        </section>

        <section class="lambda_best_practices">
            <h2>Lambda Function Best Practices</h2>
            <p>
                While lambda functions are powerful, they should be used judiciously. Here are some best practices to follow:
            </p>

            <h3>When to Use Lambda Functions</h3>
            <pre><code>
# File: lambda_best_practices.py
# Location: /python_projects/functions_tutorial/

# GOOD: Simple, one-line operations (sorting, filtering, mapping)
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))

# GOOD: Simple key functions for sorting
words = ["apple", "banana", "cherry"]
sorted_by_length = sorted(words, key=lambda word: len(word))

# GOOD: Quick callbacks for GUI events
# button = Button(text="Click me", command=lambda: print("Button clicked!"))

# GOOD: Simple transformations in list comprehensions or generators
transformed = [(lambda x: x * 2)(n) for n in numbers]

# BAD: Complex operations that would be more readable as regular functions
# Complex logic is hard to read in lambda form
complex_lambda = lambda x: (
    "High" if x > 100 
    else "Medium" if x > 50 
    else "Low" if x > 10 
    else "Very Low"
)

# Better as a regular function
def classify_value(x):
    if x > 100:
        return "High"
    elif x > 50:
        return "Medium"
    elif x > 10:
        return "Low"
    else:
        return "Very Low"

# BAD: Reusable logic that needs documentation
# This lambda lacks documentation and is not easy to reuse
calculate = lambda x, y, operation: (
    x + y if operation == "add" 
    else x - y if operation == "subtract" 
    else x * y if operation == "multiply" 
    else x / y if operation == "divide" and y != 0 
    else "Error"
)

# Better as a regular function
def calculate_operation(x, y, operation):
    """
    Perform a mathematical operation on two numbers.
    
    Args:
        x, y: Numbers to operate on
        operation: String indicating the operation ("add", "subtract", "multiply", "divide")
        
    Returns:
        The result of the operation, or "Error" for invalid operations or division by zero
    """
    if operation == "add":
        return x + y
    elif operation == "subtract":
        return x - y
    elif operation == "multiply":
        return x * y
    elif operation == "divide":
        return x / y if y != 0 else "Error"
    else:
        return "Error"
</code></pre>
            <p>
                Here's when to use lambda functions:
            </p>
            <ul>
                <li><strong>Use lambda functions</strong> for simple, one-line operations where the intent is clear</li>
                <li><strong>Use lambda functions</strong> for operations that won't be reused elsewhere</li>
                <li><strong>Use lambda functions</strong> as arguments to higher-order functions like <code>map()</code>, <code>filter()</code>, and <code>sorted()</code></li>
                <li><strong>Use regular functions</strong> for operations with multiple statements or complex logic</li>
                <li><strong>Use regular functions</strong> for code that needs documentation or requires explicit type hints</li>
                <li><strong>Use regular functions</strong> for functionality that will be used multiple times in different contexts</li>
            </ul>

            <h3>Readability Considerations</h3>
            <pre><code>
# File: lambda_readability.py
# Location: /python_projects/functions_tutorial/

# GOOD: Clear, simple lambda
is_even = lambda x: x % 2 == 0

# BAD: Trying to do too much in a lambda
complex_filter = lambda items, min_val, include_zeros, max_count: [
    x for i, x in enumerate(items) 
    if (x >= min_val or (include_zeros and x == 0)) and i < max_count
]

# BETTER: Use a regular function with clear parameter names and documentation
def filter_items(items, min_value, include_zeros=False, max_count=None):
    """
    Filter a list of items based on multiple criteria.
    
    Args:
        items: The list to filter
        min_value: Minimum value to include
        include_zeros: Whether to include zero values even if below min_value
        max_count: Maximum number of items to include (None for no limit)
    
    Returns:
        Filtered list of items
    """
    result = []
    count = 0
    
    for item in items:
        # Check if the item meets our criteria
        if item >= min_value or (include_zeros and item == 0):
            result.append(item)
            count += 1
            
            # Check if we've reached the maximum count
            if max_count is not None and count >= max_count:
                break
    
    return result

# Test data
numbers = [-2, -1, 0, 1, 2, 3, 4, 5, 6]

# Using both functions
evens = list(filter(is_even, numbers))
filtered = filter_items(numbers, min_value=1, include_zeros=True, max_count=3)

print(f"Even numbers: {evens}")
print(f"Filtered numbers: {filtered}")
</code></pre>
            <p>
                For better readability:
            </p>
            <ul>
                <li>Keep lambda functions short and focused on a single operation</li>
                <li>Avoid complex conditional logic in lambda functions</li>
                <li>Use descriptive variable names, even in short lambda functions</li>
                <li>Consider breaking complex operations into steps with intermediate variables</li>
                <li>When a lambda becomes hard to read on one line, it's a sign to use a regular function</li>
            </ul>

            <h3>Performance Considerations</h3>
            <pre><code>
# File: lambda_performance.py
# Location: /python_projects/functions_tutorial/

import time
import timeit

# Performance comparison between lambda and regular function

# Lambda function
square_lambda = lambda x: x**2

# Regular function
def square_function(x):
    return x**2

# Simple performance test
def test_performance():
    print("Testing performance of lambda vs. regular function...")
    
    # Test parameters
    number = 1000000
    
    # Time lambda function
    lambda_time = timeit.timeit(
        'square_lambda(10)', 
        number=number,
        globals={'square_lambda': square_lambda}
    )
    
    # Time regular function
    function_time = timeit.timeit(
        'square_function(10)', 
        number=number,
        globals={'square_function': square_function}
    )
    
    print(f"Lambda function took: {lambda_time:.6f} seconds")
    print(f"Regular function took: {function_time:.6f} seconds")
    print(f"Ratio: {lambda_time/function_time:.2f}x")
    
    # Note: The difference is usually very small and not significant
    # for most applications. Use whichever is more readable.

# More realistic test with map
def map_test():
    print("\nTesting performance with map()...")
    
    # Generate test data
    data = list(range(10000))
    
    # Test with lambda
    start = time.time()
    result1 = list(map(lambda x: x**2, data))
    lambda_time = time.time() - start
    
    # Test with regular function
    start = time.time()
    result2 = list(map(square_function, data))
    function_time = time.time() - start
    
    print(f"Map with lambda took: {lambda_time:.6f} seconds")
    print(f"Map with function took: {function_time:.6f} seconds")
    print(f"Ratio: {lambda_time/function_time:.2f}x")
    
    # Verify results are the same
    print(f"Results equal: {result1 == result2}")

# Run the tests
test_performance()
map_test()
</code></pre>
            <p>
                From a performance perspective:
            </p>
            <ul>
                <li>Lambda functions and regular functions have very similar performance characteristics</li>
                <li>The difference in execution speed is usually negligible for most applications</li>
                <li>Regular functions may have a slight advantage in some cases due to optimizations</li>
                <li>Choose between lambda and regular functions based on readability and maintainability, not performance</li>
                <li>For very performance-critical code, benchmark both approaches in your specific context</li>
            </ul>
        </section>

        <section class="lambda_limitations">
            <h2>Limitations of Lambda Functions</h2>
            <p>
                While lambda functions are powerful, they have some limitations you should be aware of:
            </p>
            <pre><code>
# File: lambda_limitations.py
# Location: /python_projects/functions_tutorial/

# Limitation 1: Lambda functions can only contain a single expression
# This works:
add = lambda x, y: x + y

# This doesn't work (would cause a SyntaxError):
# multi_step = lambda x: 
#     temp = x * 2  # Not allowed: statement, not expression
#     return temp + 1

# Solution: Use a regular function
def multi_step(x):
    temp = x * 2
    return temp + 1

# Limitation 2: Lambda functions can't use statements like if, for, while, etc.
# This works (conditional expression, not statement):
check_positive = lambda x: "Positive" if x > 0 else "Non-positive"

# This doesn't work (would cause a SyntaxError):
# check_complex = lambda x:
#     if x > 0:  # Not allowed: statement, not expression
#         return "Positive"
#     else:
#         return "Non-positive"

# Solution: Use a regular function
def check_complex(x):
    if x > 0:
        return "Positive"
    else:
        return "Non-positive"

# Limitation 3: Lambda functions can't have docstrings
# This doesn't work (would cause a SyntaxError):
# documented_lambda = lambda x: 
#     """This computes the square of x."""  # Not allowed in lambda
#     return x ** 2

# Solution: Use a regular function
def documented_function(x):
    """This computes the square of x."""
    return x ** 2

# Limitation 4: Lambda functions can be harder to debug
# In tracebacks, lambda functions show up without a name
def create_lambda_and_call():
    # This will cause an error
    func = lambda x: x / 0
    return func(10)

try:
    result = create_lambda_and_call()
except ZeroDivisionError as e:
    import traceback
    print("Lambda error traceback:")
    traceback.print_exc()
    print("\nThis traceback shows 'lambda' instead of a function name")

# Limitation 5: Lambda functions can harm readability with complex logic
# This lambda is hard to understand at a glance:
complex_lambda = lambda x, y, z: x if x > y and x > z else y if y > z else z

# A regular function is much clearer:
def find_maximum(x, y, z):
    """Return the largest of three values."""
    if x > y and x > z:
        return x
    elif y > z:
        return y
    else:
        return z

# Test both functions
test_values = (5, 10, 3)
print(f"Lambda result: {complex_lambda(*test_values)}")
print(f"Function result: {find_maximum(*test_values)}")
</code></pre>
            <p>
                The main limitations of lambda functions are:
            </p>
            <ul>
                <li><strong>Syntax restrictions:</strong> Lambda functions can only contain a single expression, not statements</li>
                <li><strong>No multi-line logic:</strong> Can't include multiple steps unless they're part of a single expression</li>
                <li><strong>No docstrings:</strong> Can't include documentation directly in the function</li>
                <li><strong>Debugging challenges:</strong> Error traces show "lambda" instead of a meaningful function name</li>
                <li><strong>Readability concerns:</strong> Complex lambda functions can be harder to understand than regular functions</li>
            </ul>
            <p>
                Despite these limitations, lambda functions remain a valuable tool when used appropriately for simple, concise operations.
            </p>
        </section>

        <section class="real_world_examples">
            <h2>Real-World Examples</h2>
            <p>
                Let's look at some practical, real-world examples of lambda functions in action:
            </p>

            <h3>Data Processing Example</h3>
            <pre><code>
# File: data_processing.py
# Location: /python_projects/functions_tutorial/

import csv
import json
from datetime import datetime

def process_sales_data(filename):
    """Process sales data from a CSV file."""
    print(f"Processing sales data from {filename}...")
    
    # In a real application, this would read from an actual file
    # For this example, we'll create some sample data
    sales_data = [
        {"date": "2023-01-15", "product": "Laptop", "units": 5, "price": 999.99},
        {"date": "2023-01-16", "product": "Mouse", "units": 10, "price": 24.99},
        {"date": "2023-01-16", "product": "Keyboard", "units": 7, "price": 49.99},
        {"date": "2023-01-17", "product": "Monitor", "units": 3, "price": 249.99},
        {"date": "2023-01-18", "product": "Laptop", "units": 2, "price": 999.99},
        {"date": "2023-01-19", "product": "Headphones", "units": 8, "price": 79.99}
    ]
    
    # Parse dates using a lambda
    sales_data = list(map(
        lambda item: {**item, "date": datetime.strptime(item["date"], "%Y-%m-%d")},
        sales_data
    ))
    
    # Calculate total for each sale
    sales_data = list(map(
        lambda item: {**item, "total": item["units"] * item["price"]},
        sales_data
    ))
    
    # Filter for high-value sales (over $500)
    high_value_sales = list(filter(
        lambda item: item["total"] > 500,
        sales_data
    ))
    
    # Sort by date
    sales_by_date = sorted(sales_data, key=lambda item: item["date"])
    
    # Group by product (using a dictionary)
    sales_by_product = {}
    for item in sales_data:
        product = item["product"]
        if product not in sales_by_product:
            sales_by_product[product] = []
        sales_by_product[product].append(item)
    
    # Calculate totals for each product
    product_totals = {
        product: sum(map(lambda item: item["total"], items))
        for product, items in sales_by_product.items()
    }
    
    # Find best-selling product
    best_selling_product = max(
        product_totals.items(),
        key=lambda item: item[1]
    )
    
    # Print some results
    print(f"Total sales: ${sum(item['total'] for item in sales_data):.2f}")
    print(f"Number of high-value sales: {len(high_value_sales)}")
    print(f"Best-selling product: {best_selling_product[0]} (${best_selling_product[1]:.2f})")
    
    # Return processed data
    return {
        "sales_data": sales_data,
        "high_value_sales": high_value_sales,
        "sales_by_date": sales_by_date,
        "sales_by_product": sales_by_product,
        "product_totals": product_totals
    }

# Call the function
processed_data = process_sales_data("sales_data.csv")
</code></pre>
            <p>
                In this data processing example, lambda functions are used for:
            </p>
            <ul>
                <li>Transforming data (parsing dates, calculating totals)</li>
                <li>Filtering records based on criteria</li>
                <li>Providing sorting keys</li>
                <li>Creating intermediate calculations</li>
                <li>Finding maxima/minima with custom comparison logic</li>
            </ul>

            <h3>Web Development Example</h3>
            <pre><code>
# File: web_development.py
# Location: /python_projects/functions_tutorial/

def simulate_web_app():
    """Simulate a web application with user data processing."""
    print("Simulating a web application with user data processing...")
    
    # Sample user data (would come from a database in a real app)
    users = [
        {"id": 1, "username": "alice", "email": "alice@example.com", "active": True, "role": "admin", "last_login": "2023-01-20T14:30:45Z"},
        {"id": 2, "username": "bob", "email": "bob@example.com", "active": True, "role": "user", "last_login": "2023-01-19T09:15:22Z"},
        {"id": 3, "username": "charlie", "email": "charlie@example.com", "active": False, "role": "user", "last_login": "2022-12-15T11:42:10Z"},
        {"id": 4, "username": "diana", "email": "diana@example.com", "active": True, "role": "editor", "last_login": "2023-01-21T08:05:38Z"},
        {"id": 5, "username": "eve", "email": "eve@example.com", "active": True, "role": "user", "last_login": "2023-01-18T16:20:55Z"}
    ]
    
    # Convert login times to datetime objects
    from datetime import datetime
    for user in users:
        user["last_login"] = datetime.strptime(user["last_login"], "%Y-%m-%dT%H:%M:%SZ")
    
    # Different views based on user filters
    
    # Active users only
    active_users = list(filter(lambda user: user["active"], users))
    
    # Recently logged in (within the last week)
    import datetime as dt
    one_week_ago = datetime.now() - dt.timedelta(days=7)
    recent_users = list(filter(
        lambda user: user["active"] and user["last_login"] > one_week_ago,
        users
    ))
    
    # Get users by role
    get_users_by_role = lambda role: list(filter(
        lambda user: user["role"] == role,
        users
    ))
    
    admins = get_users_by_role("admin")
    editors = get_users_by_role("editor")
    
    # Format user information for display
    format_user = lambda user: {
        "display_name": user["username"].capitalize(),
        "contact": user["email"],
        "status": "Active" if user["active"] else "Inactive",
        "last_seen": user["last_login"].strftime("%Y-%m-%d %H:%M")
    }
    
    # Format all users
    formatted_users = list(map(format_user, users))
    
    # Create permissions checker
    def create_permission_checker(required_role):
        roles_hierarchy = {"admin": 3, "editor": 2, "user": 1}
        required_level = roles_hierarchy.get(required_role, 0)
        
        return lambda user: roles_hierarchy.get(user["role"], 0) >= required_level
    
    # Create specific permission checkers
    can_edit = create_permission_checker("editor")
    can_admin = create_permission_checker("admin")
    
    # Check permissions for a specific user
    user_bob = next(filter(lambda u: u["username"] == "bob", users))
    print(f"Bob can edit: {can_edit(user_bob)}")
    print(f"Bob can admin: {can_admin(user_bob)}")
    
    # Return the processed data
    return {
        "all_users": users,
        "active_users": active_users,
        "recent_users": recent_users,
        "admins": admins,
        "editors": editors,
        "formatted_users": formatted_users
    }

# Call the function
webapp_data = simulate_web_app()
</code></pre>
            <p>
                In this web development example, lambda functions are used for:
            </p>
            <ul>
                <li>Filtering users based on various criteria</li>
                <li>Creating reusable filters (get_users_by_role)</li>
                <li>Formatting data for presentation</li>
                <li>Creating customized permission checkers</li>
                <li>Finding specific users by username</li>
            </ul>

            <h3>Data Analysis Example</h3>
            <pre><code>
# File: data_analysis.py
# Location: /python_projects/functions_tutorial/

import statistics

def analyze_student_data():
    """Analyze student performance data."""
    print("Analyzing student performance data...")
    
    # Sample student data (in a real app, this would come from a database)
    students = [
        {"id": 1, "name": "Alice", "grades": [85, 90, 88, 92], "attendance": 95, "group": "A"},
        {"id": 2, "name": "Bob", "grades": [78, 82, 80, 75], "attendance": 85, "group": "B"},
        {"id": 3, "name": "Charlie", "grades": [92, 95, 89, 94], "attendance": 90, "group": "A"},
        {"id": 4, "name": "Diana", "grades": [65, 70, 68, 72], "attendance": 70, "group": "C"},
        {"id": 5, "name": "Eve", "grades": [85, 88, 84, 90], "attendance": 92, "group": "B"},
        {"id": 6, "name": "Frank", "grades": [72, 75, 70, 78], "attendance": 80, "group": "C"},
        {"id": 7, "name": "Grace", "grades": [95, 98, 92, 97], "attendance": 98, "group": "A"},
        {"id": 8, "name": "Henry", "grades": [60, 65, 68, 63], "attendance": 75, "group": "C"}
    ]
    
    # Calculate average grade for each student
    for student in students:
        student["avg_grade"] = statistics.mean(student["grades"])
    
    # Find students with high performance (average grade >= 90 and attendance >= 90)
    high_performers = list(filter(
        lambda s: s["avg_grade"] >= 90 and s["attendance"] >= 90,
        students
    ))
    
    # Group students by their assigned group
    groups = {}
    for student in students:
        group = student["group"]
        if group not in groups:
            groups[group] = []
        groups[group].append(student)
    
    # Calculate average performance by group
    group_stats = {
        group: {
            "avg_grade": statistics.mean([s["avg_grade"] for s in students]),
            "avg_attendance": statistics.mean([s["attendance"] for s in students]),
            "count": len(students)
        }
        for group, students in groups.items()
    }
    
    # Sort students by average grade (descending)
    top_students = sorted(
        students,
        key=lambda s: s["avg_grade"],
        reverse=True
    )
    
    # Create a grade formatter function
    def grade_formatter(precision=1):
        return lambda grade: f"{grade:.{precision}f}"
    
    # Create formatters with different precision
    format_grade_1dp = grade_formatter(1)
    format_grade_2dp = grade_formatter(2)
    
    # Generate report
    print("Top 3 students:")
    for i, student in enumerate(top_students[:3]):
        print(f"{i+1}. {student['name']}: {format_grade_2dp(student['avg_grade'])}% average")
    
    print("\nGroup statistics:")
    for group, stats in group_stats.items():
        print(f"Group {group}: {format_grade_1dp(stats['avg_grade'])}% avg grade, {stats['count']} students")
        # File: data_analysis.py
        # Location: /python_projects/functions_tutorial/
        
        import statistics
        
        def analyze_student_data():
            """Analyze student performance data."""
            print("Analyzing student performance data...")
            
            # Sample student data (in a real app, this would come from a database)
            students = [
                {"id": 1, "name": "Alice", "grades": [85, 90, 88, 92], "attendance": 95, "group": "A"},
                {"id": 2, "name": "Bob", "grades": [78, 82, 80, 75], "attendance": 85, "group": "B"},
                {"id": 3, "name": "Charlie", "grades": [92, 95, 89, 94], "attendance": 90, "group": "A"},
                {"id": 4, "name": "Diana", "grades": [65, 70, 68, 72], "attendance": 70, "group": "C"},
                {"id": 5, "name": "Eve", "grades": [85, 88, 84, 90], "attendance": 92, "group": "B"},
                {"id": 6, "name": "Frank", "grades": [72, 75, 70, 78], "attendance": 80, "group": "C"},
                {"id": 7, "name": "Grace", "grades": [95, 98, 92, 97], "attendance": 98, "group": "A"},
                {"id": 8, "name": "Henry", "grades": [60, 65, 68, 63], "attendance": 75, "group": "C"}
            ]
            
            # Calculate average grade for each student
            for student in students:
                student["avg_grade"] = statistics.mean(student["grades"])
            
            # Find students with high performance (average grade >= 90 and attendance >= 90)
            high_performers = list(filter(
                lambda s: s["avg_grade"] >= 90 and s["attendance"] >= 90,
                students
            ))
            
            # Group students by their assigned group
            groups = {}
            for student in students:
                group = student["group"]
                if group not in groups:
                    groups[group] = []
                groups[group].append(student)
            
            # Calculate average performance by group
            group_stats = {
                group: {
                    "avg_grade": statistics.mean([s["avg_grade"] for s in students]),
                    "avg_attendance": statistics.mean([s["attendance"] for s in students]),
                    "count": len(students)
                }
                for group, students in groups.items()
            }
            
            # Sort students by average grade (descending)
            top_students = sorted(
                students,
                key=lambda s: s["avg_grade"],
                reverse=True
            )
            
            # Create a grade formatter function
            def grade_formatter(precision=1):
                return lambda grade: f"{grade:.{precision}f}"
            
            # Create formatters with different precision
            format_grade_1dp = grade_formatter(1)
            format_grade_2dp = grade_formatter(2)
            
            # Generate report
            print("Top 3 students:")
            for i, student in enumerate(top_students[:3]):
                print(f"{i+1}. {student['name']}: {format_grade_2dp(student['avg_grade'])}% average")
            
            print("\nGroup statistics:")
            for group, stats in group_stats.items():
                print(f"Group {group}: {format_grade_1dp(stats['avg_grade'])}% avg grade, {stats['count']} students")
            
            print("\nHigh performers:")
            for student in high_performers:
                print(f"{student['name']}: {format_grade_1dp(student['avg_grade'])}% avg grade, {student['attendance']}% attendance")
            
            # Return analysis results
            return {
                "students": students,
                "high_performers": high_performers,
                "group_stats": group_stats,
                "top_students": top_students
            }
        
        # Call the function
        analysis_results = analyze_student_data()
        </code></pre>
                    <p>
                        In this data analysis example, lambda functions are used for:
                    </p>
                    <ul>
                        <li>Filtering students based on performance criteria</li>
                        <li>Providing custom sorting keys for ranking students</li>
                        <li>Creating configurable formatting functions</li>
                        <li>Implementing function factories that generate specialized formatters</li>
                        <li>Processing and transforming data for analysis and reporting</li>
                    </ul>
                </section>
        
                <section class="libraries_with_lambdas">
                    <h2>Lambda Functions with Popular Libraries</h2>
                    <p>
                        Many popular Python libraries make extensive use of lambda functions or work particularly well with them. Let's explore some examples:
                    </p>
        
                    <h3>Pandas: Data Manipulation</h3>
                    <pre><code>
        # File: pandas_lambdas.py
        # Location: /python_projects/functions_tutorial/
        
        import pandas as pd
        import numpy as np
        
        def pandas_lambda_examples():
            """Examples of using lambda functions with pandas."""
            print("Pandas with lambda functions examples...")
            
            # Create a sample DataFrame
            data = {
                'Name': ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve'],
                'Age': [25, 30, 22, 35, 28],
                'Department': ['HR', 'Engineering', 'Marketing', 'HR', 'Engineering'],
                'Salary': [60000, 80000, 55000, 75000, 70000]
            }
            df = pd.DataFrame(data)
            
            print("Original DataFrame:")
            print(df)
            
            # Using apply with a lambda to create a new column
            df['Salary_Category'] = df['Salary'].apply(
                lambda x: 'High' if x >= 75000 else 'Medium' if x >= 60000 else 'Low'
            )
            
            print("\nWith Salary Category:")
            print(df)
            
            # Using lambda with groupby and transform
            df['Department_Avg_Salary'] = df.groupby('Department')['Salary'].transform(
                lambda x: x.mean()
            )
            
            print("\nWith Department Average Salary:")
            print(df)
            
            # Using lambda with filter method
            high_salary_departments = df.groupby('Department').filter(
                lambda x: x['Salary'].mean() > 65000
            )
            
            print("\nHigh Salary Departments:")
            print(high_salary_departments)
            
            # Using lambda with sort_values
            df_sorted = df.sort_values(
                by=['Department', 'Salary'], 
                key=lambda x: x.str.lower() if x.name == 'Department' else x,
                ascending=[True, False]
            )
            
            print("\nSorted DataFrame:")
            print(df_sorted)
            
            # Using lambda with assign
            df_with_bonus = df.assign(
                Bonus=lambda x: x['Salary'] * 0.1,
                Total_Compensation=lambda x: x['Salary'] + (x['Salary'] * 0.1)
            )
            
            print("\nWith Bonus and Total Compensation:")
            print(df_with_bonus)
            
            return df_with_bonus
        
        # Call the function
        pandas_df = pandas_lambda_examples()
        </code></pre>
                    <p>
                        Pandas, a popular library for data manipulation and analysis, works particularly well with lambda functions for:
                    </p>
                    <ul>
                        <li>Creating new columns based on transformations of existing data</li>
                        <li>Applying functions to groups of data</li>
                        <li>Filtering data based on complex conditions</li>
                        <li>Custom sorting of DataFrames</li>
                        <li>Chaining multiple operations together in a readable way</li>
                    </ul>
        
                    <h3>Matplotlib and Seaborn: Data Visualization</h3>
                    <pre><code>
        # File: visualization_lambdas.py
        # Location: /python_projects/functions_tutorial/
        
        import matplotlib.pyplot as plt
        import numpy as np
        import seaborn as sns
        import pandas as pd
        
        def visualization_lambda_examples():
            """Examples of using lambda functions with visualization libraries."""
            print("Visualization with lambda functions examples...")
            
            # Create sample data
            x = np.linspace(0, 10, 100)
            
            # Create different function curves using lambda functions
            functions = {
                'Linear': lambda x: x,
                'Quadratic': lambda x: x**2,
                'Cubic': lambda x: x**3,
                'Sine': lambda x: np.sin(x),
                'Exponential': lambda x: np.exp(x/5)
            }
            
            # Plot multiple functions
            plt.figure(figsize=(10, 6))
            
            for name, func in functions.items():
                plt.plot(x, func(x), label=name)
            
            plt.title('Different Mathematical Functions')
            plt.xlabel('x')
            plt.ylabel('y')
            plt.legend()
            plt.grid(True)
            
            # In a real application, we would show the plot with plt.show()
            # Here we'll just simulate it
            print("Created a plot comparing different mathematical functions using lambdas")
            
            # Create a sample DataFrame for Seaborn examples
            np.random.seed(42)
            df = pd.DataFrame({
                'x': np.random.normal(0, 1, 100),
                'y': np.random.normal(0, 1, 100),
                'category': np.random.choice(['A', 'B', 'C'], 100)
            })
            
            # Use lambda with Seaborn FacetGrid
            g = sns.FacetGrid(df, col='category')
            g.map_dataframe(lambda data, color: plt.scatter(data['x'], data['y'], color=color))
            
            print("Created a FacetGrid with scatter plots using lambdas")
            
            # Use lambda with Seaborn plotting functions
            plt.figure(figsize=(8, 6))
            sns.scatterplot(
                data=df,
                x='x', 
                y='y',
                hue='category',
                size=df['x'].apply(lambda v: abs(v) * 30 + 10)  # Dynamic sizing
            )
            
            print("Created a scatter plot with dynamic sizing using lambdas")
            
            # Return the data for reference
            return df
        
        # Call the function
        viz_data = visualization_lambda_examples()
        </code></pre>
                    <p>
                        In data visualization with libraries like Matplotlib and Seaborn, lambda functions are useful for:
                    </p>
                    <ul>
                        <li>Defining custom mathematical functions for plotting</li>
                        <li>Creating dynamic attributes for plot elements (size, color, etc.)</li>
                        <li>Mapping functions to data in faceted plots</li>
                        <li>Transforming data on-the-fly for visualization</li>
                        <li>Creating custom formatters for plot labels and annotations</li>
                    </ul>
        
                    <h3>Scikit-learn: Machine Learning</h3>
                    <pre><code>
        # File: sklearn_lambdas.py
        # Location: /python_projects/functions_tutorial/
        
        import numpy as np
        from sklearn.preprocessing import FunctionTransformer
        from sklearn.pipeline import Pipeline
        from sklearn.compose import ColumnTransformer
        from sklearn.ensemble import RandomForestClassifier
        from sklearn.model_selection import train_test_split
        from sklearn.metrics import accuracy_score
        
        def sklearn_lambda_examples():
            """Examples of using lambda functions with scikit-learn."""
            print("Scikit-learn with lambda functions examples...")
            
            # Create synthetic data
            np.random.seed(42)
            X = np.random.rand(100, 4) * 10  # 4 features
            y = (X[:, 0] + X[:, 1] > 10).astype(int)  # Binary classification task
            
            # Split data
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
            
            print(f"Data shape: {X.shape}, Target shape: {y.shape}")
            
            # Create custom transformers using lambda functions
            log_transformer = FunctionTransformer(
                lambda X: np.log1p(X),  # log(1+x) to handle zero values
                validate=True
            )
            
            square_transformer = FunctionTransformer(
                lambda X: np.square(X),
                validate=True
            )
            
            # Create a pipeline with different transformers for different columns
            preprocessor = ColumnTransformer(
                transformers=[
                    ('log', log_transformer, [0, 1]),  # Apply log to first two columns
                    ('square', square_transformer, [2, 3])  # Apply square to last two columns
                ]
            )
            
            # Create a pipeline with preprocessing and model
            pipeline = Pipeline(steps=[
                ('preprocessor', preprocessor),
                ('classifier', RandomForestClassifier(random_state=42))
            ])
            
            # Train the model
            pipeline.fit(X_train, y_train)
            
            # Evaluate
            y_pred = pipeline.predict(X_test)
            accuracy = accuracy_score(y_test, y_pred)
            
            print(f"Model accuracy: {accuracy:.2f}")
            
            # Feature importances
            if hasattr(pipeline.named_steps['classifier'], 'feature_importances_'):
                importances = pipeline.named_steps['classifier'].feature_importances_
                feature_names = [f"Log(X0)", f"Log(X1)", f"X2Â²", f"X3Â²"]
                
                # Sort feature importances using a lambda
                sorted_indices = sorted(range(len(importances)), key=lambda i: importances[i], reverse=True)
                
                print("\nFeature importances:")
                for i in sorted_indices:
                    print(f"  {feature_names[i]}: {importances[i]:.4f}")
            
            # Return pipeline for reference
            return pipeline
        
        # Call the function
        sklearn_pipeline = sklearn_lambda_examples()
        </code></pre>
                    <p>
                        In machine learning with scikit-learn, lambda functions are useful for:
                    </p>
                    <ul>
                        <li>Creating custom feature transformations</li>
                        <li>Implementing simple data preprocessing steps</li>
                        <li>Sorting and ranking features by importance</li>
                        <li>Creating custom scoring metrics</li>
                        <li>Defining simple target transformations</li>
                    </ul>
                </section>
        
                <section class="advanced_applications">
                    <h2>Advanced Applications of Lambda Functions</h2>
                    <p>
                        Beyond the common use cases, lambda functions can be applied in more advanced scenarios. Here are some examples:
                    </p>
        
                    <h3>Implementing Simple Decorators</h3>
                    <pre><code>
        # File: lambda_decorators.py
        # Location: /python_projects/functions_tutorial/
        
        import time
        import functools
        
        def simple_decorator_with_lambda():
            """Example of implementing a simple decorator with lambda."""
            print("Simple decorator with lambda example...")
            
            # A simple timing decorator
            def timing_decorator(func):
                @functools.wraps(func)
                def wrapper(*args, **kwargs):
                    start_time = time.time()
                    result = func(*args, **kwargs)
                    end_time = time.time()
                    print(f"{func.__name__} took {end_time - start_time:.6f} seconds to run")
                    return result
                return wrapper
            
            # A simpler timing decorator using lambda
            timing_decorator_lambda = lambda func: (
                lambda *args, **kwargs: (
                    (lambda start, result, end: (
                        print(f"{func.__name__} took {end - start:.6f} seconds to run"),
                        result
                    )[1])(
                        time.time(),
                        func(*args, **kwargs),
                        time.time()
                    )
                )
            )
            
            # Test functions to decorate
            @timing_decorator
            def slow_function(n):
                """A deliberately slow function."""
                time.sleep(0.1)
                return sum(range(n))
            
            @timing_decorator_lambda
            def slow_function_lambda(n):
                """Another deliberately slow function."""
                time.sleep(0.1)
                return sum(range(n))
            
            # Test both decorators
            print("\nTesting regular decorator:")
            result1 = slow_function(1000000)
            print(f"Result: {result1}")
            
            print("\nTesting lambda decorator:")
            result2 = slow_function_lambda(1000000)
            print(f"Result: {result2}")
            
            # Note: While the lambda decorator works, the regular decorator is more readable
            # Lambda decorators are mainly useful for very simple cases
        
        # Call the function
        simple_decorator_with_lambda()
        </code></pre>
                    <p>
                        While regular function decorators are usually more readable, lambda functions can be used to create simple decorators in some cases. This is more of an academic exercise than a practical recommendation, but it demonstrates the flexibility of lambda functions.
                    </p>
        
                    <h3>Dynamic Function Generation</h3>
                    <pre><code>
        # File: dynamic_functions.py
        # Location: /python_projects/functions_tutorial/
        
        def dynamic_function_generation():
            """Example of generating functions dynamically."""
            print("Dynamic function generation example...")
            
            # Generate a series of power functions
            powers = {}
            for i in range(1, 5):
                powers[f"power_{i}"] = lambda x, n=i: x ** n
            
            print("Generated power functions:")
            for name, func in powers.items():
                print(f"{name}(5) = {func(5)}")
            
            # Generate trigonometric functions
            import math
            trig_funcs = {
                'sin': lambda x: math.sin(x),
                'cos': lambda x: math.cos(x),
                'tan': lambda x: math.tan(x),
                'sec': lambda x: 1 / math.cos(x) if math.cos(x) != 0 else float('inf'),
                'csc': lambda x: 1 / math.sin(x) if math.sin(x) != 0 else float('inf'),
                'cot': lambda x: 1 / math.tan(x) if math.tan(x) != 0 else float('inf')
            }
            
            # Test the generated functions
            angle = math.pi / 4  # 45 degrees in radians
            
            print("\nTrigonometric functions at Ï€/4 radians:")
            for name, func in trig_funcs.items():
                try:
                    result = func(angle)
                    print(f"{name}(Ï€/4) = {result:.4f}")
                except Exception as e:
                    print(f"{name}(Ï€/4) = Error: {e}")
            
            # Generate polynomial functions based on coefficients
            def generate_polynomial(coefficients):
                """
                Generate a polynomial function based on coefficients.
                
                Args:
                    coefficients: List of coefficients [a_0, a_1, a_2, ...] for
                                  polynomial a_0 + a_1*x + a_2*x^2 + ...
                
                Returns:
                    Function that evaluates the polynomial for a given x
                """
                return lambda x: sum(coef * (x ** i) for i, coef in enumerate(coefficients))
            
            # Create some polynomial functions
            linear = generate_polynomial([2, 3])        # 2 + 3x
            quadratic = generate_polynomial([1, -2, 1])  # 1 - 2x + x^2
            cubic = generate_polynomial([0, 0, 0, 1])    # x^3
            
            print("\nPolynomial functions at x = 2:")
            print(f"Linear (2 + 3x): {linear(2)}")
            print(f"Quadratic (1 - 2x + x^2): {quadratic(2)}")
            print(f"Cubic (x^3): {cubic(2)}")
            
            # Return the generated functions for reference
            return {
                "powers": powers,
                "trig_funcs": trig_funcs,
                "polynomial": {
                    "linear": linear,
                    "quadratic": quadratic,
                    "cubic": cubic
                }
            }
        
        # Call the function
        generated_functions = dynamic_function_generation()
        </code></pre>
                    <p>
                        Lambda functions are excellent for dynamically generating functions based on parameters or patterns. This is particularly useful in mathematical applications, configuration systems, or when creating domain-specific languages.
                    </p>
        
                    <h3>Implementing Simple Domain-Specific Languages (DSLs)</h3>
                    <pre><code>
        # File: lambda_dsl.py
        # Location: /python_projects/functions_tutorial/
        
        def simple_query_dsl():
            """Example of using lambdas to create a simple query DSL."""
            print("Simple query DSL example...")
            
            # Sample data (list of dictionaries)
            people = [
                {"id": 1, "name": "Alice", "age": 25, "department": "Engineering", "salary": 75000},
                {"id": 2, "name": "Bob", "age": 30, "department": "Marketing", "salary": 65000},
                {"id": 3, "name": "Charlie", "age": 35, "department": "Engineering", "salary": 85000},
                {"id": 4, "name": "Diana", "age": 28, "department": "HR", "salary": 60000},
                {"id": 5, "name": "Eve", "age": 32, "department": "Engineering", "salary": 80000},
                {"id": 6, "name": "Frank", "age": 40, "department": "Marketing", "salary": 70000}
            ]
            
            # Query DSL operators
            def equals(field, value):
                return lambda item: item.get(field) == value
            
            def not_equals(field, value):
                return lambda item: item.get(field) != value
            
            def greater_than(field, value):
                return lambda item: item.get(field, 0) > value
            
            def less_than(field, value):
                return lambda item: item.get(field, 0) < value
            
            def contains(field, value):
                return lambda item: value in str(item.get(field, ""))
            
            def and_(*conditions):
                return lambda item: all(condition(item) for condition in conditions)
            
            def or_(*conditions):
                return lambda item: any(condition(item) for condition in conditions)
            
            # Query function
            def query(data, condition):
                return list(filter(condition, data))
            
            # Example queries
            print("\nEngineers with salary > 80000:")
            engineers_high_salary = query(
                people,
                and_(
                    equals("department", "Engineering"),
                    greater_than("salary", 80000)
                )
            )
            for person in engineers_high_salary:
                print(f"  {person['name']}: ${person['salary']}")
            
            print("\nPeople in Marketing or HR departments:")
            marketing_or_hr = query(
                people,
                or_(
                    equals("department", "Marketing"),
                    equals("department", "HR")
                )
            )
            for person in marketing_or_hr:
                print(f"  {person['name']}: {person['department']}")
            
            print("\nPeople with 'a' in their name and age < 30:")
            young_with_a = query(
                people,
                and_(
                    contains("name", "a"),
                    less_than("age", 30)
                )
            )
            for person in young_with_a:
                print(f"  {person['name']}, {person['age']}")
            
            # More complex query
            print("\nComplex query: Engineers or people over 30 with high salary:")
            complex_result = query(
                people,
                or_(
                    equals("department", "Engineering"),
                    and_(
                        greater_than("age", 30),
                        greater_than("salary", 70000)
                    )
                )
            )
            for person in complex_result:
                print(f"  {person['name']}, {person['age']}, {person['department']}, ${person['salary']}")
            
            # Return the query tools for reference
            return {
                "data": people,
                "operators": {
                    "equals": equals,
                    "not_equals": not_equals,
                    "greater_than": greater_than,
                    "less_than": less_than,
                    "contains": contains,
                    "and_": and_,
                    "or_": or_
                },
                "query": query
            }
        
        # Call the function
        query_dsl = simple_query_dsl()
        </code></pre>
                    <p>
                        Lambda functions can be used to implement simple domain-specific languages (DSLs) for tasks like querying data, building expressions, or defining rules. While more complex DSLs might use more sophisticated techniques, lambda functions provide a lightweight way to create expressive, composable interfaces.
                    </p>
        
                    <h3>Event-Driven Programming</h3>
                    <pre><code>
        # File: event_system.py
        # Location: /python_projects/functions_tutorial/
        
        def event_system_example():
            """Example of using lambdas in an event-driven system."""
            print("Event system example...")
            
            # Simple event system
            class EventSystem:
                def __init__(self):
                    self.listeners = {}
                
                def add_listener(self, event_type, listener):
                    """Add a listener for an event type."""
                    if event_type not in self.listeners:
                        self.listeners[event_type] = []
                    self.listeners[event_type].append(listener)
                
                def remove_listener(self, event_type, listener):
                    """Remove a listener for an event type."""
                    if event_type in self.listeners and listener in self.listeners[event_type]:
                        self.listeners[event_type].remove(listener)
                
                def emit(self, event_type, *args, **kwargs):
                    """Emit an event to all listeners of that type."""
                    if event_type in self.listeners:
                        for listener in self.listeners[event_type]:
                            listener(*args, **kwargs)
            
            # Create an event system
            events = EventSystem()
            
            # Add listeners using lambda functions
            events.add_listener("user_login", lambda username: print(f"User logged in: {username}"))
            events.add_listener("user_login", lambda username: print(f"Sending welcome email to {username}"))
            
            events.add_listener("purchase", lambda product, price: print(f"Product purchased: {product} for ${price:.2f}"))
            events.add_listener("purchase", lambda product, price: print(f"Adding ${price:.2f} to sales total"))
            
            # More complex listener with a lambda that captures variables from outer scope
            total_sales = {"value": 0}
            events.add_listener(
                "purchase",
                lambda product, price: (
                    total_sales.update({"value": total_sales["value"] + price}),
                    print(f"Updated total sales to ${total_sales['value']:.2f}")
                )[0]  # Return None instead of the tuple
            )
            
            # Emit some events
            print("\nEmitting events:")
            events.emit("user_login", "alice@example.com")
            events.emit("purchase", "Laptop", 999.99)
            events.emit("purchase", "Mouse", 24.99)
            
            # Create event listeners conditionally
            def create_conditional_listeners(log_level):
                """Create different listeners based on log level."""
                if log_level == "debug":
                    # In debug mode, log everything
                    events.add_listener("user_login", lambda username: print(f"DEBUG: Login event triggered for {username}"))
                    events.add_listener("purchase", lambda product, price: print(f"DEBUG: Purchase event triggered for {product}"))
                elif log_level == "error":
                    # In error mode, only log errors
                    events.add_listener("error", lambda message: print(f"ERROR: {message}"))
            
            # Add conditional listeners
            print("\nAdding debug listeners:")
            create_conditional_listeners("debug")
            
            # Emit more events
            print("\nEmitting more events:")
            events.emit("user_login", "bob@example.com")
            events.emit("error", "Something went wrong!")
            
            return events
        
        # Call the function
        event_system = event_system_example()
        </code></pre>
                    <p>
                        In event-driven programming, lambda functions are excellent for creating small event handlers or callbacks. They allow you to define behavior inline where it's used, making the code more concise and often easier to understand since the behavior is defined close to where the event is registered.
                    </p>
                </section>
        
                <section class="alternatives_to_lambda">
                    <h2>Alternatives to Lambda Functions</h2>
                    <p>
                        While lambda functions are powerful, there are sometimes better alternatives depending on the situation. Let's explore some of these alternatives:
                    </p>
        
                    <h3>List Comprehensions and Generator Expressions</h3>
                    <pre><code>
        # File: comprehensions_vs_lambda.py
        # Location: /python_projects/functions_tutorial/
        
        def comprehensions_vs_lambda():
            """Compare lambda with map/filter to comprehensions/generators."""
            print("Comparing lambda with comprehensions and generators...")
            
            numbers = list(range(1, 11))
            
            # Squaring numbers
            # With lambda and map
            squares_map = list(map(lambda x: x**2, numbers))
            
            # With list comprehension
            squares_comp = [x**2 for x in numbers]
            
            print(f"Squares via map/lambda: {squares_map}")
            print(f"Squares via comprehension: {squares_comp}")
            
            # Filtering even numbers
            # With lambda and filter
            evens_filter = list(filter(lambda x: x % 2 == 0, numbers))
            
            # With list comprehension
            evens_comp = [x for x in numbers if x % 2 == 0]
            
            print(f"Evens via filter/lambda: {evens_filter}")
            print(f"Evens via comprehension: {evens_comp}")
            
            # Combining operations
            # With lambda, map, and filter
            result_lambda = list(map(
                lambda x: x**2, 
                filter(lambda x: x % 2 == 0, numbers)
            ))
            
            # With list comprehension
            result_comp = [x**2 for x in numbers if x % 2 == 0]
            
            print(f"Combined via lambda: {result_lambda}")
            print(f"Combined via comprehension: {result_comp}")
            
            # Generator expressions for memory efficiency
            # With lambda and map
            sum_squares_lambda = sum(map(lambda x: x**2, range(1, 101)))
            
            # With generator expression
            sum_squares_gen = sum(x**2 for x in range(1, 101))
            
            print(f"Sum of squares (1-100) via lambda: {sum_squares_lambda}")
            print(f"Sum of squares (1-100) via generator: {sum_squares_gen}")
            
            # Performance comparison (simplified)
            import time
            
            # Create a larger dataset
            large_data = list(range(10000))
            
            # Measure time for map with lambda
            start = time.time()
            result_lambda = list(map(lambda x: x**2 + x + 1, large_data))
            lambda_time = time.time() - start
            
            # Measure time for list comprehension
            start = time.time()
            result_comp = [x**2 + x + 1 for x in large_data]
            comp_time = time.time() - start
            
            print(f"\nPerformance comparison (10000 elements):")
            print(f"map/lambda time: {lambda_time:.6f} seconds")
            print(f"comprehension time: {comp_time:.6f} seconds")
            print(f"Speedup factor: {lambda_time/comp_time:.2f}x")
            
            return {
                "squares_map": squares_map,
                "squares_comp": squares_comp,
                "result_lambda": result_lambda,
                "result_comp": result_comp
            }
        
        # Call the function
        comp_results = comprehensions_vs_lambda()
        </code></pre>
                    <p>
                        List comprehensions and generator expressions often provide a more readable and sometimes more efficient alternative to using <code>map()</code> and <code>filter()</code> with lambda functions. In Python, these comprehensions are considered more "Pythonic" for many simple transformation and filtering operations.
                    </p>
        
                    <h3>Regular Functions and Operator Module</h3>
                    <pre><code>
        # File: regular_functions_vs_lambda.py
        # Location: /python_projects/functions_tutorial/
        
        import operator
        
        def regular_functions_vs_lambda():
            """Compare lambda functions with regular functions and the operator module."""
            print("Comparing lambda with regular functions and operator module...")
            
            # Basic arithmetic operations
            # With lambda
            add_lambda = lambda x, y: x + y
            subtract_lambda = lambda x, y: x - y
            multiply_lambda = lambda x, y: x * y
            divide_lambda = lambda x, y: x / y
            
            # With regular functions
            def add(x, y):
                return x + y
            
            def subtract(x, y):
                return x - y
            
            def multiply(x, y):
                return x * y
            
            def divide(x, y):
                return x / y
            
            # With operator module
            add_op = operator.add
            subtract_op = operator.sub
            multiply_op = operator.mul
            divide_op = operator.truediv
            
            # Test all approaches
            x, y = 10, 3
            
            print(f"\nArithmetic operations with x={x}, y={y}:")
            print(f"Addition:")
            print(f"  Lambda: {add_lambda(x, y)}")
            print(f"  Function: {add(x, y)}")
            print(f"  Operator: {add_op(x, y)}")
            
            print(f"Subtraction:")
            print(f"  Lambda: {subtract_lambda(x, y)}")
            print(f"  Function: {subtract(x, y)}")
            print(f"  Operator: {subtract_op(x, y)}")
            
            # Other useful operator module functions
            items = [1, 5, 3, 2, 4]
            
            # Sort by a key
            # With lambda
            sorted_lambda = sorted(items, key=lambda x: -x)  # Sort in descending order
            
            # With operator
            sorted_op = sorted(items, key=operator.neg)  # Sort in descending order
            
            print(f"\nSorting in descending order:")
            print(f"  Original: {items}")
            print(f"  Lambda: {sorted_lambda}")
            print(f"  Operator: {sorted_op}")
            
            # Getting a specific item in a sequence of tuples
            data = [('a', 1), ('b', 2), ('c', 3)]
            
            # Get second item with lambda
            second_items_lambda = list(map(lambda x: x[1], data))
            
            # Get second item with operator
            second_items_op = list(map(operator.itemgetter(1), data))
            
            print(f"\nExtracting second items from {data}:")
            print(f"  Lambda: {second_items_lambda}")
            print(f"  Operator: {second_items_op}")
            
            # Working with dictionaries
            people = [
                {"name": "Alice", "age": 25},
                {"name": "Bob", "age": 30},
                {"name": "Charlie", "age": 22}
            ]
            
            # Sort by age with lambda
            sorted_by_age_lambda = sorted(people, key=lambda p: p["age"])
            
            # Sort by age with operator
            sorted_by_age_op = sorted(people, key=operator.itemgetter("age"))
            
            print(f"\nSorting people by age:")
            print(f"  Lambda result: {[p['name'] for p in sorted_by_age_lambda]}")
            print(f"  Operator result: {[p['name'] for p in sorted_by_age_op]}")
            
            return {
                "sorted_lambda": sorted_lambda,
                "sorted_op": sorted_op,
                "sorted_by_age_lambda": sorted_by_age_lambda,
                "sorted_by_age_op": sorted_by_age_op
            }
        
        # Call the function
        comparison_results = regular_functions_vs_lambda()
        </code></pre>
                    <p>
                        For many common operations, the <code>operator</code> module provides pre-defined functions that can replace simple lambda functions. This often results in more readable and slightly more efficient code. Regular named functions are also preferable to lambda functions when the operation is complex or needs to be reused in multiple places.
                    </p>
        
                    <h3>functools.partial for Partial Function Application</h3>
                    <pre><code>
        # File: partial_vs_lambda.py
        # Location: /python_projects/functions_tutorial/
        
        import functools
        
        def partial_vs_lambda():
            """Compare lambda with functools.partial for partial function application."""
            print("Comparing lambda with functools.partial...")
            
            # Define a base function
            def power(base, exponent):
                return base ** exponent
            
            # Create specialized versions with lambda
            square_lambda = lambda x: power(x, 2)
            cube_lambda = lambda x: power(x, 3)
            
            # Create specialized versions with partial
            square_partial = functools.partial(power, exponent=2)
            cube_partial = functools.partial(power, exponent=3)
            
            # Test both approaches
            x = 5
            
            print(f"\nCalculating powers of {x}:")
            print(f"Square with lambda: {square_lambda(x)}")
            print(f"Square with partial: {square_partial(x)}")
            print(f"Cube with lambda: {cube_lambda(x)}")
            print(f"Cube with partial: {cube_partial(x)}")
            
            # More complex example: string formatting
            def format_string(template, **kwargs):
                return template.format(**kwargs)
            
            # Create specialized formatters with lambda
            greet_lambda = lambda name, title="Mr.": format_string(
                "Hello, {title} {name}!", 
                title=title, 
                name=name
            )
            
            # Create specialized formatters with partial
            greet_partial = functools.partial(
                format_string,
                template="Hello, {title} {name}!"
            )
            
            print("\nFormatting strings:")
            print(f"  Lambda: {greet_lambda('Smith')}")
            print(f"  Lambda with custom title: {greet_lambda('Johnson', title='Dr.')}")
            print(f"  Partial: {greet_partial(name='Brown', title='Ms.')}")
            
            # Performance comparison (simplified)
            import time
            
            # Measure time for lambda
            start = time.time()
            for _ in range(1000000):
                square_lambda(5)
            lambda_time = time.time() - start
            
            # Measure time for partial
            start = time.time()
            for _ in range(1000000):
                square_partial(5)
            partial_time = time.time() - start
            
            print(f"\nPerformance comparison (1,000,000 calls):")
            print(f"lambda time: {lambda_time:.6f} seconds")
            print(f"partial time: {partial_time:.6f} seconds")
            print(f"Ratio: {lambda_time/partial_time:.2f}x")
            
            return {
                "square_lambda": square_lambda,
                "square_partial": square_partial,
                "greet_lambda": greet_lambda,
                "greet_partial": greet_partial
            }
        
        # Call the function
        partial_results = partial_vs_lambda()
        </code></pre>
                    <p>
                        For partial function application (fixing some arguments of a function to create a new function), <code>functools.partial</code> often provides a clearer and more readable alternative to lambda functions. It's particularly useful when you need to create variations of a function with different default parameters.
                    </p>
                </section>
        
                <section class="lambda_in_python_versions">
                    <h2>Lambda Functions Across Python Versions</h2>
                    <p>
                        Lambda functions have been a part of Python since its early versions, but there have been some changes and controversies over time:
                    </p>
                    <ul>
                        <li><strong>Python 1.x and 2.x:</strong> Lambda functions were introduced in early versions of Python and have been a core feature since then.</li>
                        <li><strong>The Lambda Controversy:</strong> There has been some debate about lambda functions in Python's history. In 2005, Python's creator Guido van Rossum considered removing lambda from Python 3.0, mainly due to syntactic concerns. However, after community feedback, lambda was kept in the language.</li>
                        <li><strong>Python 3.x:</strong> Lambda functions continue to be a key feature of Python 3.x. While there haven't been major changes to how lambda functions work, Python 3.x has introduced other features like the walrus operator (:=), which can sometimes be used with lambda functions.</li>
                        <li><strong>Assignment Expressions (Python 3.8+):</strong> The walrus operator can be used within lambda functions in Python 3.8 and later, allowing for more complex expressions in some cases.</li>
                    </ul>
                    <pre><code>
        # File: lambda_evolution.py
        # Location: /python_projects/functions_tutorial/
        
        def lambda_across_versions():
            """Demonstrate lambda functions across Python versions."""
            print("Lambda functions across Python versions...")
            
            # Original lambda syntax (all Python versions)
            original_lambda = lambda x: x * 2
            print(f"Original lambda (2 * 5): {original_lambda(5)}")
            
            # In Python 3.8+, you can use the walrus operator in lambda expressions
            # This example only works in Python 3.8 and later
            try:
                # Try to create a lambda with assignment expression
                walrus_lambda = eval("lambda x: (y := x * 2) + y")
                print(f"Lambda with walrus operator (2*5 + 2*5): {walrus_lambda(5)}")
            except SyntaxError:
                print("This Python version does not support assignment expressions in lambda")
            
            # While lambda hasn't changed much, alternatives have evolved
            
            # Python 2.x style (still works in Python 3.x)
            old_style_filter = list(filter(lambda x: x % 2 == 0, range(10)))
            print(f"Old-style filter: {old_style_filter}")
            
            # Python 3.x style with list comprehension
            new_style_filter = [x for x in range(10) if x % 2 == 0]
            print(f"New-style filter: {new_style_filter}")
            
            # Future possibilities?
            print("\nWhat might be possible in future Python versions?")
            print("- More advanced pattern matching in lambda expressions")
            print("- Multi-line lambda expressions (though this is unlikely)")
            print("- More integration with type hints")
            
            return {
                "original_lambda": original_lambda,
                "old_style_filter": old_style_filter,
                "new_style_filter": new_style_filter
            }
        
        # Call the function
        lambda_evolution = lambda_across_versions()
        </code></pre>
                    <p>
                        While the basic syntax of lambda functions has remained consistent across Python versions, the language has evolved around them, with new features and alternatives that provide different ways to accomplish similar tasks.
                    </p>
                </section>
        
                <section class="conclusion">
                    <h2>Conclusion: Mastering Lambda Functions in Python</h2>
                    <p>
                        Lambda functions are a powerful and flexible feature of Python that can make your code more concise and expressive when used appropriately. Let's recap what we've learned:
                    </p>
                    <ul>
                        <li><strong>Lambda Fundamentals:</strong> Lambda functions are anonymous, single-expression functions that automatically return their result, making them ideal for simple operations.</li>
                        <li><strong>Common Use Cases:</strong> Lambda functions excel in several scenarios:
                            <ul>
                                <li>As arguments to higher-order functions like <code>map()</code>, <code>filter()</code>, and <code>sorted()</code></li>
                                <li>For creating small, one-time-use functions</li>
                                <li>As key functions for sorting and grouping</li>
                                <li>In function factories that generate specialized functions</li>
                                <li>As simple callbacks in event-driven programming</li>
                            </ul>
                        </li>
                        <li><strong>Best Practices:</strong> Lambda functions are most effective when:
                            <ul>
                                <li>They're short and focused on a single operation</li>
                                <li>They're used in a context where the intent is clear</li>
                                <li>The operation doesn't need extensive documentation</li>
                                <li>The function is unlikely to be reused elsewhere</li>
                            </ul>
                        </li>
                        <li><strong>Alternatives:</strong> For many use cases, there are alternatives that may be more readable or efficient:
                            <ul>
                                <li>List comprehensions and generator expressions for transforming and filtering data</li>
                                <li>The <code>operator</code> module for common operations</li>
                                <li>Regular named functions for complex operations or reusable code</li>
                                <li><code>functools.partial</code> for partial function application</li>
                            </ul>
                        </li>
                    </ul>
                    <p>
                        Lambda functions, like any tool, have their place. Understanding when to use them (and when not to) is key to writing clean, readable, and effective Python code. The beauty of Python is that it provides multiple ways to solve problems, allowing you to choose the approach that best fits your specific situation.
                    </p>
                    <p>
                        Whether you're using lambda functions for data processing, functional programming, or UI development, remember that the goal is to write code that is not only correct but also clear and maintainable. Lambda functions can help you achieve that goal when used thoughtfully and in the right contexts.
                    </p>
                </section>
        
                <section class="practice_exercises">
                    <h2>Practice Exercises</h2>
                    <p>
                        To solidify your understanding of lambda functions, try these exercises:
                    </p>
                    <ol>
                        <li>Create a lambda function to check if a string is a palindrome (reads the same forwards and backwards).</li>
                        <li>Use <code>filter()</code> with a lambda to find all prime numbers in a list of integers.</li>
                        <li>Use <code>sorted()</code> with a lambda to sort a list of strings by their last character.</li>
                        <li>Create a function factory that returns lambdas for different mathematical operations (addition, subtraction, multiplication, division).</li>
                        <li>Use <code>reduce()</code> with a lambda to find the longest string in a list.</li>
                        <li>Implement a simple calculator that uses lambda functions for each operation.</li>
                        <li>Create a decorator using lambda functions.</li>
                        <li>Use lambda with list comprehensions to create a multiplication table.</li>
                        <li>Write a function that returns different lambda functions based on user input.</li>
                        <li>Use lambda with <code>map()</code> to convert a list of temperatures from Celsius to Fahrenheit.</li>
                    </ol>
                    <p>
                        These exercises will help you build confidence with lambda functions and understand their strengths and limitations.
                    </p>
                </section>
        
                <section class="further_reading">
                    <h2>Further Reading</h2>
                    <ul>
                        <li><a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" target="_blank">Python Documentation: Lambda Expressions</a></li>
                        <li><a href="https://docs.python.org/3/howto/functional.html" target="_blank">Python HOWTOs: Functional Programming</a></li>
                        <li><a href="https://docs.python.org/3/library/operator.html" target="_blank">Python Documentation: operator â€” Standard operators as functions</a></li>
                        <li><a href="https://docs.python.org/3/library/functools.html" target="_blank">Python Documentation: functools â€” Higher-order functions and operations on callable objects</a></li>
                        <li>Book: "Fluent Python" by Luciano Ramalho (Chapter on Functions)</li>
                        <li>Book: "Python Cookbook" by David Beazley and Brian K. Jones (Chapter 7: Functions)</li>
                        <li>Book: "Functional Programming in Python" by David Mertz</li>
                    </ul>
                </section>
            </main>
        
            <footer>
                <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
            </footer>
        </body>
        </html>
