<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursion Basics - Python Full Stack Web Developer Course</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 2: Thursday Afternoon - Recursion Basics</h2>
    </header>

    <main>
        <section class="lecture-intro">
            <h3>Introduction to Recursion</h3>
            <p>Welcome to our exploration of recursion! Today, we'll dive into one of the most elegant and powerful concepts in computer science. Recursion might seem challenging at first, but once you grasp its beauty, you'll see its applications everywhere - from simple algorithms to complex data structures.</p>
            
            <p>This tutorial will be stored in your course files as: <code>/week2_thursday_recursion_basics.html</code></p>
        </section>

        <section class="concept-overview">
            <h3>What is Recursion?</h3>
            <p>Recursion is a programming technique where a function calls itself to solve a problem. It's like looking at yourself in a mirror that faces another mirror - you see reflections within reflections, extending seemingly infinitely.</p>
            
            <p>At its core, recursion involves:</p>
            <ul>
                <li><strong>Base case(s)</strong>: The condition(s) that stop the recursion</li>
                <li><strong>Recursive case(s)</strong>: The part where the function calls itself with a modified input</li>
            </ul>
            
            <div class="analogy-box">
                <h4>Real-world Analogy: Russian Nesting Dolls (Matryoshka)</h4>
                <p>Think of recursion like Russian nesting dolls. Each doll contains a smaller version of itself, until you reach the smallest doll (the base case) that can't be opened further. To put them back together, you start with the smallest doll and work your way outward (unwinding the recursion).</p>
            </div>
        </section>

        <section class="why-recursion">
            <h3>Why Use Recursion?</h3>
            <p>You might wonder why we need recursion when loops can solve many of the same problems. Here's why recursion is valuable:</p>
            
            <ul>
                <li><strong>Elegant solutions</strong>: Some problems have naturally recursive structures (trees, graphs, fractals) and are much more elegant to solve recursively.</li>
                <li><strong>Divide and conquer</strong>: Recursion excels at breaking down complex problems into smaller, similar subproblems.</li>
                <li><strong>Readability</strong>: A well-written recursive solution can be more concise and readable than its iterative counterpart.</li>
                <li><strong>Some problems are inherently recursive</strong>: Certain algorithms (like tree traversals) are much more intuitive with recursion.</li>
            </ul>
            
            <div class="example-box">
                <h4>Real-world Application: File System Navigation</h4>
                <p>Your computer's file system is hierarchical - folders contain files and other folders, which can contain more files and folders. Searching through a directory structure is a naturally recursive process, as you need to look inside each subfolder and its subfolders.</p>
            </div>
        </section>

        <section class="recursion-anatomy">
            <h3>Anatomy of a Recursive Function</h3>
            <p>Every recursive function follows this general pattern:</p>
            
            <pre><code>def recursive_function(parameters):
    # Base case(s): condition to stop recursion
    if base_case_condition:
        return base_case_value
    
    # Recursive case: function calls itself
    else:
        # Process data and call function with modified parameters
        return recursive_function(modified_parameters)</code></pre>
            
            <p>The two critical components are:</p>
            
            <ol>
                <li><strong>Base case</strong>: Prevents infinite recursion by providing an exit condition</li>
                <li><strong>Recursive step</strong>: Makes progress toward the base case with each call</li>
            </ol>
            
            <div class="warning-box">
                <h4>Important Warning!</h4>
                <p>Always ensure your recursive function has:</p>
                <ul>
                    <li>At least one base case that doesn't make a recursive call</li>
                    <li>Recursive calls that move toward the base case</li>
                </ul>
                <p>Without these, you'll create an infinite recursion that will cause a stack overflow!</p>
            </div>
        </section>

        <section class="simple-examples">
            <h3>Simple Recursion Examples</h3>

            <h4>Example 1: Factorial Calculation</h4>
            <p>The factorial of a number n (written as n!) is the product of all positive integers less than or equal to n.</p>
            <p>Mathematical definition: n! = n × (n-1) × (n-2) × ... × 2 × 1</p>
            <p>Recursive definition: n! = n × (n-1)!</p>
            
            <pre><code>def factorial(n):
    # Base case
    if n == 0 or n == 1:
        return 1
    
    # Recursive case
    else:
        return n * factorial(n - 1)

# Examples
print(factorial(5))  # 5! = 5 × 4 × 3 × 2 × 1 = 120</code></pre>
            
            <div class="execution-trace">
                <h5>Execution Trace for factorial(5):</h5>
                <ol>
                    <li>factorial(5) calls factorial(4) and waits</li>
                    <li>factorial(4) calls factorial(3) and waits</li>
                    <li>factorial(3) calls factorial(2) and waits</li>
                    <li>factorial(2) calls factorial(1) and waits</li>
                    <li>factorial(1) returns 1 (base case)</li>
                    <li>factorial(2) resumes and returns 2 * 1 = 2</li>
                    <li>factorial(3) resumes and returns 3 * 2 = 6</li>
                    <li>factorial(4) resumes and returns 4 * 6 = 24</li>
                    <li>factorial(5) resumes and returns 5 * 24 = 120</li>
                </ol>
            </div>

            <h4>Example 2: Fibonacci Sequence</h4>
            <p>The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...</p>
            <p>Each number is the sum of the two preceding ones, starting from 0 and 1.</p>
            
            <pre><code>def fibonacci(n):
    # Base cases
    if n == 0:
        return 0
    elif n == 1:
        return 1
    
    # Recursive case
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# Examples
print(fibonacci(6))  # 8</code></pre>
            
            <div class="analogy-box">
                <h4>Fibonacci in Nature</h4>
                <p>The Fibonacci sequence appears throughout nature - in the arrangement of leaves on stems, the pattern of florets in a flower, the spirals of shells, and even in the structure of galaxies. This recursive mathematical pattern helps organisms grow in the most efficient ways.</p>
            </div>
            
            <div class="optimization-note">
                <h5>Note on Efficiency:</h5>
                <p>The recursive Fibonacci implementation above is elegant but inefficient for large values because it recalculates the same values multiple times. For real applications, you'd use dynamic programming (memoization) or an iterative approach for better performance.</p>
            </div>
        </section>

        <section class="practical-examples">
            <h3>Practical Recursion Examples</h3>

            <h4>Example 3: Directory Size Calculation</h4>
            <p>Let's use recursion to calculate the total size of all files in a directory and its subdirectories.</p>
            
            <pre><code>import os

def directory_size(path):
    # Base case: if path is a file, return its size
    if os.path.isfile(path):
        return os.path.getsize(path)
    
    # Recursive case: if path is a directory, calculate size of all contents
    total_size = 0
    for item in os.listdir(path):
        item_path = os.path.join(path, item)
        # Recursive call for each file/directory
        total_size += directory_size(item_path)
    
    return total_size

# Example usage
print(f"Total size: {directory_size('/path/to/directory')} bytes")</code></pre>
            
            <p>This is a perfect example of a naturally recursive problem - directory structures are hierarchical by nature.</p>

            <h4>Example 4: Recursive Binary Search</h4>
            <p>Binary search is an efficient algorithm for finding an item in a sorted list.</p>
            
            <pre><code>def binary_search(arr, target, low=0, high=None):
    if high is None:
        high = len(arr) - 1
    
    # Base case: item not found
    if low > high:
        return -1
    
    # Find middle index
    mid = (low + high) // 2
    
    # Base case: item found
    if arr[mid] == target:
        return mid
    
    # Recursive cases
    elif arr[mid] > target:
        # Search left half
        return binary_search(arr, target, low, mid - 1)
    else:
        # Search right half
        return binary_search(arr, target, mid + 1, high)

# Example
sorted_list = [1, 3, 5, 7, 9, 11, 13, 15, 17]
print(binary_search(sorted_list, 11))  # 5</code></pre>
            
            <div class="analogy-box">
                <h4>Binary Search Analogy: Phone Book</h4>
                <p>Imagine looking for a name in a phone book. You don't check every page - you open to the middle, see if the name would come before or after that page, and then only search that half. You repeat this process, cutting the search area in half each time, until you find the name. This "divide and conquer" approach is what makes binary search so efficient.</p>
            </div>
        </section>

        <section class="recursion-visualization">
            <h3>Visualizing Recursion: The Call Stack</h3>
            <p>When a function calls itself recursively, each call is placed on the "call stack" - a memory structure that keeps track of function calls.</p>
            
            <p>Let's visualize the call stack for factorial(3):</p>
            
            <pre><code>Call Stack (grows downward):
                                                    Return Value
factorial(3)                                            6
└── factorial(2)                                        2
    └── factorial(1)                                    1</code></pre>
            
            <p>Execution flow:</p>
            <ol>
                <li>factorial(3) calls factorial(2)</li>
                <li>factorial(2) calls factorial(1)</li>
                <li>factorial(1) returns 1 (base case)</li>
                <li>factorial(2) calculates 2 * 1 = 2 and returns</li>
                <li>factorial(3) calculates 3 * 2 = 6 and returns</li>
            </ol>
            
            <div class="call-stack-analogy">
                <h4>Call Stack Analogy: Stack of Plates</h4>
                <p>Think of the call stack like a stack of plates. Each time you make a recursive call, you place a new plate on top of the stack. When a function returns (hits its base case), you take a plate off the stack. You have to remove plates from the top (complete the most recent calls) before you can get to the plates below (complete the earlier calls).</p>
            </div>
        </section>

        <section class="recursion-patterns">
            <h3>Common Recursion Patterns</h3>

            <h4>Linear Recursion</h4>
            <p>Each function makes one recursive call (like factorial).</p>
            
            <h4>Binary Recursion</h4>
            <p>Each function makes two recursive calls (like Fibonacci).</p>
            
            <h4>Tail Recursion</h4>
            <p>A special case where the recursive call is the last operation in the function.</p>
            
            <pre><code># Normal recursive factorial
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)

# Tail recursive factorial (with accumulator)
def factorial_tail(n, accumulator=1):
    if n == 0 or n == 1:
        return accumulator
    else:
        return factorial_tail(n - 1, n * accumulator)</code></pre>
            
            <p>Tail recursion is important because many modern compilers can optimize it to use constant stack space (although Python currently doesn't do this optimization).</p>
            
            <h4>Mutual Recursion</h4>
            <p>Two or more functions call each other in a cycle.</p>
            
            <pre><code>def is_even(n):
    if n == 0:
        return True
    else:
        return is_odd(n - 1)

def is_odd(n):
    if n == 0:
        return False
    else:
        return is_even(n - 1)

print(is_even(4))  # True
print(is_odd(3))   # True</code></pre>
        </section>

        <section class="recursion-limitations">
            <h3>Limitations and Considerations</h3>
            
            <h4>Stack Overflow</h4>
            <p>Python limits the recursion depth (usually around 1000 calls) to prevent stack overflow. For very deep recursion, you might need to:</p>
            <ul>
                <li>Increase the limit with <code>sys.setrecursionlimit()</code> (use cautiously)</li>
                <li>Convert to an iterative solution</li>
                <li>Use tail recursion optimization techniques</li>
            </ul>
            
            <pre><code>import sys
print(f"Default recursion limit: {sys.getrecursionlimit()}")

# Increase limit (be careful!)
# sys.setrecursionlimit(3000)</code></pre>
            
            <h4>Performance Considerations</h4>
            <p>Recursive solutions can be less efficient than iterative ones due to:</p>
            <ul>
                <li>Function call overhead</li>
                <li>Stack space usage</li>
                <li>Potential redundant calculations (as in naive Fibonacci)</li>
            </ul>
            
            <div class="optimization-techniques">
                <h5>Optimization Techniques:</h5>
                <ul>
                    <li><strong>Memoization</strong>: Cache results to avoid redundant calculations</li>
                    <li><strong>Tail recursion</strong>: Write recursion so the recursive call is the last operation</li>
                    <li><strong>Convert to iteration</strong>: For performance-critical code</li>
                </ul>
            </div>
            
            <h4>Improved Fibonacci with Memoization</h4>
            <pre><code>def fibonacci_memo(n, memo={}):
    # Check if we've already calculated this value
    if n in memo:
        return memo[n]
    
    # Base cases
    if n == 0:
        return 0
    elif n == 1:
        return 1
    
    # Recursive case with memoization
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]

print(fibonacci_memo(100))  # Fast calculation of a large Fibonacci number</code></pre>
            
            <div class="warning-box">
                <h5>Warning about the above code:</h5>
                <p>Using a mutable default argument (like the empty dictionary) can cause unexpected behavior if the function is called multiple times. In production code, you'd want to create the memo dictionary inside the function or pass it as a parameter without a default value.</p>
            </div>
        </section>

        <section class="real-world-applications">
            <h3>Real-world Applications of Recursion</h3>
            
            <h4>Web Development Applications</h4>
            <ul>
                <li><strong>DOM traversal</strong>: Navigating and manipulating nested DOM structures</li>
                <li><strong>Parsing nested JSON</strong>: Processing complex, nested API responses</li>
                <li><strong>Generating site maps</strong>: Crawling websites with nested pages</li>
                <li><strong>Building navigation menus</strong>: Creating multi-level menus from hierarchical data</li>
                <li><strong>Template rendering</strong>: Processing nested template structures</li>
            </ul>
            
            <h4>Example: Parsing Nested JSON</h4>
            <pre><code>def find_all_values(json_obj, key):
    """Find all values for a given key in a nested JSON object"""
    results = []
    
    # Base case: json_obj is a dictionary
    if isinstance(json_obj, dict):
        # Check if this dictionary contains the key
        if key in json_obj:
            results.append(json_obj[key])
        
        # Recursively search all values in this dictionary
        for k in json_obj:
            results.extend(find_all_values(json_obj[k], key))
    
    # Base case: json_obj is a list
    elif isinstance(json_obj, list):
        # Recursively search each item in the list
        for item in json_obj:
            results.extend(find_all_values(item, key))
    
    # Base case: json_obj is a primitive value (str, int, etc.)
    # In this case, no recursion needed, return empty list
    
    return results

# Example usage
nested_data = {
    "user": {
        "name": "John",
        "roles": ["admin", "user"],
        "preferences": {
            "theme": "dark",
            "notifications": {
                "email": True,
                "push": False
            }
        }
    },
    "meta": {
        "theme": "system"
    }
}

print(find_all_values(nested_data, "theme"))  # ['dark', 'system']</code></pre>
            
            <h4>Example: Building a Nested Comment System</h4>
            <p>In modern web applications, comment systems often allow nested replies. Recursion is perfect for rendering these threaded comments.</p>
            
            <pre><code>def render_comment_thread(comment, depth=0):
    """Render a comment and all its replies with proper indentation"""
    # Indent based on depth
    indent = "  " * depth
    
    # Render the comment
    output = f"{indent}- {comment['author']}: {comment['text']}\n"
    
    # Recursively render all replies
    if 'replies' in comment:
        for reply in comment['replies']:
            output += render_comment_thread(reply, depth + 1)
    
    return output

# Example comment thread
comments = {
    "author": "User1",
    "text": "Great article!",
    "replies": [
        {
            "author": "User2",
            "text": "I agree, very informative.",
            "replies": [
                {
                    "author": "User1",
                    "text": "Thanks for your feedback!"
                }
            ]
        },
        {
            "author": "User3",
            "text": "I have a question about section 3..."
        }
    ]
}

print(render_comment_thread(comments))</code></pre>
            
            <div class="output-example">
                <h5>Output:</h5>
                <pre>- User1: Great article!
  - User2: I agree, very informative.
    - User1: Thanks for your feedback!
  - User3: I have a question about section 3...</pre>
            </div>
        </section>

        <section class="practice-exercises">
            <h3>Practice Exercises</h3>
            
            <div class="exercise">
                <h4>Exercise 1: Sum of a List</h4>
                <p>Write a recursive function to calculate the sum of all elements in a list.</p>
                <details>
                    <summary>Hint</summary>
                    <p>Think about the base case (empty list) and how to break down the problem into a smaller subproblem.</p>
                </details>
                <details>
                    <summary>Solution</summary>
                    <pre><code>def recursive_sum(lst):
    # Base case: empty list
    if not lst:
        return 0
    
    # Recursive case: first element + sum of rest
    return lst[0] + recursive_sum(lst[1:])

print(recursive_sum([1, 2, 3, 4, 5]))  # 15</code></pre>
                </details>
            </div>
            
            <div class="exercise">
                <h4>Exercise 2: Power Function</h4>
                <p>Write a recursive function to calculate x raised to the power n (x^n).</p>
                <details>
                    <summary>Hint</summary>
                    <p>Remember that x^n = x * x^(n-1) and x^0 = 1.</p>
                </details>
                <details>
                    <summary>Solution</summary>
                    <pre><code>def power(x, n):
    # Base case
    if n == 0:
        return 1
    
    # Recursive case
    return x * power(x, n - 1)

print(power(2, 5))  # 32</code></pre>
                </details>
            </div>
            
            <div class="exercise">
                <h4>Exercise 3: Palindrome Check</h4>
                <p>Write a recursive function to check if a string is a palindrome (reads the same forward and backward).</p>
                <details>
                    <summary>Hint</summary>
                    <p>A string is a palindrome if the first and last characters match, and the substring between them is a palindrome.</p>
                </details>
                <details>
                    <summary>Solution</summary>
                    <pre><code>def is_palindrome(s):
    # Convert to lowercase and remove non-alphanumeric characters
    s = ''.join(c.lower() for c in s if c.isalnum())
    
    # Base cases
    if len(s) <= 1:
        return True
    
    # Recursive case: check first and last characters, then check the rest
    if s[0] != s[-1]:
        return False
    
    # Recursive call with the substring excluding first and last characters
    return is_palindrome(s[1:-1])

print(is_palindrome("racecar"))  # True
print(is_palindrome("Hello"))    # False
print(is_palindrome("A man, a plan, a canal: Panama"))  # True</code></pre>
                </details>
            </div>
            
            <div class="exercise">
                <h4>Exercise 4: Recursive Count</h4>
                <p>Write a recursive function that counts the occurrences of a specific element in a nested list.</p>
                <details>
                    <summary>Hint</summary>
                    <p>You'll need to handle different data types and recursively process nested lists.</p>
                </details>
                <details>
                    <summary>Solution</summary>
                    <pre><code>def count_element(nested_list, element):
    # Initialize count
    count = 0
    
    # Iterate through items
    for item in nested_list:
        # If item is a list, recursively count
        if isinstance(item, list):
            count += count_element(item, element)
        # If item matches element, increment count
        elif item == element:
            count += 1
    
    return count

test_list = [1, [2, 3, [1, 2]], [1, [1]], 4, 1]
print(count_element(test_list, 1))  # 4</code></pre>
                </details>
            </div>
        </section>

        <section class="additional-resources">
            <h3>Additional Resources</h3>
            
            <h4>Books and Tutorials</h4>
            <ul>
                <li>"Grokking Algorithms" by Aditya Bhargava - Excellent visual explanations of recursion</li>
                <li>"Introduction to Algorithms" by Cormen, Leiserson, Rivest, and Stein - Deep dive into recursive algorithms</li>
                <li><a href="https://realpython.com/python-recursion/" target="_blank">Real Python: Python Recursion Tutorial</a></li>
            </ul>
            
            <h4>Practice Problems</h4>
            <ul>
                <li>LeetCode Recursion I and II study plans</li>
                <li>HackerRank Recursion challenges</li>
                <li>Project Euler problems (many can be solved recursively)</li>
            </ul>
            
            <h4>Visualization Tools</h4>
            <ul>
                <li><a href="http://pythontutor.com/" target="_blank">Python Tutor</a> - Visualize recursion step-by-step</li>
                <li><a href="https://recursion.vercel.app/" target="_blank">Recursion Visualization</a> - Interactive recursion examples</li>
            </ul>
        </section>

        <section class="assignment-section">
            <h3>Assignment: Building a Recursive Directory Explorer</h3>
            
            <p>Create a recursive directory explorer that:</p>
            <ol>
                <li>Takes a directory path as input</li>
                <li>Recursively lists all files and subdirectories</li>
                <li>For each file, shows the file size and extension</li>
                <li>For each directory, shows the total size of its contents</li>
                <li>Formats the output with proper indentation to show the hierarchy</li>
            </ol>
            
            <p><strong>Bonus challenges:</strong></p>
            <ul>
                <li>Add filtering by file extension</li>
                <li>Add searching for files by name pattern</li>
                <li>Add options to sort by name, size, or date</li>
            </ul>
            
            <p><strong>Tips:</strong></p>
            <ul>
                <li>Use the <code>os</code> and <code>pathlib</code> modules</li>
                <li>Think carefully about your base and recursive cases</li>
                <li>Test with small directories first</li>
                <li>Consider how to handle errors (e.g., permission denied)</li>
            </ul>
            
            <p><strong>Submission location:</strong> <code>/week2_thursday_assignment.py</code></p>
        </section>

        <section class="conclusion">
            <h3>Conclusion</h3>
            
            <p>Recursion is a powerful technique that can lead to elegant solutions for complex problems. While it may take some time to "think recursively," it's a valuable skill that will serve you well throughout your programming career.</p>
            
            <p>Remember these key points:</p>
            <ul>
                <li>Always include proper base cases</li>
                <li>Ensure progress toward the base case</li>
                <li>Consider performance implications</li>
                <li>Use optimization techniques when needed</li>
                <li>Some problems are naturally recursive - embrace that!</li>
            </ul>
            
            <p>Next time, we'll build on these concepts as we explore modules and packages in Python. Recursion will appear again when we discuss topics like tree structures, web crawling, and many algorithms.</p>
            
            <div class="quote-box">
                <blockquote>
                    "To understand recursion, you must first understand recursion."
                </blockquote>
            </div>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
