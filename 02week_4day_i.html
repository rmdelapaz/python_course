<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Handling with try/except - Python Full Stack Web Developer Course</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 2: Thursday Afternoon - Error Handling with try/except</h2>
    </header>

    <main>
        <section class="lecture-intro">
            <h3>Introduction to Error Handling</h3>
            <p>Welcome to our deep dive into error handling in Python! Today, we'll explore one of the most practical and essential aspects of programming: how to gracefully handle errors and exceptions. This skill separates novice programmers from professionals - no matter how well-designed your code is, unexpected situations will occur in real-world applications.</p>
            
            <p>This tutorial will be stored in your course files as: <code>/week2_thursday_error_handling.html</code></p>
        </section>

        <section class="concept-overview">
            <h3>Understanding Errors and Exceptions</h3>
            <p>Before we dive into handling errors, let's understand what they are. In Python, there are generally two kinds of errors:</p>
            
            <ul>
                <li><strong>Syntax errors</strong>: Errors in the structure of your code that prevent it from running (like missing colons, unclosed parentheses, etc.)</li>
                <li><strong>Exceptions</strong>: Errors that occur during execution when something unexpected happens</li>
            </ul>
            
            <p>Syntax errors need to be fixed before your code will run, but exceptions can be caught and handled, allowing your program to continue running even when something goes wrong.</p>
            
            <div class="analogy-box">
                <h4>Real-world Analogy: Driving a Car</h4>
                <p>Think of exceptions like unexpected events while driving:</p>
                <ul>
                    <li>A syntax error is like trying to start a car with no key - you won't even get moving.</li>
                    <li>An exception is like a flat tire while driving - an unexpected problem that requires handling.</li>
                    <li>Exception handling is like having a spare tire and knowing how to change it - you've prepared for the problem and can continue your journey.</li>
                </ul>
            </div>
        </section>

        <section class="why-error-handling">
            <h3>Why Error Handling Matters</h3>
            <p>Error handling is not just about preventing crashes - it's about creating robust, user-friendly software. Here's why it's crucial:</p>
            
            <ul>
                <li><strong>Robustness</strong>: Programs that can handle unexpected situations without crashing</li>
                <li><strong>User experience</strong>: Friendly error messages instead of cryptic technical details</li>
                <li><strong>Debugging</strong>: Better error information makes finding and fixing bugs easier</li>
                <li><strong>Security</strong>: Prevents exploitation of error conditions and information leakage</li>
                <li><strong>Data integrity</strong>: Ensures operations complete fully or not at all</li>
            </ul>
            
            <div class="example-box">
                <h4>Real-world Application: Web Form Submission</h4>
                <p>When a user submits a form on your website:</p>
                <ul>
                    <li><strong>Without error handling</strong>: If the database connection fails, the user sees a server error page with confusing technical details, has no idea if their data was saved, and your application crashes.</li>
                    <li><strong>With error handling</strong>: If the database connection fails, the user sees a friendly message like "We couldn't process your submission right now. Your data has been saved and we'll try again soon." Your application logs the error and continues serving other users.</li>
                </ul>
            </div>
        </section>

        <section class="basic-try-except">
            <h3>Basic try/except Structure</h3>
            <p>Python's primary mechanism for handling exceptions is the try/except block:</p>
            
            <pre><code>try:
    # Code that might raise an exception
    result = 10 / 0  # This will raise a ZeroDivisionError
except:
    # Code to handle the exception
    print("An error occurred!")</code></pre>
            
            <p>The basic structure works like this:</p>
            <ol>
                <li>The code inside the <code>try</code> block is executed.</li>
                <li>If no exception occurs, the <code>except</code> block is skipped.</li>
                <li>If an exception occurs, the rest of the <code>try</code> block is skipped and the <code>except</code> block is executed.</li>
                <li>After either case, execution continues after the try/except block.</li>
            </ol>
            
            <div class="warning-box">
                <h4>Warning: Avoid Bare Except!</h4>
                <p>Using a bare <code>except:</code> without specifying which exceptions to catch is generally considered bad practice. It can hide bugs and catch exceptions you didn't intend to handle. Always specify which exceptions you expect to catch.</p>
            </div>
        </section>

        <section class="catching-specific-exceptions">
            <h3>Catching Specific Exceptions</h3>
            <p>In practice, you should always catch specific exceptions rather than using a bare except:</p>
            
            <pre><code>try:
    number = int(input("Enter a number: "))
    result = 10 / number
    print(f"10 divided by {number} is {result}")
except ZeroDivisionError:
    print("You can't divide by zero!")
except ValueError:
    print("That's not a valid number!")</code></pre>
            
            <p>This approach has several advantages:</p>
            <ul>
                <li>Different exceptions can be handled differently</li>
                <li>Unexpected exceptions still propagate (which is good for debugging)</li>
                <li>Your code more clearly communicates what exceptions you're expecting</li>
            </ul>
            
            <h4>Common Built-in Exceptions</h4>
            <table class="exceptions-table">
                <tr>
                    <th>Exception</th>
                    <th>Description</th>
                    <th>Example Scenario</th>
                </tr>
                <tr>
                    <td><code>ValueError</code></td>
                    <td>Inappropriate value for operation</td>
                    <td>Converting a string like "hello" to an integer</td>
                </tr>
                <tr>
                    <td><code>TypeError</code></td>
                    <td>Operation or function applied to inappropriate type</td>
                    <td>Adding a string to an integer without conversion</td>
                </tr>
                <tr>
                    <td><code>ZeroDivisionError</code></td>
                    <td>Division or modulo by zero</td>
                    <td>Dividing any number by zero</td>
                </tr>
                <tr>
                    <td><code>FileNotFoundError</code></td>
                    <td>Trying to access a file that doesn't exist</td>
                    <td>Opening a file that was deleted or moved</td>
                </tr>
                <tr>
                    <td><code>IndexError</code></td>
                    <td>Sequence index out of range</td>
                    <td>Accessing list[10] in a list with only 5 elements</td>
                </tr>
                <tr>
                    <td><code>KeyError</code></td>
                    <td>Dictionary key not found</td>
                    <td>Accessing dict['key'] when 'key' isn't in the dictionary</td>
                </tr>
                <tr>
                    <td><code>AttributeError</code></td>
                    <td>Object has no such attribute or method</td>
                    <td>Calling string.append() when strings don't have an append method</td>
                </tr>
            </table>
        </section>

        <section class="exception-hierarchy">
            <h3>The Exception Hierarchy</h3>
            <p>Python's exceptions form a hierarchy, with the base class <code>BaseException</code> at the top, and <code>Exception</code> as the parent class for most exceptions you'll catch. This hierarchy is important because when you catch an exception, you also catch all its subclasses.</p>
            
            <pre><code>try:
    # This code could raise various types of exceptions
    with open("data.txt", "r") as file:
        data = file.read()
        value = int(data)
        result = 100 / value
except (ValueError, ZeroDivisionError):
    # Catch multiple specific exceptions
    print("Invalid data in file!")
except OSError as e:
    # The 'as' clause captures the exception object
    print(f"File error: {e}")</code></pre>
            
            <div class="hierarchy-note">
                <h4>Exception Hierarchy (Simplified)</h4>
                <ul>
                    <li>BaseException
                        <ul>
                            <li>SystemExit</li>
                            <li>KeyboardInterrupt</li>
                            <li>Exception (almost all other exceptions derive from this)
                                <ul>
                                    <li>ArithmeticError
                                        <ul>
                                            <li>ZeroDivisionError</li>
                                            <li>OverflowError</li>
                                        </ul>
                                    </li>
                                    <li>LookupError
                                        <ul>
                                            <li>IndexError</li>
                                            <li>KeyError</li>
                                        </ul>
                                    </li>
                                    <li>OSError
                                        <ul>
                                            <li>FileNotFoundError</li>
                                            <li>PermissionError</li>
                                        </ul>
                                    </li>
                                    <li>ValueError</li>
                                    <li>TypeError</li>
                                    <li>And many more...</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
                <p>Note: When catching exceptions, order matters! Always catch more specific exceptions before more general ones.</p>
            </div>
        </section>

        <section class="the-else-finally-clauses">
            <h3>The else and finally Clauses</h3>
            <p>The try/except statement can include two additional clauses: <code>else</code> and <code>finally</code>.</p>
            
            <h4>The else Clause</h4>
            <p>The <code>else</code> clause executes only if the try block completes without raising an exception:</p>
            
            <pre><code>try:
    number = int(input("Enter a number: "))
    result = 100 / number
except ValueError:
    print("That's not a valid number!")
except ZeroDivisionError:
    print("You can't divide by zero!")
else:
    # This runs only if no exceptions were raised
    print(f"The result is {result}")
    # You can also put code here that might raise different exceptions</code></pre>
            
            <p>The <code>else</code> clause is useful when you want some code to run only if no exceptions occur, but you still want to catch exceptions in the try block.</p>
            
            <h4>The finally Clause</h4>
            <p>The <code>finally</code> clause always executes, whether an exception was raised or not (even if there's a return statement in the try or except blocks):</p>
            
            <pre><code>try:
    file = open("important_data.txt", "w")
    file.write("Critical information")
    # Some code that might raise an exception
    result = calculate_something()
except Exception as e:
    print(f"An error occurred: {e}")
finally:
    # This ALWAYS runs, ensuring the file is closed
    file.close()
    print("File has been closed")</code></pre>
            
            <p>The <code>finally</code> clause is perfect for cleanup code that must run regardless of whether an exception occurred.</p>
            
            <div class="analogy-box">
                <h4>Try/Except/Else/Finally Analogy: Baking a Cake</h4>
                <ul>
                    <li><strong>try</strong>: Attempt to bake a cake following a recipe</li>
                    <li><strong>except</strong>: Handle specific problems (out of eggs? use a substitute)</li>
                    <li><strong>else</strong>: If the cake baked perfectly, add frosting and decoration</li>
                    <li><strong>finally</strong>: No matter what happened, clean up the kitchen</li>
                </ul>
            </div>
        </section>

        <section class="complete-example">
            <h3>Complete Example: File Processing</h3>
            <p>Let's pull everything together in a practical example of processing a data file:</p>
            
            <pre><code>def process_data_file(filename):
    processed_data = []
    file = None
    
    try:
        # Attempt to open and process the file
        file = open(filename, "r")
        
        for line_number, line in enumerate(file, 1):
            try:
                # Process each line (might fail for various reasons)
                data = line.strip().split(',')
                if len(data) != 3:
                    raise ValueError(f"Line {line_number}: Expected 3 values but got {len(data)}")
                
                name = data[0]
                age = int(data[1])
                score = float(data[2])
                
                if age < 0 or age > 120:
                    raise ValueError(f"Line {line_number}: Invalid age {age}")
                
                if score < 0 or score > 100:
                    raise ValueError(f"Line {line_number}: Invalid score {score}")
                
                processed_data.append({
                    'name': name,
                    'age': age,
                    'score': score
                })
                
            except ValueError as e:
                # Handle data format errors for this line
                print(f"Error processing line {line_number}: {e}")
                # Continue processing the next line
            
    except FileNotFoundError:
        print(f"The file {filename} does not exist.")
    except PermissionError:
        print(f"No permission to read the file {filename}.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
    else:
        print(f"Successfully processed {len(processed_data)} records.")
        return processed_data
    finally:
        # Ensure file is closed even if an exception occurred
        if file is not None:
            file.close()
            print(f"File {filename} has been closed.")
    
    # This only executes if an exception occurred in the main try block
    return None

# Example usage
data = process_data_file("student_data.txt")</code></pre>
            
            <p>This example demonstrates several key concepts:</p>
            <ul>
                <li>Nested try/except blocks for different levels of error handling</li>
                <li>Catching and handling specific exceptions differently</li>
                <li>Using the else clause for code that runs only on success</li>
                <li>Using finally for cleanup that always happens</li>
                <li>Custom validation with raised exceptions</li>
                <li>Gracefully continuing when possible (skipping bad lines)</li>
            </ul>
        </section>

        <section class="raising-exceptions">
            <h3>Raising Exceptions</h3>
            <p>Sometimes you need to raise exceptions yourself, either to report errors in your code or to re-raise caught exceptions:</p>
            
            <pre><code>def divide(a, b):
    if b == 0:
        raise ZeroDivisionError("Cannot divide by zero")
    return a / b

def calculate_average(numbers):
    if not numbers:
        raise ValueError("Cannot calculate average of empty list")
    return sum(numbers) / len(numbers)

# Re-raising with additional information
def process_user_data(user_id):
    try:
        user = get_user_from_database(user_id)
        return process_user(user)
    except DatabaseError as e:
        # Add context to the exception
        raise RuntimeError(f"Error processing user {user_id}") from e</code></pre>
            
            <p>The <code>raise ... from ...</code> syntax creates an exception chain, preserving the original exception as the cause of the new one. This is very helpful for debugging because it shows the complete exception history.</p>
            
            <h4>When to Raise Exceptions</h4>
            <ul>
                <li><strong>Invalid arguments</strong>: When a function receives arguments it can't work with</li>
                <li><strong>Impossible states</strong>: When your program reaches a state that shouldn't be possible</li>
                <li><strong>API contracts</strong>: When callers of your code violate expected conditions</li>
                <li><strong>Re-raising</strong>: To add context to caught exceptions before propagating them</li>
            </ul>
        </section>

        <section class="custom-exceptions">
            <h3>Creating Custom Exceptions</h3>
            <p>For complex applications, it's often valuable to create your own exception types:</p>
            
            <pre><code>class ApplicationError(Exception):
    """Base class for all exceptions in this application."""
    pass

class ConfigurationError(ApplicationError):
    """Raised when there's a problem with application configuration."""
    pass

class DatabaseConnectionError(ApplicationError):
    """Raised when the application cannot connect to the database."""
    pass

class UserNotFoundError(ApplicationError):
    """Raised when a requested user doesn't exist."""
    def __init__(self, user_id):
        self.user_id = user_id
        super().__init__(f"User with ID {user_id} not found")</code></pre>
            
            <p>Custom exceptions have several benefits:</p>
            <ul>
                <li>More precise exception handling specific to your application</li>
                <li>Clearer error messages and better debugging</li>
                <li>Logical organization of different error types</li>
                <li>Ability to attach additional contextual data to exceptions</li>
            </ul>
            
            <div class="usage-example">
                <h4>Using Custom Exceptions</h4>
                <pre><code>def get_user(user_id):
    try:
        # Attempt to get user from database
        if not valid_connection():
            raise DatabaseConnectionError("Database connection failed")
        
        user = find_user(user_id)
        if user is None:
            raise UserNotFoundError(user_id)
        
        return user
    
    except ApplicationError as e:
        # We can catch all our custom exceptions together
        log_error(e)
        # Or we could have specific handling for different subclasses
        raise</code></pre>
            </div>
        </section>

        <section class="context-managers">
            <h3>Context Managers and the with Statement</h3>
            <p>Python's <code>with</code> statement provides a clean way to handle resource cleanup, even if exceptions occur:</p>
            
            <pre><code># Without with statement
file = open("data.txt", "r")
try:
    data = file.read()
    # Process data...
finally:
    file.close()

# With the with statement (much cleaner!)
with open("data.txt", "r") as file:
    data = file.read()
    # Process data...
# File is automatically closed, even if an exception occurs</code></pre>
            
            <p>The <code>with</code> statement works with context managers - objects that define <code>__enter__</code> and <code>__exit__</code> methods. When the <code>with</code> block ends (normally or due to an exception), the <code>__exit__</code> method is called, ensuring cleanup.</p>
            
            <h4>Common Context Managers</h4>
            <ul>
                <li><code>open()</code> for file handling</li>
                <li>Database connections and transactions</li>
                <li>Network connections</li>
                <li>Locks and semaphores</li>
                <li>Temporarily changing settings</li>
            </ul>
            
            <h4>Creating Your Own Context Managers</h4>
            <p>You can create custom context managers using a class or the <code>contextlib</code> module:</p>
            
            <pre><code>from contextlib import contextmanager

# Using a class
class Timer:
    def __enter__(self):
        import time
        self.start_time = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.end_time = time.time()
        print(f"Operation took {self.end_time - self.start_time:.2f} seconds")
        # Return False to let any exceptions propagate
        return False

# Using the contextmanager decorator
@contextmanager
def timer():
    import time
    start_time = time.time()
    try:
        # The yield statement is where the with block's content executes
        yield
    finally:
        end_time = time.time()
        print(f"Operation took {end_time - start_time:.2f} seconds")

# Usage
with Timer():
    # Code to time...
    process_large_file()

# Or with the decorator version
with timer():
    # Code to time...
    process_large_file()</code></pre>
        </section>

        <section class="best-practices">
            <h3>Error Handling Best Practices</h3>
            
            <h4>Do's</h4>
            <ul>
                <li><strong>Catch specific exceptions</strong>, not bare <code>except:</code> clauses</li>
                <li><strong>Handle exceptions at the right level</strong> - where you have enough context to take appropriate action</li>
                <li><strong>Use else for success-only code</strong> that might raise different exceptions</li>
                <li><strong>Use finally or with for cleanup</strong> to ensure resources are properly managed</li>
                <li><strong>Include useful information in exception messages</strong> to aid debugging</li>
                <li><strong>Document exceptions</strong> your functions might raise</li>
            </ul>
            
            <h4>Don'ts</h4>
            <ul>
                <li><strong>Don't catch exceptions you can't handle meaningfully</strong></li>
                <li><strong>Don't silence exceptions</strong> without good reason (avoid <code>except: pass</code>)</li>
                <li><strong>Don't catch Exception or BaseException</strong> unless you really mean to catch everything</li>
                <li><strong>Don't use exceptions for flow control</strong> if regular control structures would work</li>
                <li><strong>Don't overuse custom exceptions</strong> - use built-in types when they're appropriate</li>
            </ul>
            
            <div class="pattern-box">
                <h4>Common Error Handling Patterns</h4>
                
                <h5>1. Look Before You Leap (LBYL) vs. Easier to Ask Forgiveness than Permission (EAFP)</h5>
                <pre><code># LBYL style (check conditions first)
if os.path.exists(filename):
    with open(filename) as f:
        data = f.read()
else:
    data = default_data

# EAFP style (try it and handle exceptions)
try:
    with open(filename) as f:
        data = f.read()
except FileNotFoundError:
    data = default_data</code></pre>
                <p>Python generally favors the EAFP style, which can be more concise and avoids race conditions.</p>
                
                <h5>2. Reraise Pattern</h5>
                <pre><code>try:
    result = complex_operation()
except SomeError as e:
    logger.error(f"Operation failed: {e}")
    raise  # Re-raise the caught exception</code></pre>
                <p>This pattern lets you take action (like logging) while still propagating the exception.</p>
                
                <h5>3. Conversion Pattern</h5>
                <pre><code>try:
    result = api.get_data()
except APIError as e:
    # Convert to a more appropriate exception for this layer
    raise DataUnavailableError("Could not retrieve data") from e</code></pre>
                <p>This pattern translates low-level exceptions into more appropriate ones for your application layer.</p>
            </div>
        </section>

        <section class="web-dev-applications">
            <h3>Error Handling in Web Development</h3>
            <p>In web applications, error handling is particularly important. Here are some specific applications:</p>
            
            <h4>Form Validation and User Input</h4>
            <pre><code>def process_user_registration(data):
    try:
        # Validate and process user data
        username = data['username']
        if not username:
            raise ValueError("Username cannot be empty")
        
        email = data['email']
        if '@' not in email:
            raise ValueError("Invalid email format")
        
        age = int(data.get('age', 0))
        if age < 18:
            raise ValueError("User must be at least 18 years old")
        
        # ... more validation
        
        # If everything is valid, create user
        return create_user(username, email, age)
        
    except KeyError as e:
        # Missing required field
        return {"success": False, "error": f"Missing required field: {e}"}
    except ValueError as e:
        # Invalid data format or validation error
        return {"success": False, "error": str(e)}
    except DatabaseError as e:
        # Database error
        log_error(f"Database error during registration: {e}")
        return {"success": False, "error": "Registration failed due to a system error. Please try again later."}
    except Exception as e:
        # Unexpected error
        log_error(f"Unexpected error during registration: {e}")
        return {"success": False, "error": "An unexpected error occurred. Please try again later."}</code></pre>
            
            <h4>API Responses and Status Codes</h4>
            <pre><code>@app.route('/api/users/<user_id>')
def get_user_api(user_id):
    try:
        user = get_user_from_database(user_id)
        return jsonify(user), 200
    except UserNotFoundError:
        return jsonify({"error": "User not found"}), 404
    except DatabaseConnectionError:
        return jsonify({"error": "Database connection error"}), 503
    except Exception as e:
        log_error(f"Unexpected error in get_user_api: {e}")
        return jsonify({"error": "Internal server error"}), 500</code></pre>
            
            <h4>Graceful Fallbacks in Templates</h4>
            <pre><code># In your Flask route
@app.route('/dashboard')
def dashboard():
    try:
        user_stats = get_user_statistics()
        recent_activity = get_recent_activity()
        notifications = get_notifications()
    except DataUnavailableError:
        # Fallback to empty data if not available
        user_stats = {}
        recent_activity = []
        notifications = []
    
    return render_template(
        'dashboard.html',
        user_stats=user_stats,
        recent_activity=recent_activity,
        notifications=notifications
    )</code></pre>
            
            <div class="security-note">
                <h4>Security Considerations</h4>
                <p>Always be careful with exception messages in production:</p>
                <ul>
                    <li>Don't expose sensitive details in user-facing error messages</li>
                    <li>Log detailed exceptions for debugging, but show users generic messages</li>
                    <li>Be aware that exception stack traces can reveal implementation details</li>
                    <li>Consider using different error handling in development vs. production</li>
                </ul>
            </div>
        </section>

        <section class="debugging-techniques">
            <h3>Debugging with Exceptions</h3>
            <p>Exceptions are not just for error handling - they're also valuable debugging tools:</p>
            
            <h4>Assertion Statements</h4>
            <pre><code>def calculate_discount(price, rate):
    # Verify inputs meet expectations
    assert price >= 0, f"Price must be non-negative, got {price}"
    assert 0 <= rate <= 1, f"Rate must be between 0 and 1, got {rate}"
    
    return price * rate</code></pre>
            <p>Assertions are checked only when Python is run without the -O (optimize) flag, making them perfect for development-time checks.</p>
            
            <h4>Logging Exceptions</h4>
            <pre><code>import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='app.log'
)

try:
    result = complex_calculation()
except Exception as e:
    # Log the exception with traceback
    logging.exception("Error in complex_calculation")
    # This is equivalent to:
    # logging.error("Error in complex_calculation", exc_info=True)
    
    # Handle the exception
    result = fallback_value</code></pre>
            <p>Proper logging of exceptions provides crucial information for debugging production issues.</p>
            
            <h4>Debugging with the traceback Module</h4>
            <pre><code>import traceback

try:
    problematic_function()
except Exception as e:
    # Print detailed traceback
    traceback.print_exc()
    
    # Or get traceback as a string for logging/display
    traceback_str = traceback.format_exc()
    log_error(traceback_str)</code></pre>
        </section>

        <section class="practice-exercises">
            <h3>Practice Exercises</h3>
            
            <div class="exercise">
                <h4>Exercise 1: File Reader</h4>
                <p>Write a function that safely reads a file, handles potential errors, and returns the content or a default value.</p>
                <details>
                    <summary>Solution</summary>
                    <pre><code>def safe_read_file(filename, default=""):
    try:
        with open(filename, 'r') as file:
            return file.read()
    except FileNotFoundError:
        print(f"Warning: File {filename} not found.")
        return default
    except PermissionError:
        print(f"Warning: No permission to read {filename}.")
        return default
    except Exception as e:
        print(f"Unexpected error reading {filename}: {e}")
        return default</code></pre>
                </details>
            </div>
            
            <div class="exercise">
                <h4>Exercise 2: Division Calculator</h4>
                <p>Create a function that divides two numbers, handling all potential errors gracefully.</p>
                <details>
                    <summary>Solution</summary>
                    <pre><code>def safe_divide():
    try:
        num1 = float(input("Enter the numerator: "))
        num2 = float(input("Enter the denominator: "))
        result = num1 / num2
        print(f"{num1} divided by {num2} is {result}")
        return result
    except ValueError:
        print("Error: Please enter valid numbers.")
    except ZeroDivisionError:
        print("Error: Cannot divide by zero.")
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
    except Exception as e:
        print(f"Unexpected error: {e}")
    
    # If we get here, an exception occurred
    return None</code></pre>
                </details>
            </div>
            
            <div class="exercise">
                <h4>Exercise 3: Custom Exception</h4>
                <p>Create a custom exception for a banking application that validates withdrawals.</p>
                <details>
                    <summary>Solution</summary>
                    <pre><code>class BankingError(Exception):
    """Base exception for banking operations."""
    pass

class InsufficientFundsError(BankingError):
    """Raised when a withdrawal would result in a negative balance."""
    def __init__(self, account_id, requested, available):
        self.account_id = account_id
        self.requested = requested
        self.available = available
        self.deficit = requested - available
        super().__init__(
            f"Account {account_id} has insufficient funds: "
            f"requested ${requested:.2f}, available ${available:.2f}, "
            f"deficit ${self.deficit:.2f}"
        )

def withdraw(account_id, amount):
    # Get account balance (in a real app, this would be from a database)
    balance = get_account_balance(account_id)
    
    if amount <= 0:
        raise ValueError("Withdrawal amount must be positive")
    
    if balance < amount:
        raise InsufficientFundsError(account_id, amount, balance)
    
    # Perform withdrawal
    new_balance = perform_withdrawal(account_id, amount)
    return new_balance

# Usage
try:
    new_balance = withdraw("ACC123456", 500.00)
    print(f"Withdrawal successful. New balance: ${new_balance:.2f}")
except ValueError as e:
    print(f"Invalid withdrawal: {e}")
except InsufficientFundsError as e:
    print(f"Withdrawal failed: {e}")
    print(f"Would you like to withdraw ${e.available:.2f} instead?")
except BankingError as e:
    print(f"Banking error: {e}")
except Exception as e:
    print(f"Unexpected error: {e}")</code></pre>
                </details>
            </div>
            
            <div class="exercise">
                <h4>Exercise 4: Context Manager</h4>
                <p>Create a context manager that measures and logs the execution time of a block of code.</p>
                <details>
                    <summary>Solution</summary>
                    <pre><code>import time
import logging
from contextlib import contextmanager

# Configure logging
logging.basicConfig(level=logging.INFO)

@contextmanager
def timing(description):
    start_time = time.time()
    try:
        yield
    finally:
        elapsed_time = time.time() - start_time
        logging.info(f"{description}: {elapsed_time:.4f} seconds")

# Usage
with timing("Data processing"):
    # Code to time
    data = process_large_dataset()

with timing("API request"):
    # Another operation to time
    response = api.get_data()</code></pre>
                </details>
            </div>
        </section>

        <section class="assignment-section">
            <h3>Assignment: Robust Data Processing Pipeline</h3>
            
            <p>Create a robust data processing pipeline that:</p>
            <ol>
                <li>Reads data from a CSV file</li>
                <li>Validates and transforms the data</li>
                <li>Processes the transformed data</li>
                <li>Writes results to an output file</li>
                <li>Handles all potential errors gracefully</li>
                <li>Creates a comprehensive log of the operation</li>
            </ol>
            
            <p><strong>Requirements:</strong></p>
            <ul>
                <li>Implement proper exception handling at all stages</li>
                <li>Create at least one custom exception type</li>
                <li>Use context managers for file operations</li>
                <li>Implement the try/except/else/finally pattern</li>
                <li>Include appropriate logging</li>
                <li>Add clear user feedback</li>
                <li>Handle partial success (some records processed, some failed)</li>
            </ul>
            
            <p><strong>Tips:</strong></p>
            <ul>
                <li>Break down the problem into smaller functions</li>
                <li>Think about what can go wrong at each stage</li>
                <li>Consider which exceptions to handle locally vs. propagate</li>
                <li>Test with various error scenarios</li>
            </ul>
            
            <p><strong>Submission location:</strong> <code>/week2_thursday_error_handling_assignment.py</code></p>
        </section>

        <section class="conclusion">
            <h3>Conclusion</h3>
            
            <p>Robust error handling is what separates professional applications from hobby projects. By mastering Python's exception handling, you'll create software that's more reliable, user-friendly, and maintainable.</p>
            
            <p>Remember these key points:</p>
            <ul>
                <li>Always catch specific exceptions rather than using bare except</li>
                <li>Use the try/except/else/finally pattern appropriately</li>
                <li>Take advantage of context managers for resource management</li>
                <li>Create custom exceptions when they add clarity</li>
                <li>Log detailed errors for debugging but show user-friendly messages</li>
                <li>Handle errors at the appropriate level of abstraction</li>
            </ul>
            
            <p>As you develop more complex applications, particularly web applications, these techniques will become an essential part of your toolkit, ensuring your software can handle the unpredictability of the real world.</p>
            
            <div class="quote-box">
                <blockquote>
                    "Defensive programming is about expecting the unexpected and being prepared for it."
                </blockquote>
            </div>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
