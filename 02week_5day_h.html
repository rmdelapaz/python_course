<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Full Stack Web Developer Course - Project Structure Best Practices</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 2: Python Fundamentals (Part 1)</h2>
        <h3>Friday Morning: Project Structure Best Practices</h3>
    </header>

    <main>
        <section class="introduction">
            <h3>Introduction to Python Project Structure</h3>
            <p>Welcome to our session on Python project structure best practices! As you progress from writing simple scripts to developing complex applications, the organization of your code becomes increasingly important. A well-structured project makes your code more maintainable, scalable, and collaborative.</p>
            
            <p>Think of project structure as the architecture of a building. Just as architects carefully plan the layout of rooms, hallways, and utilities before construction begins, software developers should thoughtfully organize their code, assets, and configuration files. A well-designed building is not only functional and efficient but also easier to navigate and modify. Similarly, a well-structured Python project is easier to understand, debug, and extend.</p>
            
            <p>In this session, we'll explore best practices for organizing Python projects of various sizes and complexities. We'll cover everything from simple script-based projects to complex full-stack web applications, with a focus on creating maintainable, scalable code that follows industry standards.</p>
        </section>

        <section class="why-structure-matters">
            <h3>Why Project Structure Matters</h3>
            
            <p>Before diving into specific structures, let's understand why good project organization is crucial:</p>
            
            <h4>1. Maintainability</h4>
            <p>Well-organized code is easier to maintain. When files and modules have clear purposes and are logically grouped, developers can quickly locate and modify specific functionality without wading through unrelated code.</p>
            
            <p><strong>Real-World Scenario:</strong> Imagine a bug report comes in for your user authentication system. In a well-structured project, you can go directly to <code>auth/login.py</code> rather than searching through a monolithic 2,000-line <code>app.py</code> file.</p>
            
            <h4>2. Scalability</h4>
            <p>Good structure allows your project to grow gracefully. As you add features, the organization adapts without becoming unwieldy.</p>
            
            <p><strong>Real-World Scenario:</strong> When adding a new payment processor to your e-commerce application, you can simply add a new module in your existing payments package without reorganizing the entire codebase.</p>
            
            <h4>3. Collaboration</h4>
            <p>When multiple developers work on the same project, clear structure reduces merge conflicts and ensures everyone can find what they need.</p>
            
            <p><strong>Real-World Scenario:</strong> One developer can work on the authentication system while another focuses on the database models, with minimal interference since the code is properly separated.</p>
            
            <h4>4. Onboarding</h4>
            <p>New team members can become productive faster when they join a well-structured project. The organization serves as a map that guides them through the codebase.</p>
            
            <p><strong>Real-World Scenario:</strong> A new developer joins your team and can understand the project architecture within hours rather than weeks, allowing them to contribute meaningful code sooner.</p>
            
            <h4>5. Testing</h4>
            <p>Proper structure facilitates testing by making it easier to isolate components and write focused tests.</p>
            
            <p><strong>Real-World Scenario:</strong> Your data processing modules are separate from your web views, allowing you to write comprehensive unit tests for data handling logic without needing to simulate HTTP requests.</p>
            
            <h4>6. Deployment</h4>
            <p>Well-structured projects are easier to package, containerize, and deploy across different environments.</p>
            
            <p><strong>Real-World Scenario:</strong> Configuration is clearly separated from application code, making it simple to deploy the same codebase with different settings in development, staging, and production environments.</p>
            
            <p><strong>Real-World Analogy:</strong> Think of a poorly structured project like a messy workshop where tools are scattered everywhere. You might eventually find what you need, but it takes longer, and you're more likely to make mistakes. A well-structured project is like a workshop where every tool has its place—you can work more efficiently and with greater confidence.</p>
        </section>

        <section class="python-packaging">
            <h3>Understanding Python Packaging</h3>
            
            <p>Before diving into specific project structures, let's review some fundamental concepts of Python packaging:</p>
            
            <h4>Modules vs. Packages</h4>
            <ul>
                <li><strong>Module:</strong> A single Python file containing code. For example, <code>utils.py</code> is a module.</li>
                <li><strong>Package:</strong> A directory containing modules and an <code>__init__.py</code> file. For example, a directory named <code>utils</code> with an <code>__init__.py</code> file is a package.</li>
            </ul>
            
            <h4>The <code>__init__.py</code> File</h4>
            <p>This file marks a directory as a Python package. It can be empty or contain initialization code that runs when the package is imported.</p>
            
            <pre><code># A simple __init__.py file that exposes specific functions
from .module1 import function1, function2
from .module2 import Class1

__all__ = ['function1', 'function2', 'Class1']</code></pre>
            
            <h4>Absolute vs. Relative Imports</h4>
            <p>Python supports two types of import statements:</p>
            
            <pre><code># Absolute import (preferred in most cases)
from mypackage.subpackage import module

# Relative import (useful within packages)
from .submodule import function  # Import from sibling module
from ..parentpackage import module  # Import from parent package</code></pre>
            
            <h4>Namespace Packages (Python 3.3+)</h4>
            <p>Packages without <code>__init__.py</code> files, allowing parts of a package to be distributed across different directories or even different distributions.</p>
            
            <h4>Python Path and Import System</h4>
            <p>Understanding how Python finds modules when you import them is crucial:</p>
            <ul>
                <li>Python searches for modules in directories listed in <code>sys.path</code></li>
                <li>The current directory is usually the first search location</li>
                <li>Other locations include installed packages and standard library paths</li>
            </ul>
            
            <pre><code>import sys
print(sys.path)  # See where Python looks for imports</code></pre>
        </section>

        <section class="simple-project">
            <h3>Simple Script Project Structure</h3>
            
            <p>For small, single-purpose scripts or utilities, a minimal structure is often sufficient:</p>
            
            <pre><code>simple_script/
├── script.py          # Main script
├── utils.py           # Helper functions
├── config.py          # Configuration variables
├── requirements.txt   # Dependencies
└── README.md          # Documentation</code></pre>
            
            <p>This structure works well when:</p>
            <ul>
                <li>Your project has a single, focused purpose</li>
                <li>The total code is less than 1,000 lines</li>
                <li>You're the only developer or have a very small team</li>
                <li>The script doesn't need to be imported by other projects</li>
            </ul>
            
            <h4>Example: Data Processing Script</h4>
            
            <p><strong>script.py</strong> - Main program flow:</p>
            <pre><code>#!/usr/bin/env python3
"""
Data processing script that reads CSV files,
performs transformations, and outputs results.
"""
import argparse
from utils import process_file, validate_data
from config import INPUT_DIRECTORY, OUTPUT_DIRECTORY

def main():
    parser = argparse.ArgumentParser(description='Process CSV data files.')
    parser.add_argument('--input', default=INPUT_DIRECTORY, help='Input directory')
    parser.add_argument('--output', default=OUTPUT_DIRECTORY, help='Output directory')
    args = parser.parse_args()
    
    # Process files
    files = get_input_files(args.input)
    for file in files:
        data = process_file(file)
        if validate_data(data):
            save_results(data, args.output)
        else:
            print(f"Validation failed for {file}")

def get_input_files(directory):
    # Code to list files in directory
    pass

def save_results(data, directory):
    # Code to save processed data
    pass

if __name__ == "__main__":
    main()</code></pre>
            
            <p><strong>utils.py</strong> - Helper functions:</p>
            <pre><code>"""Utility functions for data processing."""
import csv
import pandas as pd

def process_file(filename):
    """Process a single data file."""
    # Read and process the file
    df = pd.read_csv(filename)
    # Perform transformations
    return df

def validate_data(data):
    """Ensure data meets our requirements."""
    # Validation logic
    return True</code></pre>
            
            <p><strong>config.py</strong> - Configuration:</p>
            <pre><code>"""Configuration settings for the data processor."""
import os

# Directories
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
INPUT_DIRECTORY = os.path.join(BASE_DIR, 'data/input')
OUTPUT_DIRECTORY = os.path.join(BASE_DIR, 'data/output')

# Processing options
MAX_ROWS = 10000
CHUNK_SIZE = 1000</code></pre>
            
            <p>Even in a simple project, this separation offers several benefits:</p>
            <ul>
                <li>The main script (<code>script.py</code>) focuses on program flow</li>
                <li>Utility functions are reusable and testable in isolation</li>
                <li>Configuration is centralized and easy to modify</li>
            </ul>
        </section>

        <section class="medium-project">
            <h3>Medium-Sized Application Structure</h3>
            
            <p>As projects grow, they benefit from more structured organization. Here's a typical layout for a medium-sized Python application:</p>
            
            <pre><code>medium_project/
├── mypackage/              # Main package
│   ├── __init__.py         # Package initialization
│   ├── core.py             # Core functionality
│   ├── helpers.py          # Helper functions
│   └── subpackage/         # Sub-package for related functionality
│       ├── __init__.py
│       └── module.py
├── tests/                  # Test directory
│   ├── __init__.py
│   ├── test_core.py
│   └── test_subpackage.py
├── docs/                   # Documentation
│   └── index.md
├── scripts/                # Command-line scripts
│   └── run_analysis.py
├── setup.py                # Installation script
├── requirements.txt        # Dependencies
├── README.md               # Project overview
└── LICENSE                 # License information</code></pre>
            
            <p>Key features of this structure:</p>
            <ul>
                <li>Code is organized into packages and sub-packages</li>
                <li>Tests are separated from application code</li>
                <li>Scripts directory contains executable entry points</li>
                <li>setup.py allows the package to be installed</li>
            </ul>
            
            <h4>Example: A Library for Data Visualization</h4>
            
            <p><strong>mypackage/__init__.py</strong> - Package initialization:</p>
            <pre><code>"""Data visualization library for scientific data."""

from .core import plot_data, save_figure
from .helpers import load_data, preprocess_data

__version__ = '0.1.0'
__all__ = ['plot_data', 'save_figure', 'load_data', 'preprocess_data']</code></pre>
            
            <p><strong>mypackage/core.py</strong> - Core functionality:</p>
            <pre><code>"""Core visualization functions."""
import matplotlib.pyplot as plt
import seaborn as sns
from .helpers import validate_data

def plot_data(data, plot_type='scatter', **kwargs):
    """
    Create a visualization from the provided data.
    
    Args:
        data: Pandas DataFrame with the data to plot
        plot_type: Type of plot to create (scatter, line, bar)
        **kwargs: Additional arguments for the plot
        
    Returns:
        matplotlib.Figure: The created figure
    """
    validate_data(data)
    
    if plot_type == 'scatter':
        fig, ax = plt.subplots()
        ax.scatter(data['x'], data['y'], **kwargs)
    elif plot_type == 'line':
        fig, ax = plt.subplots()
        ax.plot(data['x'], data['y'], **kwargs)
    elif plot_type == 'bar':
        fig, ax = plt.subplots()
        ax.bar(data['x'], data['y'], **kwargs)
    else:
        raise ValueError(f"Unsupported plot type: {plot_type}")
    
    return fig

def save_figure(fig, filename, dpi=300):
    """Save a figure to a file."""
    fig.savefig(filename, dpi=dpi)</code></pre>
            
            <p><strong>mypackage/helpers.py</strong> - Helper functions:</p>
            <pre><code>"""Helper functions for data handling."""
import pandas as pd
import numpy as np

def load_data(filename):
    """Load data from a file into a DataFrame."""
    if filename.endswith('.csv'):
        return pd.read_csv(filename)
    elif filename.endswith('.xlsx'):
        return pd.read_excel(filename)
    elif filename.endswith('.json'):
        return pd.read_json(filename)
    else:
        raise ValueError(f"Unsupported file format: {filename}")

def preprocess_data(data):
    """Clean and prepare data for visualization."""
    # Remove missing values
    data = data.dropna()
    
    # Normalize numeric columns
    for col in data.select_dtypes(include=[np.number]).columns:
        data[col] = (data[col] - data[col].mean()) / data[col].std()
    
    return data

def validate_data(data):
    """Ensure data meets requirements for visualization."""
    required_columns = ['x', 'y']
    if not all(col in data.columns for col in required_columns):
        raise ValueError(f"Data must contain columns: {required_columns}")
    return True</code></pre>
            
            <p><strong>mypackage/subpackage/__init__.py</strong> - Subpackage initialization:</p>
            <pre><code>"""Advanced visualization components."""
from .module import create_dashboard</code></pre>
            
            <p><strong>mypackage/subpackage/module.py</strong> - Additional functionality:</p>
            <pre><code>"""Dashboard creation module."""
import matplotlib.pyplot as plt
from ..core import plot_data

def create_dashboard(data_list, titles=None, figsize=(12, 8)):
    """
    Create a dashboard with multiple plots.
    
    Args:
        data_list: List of DataFrames to plot
        titles: List of titles for each plot
        figsize: Size of the figure
        
    Returns:
        matplotlib.Figure: The dashboard figure
    """
    n = len(data_list)
    if titles is None:
        titles = [f"Plot {i+1}" for i in range(n)]
        
    fig, axes = plt.subplots(nrows=n, figsize=figsize)
    if n == 1:
        axes = [axes]
    
    for i, (data, title) in enumerate(zip(data_list, titles)):
        plot_data(data)
        axes[i].set_title(title)
    
    fig.tight_layout()
    return fig</code></pre>
            
            <p><strong>setup.py</strong> - Installation script:</p>
            <pre><code>from setuptools import setup, find_packages

setup(
    name="mypackage",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        "matplotlib>=3.4.0",
        "seaborn>=0.11.0",
        "pandas>=1.3.0",
        "numpy>=1.20.0",
    ],
    author="Your Name",
    author_email="your.email@example.com",
    description="A data visualization library for scientific data",
    keywords="visualization, data, science",
    url="https://github.com/yourusername/mypackage",
    classifiers=[
        "Development Status :: 3 - Alpha",
        "Intended Audience :: Science/Research",
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
    ],
    python_requires=">=3.7",
)</code></pre>
            
            <p><strong>tests/test_core.py</strong> - Core functionality tests:</p>
            <pre><code>"""Tests for core visualization functions."""
import pytest
import pandas as pd
import matplotlib.pyplot as plt
from mypackage.core import plot_data, save_figure

@pytest.fixture
def sample_data():
    """Create sample data for testing."""
    return pd.DataFrame({
        'x': [1, 2, 3, 4, 5],
        'y': [10, 15, 13, 17, 20]
    })

def test_plot_data_scatter(sample_data):
    """Test scatter plot creation."""
    fig = plot_data(sample_data, plot_type='scatter')
    assert isinstance(fig, plt.Figure)
    # Additional assertions...

def test_plot_data_invalid_type(sample_data):
    """Test error handling for invalid plot types."""
    with pytest.raises(ValueError):
        plot_data(sample_data, plot_type='invalid_type')

# More tests...</code></pre>
            
            <p><strong>scripts/run_analysis.py</strong> - Command-line script:</p>
            <pre><code>#!/usr/bin/env python3
"""
Script to run data analysis and generate visualizations.
"""
import argparse
import pandas as pd
from mypackage import load_data, preprocess_data, plot_data, save_figure

def main():
    parser = argparse.ArgumentParser(description='Generate data visualizations.')
    parser.add_argument('input_file', help='Input data file')
    parser.add_argument('output_file', help='Output image file')
    parser.add_argument('--plot-type', default='scatter', choices=['scatter', 'line', 'bar'],
                      help='Type of plot to generate')
    args = parser.parse_args()
    
    # Load and process data
    raw_data = load_data(args.input_file)
    data = preprocess_data(raw_data)
    
    # Create and save visualization
    fig = plot_data(data, plot_type=args.plot_type)
    save_figure(fig, args.output_file)
    print(f"Visualization saved to {args.output_file}")

if __name__ == "__main__":
    main()</code></pre>
            
            <p>This structure provides several advantages for medium-sized projects:</p>
            <ul>
                <li>Clear separation of concerns between modules</li>
                <li>Proper packaging allows the library to be installed and imported</li>
                <li>Tests are organized alongside the code they verify</li>
                <li>Command-line scripts provide user-friendly entry points</li>
                <li>Documentation is separated from code but lives in the repository</li>
            </ul>
        </section>

        <section class="large-project">
            <h3>Large-Scale Application Structure</h3>
            
            <p>For large applications, especially web applications, a more sophisticated structure helps manage complexity. Here's a typical layout for a Flask web application:</p>
            
            <pre><code>flask_project/
├── app/                    # Application package
│   ├── __init__.py         # App initialization
│   ├── config.py           # Configuration classes
│   ├── models/             # Database models
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── product.py
│   ├── routes/             # Route handlers
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── main.py
│   │   └── api.py
│   ├── templates/          # Jinja2 templates
│   │   ├── base.html
│   │   ├── auth/
│   │   └── main/
│   ├── static/             # Static assets
│   │   ├── css/
│   │   ├── js/
│   │   └── img/
│   ├── services/           # Business logic
│   │   ├── __init__.py
│   │   ├── auth_service.py
│   │   └── email_service.py
│   └── utils/              # Utility functions
│       ├── __init__.py
│       └── helpers.py
├── migrations/             # Database migrations
├── tests/                  # Test suite
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_models/
│   ├── test_routes/
│   └── test_services/
├── logs/                   # Application logs
├── scripts/                # Utility scripts
│   ├── deploy.sh
│   └── seed_db.py
├── docs/                   # Documentation
├── .env.example            # Environment variables template
├── .flaskenv               # Flask configurations
├── .gitignore              # Git ignore rules
├── requirements/
│   ├── base.txt            # Shared dependencies
│   ├── dev.txt             # Development dependencies
│   └── prod.txt            # Production dependencies
├── setup.py                # Package installation
├── wsgi.py                 # WSGI entry point
├── manage.py               # Command-line interface
├── README.md               # Project documentation
├── LICENSE                 # License information
└── docker-compose.yml      # Docker configuration</code></pre>
            
            <p>Key features of this structure:</p>
            <ul>
                <li>Highly modular organization by functionality</li>
                <li>Separation of business logic, models, and routes</li>
                <li>Templates and static assets for web interface</li>
                <li>Support for database migrations</li>
                <li>Comprehensive test organization</li>
                <li>DevOps configurations (Docker, deployment scripts)</li>
                <li>Environment-specific requirements</li>
            </ul>
            
            <p>Let's look at some example files from this structure:</p>
            
            <p><strong>app/__init__.py</strong> - Application factory:</p>
            <pre><code>"""Flask application factory module."""
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_login import LoginManager

# Initialize extensions
db = SQLAlchemy()
migrate = Migrate()
login_manager = LoginManager()

def create_app(config_name='development'):
    """Create and configure the Flask application."""
    app = Flask(__name__)
    
    # Load configuration
    from app.config import config
    app.config.from_object(config[config_name])
    
    # Initialize extensions
    db.init_app(app)
    migrate.init_app(app, db)
    login_manager.init_app(app)
    
    # Set up login manager
    from app.models.user import User
    login_manager.login_view = 'auth.login'
    
    @login_manager.user_loader
    def load_user(user_id):
        return User.query.get(int(user_id))
    
    # Register blueprints
    from app.routes.main import main_bp
    from app.routes.auth import auth_bp
    from app.routes.api import api_bp
    
    app.register_blueprint(main_bp)
    app.register_blueprint(auth_bp, url_prefix='/auth')
    app.register_blueprint(api_bp, url_prefix='/api')
    
    # Register error handlers
    from app.routes import errors
    errors.register_handlers(app)
    
    return app</code></pre>
            
            <p><strong>app/config.py</strong> - Configuration classes:</p>
            <pre><code>"""Application configuration module."""
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

class Config:
    """Base configuration class."""
    SECRET_KEY = os.environ.get('SECRET_KEY', 'dev-key-please-change')
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL', 'sqlite:///app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    MAIL_SERVER = os.environ.get('MAIL_SERVER', 'smtp.example.com')
    MAIL_PORT = int(os.environ.get('MAIL_PORT', 587))
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'true').lower() == 'true'
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    MAIL_DEFAULT_SENDER = os.environ.get('MAIL_DEFAULT_SENDER', 'noreply@example.com')

class DevelopmentConfig(Config):
    """Development configuration."""
    DEBUG = True
    SQLALCHEMY_ECHO = True

class TestingConfig(Config):
    """Testing configuration."""
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
    WTF_CSRF_ENABLED = False

class ProductionConfig(Config):
    """Production configuration."""
    DEBUG = False
    # Add production-specific settings here

# Configuration dictionary
config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}</code></pre>
            
            <p><strong>app/models/user.py</strong> - User model:</p>
            <pre><code>"""User model module."""
from datetime import datetime
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash
from app import db

class User(db.Model, UserMixin):
    """User model for authentication and profile information."""
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    email = db.Column(db.String(120), unique=True, index=True)
    password_hash = db.Column(db.String(128))
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships
    # posts = db.relationship('Post', backref='author', lazy='dynamic')
    
    def __repr__(self):
        return f'<User {self.username}>'
    
    def set_password(self, password):
        """Set the user's password hash."""
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        """Check if the provided password matches the hash."""
        return check_password_hash(self.password_hash, password)</code></pre>
            
            <p><strong>app/routes/auth.py</strong> - Authentication routes:</p>
            <pre><code>"""Authentication routes."""
from flask import Blueprint, render_template, redirect, url_for, flash, request
from flask_login import login_user, logout_user, current_user, login_required
from app.models.user import User
from app.services.auth_service import register_user
from app.forms.auth import LoginForm, RegistrationForm

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    """User login view."""
    if current_user.is_authenticated:
        return redirect(url_for('main.index'))
    
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.check_password(form.password.data):
            flash('Invalid username or password')
            return redirect(url_for('auth.login'))
        
        login_user(user, remember=form.remember_me.data)
        next_page = request.args.get('next')
        if not next_page or not next_page.startswith('/'):
            next_page = url_for('main.index')
        return redirect(next_page)
    
    return render_template('auth/login.html', title='Sign In', form=form)

@auth_bp.route('/logout')
def logout():
    """User logout view."""
    logout_user()
    return redirect(url_for('main.index'))

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    """User registration view."""
    if current_user.is_authenticated:
        return redirect(url_for('main.index'))
    
    form = RegistrationForm()
    if form.validate_on_submit():
        user = register_user(
            username=form.username.data,
            email=form.email.data,
            password=form.password.data
        )
        flash('Congratulations, you are now a registered user!')
        return redirect(url_for('auth.login'))
    
    return render_template('auth/register.html', title='Register', form=form)</code></pre>
            
            <p><strong>app/services/auth_service.py</strong> - Authentication service:</p>
            <pre><code>"""Authentication service module."""
from app import db
from app.models.user import User
from app.services.email_service import send_welcome_email

def register_user(username, email, password):
    """
    Register a new user.
    
    Args:
        username: User's username
        email: User's email address
        password: User's password
    
    Returns:
        User: The created user object
    """
    user = User(username=username, email=email)
    user.set_password(password)
    
    db.session.add(user)
    db.session.commit()
    
    # Send welcome email asynchronously
    send_welcome_email(user)
    
    return user

def verify_user_email(user_id, token):
    """
    Verify a user's email address.
    
    Args:
        user_id: ID of the user
        token: Email verification token
    
    Returns:
        bool: True if verification succeeded, False otherwise
    """
    user = User.query.get(user_id)
    if not user:
        return False
    
    # Verify token logic...
    user.email_verified = True
    db.session.commit()
    
    return True</code></pre>
            
            <p><strong>wsgi.py</strong> - WSGI entry point:</p>
            <pre><code>"""WSGI entry point for the application."""
from app import create_app

app = create_app('production')

if __name__ == '__main__':
    app.run()</code></pre>
            
            <p><strong>manage.py</strong> - Command-line interface:</p>
            <pre><code>#!/usr/bin/env python
"""Management script for the application."""
import os
import click
from flask.cli import FlaskGroup
from app import create_app, db
from app.models.user import User

app = create_app(os.getenv('FLASK_ENV', 'development'))

cli = FlaskGroup(app)

@cli.command('create_admin')
@click.argument('username')
@click.argument('email')
@click.password_option()
def create_admin(username, email, password):
    """Create an admin user."""
    user = User(username=username, email=email, is_admin=True)
    user.set_password(password)
    db.session.add(user)
    db.session.commit()
    click.echo(f'Admin user {username} created.')

@cli.command('reset_db')
@click.confirmation_option(prompt='Are you sure you want to reset the database?')
def reset_db():
    """Reset the database."""
    db.drop_all()
    db.create_all()
    click.echo('Database has been reset.')

if __name__ == '__main__':
    cli()</code></pre>
            
            <p>The large-scale structure provides these advantages:</p>
            <ul>
                <li>Highly modular with clear separation of concerns</li>
                <li>Routes, models, services, and utilities are distinct</li>
                <li>The application factory pattern enables different configurations</li>
                <li>Multiple entry points for different use cases (WSGI, CLI)</li>
                <li>Blueprints organize routes by feature</li>
                <li>Services layer isolates business logic from routes</li>
            </ul>
        </section>

        <section class="domain-driven-design">
            <h3>Advanced Structure: Domain-Driven Design</h3>
            
            <p>For very large and complex applications, especially those with multiple developers or teams, Domain-Driven Design (DDD) offers a powerful organizing principle. In DDD, the codebase is organized around business domains rather than technical layers:</p>
            
            <pre><code>ddd_project/
├── src/
│   ├── users/              # User domain
│   │   ├── __init__.py
│   │   ├── models.py       # User domain models
│   │   ├── repositories.py # User data access
│   │   ├── services.py     # User business logic
│   │   └── routes.py       # User API endpoints
│   ├── products/           # Product domain
│   │   ├── __init__.py
│   │   ├── models.py
│   │   ├── repositories.py
│   │   ├── services.py
│   │   └── routes.py
│   ├── orders/             # Order domain
│   │   ├── __init__.py
│   │   ├── models.py
│   │   ├── repositories.py
│   │   ├── services.py
│   │   └── routes.py
│   └── shared/             # Shared components
│       ├── __init__.py
│       ├── database.py     # Database connection
│       ├── security.py     # Security utilities
│       └── utils.py        # Common utilities
├── app/                    # Application assembly
│   ├── __init__.py
│   ├── config.py           # Configuration
│   ├── api.py              # API initialization
│   └── cli.py              # CLI commands
├── tests/                  # Tests by domain
│   ├── users/
│   ├── products/
│   └── orders/
└── infrastructure/         # Infrastructure concerns
    ├── database/           # Database scripts
    ├── logging/            # Logging configuration
    └── messaging/          # Message queue setup</code></pre>
            
            <p>In this structure:</p>
            <ul>
                <li>Each domain module contains all the code related to that domain, regardless of type (models, services, etc.)</li>
                <li>The shared module contains code used across domains</li>
                <li>The app module wires everything together</li>
                <li>The infrastructure module handles technical concerns</li>
            </ul>
            
            <p>DDD shines in complex applications where:</p>
            <ul>
                <li>The business domain is complex with many rules and processes</li>
                <li>Multiple teams work on different parts of the application</li>
                <li>Different parts of the system evolve at different rates</li>
                <li>Long-term maintainability is crucial</li>
            </ul>
            
            <p>This structure facilitates:</p>
            <ul>
                <li>Better alignment with business domains</li>
                <li>Clearer boundaries between system components</li>
                <li>Easier parallel development by multiple teams</li>
                <li>More focused testing of domain logic</li>
            </ul>
        </section>

        <section class="structure-recommendations">
            <h3>Choosing the Right Structure</h3>
            
            <p>Selecting the appropriate project structure depends on several factors:</p>
            
            <h4>Project Size and Complexity</h4>
            <table>
                <tr>
                    <th>Size</th>
                    <th>Characteristics</th>
                    <th>Recommended Structure</th>
                </tr>
                <tr>
                    <td>Small</td>
                    <td>
                        <ul>
                            <li>&lt; 1,000 lines of code</li>
                            <li>Single purpose</li>
                            <li>1-2 developers</li>
                        </ul>
                    </td>
                    <td>Simple script structure</td>
                </tr>
                <tr>
                    <td>Medium</td>
                    <td>
                        <ul>
                            <li>1,000 - 10,000 lines of code</li>
                            <li>Multiple features</li>
                            <li>Small team</li>
                        </ul>
                    </td>
                    <td>Package-based structure</td>
                </tr>
                <tr>
                    <td>Large</td>
                    <td>
                        <ul>
                            <li>10,000+ lines of code</li>
                            <li>Many features</li>
                            <li>Multiple developers</li>
                        </ul>
                    </td>
                    <td>Application structure or DDD</td>
                </tr>
            </table>
            
            <h4>Project Type</h4>
            <table>
                <tr>
                    <th>Type</th>
                    <th>Recommended Structure</th>
                </tr>
                <tr>
                    <td>Command-line tool</td>
                    <td>Simple or medium structure with scripts/ directory</td>
                </tr>
                <tr>
                    <td>Library/package</td>
                    <td>Medium structure with clear API</td>
                </tr>
                <tr>
                    <td>Web application</td>
                    <td>Large application structure</td>
                </tr>
                <tr>
                    <td>Enterprise application</td>
                    <td>Domain-driven design</td>
                </tr>
            </table>
            
            <h4>Team Considerations</h4>
            <ul>
                <li><strong>Team Size:</strong> Larger teams need more structure to coordinate effectively</li>
                <li><strong>Team Experience:</strong> Less experienced teams may benefit from more prescriptive structures</li>
                <li><strong>Team Organization:</strong> If teams are organized by feature, DDD may align better</li>
            </ul>
            
            <h4>Evolution Strategy</h4>
            <p>It's important to remember that project structure can evolve as your application grows:</p>
            <ol>
                <li>Start with a simple structure suitable for your current needs</li>
                <li>As complexity increases, refactor toward a more structured organization</li>
                <li>Follow the principle of "emergent design" rather than over-engineering initially</li>
            </ol>
            
            <p><strong>Tip:</strong> For new projects, choose a structure that's slightly more sophisticated than what you think you need. This provides room to grow without requiring immediate restructuring.</p>
        </section>

        <section class="best-practices">
            <h3>Project Structure Best Practices</h3>
            
            <p>Regardless of the specific structure you choose, these best practices will help keep your project organized and maintainable:</p>
            
            <h4>1. Follow the Single Responsibility Principle</h4>
            <p>Each module or package should have a single, well-defined purpose. If a module is doing too many things, it's time to split it.</p>
            
            <p><strong>Good:</strong> Separate <code>auth_service.py</code>, <code>email_service.py</code>, and <code>payment_service.py</code></p>
            <p><strong>Bad:</strong> A single <code>services.py</code> with all service functions mixed together</p>
            
            <h4>2. Keep Related Files Together</h4>
            <p>Files that change together should be located near each other in the directory structure.</p>
            
            <p><strong>Good:</strong> Putting user model, repository, service, and routes in a <code>users/</code> package</p>
            <p><strong>Bad:</strong> Spreading user-related code across many different directories based solely on type</p>
            
            <h4>3. Create Clear API Boundaries</h4>
            <p>Make it obvious what parts of your code are public interfaces vs. internal implementation details.</p>
            
            <p><strong>Good:</strong> Using <code>__init__.py</code> to expose only the public interface, using underscore prefixes for internal functions</p>
            <p><strong>Bad:</strong> No clear distinction between public and private components</p>
            
            <h4>4. Separate Configuration from Code</h4>
            <p>Configuration settings should be separated from application logic.</p>
            
            <p><strong>Good:</strong> Using environment variables, config files, or a dedicated <code>config.py</code> module</p>
            <p><strong>Bad:</strong> Hardcoding configuration values throughout the codebase</p>
            
            <h4>5. Keep the Root Directory Clean</h4>
            <p>The project root should contain only high-level files and directories.</p>
            
            <p><strong>Good:</strong> Moving implementation details into subdirectories, keeping only essential files at the root</p>
            <p><strong>Bad:</strong> Dozens of Python files in the root directory</p>
            
            <h4>6. Use Common Conventions</h4>
            <p>Follow established naming and organization conventions to make your project more approachable.</p>
            
            <p><strong>Good:</strong> Using standard names like <code>tests/</code>, <code>docs/</code>, and <code>README.md</code></p>
            <p><strong>Bad:</strong> Inventing unique naming schemes that deviate from community standards</p>
            
            <h4>7. Include Essential Project Files</h4>
            <p>Every project should include certain standard files.</p>
            
            <p><strong>Essential files:</strong></p>
            <ul>
                <li><code>README.md</code> - Project overview, installation instructions, basic usage examples</li>
                <li><code>LICENSE</code> - The project's license terms</li>
                <li><code>requirements.txt</code> or equivalent - Project dependencies</li>
                <li><code>.gitignore</code> - Files for Git to ignore</li>
                <li>Setup or build script (<code>setup.py</code>, <code>pyproject.toml</code>, etc.)</li>
            </ul>
            
            <h4>8. Document Your Structure</h4>
            <p>Make sure new team members can understand your project organization.</p>
            
            <p><strong>Good:</strong> Including a "Project Structure" section in your README or documentation</p>
            <p><strong>Bad:</strong> Assuming others will intuitively understand your organization</p>
            
            <h4>9. Test Directory Structure Should Mirror Source</h4>
            <p>Organize tests to reflect the structure of the code they test.</p>
            
            <p><strong>Good:</strong> If you have <code>app/models/user.py</code>, create <code>tests/test_models/test_user.py</code></p>
            <p><strong>Bad:</strong> Test organization that doesn't correspond to the source structure</p>
            
            <h4>10. Use Consistent Import Style</h4>
            <p>Establish and follow consistent rules for imports within your project.</p>
            
            <p><strong>Good:</strong> Using absolute imports from the project root for clarity</p>
            <p><strong>Bad:</strong> Mixing absolute and relative imports inconsistently</p>
        </section>

        <section class="common-patterns">
            <h3>Common Structure Patterns</h3>
            
            <p>Several structural patterns appear across many Python projects. Understanding these can help you recognize and apply common organizational strategies:</p>
            
            <h4>1. Application Factory Pattern</h4>
            <p>Creating the application object via a factory function rather than globally. This pattern is especially common in Flask applications.</p>
            
            <pre><code># app/__init__.py
def create_app(config_name='development'):
    app = Flask(__name__)
    # Configure the app
    # Register extensions, blueprints, etc.
    return app</code></pre>
            
            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Enables different configurations for different environments</li>
                <li>Simplifies testing by allowing test-specific configurations</li>
                <li>Avoids circular import issues</li>
            </ul>
            
            <h4>2. Blueprint Pattern</h4>
            <p>Organizing routes into modular components, often by feature area. Common in Flask and similar frameworks.</p>
            
            <pre><code># app/routes/auth.py
auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login')
def login():
    # Login logic

# app/__init__.py
from app.routes.auth import auth_bp
app.register_blueprint(auth_bp, url_prefix='/auth')</code></pre>
            
            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Modular organization of routes</li>
                <li>Separate URL prefixes for different areas</li>
                <li>Enables parallel development</li>
            </ul>
            
            <h4>3. Repository Pattern</h4>
            <p>Abstracting data access behind repository interfaces.</p>
            
            <pre><code># app/repositories/user_repository.py
class UserRepository:
    def get_by_id(self, user_id):
        # Query the database
        return User.query.get(user_id)
    
    def create(self, user_data):
        # Create a new user
        user = User(**user_data)
        db.session.add(user)
        db.session.commit()
        return user</code></pre>
            
            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Abstracts data access details from business logic</li>
                <li>Makes testing easier through mocking</li>
                <li>Allows changing the data storage mechanism without affecting other code</li>
            </ul>
            
            <h4>4. Service Layer Pattern</h4>
            <p>Encapsulating business logic in service modules separate from routes and models.</p>
            
            <pre><code># app/services/auth_service.py
def authenticate_user(username, password):
    user = User.query.filter_by(username=username).first()
    if user and user.check_password(password):
        return user
    return None

def register_user(username, email, password):
    user = User(username=username, email=email)
    user.set_password(password)
    db.session.add(user)
    db.session.commit()
    send_welcome_email(user)  # Side effect managed by service
    return user</code></pre>
            
            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Separates business logic from HTTP handling</li>
                <li>Makes business logic more testable</li>
                <li>Can be reused across different entry points (web, CLI, API)</li>
            </ul>
            
            <h4>5. Command Pattern</h4>
            <p>Encapsulating operations as command objects. Common in CLI-heavy applications and task queues.</p>
            
            <pre><code># app/commands/user_commands.py
class CreateUserCommand:
    def __init__(self, username, email, password):
        self.username = username
        self.email = email
        self.password = password
    
    def execute(self):
        user = User(username=self.username, email=self.email)
        user.set_password(self.password)
        db.session.add(user)
        db.session.commit()
        return user</code></pre>
            
            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Encapsulates operations in a clean way</li>
                <li>Enables features like command queuing, logging, and undo</li>
                <li>Simplifies complex operation sequences</li>
            </ul>
            
            <h4>6. Settings Module Pattern</h4>
            <p>Centralizing configuration in a dedicated module, often with environment-specific subclasses.</p>
            
            <pre><code># app/config.py
class Config:
    DEBUG = False
    SECRET_KEY = os.environ.get('SECRET_KEY', 'dev-key')
    
class DevelopmentConfig(Config):
    DEBUG = True
    
class ProductionConfig(Config):
    # Production-specific settings</code></pre>
            
            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Centralizes configuration</li>
                <li>Supports different environments</li>
                <li>Makes configuration explicit and documented</li>
            </ul>
        </section>

        <section class="tools">
            <h3>Tools for Project Structure Management</h3>
            
            <p>Several tools can help you create and maintain good project structures:</p>
            
            <h4>Project Templates</h4>
            <ul>
                <li><strong>cookiecutter</strong>: Generate projects from templates
                    <pre><code>pip install cookiecutter
cookiecutter https://github.com/audreyfeldroy/cookiecutter-pypackage</code></pre>
                </li>
                <li><strong>Framework CLI tools</strong>: Most frameworks have tools to generate projects
                    <pre><code>django-admin startproject myproject
flask create-app --name myapp</code></pre>
                </li>
            </ul>
            
            <h4>Code Quality Tools</h4>
            <ul>
                <li><strong>pylint</strong>: Check code quality and enforces structure conventions
                    <pre><code>pip install pylint
pylint mypackage</code></pre>
                </li>
                <li><strong>flake8</strong>: Similar to pylint but more focused on style
                    <pre><code>pip install flake8
flake8 mypackage</code></pre>
                </li>
                <li><strong>black</strong>: Automatic code formatting
                    <pre><code>pip install black
black mypackage</code></pre>
                </li>
                <li><strong>isort</strong>: Organize imports consistently
                    <pre><code>pip install isort
isort mypackage</code></pre>
                </li>
            </ul>
            
            <h4>Documentation Tools</h4>
            <ul>
                <li><strong>Sphinx</strong>: Generate documentation from docstrings
                    <pre><code>pip install sphinx
sphinx-quickstart</code></pre>
                </li>
                <li><strong>mkdocs</strong>: Simpler Markdown-based documentation
                    <pre><code>pip install mkdocs
mkdocs new myproject</code></pre>
                </li>
            </ul>
            
            <h4>Project Structure Analysis</h4>
            <ul>
                <li><strong>pyan3</strong>: Analyze and visualize dependencies
                    <pre><code>pip install pyan3
pyan3 mypackage/*.py --dot > deps.dot
dot -Tpng deps.dot -o deps.png</code></pre>
                </li>
                <li><strong>pipdeptree</strong>: Visualize package dependencies
                    <pre><code>pip install pipdeptree
pipdeptree</code></pre>
                </li>
            </ul>
        </section>

        <section class="real-world-examples">
            <h3>Real-World Examples</h3>
            
            <p>Examining popular open-source projects can provide valuable insights into effective project structures. Here are some notable examples:</p>
            
            <h4>Flask (Web Framework)</h4>
            <p>Flask uses a simple, package-based structure that's easy to understand:</p>
            <pre><code>flask/
├── docs/                 # Documentation
├── examples/             # Example applications
├── src/
│   └── flask/            # Main package
│       ├── __init__.py   # Public API
│       ├── app.py        # Application object
│       ├── blueprints.py # Blueprint support
│       ├── cli.py        # Command-line interface
│       ├── config.py     # Configuration handling
│       ├── globals.py    # Global objects
│       ├── sessions.py   # Session handling
│       ├── templating.py # Template support
│       └── ...           # Other modules
├── tests/                # Test suite
├── setup.py              # Package setup
└── pyproject.toml        # Project metadata</code></pre>
            
            <p><strong>Key Insights:</strong></p>
            <ul>
                <li>Clear separation of public API in __init__.py</li>
                <li>Modules organized by functionality</li>
                <li>Tests separate from source code</li>
                <li>Examples directory for learning</li>
            </ul>
            
            <h4>Django (Web Framework)</h4>
            <p>Django uses a more complex structure reflecting its larger scope:</p>
            <pre><code>django/
├── django/              # Main package
│   ├── __init__.py
│   ├── apps/            # Application registry
│   ├── conf/            # Settings and configuration
│   ├── contrib/         # Bundled apps (admin, auth, etc.)
│   ├── core/            # Core functionality
│   ├── db/              # Database layer
│   ├── http/            # HTTP handling
│   ├── template/        # Template system
│   ├── urls/            # URL routing
│   ├── utils/           # Utilities
│   └── views/           # View functions
├── docs/                # Documentation
├── tests/               # Test suite
├── scripts/             # Utility scripts
└── setup.py             # Package setup</code></pre>
            
            <p><strong>Key Insights:</strong></p>
            <ul>
                <li>Highly modular with clear boundaries</li>
                <li>Separation of core framework from bundled apps</li>
                <li>Utils package for shared functionality</li>
                <li>Each area of functionality has its own package</li>
            </ul>
            
            <h4>Requests (HTTP Library)</h4>
            <p>Requests uses a simpler structure appropriate for its focused purpose:</p>
            <pre><code>requests/
├── requests/            # Main package
│   ├── __init__.py      # Public API
│   ├── api.py           # API functionality
│   ├── models.py        # Data models
│   ├── sessions.py      # Session handling
│   ├── structures.py    # Data structures
│   └── utils.py         # Utilities
├── docs/                # Documentation
├── tests/               # Test suite
└── setup.py             # Package setup</code></pre>
            
            <p><strong>Key Insights:</strong></p>
            <ul>
                <li>Simple flat structure for a focused library</li>
                <li>Clear separation of concerns between modules</li>
                <li>Public API exposed in __init__.py</li>
                <li>Comprehensive test suite</li>
            </ul>
            
            <h4>SQLAlchemy (ORM Library)</h4>
            <p>SQLAlchemy uses a more complex structure suitable for its comprehensive nature:</p>
            <pre><code>sqlalchemy/
├── lib/
│   └── sqlalchemy/     # Main package
│       ├── __init__.py
│       ├── engine/     # Database engine
│       ├── ext/        # Extensions
│       ├── orm/        # Object-relational mapping
│       ├── sql/        # SQL expression language
│       └── ...         # Other modules
├── doc/                # Documentation
├── test/               # Test suite
├── examples/           # Example applications
└── setup.py            # Package setup</code></pre>
            
            <p><strong>Key Insights:</strong></p>
            <ul>
                <li>Hierarchical structure for a complex library</li>
                <li>Clear separation between core components (engine, ORM, etc.)</li>
                <li>Extensions in a separate package</li>
                <li>Examples provided for learning</li>
            </ul>
        </section>

        <section class="exercise">
            <h3>Exercise: Refactoring a Project Structure</h3>
            
            <p>Let's practice by refactoring a poorly structured project into a well-organized one:</p>
            
            <h4>Original Structure (Poorly Organized)</h4>
            <pre><code>messy_project/
├── app.py               # Contains everything: models, routes, business logic
├── utils.py             # Miscellaneous utilities
├── templates/           # HTML templates
├── static/              # Static assets
├── test.py              # All tests in one file
└── requirements.txt     # Dependencies</code></pre>
            
            <p>The <code>app.py</code> file is over 2,000 lines long and contains:</p>
            <ul>
                <li>Database models</li>
                <li>Route handlers</li>
                <li>Business logic</li>
                <li>Authentication code</li>
                <li>Utility functions</li>
                <li>Configuration settings</li>
            </ul>
            
            <h4>Task: Refactor this into a well-structured Flask application</h4>
            
            <h4>Steps:</h4>
            <ol>
                <li>Create a proper package structure</li>
                <li>Separate models, views, and business logic</li>
                <li>Organize templates and static files</li>
                <li>Move configuration to a dedicated module</li>
                <li>Structure tests properly</li>
                <li>Add necessary project files</li>
            </ol>
            
            <h4>Target Structure:</h4>
            <pre><code>organized_project/
├── app/                  # Application package
│   ├── __init__.py       # Application factory
│   ├── config.py         # Configuration
│   ├── models/           # Database models
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── item.py
│   ├── routes/           # Route handlers
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   └── main.py
│   ├── services/         # Business logic
│   │   ├── __init__.py
│   │   └── item_service.py
│   ├── templates/        # HTML templates
│   │   ├── base.html
│   │   ├── auth/
│   │   └── main/
│   ├── static/           # Static assets
│   │   ├── css/
│   │   ├── js/
│   │   └── img/
│   └── utils/            # Utilities
│       ├── __init__.py
│       └── helpers.py
├── tests/                # Test suite
│   ├── __init__.py
│   ├── conftest.py       # Test fixtures
│   ├── test_models/
│   ├── test_routes/
│   └── test_services/
├── .env.example          # Environment variables template
├── .gitignore            # Git ignore rules
├── README.md             # Project documentation
├── requirements.txt      # Dependencies
└── wsgi.py               # WSGI entry point</code></pre>
            
            <h4>Implementation Steps</h4>
            
            <ol>
                <li><strong>Create the directory structure</strong>
                    <pre><code># Create directories
mkdir -p organized_project/app/{models,routes,services,templates/{auth,main},static/{css,js,img},utils}
mkdir -p organized_project/tests/{test_models,test_routes,test_services}
touch organized_project/app/{__init__.py,config.py}
touch organized_project/app/{models,routes,services,utils}/__init__.py
touch organized_project/tests/{__init__.py,conftest.py}
touch organized_project/{.env.example,.gitignore,README.md,requirements.txt,wsgi.py}</code></pre>
                </li>
                
                <li><strong>Extract models from app.py</strong>
                    <pre><code># Extract user model
# From app.py:
# class User(db.Model):
#     ...
# Create app/models/user.py:
"""User model module."""
from app import db
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash

class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    # ...

# Extract item model
# Create app/models/item.py
"""Item model module."""
from app import db
from datetime import datetime

class Item(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    # ...</code></pre>
                </li>
                
                <li><strong>Extract routes from app.py</strong>
                    <pre><code># Extract auth routes
# Create app/routes/auth.py
"""Authentication routes."""
from flask import Blueprint, render_template, redirect, url_for, flash, request
from flask_login import login_user, logout_user, current_user, login_required
from app.models.user import User
from app.services.auth_service import register_user
from app.forms.auth import LoginForm, RegistrationForm

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    # Login logic...

# Extract main routes
# Create app/routes/main.py
"""Main application routes."""
from flask import Blueprint, render_template, request
from flask_login import login_required
from app.models.item import Item
from app.services.item_service import get_items, create_item

main_bp = Blueprint('main', __name__)

@main_bp.route('/')
def index():
    # Homepage logic...</code></pre>
                </li>
                
                <li><strong>Extract business logic to services</strong>
                    <pre><code># Create app/services/item_service.py
"""Item service module for business
