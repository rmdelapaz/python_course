<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Object-Oriented Programming Concepts</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Introduction to Object-Oriented Programming Concepts</h1>
        <h2>Week 3: Monday Morning Session</h2>
    </header>

    <main>
        <section class="lesson-intro">
            <h3>Lesson Overview</h3>
            <p>Welcome to Week 3! After spending two weeks building a strong foundation in Python fundamentals, we're now ready to explore one of the most powerful programming paradigms: Object-Oriented Programming (OOP). Today's morning session will introduce the core concepts of OOP and prepare you for the afternoon practical session where you'll begin creating your own classes and objects.</p>
            

        </section>

        <section>
            <h3>What is Object-Oriented Programming?</h3>
            <p>Object-Oriented Programming is a programming paradigm (a style of organizing code) based on the concept of "objects" which can contain data and code: data in the form of attributes (also known as properties), and code, in the form of methods (functions).</p>
            
            <p>To understand OOP, let's first consider the world around us. Everything in the physical world can be thought of as an "object" with:</p>
            <ul>
                <li><strong>Properties</strong> (what the object has or is) - like color, size, or state</li>
                <li><strong>Behaviors</strong> (what the object can do) - like move, make sound, or transform</li>
            </ul>
            
            <p>For example, consider a car:</p>
            <ul>
                <li><strong>Properties:</strong> color, make, model, current speed, fuel level</li>
                <li><strong>Behaviors:</strong> accelerate, brake, turn, honk horn</li>
            </ul>
            
            <p>OOP allows us to model software in a similar way, creating virtual "objects" that mimic real-world entities or abstract concepts with their own properties and behaviors.</p>

            <div class="concept-highlight">
                <p><strong>Real-world analogy:</strong> Think of a blueprint for a house. The blueprint itself isn't a house—it's a template that defines what a house of that type will look like. From a single blueprint, you can build multiple identical houses. In OOP, a class is like a blueprint, and objects are like the actual houses built from that blueprint.</p>
            </div>
        </section>

        <section>
            <h3>Why Use Object-Oriented Programming?</h3>
            <p>Before diving deeper into OOP concepts, let's understand why it became such a popular paradigm:</p>
            
            <ul>
                <li><strong>Organization:</strong> OOP helps organize code in a way that mirrors how we think about the world</li>
                <li><strong>Reusability:</strong> Once you create a class, you can reuse it throughout your program or in other programs</li>
                <li><strong>Encapsulation:</strong> OOP allows you to hide the complex implementation details while presenting a simple interface</li>
                <li><strong>Maintenance:</strong> Changes to one part of the code are less likely to break other parts</li>
                <li><strong>Scalability:</strong> As your program grows, OOP principles help manage complexity</li>
            </ul>
            
            <p><strong>Real-world example:</strong> Consider how libraries organize books. Without organization (like OOP), finding a specific book would require searching through every book. With organization (books categorized by subject, author, etc.), finding a book becomes much easier. Similarly, OOP helps organize code for easier navigation and maintenance.</p>
        </section>

        <section>
            <h3>Core OOP Concepts</h3>
            
            <h4>Classes and Objects</h4>
            <p>A <strong>class</strong> is a blueprint for creating objects. It defines attributes and methods that will be common to all objects of that type.</p>
            
            <p>An <strong>object</strong> is an instance of a class. If a class is a blueprint, an object is the actual "thing" built from that blueprint.</p>
            
            <div class="code-example">
                <p>Basic Python class and object creation:</p>
                <pre><code># Define a class
class Dog:
    # Class attributes (shared by all instances)
    species = "Canis familiaris"
    
    # The __init__ method (constructor)
    def __init__(self, name, age):
        # Instance attributes (unique to each instance)
        self.name = name
        self.age = age
    
    # Instance method
    def bark(self):
        return f"{self.name} says Woof!"

# Create objects (instances of the Dog class)
buddy = Dog("Buddy", 5)
miles = Dog("Miles", 2)

# Access attributes
print(buddy.name)  # Output: Buddy
print(miles.age)   # Output: 2

# Call methods
print(buddy.bark())  # Output: Buddy says Woof!</code></pre>
            </div>
            
            <p><strong>Analogy:</strong> If Dog is a class, then your specific pet dog is an object. Your neighbor's dog is a different object of the same class. They share certain characteristics (they're both dogs), but have their own unique attributes (name, age, etc.).</p>
            
            <h4>Attributes and Methods</h4>
            <p><strong>Attributes</strong> are the properties or characteristics of an object. They represent the state of an object.</p>
            <ul>
                <li><strong>Class attributes:</strong> Shared by all instances of a class</li>
                <li><strong>Instance attributes:</strong> Unique to each object</li>
            </ul>
            
            <p><strong>Methods</strong> are functions defined inside a class that describe what an object can do.</p>
            
            <div class="concept-highlight">
                <p><strong>Practical example:</strong> In a banking application, you might have a <code>BankAccount</code> class with attributes like <code>account_number</code>, <code>owner_name</code>, and <code>balance</code>. Methods might include <code>deposit()</code>, <code>withdraw()</code>, and <code>get_statement()</code>.</p>
            </div>
            
            <h4>Constructors and Initialization</h4>
            <p>The <strong>constructor</strong> is a special method that gets called when you create a new object from a class. In Python, the constructor method is <code>__init__</code>.</p>
            
            <p>The constructor is used to initialize new objects with specific attribute values. It runs automatically when you create a new instance of a class.</p>
            
            <div class="code-example">
                <pre><code>class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

# The __init__ method runs automatically here
rect = Rectangle(10, 5)
print(rect.area())  # Output: 50</code></pre>
            </div>
            
            <p><strong>Analogy:</strong> Think of the constructor as the setup instructions for assembling furniture. When you buy a new bookshelf, you follow the setup instructions to prepare it for use. Similarly, the constructor prepares a new object for use by setting up its initial state.</p>
            
            <h4>The <code>self</code> Parameter</h4>
            <p>You might have noticed the <code>self</code> parameter in the class methods above. In Python, <code>self</code> refers to the instance of the class. It's a way for methods to reference and modify the object's attributes.</p>
            
            <p>When you call a method on an object, Python automatically passes the object as the first argument to the method.</p>
            
            <div class="concept-highlight">
                <p><strong>Important:</strong> The name <code>self</code> is just a convention. You could use any name, but it's strongly recommended to stick with <code>self</code> for readability and compatibility with other Python code.</p>
            </div>
            
            <div class="code-example">
                <pre><code>class Person:
    def __init__(self, name):
        self.name = name
    
    def greet(self):
        return f"Hello, my name is {self.name}"

alice = Person("Alice")
print(alice.greet())  # Output: Hello, my name is Alice

# What happens behind the scenes when you call alice.greet():
# It's equivalent to Person.greet(alice)</code></pre>
            </div>
        </section>

        <section>
            <h3>Instance vs. Class Variables</h3>
            <p>Python classes support two types of variables:</p>
            
            <h4>Instance Variables</h4>
            <p>Instance variables are unique to each instance of a class. They are defined inside methods, usually in the <code>__init__</code> method.</p>
            
            <h4>Class Variables</h4>
            <p>Class variables are shared by all instances of a class. They are defined outside any method, directly in the class.</p>
            
            <div class="code-example">
                <pre><code>class Dog:
    # Class variable
    species = "Canis familiaris"
    
    def __init__(self, name, age):
        # Instance variables
        self.name = name
        self.age = age

# All dogs share the species class variable
buddy = Dog("Buddy", 5)
miles = Dog("Miles", 2)

print(buddy.species)  # Output: Canis familiaris
print(miles.species)  # Output: Canis familiaris

# But each has its own name and age
print(buddy.name)  # Output: Buddy
print(miles.name)  # Output: Miles</code></pre>
            </div>
            
            <p><strong>Analogy:</strong> Think of a car factory. All cars from that factory might share certain characteristics (like the manufacturer name - a class variable), but each car has its own unique identification number, color, etc. (instance variables).</p>
            
            <div class="concept-highlight">
                <p><strong>Warning:</strong> Be careful with mutable class variables! If you have a class variable that's a mutable type (like a list or dictionary), modifying it from one instance will affect all instances.</p>
                
                <pre><code>class BadExample:
    # Class variable that's a mutable list
    items = []
    
    def add_item(self, item):
        self.items.append(item)

# This will cause unexpected behavior
obj1 = BadExample()
obj2 = BadExample()

obj1.add_item("apple")
print(obj2.items)  # Output: ['apple'] - obj2's list contains obj1's item!</code></pre>
            </div>
        </section>

        <section>
            <h3>The Four Pillars of OOP</h3>
            <p>There are four fundamental principles that make OOP powerful:</p>
            
            <h4>1. Encapsulation</h4>
            <p>Encapsulation is the bundling of data (attributes) and methods that operate on that data into a single unit (a class). It also involves restricting direct access to some of the object's components.</p>
            
            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Prevents external code from accidentally corrupting an object's internal state</li>
                <li>Simplifies the interface that others need to work with</li>
                <li>Allows you to change implementation details without affecting code that uses your class</li>
            </ul>
            
            <p><strong>Analogy:</strong> Think of a car's engine. As a driver, you don't need to understand the complex internal workings of the engine. You just need to know how to use the steering wheel, gas pedal, and brake. The engine's complexity is "encapsulated" away from you.</p>
            
            <p>In Python, encapsulation is achieved through conventions rather than strict access control:</p>
            <ul>
                <li>A single underscore prefix (e.g., <code>_variable</code>) indicates that the attribute is meant to be treated as private</li>
                <li>A double underscore prefix (e.g., <code>__variable</code>) enforces name mangling, making the attribute harder to access from outside the class</li>
            </ul>
            
            <div class="code-example">
                <pre><code>class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self._balance = balance  # "private" attribute
    
    def deposit(self, amount):
        if amount > 0:
            self._balance += amount
            return True
        return False
    
    def withdraw(self, amount):
        if 0 < amount <= self._balance:
            self._balance -= amount
            return True
        return False
    
    def get_balance(self):
        return self._balance

# Creating and using a BankAccount
account = BankAccount("Alice", 1000)
account.deposit(500)
print(account.get_balance())  # Output: 1500

# Direct access to _balance is discouraged
# account._balance = 1000000  # This would work but is bad practice</code></pre>
            </div>
            
            <p>In this example, we don't access or modify the <code>_balance</code> directly. Instead, we use the methods <code>deposit()</code>, <code>withdraw()</code>, and <code>get_balance()</code>. This way, we can enforce rules (like preventing negative deposits) and potentially add functionality in the future (like logging transactions) without changing the interface others use.</p>
            
            <h4>2. Inheritance</h4>
            <p>Inheritance allows a class to inherit attributes and methods from another class. The original class is called the parent or base class, and the inheriting class is called the child or derived class.</p>
            
            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Code reuse: Inherit common functionality from a parent class</li>
                <li>Express "is-a" relationships (a Car is a Vehicle)</li>
                <li>Create specialized versions of classes</li>
            </ul>
            
            <p><strong>Analogy:</strong> Think of biological inheritance. Children inherit traits from their parents but may also have unique traits of their own.</p>
            
            <p>We'll cover inheritance in depth in tomorrow morning's session, but here's a quick example:</p>
            
            <div class="code-example">
                <pre><code>class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return "Some generic animal sound"

class Dog(Animal):  # Dog inherits from Animal
    def speak(self):  # Overriding the speak method
        return "Woof!"

class Cat(Animal):  # Cat also inherits from Animal
    def speak(self):  # Overriding the speak method
        return "Meow!"

# Creating and using inherited classes
fido = Dog("Fido")
whiskers = Cat("Whiskers")

print(fido.name)       # Output: Fido (inherited from Animal)
print(fido.speak())    # Output: Woof! (overridden in Dog)
print(whiskers.speak())  # Output: Meow! (overridden in Cat)</code></pre>
            </div>
            
            <h4>3. Polymorphism</h4>
            <p>Polymorphism means "many forms" and refers to the ability to process objects differently depending on their class. It allows you to write code that can work with objects of different classes, as long as they support the same methods or attributes.</p>
            
            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Write more flexible and reusable code</li>
                <li>Use the same interface for different underlying forms (data types or classes)</li>
                <li>Implement "duck typing" - "If it walks like a duck and quacks like a duck, then it probably is a duck"</li>
            </ul>
            
            <p><strong>Analogy:</strong> Consider a universal remote control that can operate different brands of TVs. Each TV handles the "volume up" command differently internally, but the remote provides a consistent interface (button) for this command.</p>
            
            <div class="code-example">
                <pre><code># Continuing from the previous example
def make_animal_speak(animal):
    # This function works with any object that has a speak() method
    return animal.speak()

# We can pass different types of animals
print(make_animal_speak(fido))      # Output: Woof!
print(make_animal_speak(whiskers))  # Output: Meow!

# We can even create a new class and use it with the same function
class Cow(Animal):
    def speak(self):
        return "Moo!"

bessie = Cow("Bessie")
print(make_animal_speak(bessie))    # Output: Moo!</code></pre>
            </div>
            
            <p>In this example, <code>make_animal_speak()</code> doesn't care what type of animal it receives. It only cares that the object has a <code>speak()</code> method it can call. This is polymorphism in action.</p>
            
            <h4>4. Abstraction</h4>
            <p>Abstraction means hiding complex implementation details and showing only the necessary features of an object. It's similar to encapsulation but focuses more on the idea of providing a simple interface to complex systems.</p>
            
            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Reduces complexity by hiding unnecessary details</li>
                <li>Allows you to focus on what an object does rather than how it does it</li>
                <li>Makes code more maintainable and understandable</li>
            </ul>
            
            <p><strong>Analogy:</strong> Think about driving a car. You don't need to understand the complex internal combustion process to drive it. You just need to know how to use the steering wheel, pedals, and gears. The car's controls are an abstraction of its complex mechanics.</p>
            
            <p>In Python, abstraction can be achieved through abstract base classes (using the <code>abc</code> module) which we'll cover in tomorrow's session. For now, understand that abstraction is about focusing on the essential qualities of something rather than the specifics.</p>
        </section>

        <section>
            <h3>OOP in the Real World</h3>
            <p>Object-oriented programming isn't just an academic concept—it's used extensively in real-world applications:</p>
            
            <h4>Web Development</h4>
            <p>Frameworks like Django (which we'll cover in Week 10) use OOP extensively. For example, each database table is represented as a class, and each row as an object. The entire request-response cycle is handled through objects.</p>
            
            <h4>Game Development</h4>
            <p>Games use OOP to model characters, items, and environments. For example, a character class might have attributes like health and position, and methods like move() and attack().</p>
            
            <h4>Desktop Applications</h4>
            <p>GUI frameworks like PyQt or Tkinter use OOP to model windows, buttons, and other interface elements. Each widget is an object with its own properties and behaviors.</p>
            
            <h4>Data Science</h4>
            <p>Libraries like Pandas use OOP principles. A DataFrame is an object with methods for data manipulation, and each column can have its own data type with specific behaviors.</p>
            
            <div class="concept-highlight">
                <p><strong>Real-world example:</strong> Consider a content management system (CMS) for a blog. You might have classes for Articles, Users, Comments, and Categories. Each article is an object with attributes (title, content, publication date) and methods (publish, edit, delete). Users can create articles, leave comments, etc., each operation modeled as methods on the respective objects.</p>
            </div>
        </section>

        <section>
            <h3>Thinking in Objects: A Practical Exercise</h3>
            <p>Let's practice thinking in an object-oriented way by modeling a simple system:</p>
            
            <p><strong>Scenario:</strong> You're building a library management system.</p>
            
            <p><strong>Step 1: Identify the main entities (classes)</strong></p>
            <ul>
                <li>Book</li>
                <li>Member</li>
                <li>Library</li>
            </ul>
            
            <p><strong>Step 2: Define attributes for each class</strong></p>
            <ul>
                <li>Book: title, author, ISBN, publication_year, available</li>
                <li>Member: name, member_id, books_borrowed</li>
                <li>Library: name, books, members</li>
            </ul>
            
            <p><strong>Step 3: Define methods for each class</strong></p>
            <ul>
                <li>Book: check_out(), return_book(), is_available()</li>
                <li>Member: borrow_book(), return_book(), get_borrowed_books()</li>
                <li>Library: add_book(), add_member(), find_book_by_title(), checkout_book_to_member()</li>
            </ul>
            
            <p><strong>Step 4: Think about the relationships</strong></p>
            <ul>
                <li>A Library has many Books (one-to-many)</li>
                <li>A Library has many Members (one-to-many)</li>
                <li>A Member can borrow multiple Books, and a Book can be borrowed by one Member at a time (many-to-many with constraints)</li>
            </ul>
            
            <div class="code-example">
                <p>Here's a simplified implementation of our library system:</p>
                <pre><code>class Book:
    def __init__(self, title, author, isbn, publication_year):
        self.title = title
        self.author = author
        self.isbn = isbn
        self.publication_year = publication_year
        self.available = True
        self.borrower = None
    
    def check_out(self, member):
        if self.available:
            self.available = False
            self.borrower = member
            return True
        return False
    
    def return_book(self):
        if not self.available:
            self.available = True
            self.borrower = None
            return True
        return False
    
    def is_available(self):
        return self.available
    
    def __str__(self):
        return f"{self.title} by {self.author} ({self.publication_year})"


class Member:
    def __init__(self, name, member_id):
        self.name = name
        self.member_id = member_id
        self.books_borrowed = []
    
    def borrow_book(self, book):
        if book.check_out(self):
            self.books_borrowed.append(book)
            return True
        return False
    
    def return_book(self, book):
        if book in self.books_borrowed and book.return_book():
            self.books_borrowed.remove(book)
            return True
        return False
    
    def get_borrowed_books(self):
        return self.books_borrowed
    
    def __str__(self):
        return f"{self.name} (ID: {self.member_id})"


class Library:
    def __init__(self, name):
        self.name = name
        self.books = []
        self.members = []
    
    def add_book(self, book):
        self.books.append(book)
    
    def add_member(self, member):
        self.members.append(member)
    
    def find_book_by_title(self, title):
        for book in self.books:
            if book.title.lower() == title.lower():
                return book
        return None
    
    def find_member_by_id(self, member_id):
        for member in self.members:
            if member.member_id == member_id:
                return member
        return None
    
    def checkout_book_to_member(self, book_title, member_id):
        book = self.find_book_by_title(book_title)
        member = self.find_member_by_id(member_id)
        
        if book and member:
            return member.borrow_book(book)
        return False
    
    def __str__(self):
        return f"{self.name} Library with {len(self.books)} books and {len(self.members)} members"


# Using our library system
city_library = Library("City")

# Adding books
book1 = Book("The Hobbit", "J.R.R. Tolkien", "9780547928227", 1937)
book2 = Book("1984", "George Orwell", "9780451524935", 1949)
city_library.add_book(book1)
city_library.add_book(book2)

# Adding members
alice = Member("Alice Smith", "A123")
bob = Member("Bob Johnson", "B456")
city_library.add_member(alice)
city_library.add_member(bob)

# Borrowing books
alice.borrow_book(book1)
print(f"{alice.name} has borrowed: {alice.get_borrowed_books()[0]}")
print(f"Is '{book1.title}' available? {book1.is_available()}")

# Returning books
alice.return_book(book1)
print(f"After return, is '{book1.title}' available? {book1.is_available()}")

# Using the library's convenience methods
city_library.checkout_book_to_member("1984", "B456")
print(f"{bob.name} has borrowed: {bob.get_borrowed_books()[0]}")</code></pre>
            </div>
            
            <p>This example demonstrates several OOP concepts:</p>
            <ul>
                <li><strong>Classes and Objects:</strong> We defined three classes and created instances of each</li>
                <li><strong>Attributes:</strong> Each class has its own attributes (like title, name, etc.)</li>
                <li><strong>Methods:</strong> Each class has methods that operate on its data</li>
                <li><strong>Encapsulation:</strong> The internal workings of book borrowing are hidden behind simple method calls</li>
                <li><strong>Relationships:</strong> Objects refer to and interact with other objects</li>
            </ul>
        </section>

        <section>
            <h3>Common Pitfalls and Best Practices</h3>
            
            <h4>Pitfalls to Avoid</h4>
            <ul>
                <li><strong>Overusing OOP:</strong> Not every problem needs an object-oriented solution. Sometimes a simple function is all you need.</li>
                <li><strong>Creating "god objects":</strong> Classes that try to do too much violate the single responsibility principle.</li>
                <li><strong>Deep inheritance hierarchies:</strong> Too many levels of inheritance can make code hard to understand and maintain.</li>
                <li><strong>Ignoring encapsulation:</strong> Directly accessing or modifying attributes instead of using methods can lead to bugs.</li>
            </ul>
            
            <h4>Best Practices</h4>
            <ul>
                <li><strong>Keep classes focused:</strong> Each class should have a single responsibility.</li>
                <li><strong>Use meaningful names:</strong> Class names should be nouns, method names should be verbs.</li>
                <li><strong>Favor composition over inheritance:</strong> Instead of inheriting behavior, consider containing objects of other classes.</li>
                <li><strong>Document your classes:</strong> Use docstrings to explain the purpose of classes, methods, and attributes.</li>
                <li><strong>Follow Python conventions:</strong> Use PEP 8 style guidelines and naming conventions.</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Tip:</strong> When designing classes, ask yourself: "Does this class represent a single, coherent concept? Do these attributes and methods naturally belong together?"</p>
            </div>
        </section>

        <section>
            <h3>Conclusion</h3>
            <p>Today we've introduced the fundamental concepts of Object-Oriented Programming:</p>
            <ul>
                <li>Classes and objects</li>
                <li>Attributes and methods</li>
                <li>Constructors and the <code>self</code> parameter</li>
                <li>Instance vs. class variables</li>
                <li>The four pillars of OOP: encapsulation, inheritance, polymorphism, and abstraction</li>
            </ul>
            
            <p>In this afternoon's session, we'll put these concepts into practice by creating and using our own classes. Then, tomorrow, we'll dive deeper into more advanced OOP concepts like inheritance, method overriding, and abstract classes.</p>
            
            <p>Remember that OOP is a powerful tool, but it's just one approach to solving problems with code. The goal is not to use OOP everywhere, but to understand when and how to use it effectively to create clean, maintainable, and reusable code.</p>
            
            <div class="practice-exercise">
                <h4>Pre-Session Exercise</h4>
                <p>Before this afternoon's session, try to model a simple real-world system using OOP concepts. Think about:</p>
                <ol>
                    <li>What classes would you create?</li>
                    <li>What attributes would each class have?</li>
                    <li>What methods would each class need?</li>
                    <li>How would the classes interact with each other?</li>
                </ol>
                <p>Some ideas for systems to model: a restaurant ordering system, a social media platform, or a vehicle rental service.</p>
            </div>
        </section>

        <section class="additional-resources">
            <h3>Additional Resources</h3>
            <ul>
                <li><a href="https://docs.python.org/3/tutorial/classes.html" target="_blank">Python Official Documentation on Classes</a></li>
                <li><a href="https://realpython.com/python3-object-oriented-programming/" target="_blank">Real Python: OOP in Python 3</a></li>
                <li><a href="https://www.geeksforgeeks.org/object-oriented-programming-in-python/" target="_blank">GeeksforGeeks: OOP in Python</a></li>
                <li>Recommended Book: "Python 3 Object-Oriented Programming" by Dusty Phillips</li>
                <li>Recommended Book: "Head First Design Patterns" (for more advanced OOP concepts)</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
