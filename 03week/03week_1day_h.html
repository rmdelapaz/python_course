<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Method Implementation in Python</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Method Implementation in Python</h1>
        <h2>Week 3: Monday Afternoon Session</h2>
    </header>

    <main>
        <section class="introduction">
            <h3>Understanding Method Implementation</h3>
            <p>Welcome to our deep dive into method implementation in Python!</p>
            
            <p>Methods are the behaviors or actions that objects can perform. They define what an object can do and how it can interact with other objects. Creating well-designed methods is crucial for building effective object-oriented systems that are maintainable, reusable, and easy to understand.</p>
            
            <div class="concept-highlight">
                <p><strong>Real-world analogy:</strong> Think of a car. A car has various components (attributes) like the engine, wheels, and fuel tank, but it also has capabilities (methods) like accelerate(), brake(), and turn(). These methods define what the car can do, and they interact with the car's components to make things happen.</p>
            </div>
        </section>

        <section>
            <h3>Basic Method Structure</h3>
            
            <p>Let's start with the basic structure of a method in Python:</p>
            
            <div class="code-example">
                <pre><code>class Dog:
    def __init__(self, name, breed, age):
        self.name = name
        self.breed = breed
        self.age = age
        self.is_sitting = False
    
    def bark(self):
        """Make the dog bark."""
        return f"{self.name} says Woof!"
    
    def sit(self):
        """Make the dog sit down."""
        if self.is_sitting:
            return f"{self.name} is already sitting"
        else:
            self.is_sitting = True
            return f"{self.name} sits down"
    
    def stand(self):
        """Make the dog stand up."""
        if not self.is_sitting:
            return f"{self.name} is already standing"
        else:
            self.is_sitting = False
            return f"{self.name} stands up"
    
    def describe(self):
        """Return a description of the dog."""
        status = "sitting" if self.is_sitting else "standing"
        return f"{self.name} is a {self.age}-year-old {self.breed} who is currently {status}"</code></pre>
            </div>
            
            <p>Every method in a Python class follows this basic structure:</p>
            <ul>
                <li><strong>Method declaration:</strong> The <code>def</code> keyword followed by the method name and parameters</li>
                <li><strong>Self parameter:</strong> The first parameter is always <code>self</code>, which refers to the instance the method is called on</li>
                <li><strong>Docstring:</strong> A triple-quoted string that documents what the method does</li>
                <li><strong>Method body:</strong> The actual code that performs the method's function</li>
                <li><strong>Return value:</strong> Many methods return a value, though it's not required</li>
            </ul>
            
            <p>Let's see how to use these methods:</p>
            
            <div class="code-example">
                <pre><code># Create a dog
buddy = Dog("Buddy", "Golden Retriever", 3)

# Call methods
print(buddy.bark())       # Output: Buddy says Woof!
print(buddy.sit())        # Output: Buddy sits down
print(buddy.sit())        # Output: Buddy is already sitting
print(buddy.describe())   # Output: Buddy is a 3-year-old Golden Retriever who is currently sitting
print(buddy.stand())      # Output: Buddy stands up</code></pre>
            </div>
            
            <div class="concept-highlight">
                <p><strong>The <code>self</code> parameter:</strong> In every method, <code>self</code> refers to the specific instance the method is called on. It allows methods to access and modify the instance's attributes. When you call <code>buddy.sit()</code>, Python automatically passes <code>buddy</code> as the <code>self</code> parameter to the <code>sit</code> method.</p>
            </div>
        </section>

        <section>
            <h3>Types of Methods</h3>
            
            <p>Python supports several types of methods, each with its own purpose and behavior:</p>
            
            <h4>Instance Methods</h4>
            <p>These are the most common methods. They operate on instance data and can modify an instance's state. They take <code>self</code> as their first parameter, which automatically receives the instance when the method is called.</p>
            
            <h4>Class Methods</h4>
            <p>Class methods operate on class-level data rather than instance data. They are defined using the <code>@classmethod</code> decorator and take <code>cls</code> as their first parameter (a reference to the class itself, not an instance).</p>
            
            <h4>Static Methods</h4>
            <p>Static methods don't operate on either instance or class data. They are utility functions that are related to the class but don't need access to instance or class attributes. They are defined using the <code>@staticmethod</code> decorator and don't take <code>self</code> or <code>cls</code> as parameters.</p>
            
            <div class="code-example">
                <pre><code>class MathUtil:
    # Class variable
    pi = 3.14159265359
    
    def __init__(self, value):
        # Instance variable
        self.value = value
    
    # Instance method - operates on instance data (self.value)
    def square(self):
        """Return the square of the instance's value."""
        return self.value ** 2
    
    # Class method - operates on class data (cls.pi)
    @classmethod
    def circle_area(cls, radius):
        """Calculate the area of a circle with the given radius."""
        return cls.pi * radius ** 2
    
    # Static method - doesn't operate on instance or class data
    @staticmethod
    def add(x, y):
        """Add two numbers."""
        return x + y

# Using the different method types
math = MathUtil(5)
print(math.square())                # Instance method: 25
print(MathUtil.circle_area(3))      # Class method: 28.27...
print(MathUtil.add(10, 20))         # Static method: 30
print(math.add(10, 20))             # Static methods can also be called on instances: 30</code></pre>
            </div>
            
            <div class="concept-highlight">
                <p><strong>When to use each type:</strong></p>
                <ul>
                    <li>Use <strong>instance methods</strong> when you need to access or modify instance attributes or when the method's behavior depends on instance state.</li>
                    <li>Use <strong>class methods</strong> when you need to access or modify class attributes, or when you want to create an alternative constructor.</li>
                    <li>Use <strong>static methods</strong> when you want to include a utility function in your class that doesn't require access to instance or class data.</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Method Parameters and Arguments</h3>
            
            <p>Methods, like regular functions, can accept parameters that customize their behavior. Let's explore different parameter patterns:</p>
            
            <h4>Required Parameters</h4>
            <p>These are parameters that must be provided when calling the method.</p>
            
            <h4>Optional Parameters (Default Values)</h4>
            <p>These are parameters with default values, which can be omitted when calling the method.</p>
            
            <h4>Variable Numbers of Arguments</h4>
            <p>Methods can accept a variable number of positional arguments using <code>*args</code> or keyword arguments using <code>**kwargs</code>.</p>
            
            <div class="code-example">
                <pre><code>class ShoppingCart:
    def __init__(self):
        self.items = {}  # Dictionary to store items and quantities
    
    # Method with required parameters
    def add_item(self, item, price):
        """Add an item to the cart with quantity 1."""
        if item in self.items:
            self.items[item]['quantity'] += 1
        else:
            self.items[item] = {'price': price, 'quantity': 1}
        return f"Added {item} to cart"
    
    # Method with an optional parameter (default value)
    def update_quantity(self, item, quantity=1):
        """Update the quantity of an item in the cart."""
        if item not in self.items:
            return f"{item} not in cart"
        
        self.items[item]['quantity'] = quantity
        return f"Updated {item} quantity to {quantity}"
    
    # Method with variable arguments
    def add_multiple_items(self, *args, **kwargs):
        """Add multiple items to the cart.
        
        There are two ways to use this method:
        1. Pass (item, price) pairs as positional arguments: add_multiple_items("apple", 0.50, "banana", 0.30)
        2. Pass item=price keyword arguments: add_multiple_items(apple=0.50, banana=0.30)
        """
        # Process positional arguments (item, price pairs)
        if args:
            if len(args) % 2 != 0:
                return "Positional arguments must be (item, price) pairs"
            
            for i in range(0, len(args), 2):
                item, price = args[i], args[i+1]
                self.add_item(item, price)
        
        # Process keyword arguments (item=price)
        for item, price in kwargs.items():
            self.add_item(item, price)
        
        return f"Added {(len(args) // 2) + len(kwargs)} items to cart"
    
    def get_total(self):
        """Calculate the total price of all items in the cart."""
        total = 0
        for item, details in self.items.items():
            total += details['price'] * details['quantity']
        return total
    
    def display(self):
        """Display the cart contents."""
        if not self.items:
            return "Cart is empty"
        
        result = ["Shopping Cart:"]
        for item, details in self.items.items():
            subtotal = details['price'] * details['quantity']
            result.append(f"{item}: {details['quantity']} x ${details['price']:.2f} = ${subtotal:.2f}")
        
        result.append(f"Total: ${self.get_total():.2f}")
        return "\n".join(result)

# Using the ShoppingCart
cart = ShoppingCart()

# Required parameters
cart.add_item("apple", 0.50)
cart.add_item("banana", 0.30)

# Optional parameter (using default)
cart.add_item("orange", 0.75)
# Optional parameter (specifying a value)
cart.update_quantity("orange", 3)

# Variable arguments
cart.add_multiple_items("grapes", 2.50, "bread", 1.50)  # Positional
cart.add_multiple_items(milk=2.99, eggs=1.99)           # Keyword

# Display the cart
print(cart.display())</code></pre>
            </div>
            
            <p>This example demonstrates:</p>
            <ul>
                <li>Required parameters in <code>add_item(self, item, price)</code></li>
                <li>Optional parameters in <code>update_quantity(self, item, quantity=1)</code></li>
                <li>Variable arguments in <code>add_multiple_items(self, *args, **kwargs)</code></li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Parameter design tips:</strong></p>
                <ul>
                    <li>Keep required parameters to a minimum and put them first</li>
                    <li>Use default values for parameters that have sensible defaults</li>
                    <li>Use <code>*args</code> and <code>**kwargs</code> when the method needs to handle a variable number of inputs</li>
                    <li>Document parameter usage clearly in the method's docstring</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Method Return Values</h3>
            
            <p>Methods can return values that provide information or results to the caller. Let's explore different return patterns:</p>
            
            <h4>Returning Simple Values</h4>
            <p>Methods can return simple values like numbers, strings, or booleans.</p>
            
            <h4>Returning Complex Structures</h4>
            <p>Methods can return complex data structures like lists, dictionaries, or custom objects.</p>
            
            <h4>Returning Multiple Values</h4>
            <p>Methods can return multiple values using tuples (or other collections).</p>
            
            <h4>Returning None</h4>
            <p>If a method doesn't explicitly return anything, it implicitly returns <code>None</code>.</p>
            
            <div class="code-example">
                <pre><code>class DataProcessor:
    def __init__(self, data):
        self.data = data if data else []
    
    # Return a simple value (number)
    def count(self):
        """Return the number of items in the data."""
        return len(self.data)
    
    # Return a boolean
    def is_empty(self):
        """Check if the data is empty."""
        return len(self.data) == 0
    
    # Return a complex structure (list)
    def get_sorted(self):
        """Return a sorted copy of the data."""
        return sorted(self.data)
    
    # Return multiple values (as a tuple)
    def get_stats(self):
        """Return basic statistics about the data: min, max, sum, average."""
        if not self.data:
            return None, None, 0, None
        
        data_min = min(self.data)
        data_max = max(self.data)
        data_sum = sum(self.data)
        data_avg = data_sum / len(self.data)
        
        return data_min, data_max, data_sum, data_avg
    
    # Return different types based on conditions
    def get_element(self, index):
        """Get the element at the specified index, or None if out of bounds."""
        if 0 <= index < len(self.data):
            return self.data[index]
        return None
    
    # Method with no explicit return (implicitly returns None)
    def clear(self):
        """Clear all data."""
        self.data = []

# Using the DataProcessor
numbers = DataProcessor([5, 2, 8, 1, 9, 3])

# Simple return values
print(f"Count: {numbers.count()}")              # Output: Count: 6
print(f"Is empty: {numbers.is_empty()}")        # Output: Is empty: False

# Complex return value (list)
print(f"Sorted: {numbers.get_sorted()}")        # Output: Sorted: [1, 2, 3, 5, 8, 9]

# Multiple return values (tuple)
min_val, max_val, sum_val, avg_val = numbers.get_stats()
print(f"Min: {min_val}, Max: {max_val}, Sum: {sum_val}, Average: {avg_val:.2f}")
# Output: Min: 1, Max: 9, Sum: 28, Average: 4.67

# Conditional return
print(f"Element at index 2: {numbers.get_element(2)}")    # Output: Element at index 2: 8
print(f"Element at index 10: {numbers.get_element(10)}")  # Output: Element at index 10: None

# Method with no return value
numbers.clear()
print(f"After clearing - Count: {numbers.count()}")       # Output: After clearing - Count: 0</code></pre>
            </div>
            
            <div class="concept-highlight">
                <p><strong>Return value design tips:</strong></p>
                <ul>
                    <li>Return values that are natural for the method's purpose</li>
                    <li>Be consistent with return types for similar methods</li>
                    <li>Document return values in the method's docstring</li>
                    <li>Consider returning <code>None</code> or raising exceptions for error cases</li>
                    <li>Use tuple unpacking for methods that return multiple values</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Method Naming Conventions</h3>
            
            <p>Good method names are crucial for creating intuitive, readable classes. Python has established conventions for method naming:</p>
            
            <h4>General Naming Rules</h4>
            <ul>
                <li>Use <code>snake_case</code> for method names (lowercase with underscores)</li>
                <li>Names should be descriptive and indicate what the method does</li>
                <li>Keep names reasonably short but clear</li>
            </ul>
            
            <h4>Common Method Name Patterns</h4>
            <ul>
                <li><strong>get_</strong> - Methods that retrieve or calculate a value</li>
                <li><strong>set_</strong> - Methods that set or update a value</li>
                <li><strong>is_</strong> or <strong>has_</strong> - Methods that return boolean values</li>
                <li><strong>add_</strong> or <strong>remove_</strong> - Methods that modify collections</li>
                <li><strong>calculate_</strong> or <strong>compute_</strong> - Methods that perform calculations</li>
                <li><strong>to_</strong> - Methods that convert to different formats</li>
            </ul>
            
            <h4>Special Method Names</h4>
            <p>Methods surrounded by double underscores (like <code>__init__</code> or <code>__str__</code>) are special methods with predefined meanings in Python.</p>
            
            <div class="code-example">
                <pre><code>class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.friends = []
    
    # Getters (retrieving values)
    def get_name(self):
        return self.name
    
    def get_age(self):
        return self.age
    
    # Setters (updating values)
    def set_name(self, name):
        self.name = name
    
    def set_age(self, age):
        if age < 0:
            raise ValueError("Age cannot be negative")
        self.age = age
    
    # Boolean methods (is_ or has_)
    def is_adult(self):
        return self.age >= 18
    
    def has_friends(self):
        return len(self.friends) > 0
    
    # Add/Remove methods
    def add_friend(self, friend_name):
        if friend_name not in self.friends:
            self.friends.append(friend_name)
            return f"{friend_name} added as a friend"
        return f"{friend_name} is already a friend"
    
    def remove_friend(self, friend_name):
        if friend_name in self.friends:
            self.friends.remove(friend_name)
            return f"{friend_name} removed from friends"
        return f"{friend_name} is not in friends list"
    
    # Calculation methods
    def calculate_birth_year(self, current_year):
        return current_year - self.age
    
    # Conversion methods
    def to_dict(self):
        return {
            "name": self.name,
            "age": self.age,
            "friends": self.friends
        }
    
    # Special methods
    def __str__(self):
        return f"{self.name}, {self.age} years old"
    
    def __repr__(self):
        return f"Person('{self.name}', {self.age})"

# Using the Person class
person = Person("Alice", 30)

# Using getters and setters
print(person.get_name())          # Output: Alice
person.set_age(32)
print(person.get_age())           # Output: 32

# Using boolean methods
print(person.is_adult())          # Output: True
print(person.has_friends())       # Output: False

# Using add/remove methods
print(person.add_friend("Bob"))   # Output: Bob added as a friend
print(person.add_friend("Carol")) # Output: Carol added as a friend
print(person.has_friends())       # Output: True
print(person.remove_friend("Bob")) # Output: Bob removed from friends

# Using calculation methods
print(person.calculate_birth_year(2023))  # Output: 1991

# Using conversion methods
print(person.to_dict())           # Output: {'name': 'Alice', 'age': 32, 'friends': ['Carol']}

# Using special methods
print(person)                     # Output: Alice, 32 years old
print(repr(person))               # Output: Person('Alice', 32)</code></pre>
            </div>
            
            <div class="concept-highlight">
                <p><strong>Naming best practices:</strong></p>
                <ul>
                    <li>Choose names that make the method's purpose immediately clear</li>
                    <li>Use consistent naming patterns across your classes</li>
                    <li>Use verbs for methods that perform actions</li>
                    <li>Use nouns or adjectives with is_/has_ for methods that check conditions</li>
                    <li>Follow established conventions for standard operations (get_/set_, add_/remove_, etc.)</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Method Documentation</h3>
            
            <p>Well-documented methods make your code more maintainable and easier for others (including your future self) to understand. Python uses docstrings for method documentation:</p>
            
            <div class="code-example">
                <pre><code>class BankAccount:
    """A class representing a bank account."""
    
    def __init__(self, account_number, owner_name, balance=0):
        """Initialize a new bank account.
        
        Args:
            account_number (str): The account number.
            owner_name (str): The name of the account owner.
            balance (float, optional): The initial balance. Defaults to 0.
        
        Raises:
            ValueError: If the initial balance is negative.
        """
        if balance < 0:
            raise ValueError("Initial balance cannot be negative")
        
        self.account_number = account_number
        self.owner_name = owner_name
        self.balance = balance
        self.transactions = []
        
        # Record initial deposit if any
        if balance > 0:
            self.transactions.append(("deposit", balance))
    
    def deposit(self, amount):
        """Deposit money into the account.
        
        Args:
            amount (float): The amount to deposit.
            
        Returns:
            str: A confirmation message.
            
        Raises:
            ValueError: If the amount is not positive.
        """
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        
        self.balance += amount
        self.transactions.append(("deposit", amount))
        return f"Deposited ${amount:.2f}. New balance: ${self.balance:.2f}"
    
    def withdraw(self, amount):
        """Withdraw money from the account.
        
        Args:
            amount (float): The amount to withdraw.
            
        Returns:
            str: A confirmation message.
            
        Raises:
            ValueError: If the amount is not positive or exceeds the balance.
        """
        if amount <= 0:
            raise ValueError("Withdrawal amount must be positive")
        
        if amount > self.balance:
            raise ValueError("Insufficient funds")
        
        self.balance -= amount
        self.transactions.append(("withdrawal", amount))
        return f"Withdrew ${amount:.2f}. New balance: ${self.balance:.2f}"
    
    def get_balance(self):
        """Get the current account balance.
        
        Returns:
            float: The current balance.
        """
        return self.balance
    
    def get_transaction_history(self):
        """Get the account's transaction history.
        
        Returns:
            list: A list of tuples (transaction_type, amount).
        """
        return self.transactions.copy()
    
    def __str__(self):
        """Return a string representation of the account.
        
        Returns:
            str: A string describing the account.
        """
        return f"Account {self.account_number} owned by {self.owner_name}, Balance: ${self.balance:.2f}"</code></pre>
            </div>
            
            <p>A good method docstring typically includes:</p>
            <ul>
                <li>A brief description of what the method does</li>
                <li>Parameters (arguments) with their types and descriptions</li>
                <li>Return value with its type and description</li>
                <li>Exceptions that might be raised</li>
                <li>Examples of usage (for complex methods)</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Documentation formats:</strong> The example above uses the Google style of docstrings, which is clear and readable. Other formats include reStructuredText (used by Sphinx) and NumPy style. Choose a consistent format for your project.</p>
            </div>
            
            <p>Good documentation helps:</p>
            <ul>
                <li>Other developers understand how to use your methods</li>
                <li>IDEs provide better code completion and parameter hints</li>
                <li>Documentation generators create API documentation</li>
                <li>Your future self remember what you intended</li>
            </ul>
        </section>

        <section>
            <h3>Method Design Patterns</h3>
            
            <p>When implementing methods, certain patterns are commonly used to solve specific problems. Let's explore some useful method design patterns:</p>
            
            <h4>Accessor Methods (Getters)</h4>
            <p>Methods that return information about an object's state. They typically don't modify the object.</p>
            
            <h4>Mutator Methods (Setters)</h4>
            <p>Methods that change an object's state. They typically validate the new values before making changes.</p>
            
            <h4>Helper Methods</h4>
            <p>Private or protected methods that perform part of a more complex operation. They're called by other methods rather than directly by users of the class.</p>
            
            <h4>Factory Methods</h4>
            <p>Class methods that create and return instances of the class, often with special initialization logic.</p>
            
            <h4>Method Chaining</h4>
            <p>Methods that return <code>self</code> to allow multiple method calls to be chained together.</p>
            
            <div class="code-example">
                <pre><code>class Rectangle:
    """A class representing a rectangle."""
    
    def __init__(self, width=0, height=0):
        """Initialize a rectangle with the given width and height."""
        self.width = width
        self.height = height
    
    # Accessor methods (getters)
    def get_width(self):
        """Get the rectangle's width."""
        return self.width
    
    def get_height(self):
        """Get the rectangle's height."""
        return self.height
    
    def get_area(self):
        """Calculate and return the rectangle's area."""
        return self.width * self.height
    
    def get_perimeter(self):
        """Calculate and return the rectangle's perimeter."""
        return 2 * (self.width + self.height)
    
    # Mutator methods (setters)
    def set_width(self, width):
        """Set the rectangle's width."""
        if width < 0:
            raise ValueError("Width cannot be negative")
        self.width = width
        return self  # For method chaining
    
    def set_height(self, height):
        """Set the rectangle's height."""
        if height < 0:
            raise ValueError("Height cannot be negative")
        self.height = height
        return self  # For method chaining
    
    # Helper method (private by convention)
    def _is_square(self):
        """Check if the rectangle is a square."""
        return self.width == self.height
    
    # Method that uses the helper method
    def describe(self):
        """Return a description of the rectangle."""
        shape_name = "square" if self._is_square() else "rectangle"
        return f"A {shape_name} with width={self.width}, height={self.height}, area={self.get_area()}"
    
    # Factory method
    @classmethod
    def create_square(cls, side_length):
        """Create a square (a rectangle with equal sides)."""
        return cls(side_length, side_length)
    
    @classmethod
    def create_from_area(cls, area, width_height_ratio=1):
        """Create a rectangle with the given area and width/height ratio."""
        height = (area / width_height_ratio) ** 0.5
        width = height * width_height_ratio
        return cls(width, height)
    
    # Method chaining example
    def double_size(self):
        """Double both width and height."""
        self.width *= 2
        self.height *= 2
        return self  # Returning self allows method chaining

# Using accessor and mutator methods
rect = Rectangle(5, 3)
print(f"Width: {rect.get_width()}, Height: {rect.get_height()}")
print(f"Area: {rect.get_area()}, Perimeter: {rect.get_perimeter()}")

# Using a method that uses a helper method
print(rect.describe())  # Output: A rectangle with width=5, height=3, area=15

# Using factory methods
square = Rectangle.create_square(4)
print(square.describe())  # Output: A square with width=4, height=4, area=16

custom_rect = Rectangle.create_from_area(50, 2)  # Width is twice the height
print(custom_rect.describe())
print(f"Dimensions: {custom_rect.get_width():.2f} x {custom_rect.get_height():.2f}")

# Using method chaining
rect.set_width(2).set_height(6)
print(rect.describe())  # Output: A rectangle with width=2, height=6, area=12

rect.double_size().double_size()
print(rect.describe())  # Output: A rectangle with width=8, height=24, area=192</code></pre>
            </div>
            
            <div class="concept-highlight">
                <p><strong>Design pattern tips:</strong></p>
                <ul>
                    <li>Use accessor methods for getting attributes when you need to add logic beyond a simple return</li>
                    <li>Use mutator methods for setting attributes when you need validation or side effects</li>
                    <li>Keep helper methods private (prefix with underscore) if they're implementation details</li>
                    <li>Use factory methods to provide alternative ways to create objects</li>
                    <li>Consider method chaining for operations that naturally chain together</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Special Methods</h3>
            
            <p>Python has special methods (also called "dunder methods" or "magic methods") that enable classes to integrate with Python's built-in functionalities. These methods are surrounded by double underscores, like <code>__init__</code>.</p>
            
            <p>Here are some commonly used special methods and what they enable:</p>
            
            <div class="code-example">
                <pre><code>class Vector:
    """A class representing a 2D vector."""
    
    def __init__(self, x, y):
        """Initialize a vector with x and y components."""
        self.x = x
        self.y = y
    
    # String representation methods
    def __str__(self):
        """Return a user-friendly string representation."""
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):
        """Return a developer-friendly string representation."""
        return f"Vector({self.x}, {self.y})"
    
    # Comparison methods
    def __eq__(self, other):
        """Check if two vectors are equal."""
        if not isinstance(other, Vector):
            return NotImplemented
        return self.x == other.x and self.y == other.y
    
    def __lt__(self, other):
        """Compare vectors based on their magnitude."""
        if not isinstance(other, Vector):
            return NotImplemented
        return self.magnitude() < other.magnitude()
    
    # Arithmetic methods
    def __add__(self, other):
        """Add two vectors."""
        if not isinstance(other, Vector):
            return NotImplemented
        return Vector(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other):
        """Subtract another vector from this one."""
        if not isinstance(other, Vector):
            return NotImplemented
        return Vector(self.x - other.x, self.y - other.y)
    
    def __mul__(self, scalar):
        """Multiply the vector by a scalar."""
        if not isinstance(scalar, (int, float)):
            return NotImplemented
        return Vector(self.x * scalar, self.y * scalar)
    
    def __rmul__(self, scalar):
        """Handle scalar multiplication when the scalar is on the left."""
        return self.__mul__(scalar)
    
    # Unary operators
    def __neg__(self):
        """Negate the vector."""
        return Vector(-self.x, -self.y)
    
    def __abs__(self):
        """Return the magnitude of the vector."""
        return self.magnitude()
    
    # Length method
    def __len__(self):
        """Return the magnitude rounded to the nearest integer."""
        return round(self.magnitude())
    
    # Container methods
    def __getitem__(self, index):
        """Allow indexing: vector[0] returns x, vector[1] returns y."""
        if index == 0:
            return self.x
        elif index == 1:
            return self.y
        else:
            raise IndexError("Vector index out of range")
    
    # Other methods
    def magnitude(self):
        """Calculate the magnitude (length) of the vector."""
        return (self.x**2 + self.y**2)**0.5
    
    def dot(self, other):
        """Calculate the dot product with another vector."""
        if not isinstance(other, Vector):
            raise TypeError("Dot product requires another Vector")
        return self.x * other.x + self.y * other.y

# Creating vectors
v1 = Vector(3, 4)
v2 = Vector(1, 2)

# String representation
print(v1)  # Uses __str__
print(repr(v2))  # Uses __repr__

# Comparison
print(v1 == Vector(3, 4))  # True, uses __eq__
print(v1 != v2)  # True, uses __eq__
print(v1 < v2)  # False, uses __lt__ (v1 has greater magnitude)

# Arithmetic
v3 = v1 + v2  # Uses __add__
print(v3)  # Vector(4, 6)

v4 = v1 - v2  # Uses __sub__
print(v4)  # Vector(2, 2)

v5 = v1 * 2  # Uses __mul__
print(v5)  # Vector(6, 8)

v6 = 3 * v2  # Uses __rmul__
print(v6)  # Vector(3, 6)

# Unary operators
v7 = -v1  # Uses __neg__
print(v7)  # Vector(-3, -4)

# Built-in functions
print(abs(v1))  # 5.0, uses __abs__
print(len(v1))  # 5, uses __len__

# Indexing
print(v1[0])  # 3, uses __getitem__
print(v1[1])  # 4, uses __getitem__

# Regular methods
print(v1.magnitude())  # 5.0
print(v1.dot(v2))  # 11</code></pre>
            </div>
            
            <p>This example demonstrates many of Python's special methods, which allow custom classes to work with:</p>
            <ul>
                <li>String representation: <code>__str__</code>, <code>__repr__</code></li>
                <li>Comparison operators: <code>__eq__</code>, <code>__lt__</code>, etc.</li>
                <li>Arithmetic operators: <code>__add__</code>, <code>__sub__</code>, <code>__mul__</code>, etc.</li>
                <li>Unary operators: <code>__neg__</code>, <code>__abs__</code></li>
                <li>Built-in functions: <code>__len__</code>, <code>__bool__</code>, etc.</li>
                <li>Container operations: <code>__getitem__</code>, <code>__contains__</code>, etc.</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Special method design tips:</strong></p>
                <ul>
                    <li>Always implement <code>__str__</code> and <code>__repr__</code> to make your objects printable</li>
                    <li>Implement comparison methods like <code>__eq__</code> for objects that should be comparable</li>
                    <li>Implement arithmetic methods if your class represents a value that can be used in calculations</li>
                    <li>Return <code>NotImplemented</code> when an operation doesn't make sense for the given input</li>
                    <li>Be consistent with Python's built-in types in how your special methods behave</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Error Handling in Methods</h3>
            
            <p>Proper error handling is crucial for creating robust methods. Let's look at common patterns for handling errors in methods:</p>
            
            <h4>Input Validation</h4>
            <p>Check that method arguments are valid before processing them.</p>
            
            <h4>Raising Exceptions</h4>
            <p>Signal errors using appropriate exception types.</p>
            
            <h4>Try-Except Blocks</h4>
            <p>Catch and handle exceptions that might occur during method execution.</p>
            
            <div class="code-example">
                <pre><code>class BankAccount:
    """A class representing a bank account."""
    
    minimum_balance = 100  # Minimum balance required
    
    def __init__(self, account_number, owner_name, balance=0):
        """Initialize a new bank account."""
        # Input validation
        if not isinstance(account_number, str):
            raise TypeError("Account number must be a string")
        
        if balance < 0:
            raise ValueError("Initial balance cannot be negative")
        
        self.account_number = account_number
        self.owner_name = owner_name
        self.balance = balance
    
    def deposit(self, amount):
        """Deposit money into the account."""
        # Input validation
        if not isinstance(amount, (int, float)):
            raise TypeError("Amount must be a number")
        
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        
        # Processing
        try:
            self.balance += amount
            return f"Deposited ${amount:.2f}. New balance: ${self.balance:.2f}"
        except Exception as e:
            # Handle unexpected errors
            return f"Error during deposit: {str(e)}"
    
    def withdraw(self, amount):
        """Withdraw money from the account."""
        # Input validation
        if not isinstance(amount, (int, float)):
            raise TypeError("Amount must be a number")
        
        if amount <= 0:
            raise ValueError("Withdrawal amount must be positive")
        
        # Business logic validation
        if self.balance - amount < self.minimum_balance:
            raise ValueError(f"Withdrawal would put account below minimum balance of ${self.minimum_balance}")
        
        # Processing
        try:
            self.balance -= amount
            return f"Withdrew ${amount:.2f}. New balance: ${self.balance:.2f}"
        except Exception as e:
            # Handle unexpected errors
            return f"Error during withdrawal: {str(e)}"
    
    def transfer(self, target_account, amount):
        """Transfer money to another account."""
        # Input validation
        if not isinstance(target_account, BankAccount):
            raise TypeError("Target must be a BankAccount")
        
        # Use a try-except block to ensure atomicity (all-or-nothing)
        try:
            # First withdraw from this account (might raise an exception)
            withdrawal_result = self.withdraw(amount)
            
            # Then deposit to the target account
            target_account.deposit(amount)
            
            return f"Transferred ${amount:.2f} to account {target_account.account_number}"
        except Exception as e:
            # If anything goes wrong, don't complete the transfer
            return f"Transfer failed: {str(e)}"
    
    def get_balance(self):
        """Get the current account balance."""
        return self.balance

# Using the BankAccount with error handling
try:
    # Create accounts
    account1 = BankAccount("12345", "Alice", 500)
    account2 = BankAccount("67890", "Bob", 300)
    
    # Successful operations
    print(account1.deposit(200))
    print(account1.transfer(account2, 100))
    
    # Operations with errors
    try:
        print(account1.withdraw(1000))  # Would go below minimum balance
    except ValueError as e:
        print(f"Error: {e}")
    
    try:
        print(account1.deposit(-50))  # Negative amount
    except ValueError as e:
        print(f"Error: {e}")
    
    try:
        print(account1.transfer("not an account", 100))  # Wrong type
    except TypeError as e:
        print(f"Error: {e}")
    
except Exception as e:
    print(f"Unexpected error: {e}")</code></pre>
            </div>
            
            <p>This example demonstrates different levels of error handling in methods:</p>
            <ul>
                <li><strong>Input validation</strong> checks that arguments are the correct type and value</li>
                <li><strong>Business logic validation</strong> ensures that operations make sense (e.g., not going below minimum balance)</li>
                <li><strong>Exception handling</strong> catches and handles errors that might occur during processing</li>
                <li><strong>Transaction safety</strong> ensures that operations like transfers are atomic (all-or-nothing)</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Error handling tips:</strong></p>
                <ul>
                    <li>Validate inputs early in the method</li>
                    <li>Use appropriate exception types (<code>TypeError</code>, <code>ValueError</code>, etc.)</li>
                    <li>Include helpful error messages that explain what went wrong</li>
                    <li>Catch only exceptions you can actually handle</li>
                    <li>Consider using custom exception classes for application-specific errors</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Properties: Method-Like Attributes</h3>
            
            <p>Python's property decorator allows you to define methods that act like attributes, giving you the best of both worlds: the simplicity of attribute access with the control of method calls.</p>
            
            <div class="code-example">
                <pre><code>class Circle:
    """A class representing a circle."""
    
    def __init__(self, radius):
        """Initialize a circle with the given radius."""
        self._radius = None  # Using a private attribute
        self.radius = radius  # This calls the radius setter
    
    @property
    def radius(self):
        """Get the circle's radius."""
        return self._radius
    
    @radius.setter
    def radius(self, value):
        """Set the circle's radius with validation."""
        if not isinstance(value, (int, float)):
            raise TypeError("Radius must be a number")
        
        if value <= 0:
            raise ValueError("Radius must be positive")
        
        self._radius = value
    
    @property
    def diameter(self):
        """Calculate the circle's diameter."""
        return self.radius * 2
    
    @diameter.setter
    def diameter(self, value):
        """Set the circle's diameter."""
        self.radius = value / 2  # This calls the radius setter for validation
    
    @property
    def area(self):
        """Calculate the circle's area."""
        import math
        return math.pi * self.radius ** 2
    
    @property
    def circumference(self):
        """Calculate the circle's circumference."""
        import math
        return 2 * math.pi * self.radius

# Using the Circle class with properties
circle = Circle(5)

# Properties are accessed like attributes
print(f"Radius: {circle.radius}")
print(f"Diameter: {circle.diameter}")
print(f"Area: {circle.area:.2f}")
print(f"Circumference: {circle.circumference:.2f}")

# Properties can also be set like attributes (if they have setters)
circle.radius = 7
print(f"New radius: {circle.radius}")
print(f"New diameter: {circle.diameter}")

circle.diameter = 20
print(f"After setting diameter - Radius: {circle.radius}")
print(f"After setting diameter - Area: {circle.area:.2f}")

# But they include validation
try:
    circle.radius = -10  # This will raise an exception
except ValueError as e:
    print(f"Error: {e}")

# Read-only properties can't be set
try:
    circle.area = 100  # This will raise an AttributeError
except AttributeError as e:
    print(f"Error: {e}")</code></pre>
            </div>
            
            <p>Properties offer several advantages:</p>
            <ul>
                <li>They provide a clean, attribute-like interface</li>
                <li>They can include validation and computation</li>
                <li>They allow you to change the implementation without changing the interface</li>
                <li>They support read-only, write-only, or read-write access</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Property design tips:</strong></p>
                <ul>
                    <li>Use properties when you want attribute-like access with method-like control</li>
                    <li>Use a leading underscore for the backing attribute (<code>_radius</code>)</li>
                    <li>Include validation in setters to ensure data integrity</li>
                    <li>Use properties for derived attributes that are computed from other attributes</li>
                    <li>Keep property getters lightweight; for expensive computations, consider caching</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Method Overriding and Polymorphism</h3>
            
            <p>In inheritance relationships, subclasses can override methods from their parent class to provide specialized behavior. This is a form of polymorphism - the ability to present the same interface for different underlying implementations.</p>
            
            <div class="code-example">
                <pre><code>class Shape:
    """Base class for geometric shapes."""
    
    def __init__(self, color="white"):
        """Initialize a shape with the given color."""
        self.color = color
    
    def area(self):
        """Calculate the shape's area. Should be overridden by subclasses."""
        raise NotImplementedError("Subclasses must implement area()")
    
    def perimeter(self):
        """Calculate the shape's perimeter. Should be overridden by subclasses."""
        raise NotImplementedError("Subclasses must implement perimeter()")
    
    def describe(self):
        """Return a description of the shape."""
        return f"A {self.color} shape"

class Circle(Shape):
    """A circle shape."""
    
    def __init__(self, radius, color="white"):
        """Initialize a circle with the given radius and color."""
        super().__init__(color)  # Call the parent's __init__
        self.radius = radius
    
    def area(self):
        """Calculate the circle's area."""
        import math
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        """Calculate the circle's perimeter (circumference)."""
        import math
        return 2 * math.pi * self.radius
    
    def describe(self):
        """Return a description of the circle. Overrides Shape.describe()."""
        return f"A {self.color} circle with radius {self.radius}"

class Rectangle(Shape):
    """A rectangle shape."""
    
    def __init__(self, width, height, color="white"):
        """Initialize a rectangle with the given width, height, and color."""
        super().__init__(color)  # Call the parent's __init__
        self.width = width
        self.height = height
    
    def area(self):
        """Calculate the rectangle's area."""
        return self.width * self.height
    
    def perimeter(self):
        """Calculate the rectangle's perimeter."""
        return 2 * (self.width + self.height)
    
    def describe(self):
        """Return a description of the rectangle. Overrides Shape.describe()."""
        return f"A {self.color} rectangle with width {self.width} and height {self.height}"

class Square(Rectangle):
    """A square shape (a special kind of rectangle)."""
    
    def __init__(self, side_length, color="white"):
        """Initialize a square with the given side length and color."""
        super().__init__(side_length, side_length, color)  # A square is a rectangle with equal sides
    
    def describe(self):
        """Return a description of the square. Overrides Rectangle.describe()."""
        return f"A {self.color} square with side length {self.width}"

# Function that works with any Shape
def print_shape_info(shape):
    """Print information about a shape."""
    print(shape.describe())
    print(f"Area: {shape.area():.2f}")
    print(f"Perimeter: {shape.perimeter():.2f}")
    print()

# Create different shapes
circle = Circle(5, "red")
rectangle = Rectangle(4, 6, "blue")
square = Square(3, "green")

# Use polymorphism through the common interface
shapes = [circle, rectangle, square]
for shape in shapes:
    print_shape_info(shape)</code></pre>
            </div>
            
            <p>This example demonstrates method overriding and polymorphism:</p>
            <ul>
                <li>The <code>Shape</code> base class defines a common interface with <code>area()</code>, <code>perimeter()</code>, and <code>describe()</code> methods</li>
                <li>Each subclass overrides these methods to provide its own implementation</li>
                <li>The <code>print_shape_info()</code> function works with any <code>Shape</code> object through polymorphism</li>
                <li>The correct implementation is called based on the actual type of the object at runtime</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Method overriding tips:</strong></p>
                <ul>
                    <li>Always call the parent's <code>__init__</code> method when overriding it</li>
                    <li>Use <code>super()</code> to access the parent class's methods</li>
                    <li>Override methods to specialize behavior while maintaining the same interface</li>
                    <li>Remember that override methods should generally accept the same parameters as the parent's methods</li>
                    <li>Consider using abstract base classes to define interfaces that subclasses must implement</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Method Resolution Order (MRO)</h3>
            
            <p>When a method is called on an object, Python needs to determine which method implementation to use, especially in complex inheritance hierarchies. The sequence in which Python searches for methods is called the Method Resolution Order (MRO).</p>
            
            <div class="code-example">
                <pre><code>class A:
    def method(self):
        return "Method from A"

class B(A):
    def method(self):
        return "Method from B"

class C(A):
    def method(self):
        return "Method from C"

class D(B, C):
    pass  # No method override

# Creating an instance of D
d = D()

# Which method implementation will be called?
print(d.method())  # Output: Method from B

# Examining the MRO
print(D.__mro__)
# Output: (&lt;class '__main__.D'>, &lt;class '__main__.B'>, &lt;class '__main__.C'>, &lt;class '__main__.A'>, &lt;class 'object'>)

# The MRO determines the search order for methods:
# 1. D (no method found)
# 2. B (method found here, so it's used)
# 3. C (not searched because B's method is used)
# 4. A (not searched because B's method is used)
# 5. object (not searched because B's method is used)</code></pre>
            </div>
            
            <p>Python uses the C3 linearization algorithm to determine the MRO, which ensures that:</p>
            <ul>
                <li>Children are searched before their parents</li>
                <li>Left-to-right order of base classes is preserved</li>
                <li>Each class appears only once in the MRO</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>MRO implications:</strong></p>
                <ul>
                    <li>The order of parent classes in a class definition matters</li>
                    <li>Method overrides in earlier MRO classes take precedence</li>
                    <li>Understanding MRO is important for complex inheritance hierarchies</li>
                    <li>You can use <code>super()</code> to call the next method in the MRO</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Collaborative Methods with super()</h3>
            
            <p>The <code>super()</code> function allows you to call methods from parent classes in a way that works correctly with multiple inheritance. It's particularly useful for creating cooperative methods that build on parent functionality rather than completely replacing it.</p>
            
            <div class="code-example">
                <pre><code>class Vehicle:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.is_running = False
    
    def start(self):
        if not self.is_running:
            self.is_running = True
            return f"{self.make} {self.model} started"
        return f"{self.make} {self.model} is already running"
    
    def stop(self):
        if self.is_running:
            self.is_running = False
            return f"{self.make} {self.model} stopped"
        return f"{self.make} {self.model} is already stopped"
    
    def honk(self):
        return "Beep!"
    
    def describe(self):
        status = "running" if self.is_running else "not running"
        return f"{self.year} {self.make} {self.model} ({status})"

class Car(Vehicle):
    def __init__(self, make, model, year, fuel_type="gasoline"):
        super().__init__(make, model, year)
        self.fuel_type = fuel_type
        self.gear = "park"
    
    def shift_gear(self, gear):
        allowed_gears = ["park", "reverse", "neutral", "drive"]
        if gear.lower() not in allowed_gears:
            return f"Invalid gear: {gear}"
        
        self.gear = gear.lower()
        return f"Shifted to {self.gear}"
    
    def describe(self):
        # Use super() to get the parent's description and add to it
        base_description = super().describe()
        return f"{base_description}, {self.fuel_type} fuel, in {self.gear} gear"
    
    def honk(self):
        # Override honk with custom sound
        return "Honk! Honk!"

class ElectricCar(Car):
    def __init__(self, make, model, year, battery_capacity):
        # Pass "electric" as the fuel type to the parent
        super().__init__(make, model, year, "electric")
        self.battery_capacity = battery_capacity
        self.battery_level = 100  # Percent
    
    def start(self):
        # Collaborative override: check battery before starting
        if self.battery_level < 5:
            return f"{self.make} {self.model} cannot start: Battery too low"
        
        # Call parent's start method
        return super().start() + " (silently)"
    
    def describe(self):
        # Build on the parent's description
        base_description = super().describe()
        return f"{base_description}, battery: {self.battery_level}%"

# Create and use vehicles
regular_car = Car("Toyota", "Corolla", 2020)
tesla = ElectricCar("Tesla", "Model 3", 2021, 75)

# Test the collaborative methods
print(regular_car.describe())
regular_car.start()
regular_car.shift_gear("drive")
print(regular_car.describe())
print(regular_car.honk())

print("\n" + "="*50 + "\n")

print(tesla.describe())
tesla.start()
tesla.shift_gear("drive")
print(tesla.describe())

# Test low battery scenario
tesla.battery_level = 3
print(tesla.start())</code></pre>
            </div>
            
            <p>This example demonstrates collaborative methods using <code>super()</code>:</p>
            <ul>
                <li>The <code>Car.describe()</code> method extends <code>Vehicle.describe()</code> by adding more information</li>
                <li>The <code>ElectricCar.start()</code> method first performs its own checks, then calls the parent's method</li>
                <li>The <code>ElectricCar.describe()</code> method builds on top of <code>Car.describe()</code></li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Collaborative method tips:</strong></p>
                <ul>
                    <li>Use <code>super()</code> to call the parent's implementation of a method</li>
                    <li>Override methods to add functionality rather than completely replacing it</li>
                    <li>Consider whether pre-processing (before calling super) or post-processing (after calling super) is more appropriate</li>
                    <li>Use collaborative methods to reduce code duplication and maintain the "is-a" relationship</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Method Design Best Practices</h3>
            
            <p>Let's summarize the best practices for designing and implementing methods in Python:</p>
            
            <h4>Method Signatures</h4>
            <ul>
                <li>Give methods clear, descriptive names that indicate their purpose</li>
                <li>Keep required parameters to a minimum</li>
                <li>Use default values for optional parameters</li>
                <li>Document parameters and return values with docstrings</li>
            </ul>
            
            <h4>Method Behavior</h4>
            <ul>
                <li>Follow the Single Responsibility Principle: each method should do one thing well</li>
                <li>Keep methods relatively short (typically under 20-30 lines)</li>
                <li>Validate inputs early in the method</li>
                <li>Return values consistently (same type for similar operations)</li>
                <li>Avoid side effects when possible, especially unexpected ones</li>
            </ul>
            
            <h4>Cohesion and Coupling</h4>
            <ul>
                <li>Methods should be highly cohesive (all parts contribute to a single purpose)</li>
                <li>Methods should be loosely coupled to other methods and classes</li>
                <li>Use helper methods to break complex operations into manageable pieces</li>
                <li>Pass dependencies explicitly rather than accessing global state</li>
            </ul>
            
            <h4>Error Handling</h4>
            <ul>
                <li>Use exceptions to signal errors, not return codes</li>
                <li>Choose appropriate exception types</li>
                <li>Include helpful error messages that explain what went wrong</li>
                <li>Handle exceptions at the appropriate level (not always in the same method)</li>
            </ul>
            
            <h4>Inheritance and Polymorphism</h4>
            <ul>
                <li>Override methods to specialize behavior while maintaining the same interface</li>
                <li>Use <code>super()</code> to call parent methods when appropriate</li>
                <li>Follow the Liskov Substitution Principle: subclasses should be usable wherever the parent class is expected</li>
                <li>Consider using abstract base classes to define interfaces</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>The Zen of Method Design:</strong> Methods should be clear, focused, and predictable. They should do what their name suggests, nothing more, nothing less. Well-designed methods make classes easier to use correctly and harder to use incorrectly.</p>
            </div>
        </section>

       
                  <section>
                      <h3>Practical Example: E-Commerce System</h3>
                      
                      <p>Let's apply what we've learned to implement a simplified e-commerce system with various types of methods:</p>
                      
                      <div class="code-example">
                          <pre><code>class Product:
              """A class representing a product in an e-commerce system."""
              
              # Class variable to track all products
              all_products = {}
              
              def __init__(self, product_id, name, price, category, stock=0):
                  """Initialize a new product."""
                  # Validate inputs
                  if not isinstance(price, (int, float)) or price < 0:
                      raise ValueError("Price must be a non-negative number")
                  
                  if not isinstance(stock, int) or stock < 0:
                      raise ValueError("Stock must be a non-negative integer")
                  
                  # Set instance attributes
                  self.product_id = product_id
                  self.name = name
                  self.price = price
                  self.category = category
                  self.stock = stock
                  
                  # Register the product in the class dictionary
                  Product.all_products[product_id] = self
              
              # Instance methods
              def update_stock(self, quantity):
                  """Update the product's stock level."""
                  new_stock = self.stock + quantity
                  if new_stock < 0:
                      raise ValueError("Cannot reduce stock below zero")
                  
                  self.stock = new_stock
                  return f"{self.name} stock updated to {self.stock}"
              
              def is_available(self):
                  """Check if the product is in stock."""
                  return self.stock > 0
              
              def apply_discount(self, percent):
                  """Apply a discount to the product's price."""
                  if not 0 <= percent <= 100:
                      raise ValueError("Discount percentage must be between 0 and 100")
                  
                  discount_amount = (percent / 100) * self.price
                  self.price -= discount_amount
                  return f"{self.name} price discounted by {percent}% to ${self.price:.2f}"
              
              # Special methods
              def __str__(self):
                  """Return a string representation of the product."""
                  status = "In Stock" if self.stock > 0 else "Out of Stock"
                  return f"{self.name} (${self.price:.2f}) - {status}"
              
              # Class methods
              @classmethod
              def find_by_id(cls, product_id):
                  """Find a product by its ID."""
                  return cls.all_products.get(product_id)
              
              @classmethod
              def find_by_category(cls, category):
                  """Find all products in a specific category."""
                  return [product for product in cls.all_products.values() 
                          if product.category.lower() == category.lower()]
              
              # Static method
              @staticmethod
              def format_currency(amount):
                  """Format a number as a currency string."""
                  return f"${amount:.2f}"
          
          
          class ShoppingCart:
              """A class representing a shopping cart."""
              
              def __init__(self, customer_name):
                  """Initialize a new shopping cart."""
                  self.customer_name = customer_name
                  self.items = {}  # Dictionary to store product_id: quantity
              
              def add_item(self, product, quantity=1):
                  """Add a product to the cart."""
                  # Validate inputs
                  if not isinstance(product, Product):
                      raise TypeError("Product must be a Product object")
                  
                  if not isinstance(quantity, int) or quantity <= 0:
                      raise ValueError("Quantity must be a positive integer")
                  
                  # Check if product is available
                  if not product.is_available():
                      return f"{product.name} is out of stock"
                  
                  # Check if there's enough stock
                  if product.stock < quantity:
                      return f"Not enough stock for {product.name}. Available: {product.stock}"
                  
                  # Add to cart
                  if product.product_id in self.items:
                      self.items[product.product_id] += quantity
                  else:
                      self.items[product.product_id] = quantity
                  
                  return f"Added {quantity} x {product.name} to cart"
              
              def remove_item(self, product, quantity=None):
                  """Remove a product from the cart."""
                  if not isinstance(product, Product):
                      raise TypeError("Product must be a Product object")
                  
                  if product.product_id not in self.items:
                      return f"{product.name} not in cart"
                  
                  if quantity is None or quantity >= self.items[product.product_id]:
                      # Remove all of this product
                      del self.items[product.product_id]
                      return f"Removed {product.name} from cart"
                  else:
                      # Remove specified quantity
                      self.items[product.product_id] -= quantity
                      return f"Removed {quantity} x {product.name} from cart"
              
              def get_total(self):
                  """Calculate the total price of the cart."""
                  total = 0
                  for product_id, quantity in self.items.items():
                      product = Product.find_by_id(product_id)
                      if product:
                          total += product.price * quantity
                  return total
              
              def clear(self):
                  """Remove all items from the cart."""
                  self.items = {}
                  return f"{self.customer_name}'s cart has been cleared"
              
              def checkout(self):
                  """Process the checkout, updating product stock."""
                  if not self.items:
                      return "Cart is empty"
                  
                  # Check if all products are still available
                  for product_id, quantity in self.items.items():
                      product = Product.find_by_id(product_id)
                      if not product:
                          return f"Product with ID {product_id} no longer exists"
                      
                      if product.stock < quantity:
                          return f"Not enough stock for {product.name}. Available: {product.stock}"
                  
                  # Process the purchase by updating stock
                  order_summary = [f"Order for {self.customer_name}:"]
                  for product_id, quantity in self.items.items():
                      product = Product.find_by_id(product_id)
                      product.update_stock(-quantity)  # Reduce stock
                      order_summary.append(f"- {quantity} x {product.name} @ {Product.format_currency(product.price)} each")
                  
                  # Add total to order summary
                  total = self.get_total()
                  order_summary.append(f"Total: {Product.format_currency(total)}")
                  
                  # Clear the cart
                  self.clear()
                  
                  return "\n".join(order_summary)
              
              def __str__(self):
                  """Return a string representation of the cart."""
                  if not self.items:
                      return f"{self.customer_name}'s cart is empty"
                  
                  cart_items = []
                  for product_id, quantity in self.items.items():
                      product = Product.find_by_id(product_id)
                      if product:
                          item_total = product.price * quantity
                          cart_items.append(f"{quantity} x {product.name} @ {Product.format_currency(product.price)} = {Product.format_currency(item_total)}")
                  
                  cart_summary = [f"{self.customer_name}'s Shopping Cart:"]
                  cart_summary.extend(cart_items)
                  cart_summary.append(f"Total: {Product.format_currency(self.get_total())}")
                  
                  return "\n".join(cart_summary)
          
          
          class DiscountedProduct(Product):
              """A product with special discounting capabilities."""
              
              def __init__(self, product_id, name, price, category, discount_percent=0, stock=0):
                  """Initialize a discounted product."""
                  # Call the parent's __init__
                  super().__init__(product_id, name, price, category, stock)
                  
                  # Additional attributes
                  self._discount_percent = 0  # Use property setter
                  self.discount_percent = discount_percent  # Validate and set discount
                  self.original_price = price  # Store original price
              
              @property
              def discount_percent(self):
                  """Get the discount percentage."""
                  return self._discount_percent
              
              @discount_percent.setter
              def discount_percent(self, value):
                  """Set the discount percentage and update the price."""
                  if not isinstance(value, (int, float)):
                      raise TypeError("Discount percentage must be a number")
                  
                  if not 0 <= value <= 100:
                      raise ValueError("Discount percentage must be between 0 and 100")
                  
                  # If discount is changing, update price
                  if value != self._discount_percent:
                      self._discount_percent = value
                      
                      # Reset price to original and apply new discount
                      self.price = self.original_price * (1 - value / 100)
              
              def apply_discount(self, percent):
                  """Override the parent's apply_discount method."""
                  # Instead of applying an additional discount, update the discount property
                  self.discount_percent = percent
                  return f"{self.name} price discounted by {percent}% to ${self.price:.2f}"
              
              def reset_discount(self):
                  """Reset the product to its original price."""
                  old_price = self.price
                  self.discount_percent = 0
                  return f"{self.name} price reset from ${old_price:.2f} to ${self.price:.2f}"
              
              def __str__(self):
                  """Override the parent's __str__ method."""
                  status = "In Stock" if self.stock > 0 else "Out of Stock"
                  if self.discount_percent > 0:
                      return f"{self.name} (${self.price:.2f}, {self.discount_percent}% off) - {status}"
                  else:
                      return f"{self.name} (${self.price:.2f}) - {status}"
          
          
          # Using the e-commerce system
          
          # Create some products
          headphones = Product("P001", "Wireless Headphones", 99.99, "Electronics", 10)
          laptop = Product("P002", "Laptop", 1299.99, "Electronics", 5)
          t_shirt = Product("P003", "T-Shirt", 19.99, "Clothing", 50)
          discounted_phone = DiscountedProduct("P004", "Smartphone", 699.99, "Electronics", 15, 8)
          
          # Find products by category
          electronics = Product.find_by_category("Electronics")
          print(f"Electronics products: {len(electronics)}")
          for product in electronics:
              print(f"- {product}")
          
          # Shopping cart operations
          cart = ShoppingCart("Alice")
          print(cart.add_item(headphones, 2))
          print(cart.add_item(laptop))
          print(cart.add_item(discounted_phone))
          
          # Display cart
          print("\n" + str(cart) + "\n")
          
          # Update product stock and check availability
          laptop.update_stock(-3)
          print(f"{laptop.name} availability: {laptop.is_available()}")
          
          # Remove an item from the cart
          print(cart.remove_item(headphones, 1))
          
          # Apply a discount to a product
          print(headphones.apply_discount(10))
          
          # Update discount on discounted product
          print(discounted_phone.discount_percent)
          print(discounted_phone.apply_discount(25))
          print(discounted_phone.discount_percent)
          
          # Checkout
          print("\n" + cart.checkout() + "\n")
          
          # Cart should be empty after checkout
          print(cart)</code></pre>
                      </div>
                      
                      <p>This example demonstrates a comprehensive application of method implementation techniques:</p>
                      
                      <h4>In the <code>Product</code> class:</h4>
                      <ul>
                          <li>Instance methods like <code>update_stock()</code> and <code>apply_discount()</code> modify the object's state</li>
                          <li>Boolean method <code>is_available()</code> provides a simple check</li>
                          <li>Special method <code>__str__()</code> provides a string representation</li>
                          <li>Class methods <code>find_by_id()</code> and <code>find_by_category()</code> work with a class-level collection</li>
                          <li>Static method <code>format_currency()</code> provides a utility function</li>
                      </ul>
                      
                      <h4>In the <code>ShoppingCart</code> class:</h4>
                      <ul>
                          <li>Methods with input validation ensure valid operations</li>
                          <li>Methods that interact with other objects (products)</li>
                          <li>Methods that perform complex operations (<code>checkout()</code>)</li>
                      </ul>
                      
                      <h4>In the <code>DiscountedProduct</code> class:</h4>
                      <ul>
                          <li>Properties for controlled attribute access</li>
                          <li>Overridden methods that specialize behavior</li>
                          <li>Additional methods specific to the subclass</li>
                      </ul>
                      
                      <div class="concept-highlight">
                          <p><strong>Real-world parallel:</strong> This example mimics the structure of actual e-commerce systems, where different classes handle products, shopping carts, and order processing, each with methods appropriate to their responsibilities.</p>
                      </div>
                  </section>
          
                  <section>
                      <h3>Common Method Implementation Patterns</h3>
                      
                      <p>Let's explore some common patterns for implementing methods that solve particular problems:</p>
                      
                      <h4>Delegate Methods</h4>
                      <p>These methods pass the work to another object's method, sometimes with additional pre- or post-processing.</p>
                      
                      <div class="code-example">
                          <pre><code>class LibraryMember:
              def __init__(self, member_id, name):
                  self.member_id = member_id
                  self.name = name
                  self.borrowed_books = []
              
              def borrow_book(self, book):
                  """Borrow a book by delegating to the book's checkout method."""
                  result = book.checkout(self.member_id)
                  if book.is_checked_out:
                      self.borrowed_books.append(book)
                  return result
          
          class Book:
              def __init__(self, title, author, isbn):
                  self.title = title
                  self.author = author
                  self.isbn = isbn
                  self.is_checked_out = False
                  self.borrower_id = None
              
              def checkout(self, member_id):
                  """Process a checkout request."""
                  if self.is_checked_out:
                      return f"{self.title} is already checked out"
                  
                  self.is_checked_out = True
                  self.borrower_id = member_id
                  return f"{self.title} has been checked out"</code></pre>
                      </div>
                      
                      <h4>Lazy Initialization Methods</h4>
                      <p>These methods delay creating expensive resources until they're actually needed.</p>
                      
                      <div class="code-example">
                          <pre><code>class DatabaseConnection:
              def __init__(self, host, username, password):
                  self.host = host
                  self.username = username
                  self.password = password
                  self._connection = None  # Not created yet
              
              def get_connection(self):
                  """Lazily initialize the database connection."""
                  if self._connection is None:
                      print(f"Connecting to database at {self.host}...")
                      # In a real implementation, this would use a DB library
                      self._connection = f"Connection to {self.host} as {self.username}"
                  
                  return self._connection</code></pre>
                      </div>
                      
                      <h4>Fluent Interface Methods</h4>
                      <p>These methods return self to enable method chaining for more readable code.</p>
                      
                      <div class="code-example">
                          <pre><code>class QueryBuilder:
              def __init__(self):
                  self.table = None
                  self.columns = ["*"]
                  self.filters = []
                  self.order_by = None
                  self.limit_value = None
              
              def select(self, *columns):
                  """Specify columns to select."""
                  if columns:
                      self.columns = columns
                  return self  # Return self for chaining
              
              def from_table(self, table):
                  """Specify the table to query."""
                  self.table = table
                  return self
              
              def where(self, condition):
                  """Add a WHERE condition."""
                  self.filters.append(condition)
                  return self
              
              def order_by(self, column, descending=False):
                  """Specify ordering."""
                  direction = "DESC" if descending else "ASC"
                  self.order_by = f"{column} {direction}"
                  return self
              
              def limit(self, count):
                  """Specify a limit."""
                  self.limit_value = count
                  return self
              
              def build(self):
                  """Build and return the SQL query string."""
                  if not self.table:
                      raise ValueError("Table must be specified")
                  
                  query = f"SELECT {', '.join(self.columns)} FROM {self.table}"
                  
                  if self.filters:
                      query += f" WHERE {' AND '.join(self.filters)}"
                  
                  if self.order_by:
                      query += f" ORDER BY {self.order_by}"
                  
                  if self.limit_value:
                      query += f" LIMIT {self.limit_value}"
                  
                  return query
          
          # Using the fluent interface
          query = QueryBuilder() \
              .select("id", "name", "price") \
              .from_table("products") \
              .where("category = 'Electronics'") \
              .where("price < 1000") \
              .order_by("price", descending=True) \
              .limit(10) \
              .build()
          
          print(query)
          # Output: SELECT id, name, price FROM products WHERE category = 'Electronics' AND price < 1000 ORDER BY price DESC LIMIT 10</code></pre>
                      </div>
                      
                      <h4>Template Methods</h4>
                      <p>These methods define a skeleton of an algorithm, deferring some steps to subclasses.</p>
                      
                      <div class="code-example">
                          <pre><code>class ReportGenerator:
              """Base class for report generators."""
              
              def generate_report(self, data):
                  """Template method that defines the report generation algorithm."""
                  # Steps that are the same for all report types
                  processed_data = self.process_data(data)
                  report = self.format_header()
                  report += self.format_body(processed_data)
                  report += self.format_footer()
                  
                  return report
              
              def process_data(self, data):
                  """Process the data before formatting. Can be overridden."""
                  return data
              
              def format_header(self):
                  """Format the report header. Must be overridden."""
                  raise NotImplementedError("Subclasses must implement format_header()")
              
              def format_body(self, data):
                  """Format the report body. Must be overridden."""
                  raise NotImplementedError("Subclasses must implement format_body()")
              
              def format_footer(self):
                  """Format the report footer. Must be overridden."""
                  raise NotImplementedError("Subclasses must implement format_footer()")
          
          
          class TextReportGenerator(ReportGenerator):
              """Generates text-based reports."""
              
              def __init__(self, title):
                  self.title = title
              
              def format_header(self):
                  """Format the text report header."""
                  header = f"{self.title}\n"
                  header += "=" * len(self.title) + "\n\n"
                  return header
              
              def format_body(self, data):
                  """Format the text report body."""
                  body = ""
                  for item in data:
                      body += f"- {item}\n"
                  return body
              
              def format_footer(self):
                  """Format the text report footer."""
                  import datetime
                  now = datetime.datetime.now()
                  return f"\nReport generated on {now.strftime('%Y-%m-%d %H:%M')}"
          
          
          class HTMLReportGenerator(ReportGenerator):
              """Generates HTML-based reports."""
              
              def __init__(self, title):
                  self.title = title
              
              def process_data(self, data):
                  """Process data, filtering out any empty items."""
                  return [item for item in data if item.strip()]
              
              def format_header(self):
                  """Format the HTML report header."""
                  return f"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{self.title}&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;{self.title}&lt;/h1&gt;\n    &lt;ul&gt;\n"
              
              def format_body(self, data):
                  """Format the HTML report body."""
                  body = ""
                  for item in data:
                      body += f"        &lt;li&gt;{item}&lt;/li&gt;\n"
                  return body
              
              def format_footer(self):
                  """Format the HTML report footer."""
                  import datetime
                  now = datetime.datetime.now()
                  footer = f"    &lt;/ul&gt;\n    &lt;p&gt;Report generated on {now.strftime('%Y-%m-%d %H:%M')}&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;"
                  return footer
          
          # Sample data
          items = ["Apple", "Banana", "Cherry", "", "Elderberry"]
          
          # Generate text report
          text_generator = TextReportGenerator("Fruit Inventory")
          text_report = text_generator.generate_report(items)
          print(text_report)
          
          print("\n" + "="*50 + "\n")
          
          # Generate HTML report
          html_generator = HTMLReportGenerator("Fruit Inventory")
          html_report = html_generator.generate_report(items)
          print(html_report)</code></pre>
                      </div>
                      
                      <h4>Memoization Methods</h4>
                      <p>These methods cache their results to avoid redundant calculations.</p>
                      
                      <div class="code-example">
                          <pre><code>class Fibonacci:
              """Class for calculating Fibonacci numbers efficiently."""
              
              def __init__(self):
                  """Initialize with a cache for previously calculated values."""
                  self._cache = {0: 0, 1: 1}  # Base cases
              
              def calculate(self, n):
                  """Calculate the nth Fibonacci number with memoization."""
                  if n < 0:
                      raise ValueError("n must be non-negative")
                  
                  # Check if the value is in the cache
                  if n in self._cache:
                      return self._cache[n]
                  
                  # Calculate and cache the value
                  result = self.calculate(n-1) + self.calculate(n-2)
                  self._cache[n] = result
                  
                  return result
          
          # Using the memoization method
          fib = Fibonacci()
          print(f"Fibonacci(10) = {fib.calculate(10)}")
          print(f"Fibonacci(50) = {fib.calculate(50)}")  # Would be very slow without memoization</code></pre>
                      </div>
                      
                      <div class="concept-highlight">
                          <p><strong>Method pattern selection:</strong> Choose patterns based on what problem you're trying to solve:</p>
                          <ul>
                              <li>Use <strong>delegate methods</strong> when functionality logically belongs to another object</li>
                              <li>Use <strong>lazy initialization</strong> for expensive resources that might not be needed</li>
                              <li>Use <strong>fluent interfaces</strong> when building complex objects or configurations</li>
                              <li>Use the <strong>template method pattern</strong> when you have a fixed algorithm with variable steps</li>
                              <li>Use <strong>memoization</strong> for expensive calculations that might be repeated</li>
                          </ul>
                      </div>
                  </section>
          
                  <section>
                      <h3>Python-Specific Method Techniques</h3>
                      
                      <p>Python has some unique features that enable special method implementation techniques:</p>
                      
                      <h4>Decorators for Method Modification</h4>
                      <p>Python decorators can modify or enhance methods without changing their code.</p>
                      
                      <div class="code-example">
                          <pre><code>import time
          import functools
          
          # Define decorators
          def timer(func):
              """Decorator that times method execution."""
              @functools.wraps(func)
              def wrapper(*args, **kwargs):
                  start_time = time.time()
                  result = func(*args, **kwargs)
                  end_time = time.time()
                  print(f"{func.__name__} took {end_time - start_time:.6f} seconds to run")
                  return result
              return wrapper
          
          def log_calls(func):
              """Decorator that logs method calls."""
              @functools.wraps(func)
              def wrapper(*args, **kwargs):
                  print(f"Calling {func.__name__} with args: {args[1:]} and kwargs: {kwargs}")
                  result = func(*args, **kwargs)
                  print(f"{func.__name__} returned: {result}")
                  return result
              return wrapper
          
          # Apply decorators to methods
          class MathOperations:
              @timer
              def factorial(self, n):
                  """Calculate the factorial of n."""
                  if n < 0:
                      raise ValueError("n must be non-negative")
                  
                  result = 1
                  for i in range(2, n + 1):
                      result *= i
                  
                  return result
              
              @log_calls
              def power(self, base, exponent):
                  """Calculate base raised to the power of exponent."""
                  return base ** exponent
              
              @timer
              @log_calls
              def fibonacci(self, n):
                  """Calculate the nth Fibonacci number (inefficient implementation)."""
                  if n < 0:
                      raise ValueError("n must be non-negative")
                  
                  if n <= 1:
                      return n
                  
                  return self.fibonacci(n-1) + self.fibonacci(n-2)
          
          # Using decorated methods
          math = MathOperations()
          print(f"Factorial of 5: {math.factorial(5)}")
          print(f"2^10: {math.power(2, 10)}")
          print(f"Fibonacci(10): {math.fibonacci(10)}")  # This will be slow and show lots of logs</code></pre>
                      </div>
                      
                      <h4>Context Managers with the "with" Statement</h4>
                      <p>Classes can implement <code>__enter__</code> and <code>__exit__</code> methods to support the <code>with</code> statement for resource management.</p>
                      
                      <div class="code-example">
                          <pre><code>class DatabaseConnection:
              """A database connection that can be used as a context manager."""
              
              def __init__(self, connection_string):
                  self.connection_string = connection_string
                  self.connection = None
              
              def __enter__(self):
                  """Set up the connection when entering a with block."""
                  print(f"Connecting to {self.connection_string}...")
                  # In a real implementation, this would use a DB library
                  self.connection = f"Connection to {self.connection_string}"
                  return self
              
              def __exit__(self, exc_type, exc_val, exc_tb):
                  """Close the connection when exiting a with block."""
                  print(f"Closing connection to {self.connection_string}")
                  self.connection = None
                  
                  # If we return True, exceptions are suppressed
                  # If we return False or None, exceptions are propagated
                  return False  # Let exceptions propagate
              
              def execute_query(self, query):
                  """Execute a database query."""
                  if not self.connection:
                      raise RuntimeError("Connection is not established")
                  
                  print(f"Executing query: {query}")
                  return f"Results for {query}"
          
          # Using a context manager
          try:
              with DatabaseConnection("db://example.com/mydb") as db:
                  result = db.execute_query("SELECT * FROM users")
                  print(result)
                  
                  # This will raise an exception
                  if "error" in result:
                      raise ValueError("Query error")
              
              # The connection is automatically closed when exiting the with block
              
          except ValueError as e:
              print(f"Caught an error: {e}")
              # The connection is still properly closed!</code></pre>
                      </div>
                      
                      <h4>Generator Methods</h4>
                      <p>Methods can use <code>yield</code> to create generators that produce sequences of values lazily.</p>
                      
                      <div class="code-example">
                          <pre><code>class DataProcessor:
              """A class for processing large datasets efficiently."""
              
              def __init__(self, data):
                  self.data = data
              
              def filter_values(self, predicate):
                  """Generate values that satisfy the predicate."""
                  for item in self.data:
                      if predicate(item):
                          yield item
              
              def transform_values(self, transformer):
                  """Generate transformed values."""
                  for item in self.data:
                      yield transformer(item)
              
              def process_in_chunks(self, chunk_size):
                  """Generate chunks of the data."""
                  for i in range(0, len(self.data), chunk_size):
                      yield self.data[i:i+chunk_size]
          
          # Using generator methods
          data = list(range(1, 101))  # Numbers 1 to 100
          processor = DataProcessor(data)
          
          # Filter for even numbers
          even_numbers = processor.filter_values(lambda x: x % 2 == 0)
          print("First 5 even numbers:")
          for i, num in enumerate(even_numbers):
              if i >= 5:
                  break
              print(num, end=" ")
          print()
          
          # Transform values
          squares = processor.transform_values(lambda x: x**2)
          print("First 5 squares:")
          for i, num in enumerate(squares):
              if i >= 5:
                  break
              print(num, end=" ")
          print()
          
          # Process in chunks
          chunks = processor.process_in_chunks(10)
          print("First 3 chunks:")
          for i, chunk in enumerate(chunks):
              if i >= 3:
                  break
              print(chunk)</code></pre>
                      </div>
                      
                      <h4>Method Dispatch with Singledispatch</h4>
                      <p>The <code>functools.singledispatch</code> decorator enables methods to behave differently based on the type of their first argument.</p>
                      
                      <div class="code-example">
                          <pre><code>from functools import singledispatchmethod
          
          class Formatter:
              """A class that can format different types of data."""
              
              @singledispatchmethod
              def format(self, arg):
                  """Default implementation for unknown types."""
                  return f"Unknown type: {type(arg).__name__}"
              
              @format.register
              def _(self, arg: int):
                  """Format integers."""
                  return f"Integer: {arg:,d}"
              
              @format.register
              def _(self, arg: float):
                  """Format floats."""
                  return f"Float: {arg:.2f}"
              
              @format.register
              def _(self, arg: str):
                  """Format strings."""
                  return f"String: '{arg}'"
              
              @format.register
              def _(self, arg: list):
                  """Format lists."""
                  return f"List with {len(arg)} items: {arg}"
              
              @format.register
              def _(self, arg: dict):
                  """Format dictionaries."""
                  return f"Dict with {len(arg)} keys: {arg}"
          
          # Using the singledispatch method
          formatter = Formatter()
          print(formatter.format(42))
          print(formatter.format(3.14159))
          print(formatter.format("Hello, world!"))
          print(formatter.format([1, 2, 3, 4, 5]))
          print(formatter.format({"a": 1, "b": 2, "c": 3}))
          print(formatter.format(complex(1, 2)))  # Uses the default implementation</code></pre>
                      </div>
                      
                      <div class="concept-highlight">
                          <p><strong>Python-specific technique tips:</strong></p>
                          <ul>
                              <li>Use <strong>decorators</strong> to add cross-cutting concerns (logging, timing, etc.) without modifying method code</li>
                              <li>Implement the <strong>context manager protocol</strong> (<code>__enter__</code> and <code>__exit__</code>) for resource management</li>
                              <li>Use <strong>generators</strong> for methods that need to process large datasets efficiently</li>
                              <li>Consider <strong>singledispatch</strong> for methods that need to handle different types of inputs differently</li>
                          </ul>
                      </div>
                  </section>
          
                  <section>
                      <h3>Testing and Debugging Methods</h3>
                      
                      <p>Well-designed methods should be testable. Here are some techniques for testing and debugging methods:</p>
                      
                      <h4>Unit Testing Methods</h4>
                      <p>Write tests that verify each method behaves correctly in isolation.</p>
                      
                      <div class="code-example">
                          <pre><code>import unittest
          
          class Calculator:
              """A simple calculator class."""
              
              def add(self, a, b):
                  """Add two numbers."""
                  return a + b
              
              def subtract(self, a, b):
                  """Subtract b from a."""
                  return a - b
              
              def multiply(self, a, b):
                  """Multiply two numbers."""
                  return a * b
              
              def divide(self, a, b):
                  """Divide a by b."""
                  if b == 0:
                      raise ValueError("Cannot divide by zero")
                  return a / b
          
          class TestCalculator(unittest.TestCase):
              """Tests for the Calculator class."""
              
              def setUp(self):
                  """Set up for each test."""
                  self.calc = Calculator()
              
              def test_add(self):
                  """Test the add method."""
                  self.assertEqual(self.calc.add(2, 3), 5)
                  self.assertEqual(self.calc.add(-1, 1), 0)
                  self.assertEqual(self.calc.add(0, 0), 0)
              
              def test_subtract(self):
                  """Test the subtract method."""
                  self.assertEqual(self.calc.subtract(5, 3), 2)
                  self.assertEqual(self.calc.subtract(1, 1), 0)
                  self.assertEqual(self.calc.subtract(0, 5), -5)
              
              def test_multiply(self):
                  """Test the multiply method."""
                  self.assertEqual(self.calc.multiply(2, 3), 6)
                  self.assertEqual(self.calc.multiply(-2, 3), -6)
                  self.assertEqual(self.calc.multiply(0, 5), 0)
              
              def test_divide(self):
                  """Test the divide method."""
                  self.assertEqual(self.calc.divide(6, 3), 2)
                  self.assertEqual(self.calc.divide(5, 2), 2.5)
                  self.assertEqual(self.calc.divide(0, 5), 0)
                  
                  # Test division by zero raises ValueError
                  with self.assertRaises(ValueError):
                      self.calc.divide(5, 0)
          
          # Run the tests
          if __name__ == "__main__":
              unittest.main(argv=['first-arg-is-ignored'], exit=False)</code></pre>
                      </div>
                      
                      <h4>Method Debugging Techniques</h4>
                      <p>Use print statements, logging, or debuggers to understand method behavior.</p>
                      
                      <div class="code-example">
                          <pre><code>import logging
          
          # Configure logging
          logging.basicConfig(level=logging.DEBUG, format='%(levelname)s - %(message)s')
          
          class ComplexCalculation:
              """A class with a complex calculation method to demonstrate debugging."""
              
              def __init__(self, base_value):
                  self.base_value = base_value
                  logging.info(f"Created ComplexCalculation with base_value={base_value}")
              
              def calculate(self, x, iterations=3):
                  """Perform a complex calculation."""
                  logging.debug(f"calculate called with x={x}, iterations={iterations}")
                  
                  result = self.base_value
                  
                  for i in range(iterations):
                      # Print statement for debugging
                      print(f"Iteration {i}: result = {result}")
                      
                      # Logging for more structured debugging
                      logging.debug(f"Iteration {i}: result before calculation = {result}")
                      
                      # Calculation step
                      prev_result = result
                      result = (result * x + i) / (i + 1)
                      
                      logging.debug(f"Iteration {i}: result after calculation = {result}")
                      
                      # Check for potential issues
                      if result == prev_result:
                          logging.warning(f"Result unchanged after iteration {i}")
                      
                      if not isinstance(result, (int, float)) or result > 1e6:
                          logging.error(f"Unexpected result value: {result}")
                          break
                  
                  logging.info(f"Final result: {result}")
                  return result
          
          # Using the class with debugging
          calc = ComplexCalculation(10)
          result = calc.calculate(2, iterations=4)
          print(f"Final result: {result}")</code></pre>
                      </div>
                      
                      <div class="concept-highlight">
                          <p><strong>Testing and debugging tips:</strong></p>
                          <ul>
                              <li>Write unit tests for each method to verify its behavior</li>
                              <li>Test normal cases, edge cases, and error cases</li>
                              <li>Use logging for persistent debugging information</li>
                              <li>Add temporary print statements for quick debugging</li>
                              <li>Use Python's built-in debugger (pdb) or an IDE debugger for complex issues</li>
                          </ul>
                      </div>
                  </section>
          
                  <section>
                      <h3>Conclusion</h3>
                      <p>In this tutorial, we've explored the art and science of method implementation in Python. We've covered the basics of defining methods, different types of methods, and advanced patterns for solving specific problems. We've also seen how to apply these techniques in practical examples.</p>
                      
                      <p>Key takeaways about method implementation:</p>
                      <ul>
                          <li><strong>Method types:</strong> Instance methods, class methods, and static methods serve different purposes</li>
                          <li><strong>Method design:</strong> Well-designed methods have clear purposes, appropriate parameters, and consistent return values</li>
                          <li><strong>Special methods:</strong> Python's special methods allow classes to integrate with built-in functionality</li>
                          <li><strong>Properties:</strong> The property decorator provides attribute-like access with method-like control</li>
                          <li><strong>Design patterns:</strong> Common method implementation patterns solve recurring problems</li>
                          <li><strong>Python-specific techniques:</strong> Python offers unique features like decorators, context managers, and generators for method implementation</li>
                          <li><strong>Testing and debugging:</strong> Well-designed methods are testable and debuggable</li>
                      </ul>
                      
                      <p>As you continue your journey in object-oriented programming, remember that method implementation is where the rubber meets the road. A well-designed class with thoughtfully implemented methods can make your code more maintainable, reusable, and elegant.</p>
                      
                      <div class="practice-exercise">
                          <h4>Practice Exercise</h4>
                          <p>Design and implement a <code>BankAccount</code> class with the following features:</p>
                          <ol>
                              <li>Store account number, account holder name, and balance</li>
                              <li>Implement methods for deposit, withdrawal, and transfer</li>
                              <li>Include validation to prevent negative balances</li>
                              <li>Keep a transaction history</li>
                              <li>Use properties to control access to the balance</li>
                              <li>Use special methods to make the class more Pythonic</li>
                              <li>Use decorators to add logging to key methods</li>
                              <li>Implement a static method for generating account numbers</li>
                          </ol>
                          <p>Bonus: Create a <code>Bank</code> class that manages multiple accounts and implements methods for finding accounts, calculating total deposits, etc.</p>
                      </div>
                  </section>
          
                  <section class="additional-resources">
                      <h3>Additional Resources</h3>
                      <ul>
                          <li><a href="https://docs.python.org/3/tutorial/classes.html" target="_blank">Python Official Documentation: Classes</a></li>
                          <li><a href="https://realpython.com/instance-class-and-static-methods-demystified/" target="_blank">Real Python: Instance, Class, and Static Methods Demystified</a></li>
                          <li><a href="https://realpython.com/python-property/" target="_blank">Real Python: Python's property() Function</a></li>
                          <li><a href="https://refactoring.guru/design-patterns/python" target="_blank">Refactoring Guru: Design Patterns in Python</a></li>
                          <li><a href="https://www.python-course.eu/python3_decorators.php" target="_blank">Python Course: Decorators</a></li>
                          <li>Recommended Book: "Fluent Python" by Luciano Ramalho (Chapters on Objects and Methods)</li>
                      </ul>
                  </section>
              </main>
          
              <footer>
                  <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
              </footer>
          </body>
          </html>
