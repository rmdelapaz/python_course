<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Inheritance in Python</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 3: Object-Oriented Programming Advanced Concepts</h2>
        <h3>Multiple Inheritance</h3>
    </header>

    <main>
        <section class="introduction">
            <h3>Understanding Multiple Inheritance in Python</h3>
            <p>Multiple inheritance is a powerful feature of Python's object-oriented programming model that allows a class to inherit attributes and methods from more than one parent class. Unlike some languages (such as Java) that support only single inheritance, Python embraces the flexibility of multiple inheritance, enabling developers to create sophisticated class hierarchies and reuse code from various sources.</p>
            
            <p>Think of multiple inheritance as a child who inherits traits from both parents rather than just one. This child might have their mother's eye color and their father's height. Similarly, a class with multiple inheritance can combine the functionality of several parent classes to create a more specialized and feature-rich entity.</p>
            
            <p>While powerful, multiple inheritance adds complexity that must be managed carefully. In this session, we'll explore the mechanics, benefits, challenges, and best practices of multiple inheritance in Python.</p>
        </section>

        <section class="folder_structure">
            <h3>Today's File Structure</h3>
            <p>For today's lesson, we'll create a new Python module in our project. Ensure you have the following directory structure:</p>
            <pre>
project_root/
├── multiple_inheritance/
│   ├── __init__.py  (empty file to make the folder a package)
│   ├── basic_multiple_inheritance.py
│   ├── mro_explanation.py
│   ├── mixins.py
│   ├── diamond_problem.py
│   └── real_world_examples.py
</pre>
            <p>All code examples will be saved in these files, allowing you to organize and revisit these concepts easily.</p>
        </section>

        <section class="basic_multiple_inheritance">
            <h3>Basic Multiple Inheritance</h3>
            <p>Let's start with the fundamental syntax and behavior of multiple inheritance in Python. Create a file named <code>basic_multiple_inheritance.py</code> with the following code:</p>
            
            <pre>
# File: multiple_inheritance/basic_multiple_inheritance.py

class Animal:
    """Base class for all animals"""
    
    def __init__(self, name):
        self.name = name
    
    def eat(self):
        return f"{self.name} is eating."
    
    def sleep(self):
        return f"{self.name} is sleeping."


class Flyable:
    """Mixin class for flying capabilities"""
    
    def fly(self):
        return f"{self.name} is flying through the air."
    
    def land(self):
        return f"{self.name} is landing."


class Swimmable:
    """Mixin class for swimming capabilities"""
    
    def swim(self):
        return f"{self.name} is swimming in the water."
    
    def dive(self):
        return f"{self.name} is diving underwater."


class Bird(Animal, Flyable):
    """Bird class inherits from both Animal and Flyable"""
    
    def __init__(self, name, wingspan):
        Animal.__init__(self, name)  # Explicitly calling parent's __init__
        self.wingspan = wingspan
    
    def chirp(self):
        return f"{self.name} is chirping."


class Duck(Bird, Swimmable):
    """Duck class inherits from Bird and Swimmable, which means it
    ultimately inherits from Animal, Flyable, and Swimmable"""
    
    def __init__(self, name, wingspan, swimming_speed):
        Bird.__init__(self, name, wingspan)  # Call Bird's __init__
        self.swimming_speed = swimming_speed
    
    def quack(self):
        return f"{self.name} is quacking."


# Create and use the classes
print("Creating a Bird:")
eagle = Bird("Eddie the Eagle", wingspan=2.1)
print(eagle.eat())       # From Animal
print(eagle.fly())       # From Flyable
print(eagle.chirp())     # From Bird

print("\nCreating a Duck:")
donald = Duck("Donald", wingspan=0.5, swimming_speed=5)
print(donald.eat())      # From Animal
print(donald.fly())      # From Flyable
print(donald.swim())     # From Swimmable
print(donald.chirp())    # From Bird
print(donald.quack())    # From Duck

# Display method resolution order
print("\nMethod Resolution Order for Duck:")
print(Duck.__mro__)
</pre>

            <p><strong>Code Breakdown:</strong></p>
            <ul>
                <li>We define a base class <code>Animal</code> with common attributes and behaviors for all animals.</li>
                <li>We create two "mixin" classes, <code>Flyable</code> and <code>Swimmable</code>, which each provide a specific set of capabilities.</li>
                <li>The <code>Bird</code> class inherits from both <code>Animal</code> and <code>Flyable</code>, allowing birds to both eat/sleep and fly.</li>
                <li>The <code>Duck</code> class inherits from both <code>Bird</code> and <code>Swimmable</code>, making it a bird that can also swim.</li>
                <li>Note how we explicitly call the parent class initializers using <code>Animal.__init__(self, name)</code> and <code>Bird.__init__(self, name, wingspan)</code>.</li>
            </ul>

            <h4>Alternative Constructor Calling with super()</h4>
            <p>Instead of explicitly calling each parent class's <code>__init__</code> method, we can use <code>super()</code> with multiple inheritance, but it requires careful consideration of the Method Resolution Order (MRO):</p>
            
            <pre>
class Bird(Animal, Flyable):
    def __init__(self, name, wingspan):
        super().__init__(name)  # This calls Animal.__init__
        self.wingspan = wingspan

# This works because Animal is first in the MRO
</pre>
            
            <p>However, with more complex inheritance hierarchies, using <code>super()</code> requires understanding the MRO to know which parent's method will be called.</p>
            
            <p><strong>Real-world analogy:</strong> Think of multiple inheritance like a smartphone that is both a phone and a camera. It inherits functionality from two different device types, combining their features into a single device. Similarly, our <code>Duck</code> class inherits the capabilities of an animal, the ability to fly, and the ability to swim.</p>
        </section>

        <section class="mro_explanation">
            <h3>Method Resolution Order (MRO)</h3>
            <p>When a class inherits from multiple parents, Python needs to determine which method to call when there are methods with the same name in different parent classes. The order in which Python searches for methods is called the Method Resolution Order (MRO).</p>
            
            <p>Let's create a file named <code>mro_explanation.py</code> to explore this concept:</p>
            
            <pre>
# File: multiple_inheritance/mro_explanation.py

class A:
    def method(self):
        return "Method from A"


class B:
    def method(self):
        return "Method from B"


class C(A, B):
    pass


class D(B, A):
    pass


class E(C, D):
    pass  # This would raise TypeError due to inconsistent MRO


# Let's see the MRO for these classes
print("MRO for C (inherits from A, B):")
print(C.__mro__)

print("\nMRO for D (inherits from B, A):")
print(D.__mro__)

# Uncomment to see the error
# print("\nMRO for E (inherits from C, D):")
# print(E.__mro__)

# Using the classes
c = C()
d = D()

print("\nCalling method on C instance:")
print(c.method())  # Will call A's method

print("\nCalling method on D instance:")
print(d.method())  # Will call B's method
</pre>

            <p><strong>Code Breakdown:</strong></p>
            <ul>
                <li>We define two classes <code>A</code> and <code>B</code>, each with a method called <code>method</code>.</li>
                <li>We create class <code>C</code> that inherits from <code>A</code> first, then <code>B</code>.</li>
                <li>We create class <code>D</code> that inherits from <code>B</code> first, then <code>A</code>.</li>
                <li>Class <code>E</code> tries to inherit from both <code>C</code> and <code>D</code>, which would create an inconsistent MRO.</li>
                <li>We print the MRO for these classes using <code>__mro__</code> attribute.</li>
            </ul>

            <h4>C3 Linearization Algorithm</h4>
            <p>Python uses an algorithm called C3 linearization to determine the MRO. This algorithm ensures that:</p>
            <ol>
                <li>A subclass appears before its parents</li>
                <li>If a class inherits from multiple classes, they are kept in the order specified in the class definition</li>
                <li>The algorithm preserves monotonicity (if A precedes B in one inheritance chain, A must precede B in the linearized MRO)</li>
            </ol>
            
            <p>When the C3 algorithm cannot create a consistent linearization (as in the case of class <code>E</code> above), Python raises a <code>TypeError</code> with the message "Cannot create a consistent method resolution order (MRO)".</p>
            
            <p><strong>Real-world analogy:</strong> Think of MRO like a chain of command in a company with multiple departments. If an employee needs to get approval for something, they might first ask their direct supervisor, then the department head, then the division manager, and so on up the hierarchy. The MRO defines the exact sequence of who to ask and in what order.</p>
        </section>

        <section class="diamond_problem">
            <h3>The Diamond Problem</h3>
            <p>One of the classic challenges in multiple inheritance is the "diamond problem" (also known as the "deadly diamond of death"). This occurs when a class inherits from two classes that both inherit from a common base class, creating a diamond-shaped inheritance hierarchy.</p>
            
            <p>Let's create a file named <code>diamond_problem.py</code> to explore this:</p>
            
            <pre>
# File: multiple_inheritance/diamond_problem.py

class Base:
    def __init__(self):
        print("Base.__init__ called")
    
    def method(self):
        return "Method from Base"


class Left(Base):
    def __init__(self):
        super().__init__()
        print("Left.__init__ called")
    
    def method(self):
        return "Method from Left"


class Right(Base):
    def __init__(self):
        super().__init__()
        print("Right.__init__ called")
    
    def method(self):
        return "Method from Right"


class Diamond(Left, Right):
    def __init__(self):
        super().__init__()
        print("Diamond.__init__ called")


# Create an instance of Diamond
print("Creating a Diamond instance:")
d = Diamond()

# Check the MRO
print("\nDiamond MRO:")
print(Diamond.__mro__)

# Call the method
print("\nCalling method on Diamond instance:")
print(d.method())  # Which method will be called?

# Example of super() with diamond inheritance
class ImprovedBase:
    def __init__(self, value):
        self.value = value
        print(f"ImprovedBase.__init__ called with value={value}")


class ImprovedLeft(ImprovedBase):
    def __init__(self, value):
        super().__init__(value + 1)
        print(f"ImprovedLeft.__init__ called with value={value}")


class ImprovedRight(ImprovedBase):
    def __init__(self, value):
        super().__init__(value + 2)
        print(f"ImprovedRight.__init__ called with value={value}")


class ImprovedDiamond(ImprovedLeft, ImprovedRight):
    def __init__(self, value):
        super().__init__(value)
        print(f"ImprovedDiamond.__init__ called with value={value}")


print("\nCreating an ImprovedDiamond instance:")
improved_d = ImprovedDiamond(10)
print(f"Final value: {improved_d.value}")
</pre>

            <p><strong>Code Breakdown:</strong></p>
            <ul>
                <li>We create a diamond-shaped inheritance hierarchy: <code>Diamond</code> inherits from both <code>Left</code> and <code>Right</code>, which both inherit from <code>Base</code>.</li>
                <li>Each class defines an <code>__init__</code> method and a <code>method</code> method.</li>
                <li>We use <code>super().__init__()</code> to call the parent's initializer in each class.</li>
                <li>We create an instance of <code>Diamond</code> and observe the initialization order.</li>
                <li>We check the MRO to understand which version of <code>method</code> will be called.</li>
                <li>We create an improved version of the diamond with value passing to demonstrate how values flow through the hierarchy.</li>
            </ul>

            <h4>How Python Solves the Diamond Problem</h4>
            <p>Python solves the diamond problem through its C3 linearization algorithm and the use of <code>super()</code>. When you create an instance of <code>Diamond</code>, the Base class is initialized only once, not twice (as might happen in languages without proper diamond problem handling).</p>
            
            <p>The MRO ensures a consistent order for method resolution, and <code>super()</code> follows this order when calling methods. In our example, <code>Diamond</code>'s MRO would be: <code>[Diamond, Left, Right, Base, object]</code>, so <code>d.method()</code> would call <code>Left.method()</code>.</p>
            
            <p><strong>Real-world analogy:</strong> Imagine a person who inherits traits from both parents, who in turn share some ancestry (grandparents). The diamond problem is like determining which version of a family trait (e.g., eye color) the person inherits when different versions exist in the family tree. Python's MRO is like a family tree that establishes clear precedence rules for inheritance.</p>
        </section>

        <section class="mixins">
            <h3>Mixins: A Powerful Pattern for Multiple Inheritance</h3>
            <p>A common and effective use of multiple inheritance in Python is the "mixin" pattern. Mixins are classes that provide a specific set of functionality that can be "mixed in" to other classes without establishing an "is-a" relationship.</p>
            
            <p>Let's create a file named <code>mixins.py</code> to explore this pattern:</p>
            
            <pre>
# File: multiple_inheritance/mixins.py

class SerializationMixin:
    """Mixin providing JSON serialization capabilities"""
    
    def to_json(self):
        """Convert object attributes to a JSON-serializable dictionary"""
        return {
            attr: value for attr, value in self.__dict__.items()
            if not attr.startswith('_')  # Skip private attributes
        }
    
    def from_json(self, data):
        """Update object attributes from a dictionary"""
        for key, value in data.items():
            setattr(self, key, value)
        return self


class ValidationMixin:
    """Mixin providing data validation capabilities"""
    
    def validate(self):
        """Validate object attributes based on _validation_rules"""
        if not hasattr(self, '_validation_rules'):
            return True, []
        
        errors = []
        for attr, rules in self._validation_rules.items():
            value = getattr(self, attr, None)
            
            # Check required fields
            if rules.get('required', False) and value is None:
                errors.append(f"{attr} is required")
                continue
            
            # Skip other validations if value is None
            if value is None:
                continue
            
            # Check minimum value
            if 'min' in rules and value < rules['min']:
                errors.append(f"{attr} must be at least {rules['min']}")
            
            # Check maximum value
            if 'max' in rules and value > rules['max']:
                errors.append(f"{attr} must be at most {rules['max']}")
            
            # Check string length
            if 'min_length' in rules and len(str(value)) < rules['min_length']:
                errors.append(f"{attr} must be at least {rules['min_length']} characters")
            
            # Check string pattern (simplified)
            if 'pattern' in rules and rules['pattern'] == 'email':
                if '@' not in str(value):
                    errors.append(f"{attr} must be a valid email address")
        
        return len(errors) == 0, errors


class LoggingMixin:
    """Mixin providing logging capabilities"""
    
    def log(self, message, level='INFO'):
        """Log a message with the specified level"""
        prefix = f"[{level}] {self.__class__.__name__}"
        print(f"{prefix}: {message}")
    
    def log_method_call(self, method_name, *args, **kwargs):
        """Log a method call with its arguments"""
        args_str = ', '.join([str(arg) for arg in args])
        kwargs_str = ', '.join([f"{k}={v}" for k, v in kwargs.items()])
        all_args = f"{args_str}{', ' if args_str and kwargs_str else ''}{kwargs_str}"
        self.log(f"Called {method_name}({all_args})")


# Example class using mixins
class User(SerializationMixin, ValidationMixin, LoggingMixin):
    """User class with serialization, validation, and logging capabilities"""
    
    def __init__(self, username=None, email=None, age=None):
        self.username = username
        self.email = email
        self.age = age
        
        # Define validation rules
        self._validation_rules = {
            'username': {
                'required': True,
                'min_length': 3
            },
            'email': {
                'required': True,
                'pattern': 'email'
            },
            'age': {
                'min': 18,
                'max': 120
            }
        }
    
    def save(self):
        """Save the user (simulation)"""
        self.log_method_call('save')
        
        # Validate before saving
        is_valid, errors = self.validate()
        if not is_valid:
            self.log(f"Validation failed: {errors}", level='ERROR')
            return False
        
        self.log(f"User {self.username} saved successfully")
        return True


# Test the mixins
user = User(username="john_doe", email="john@example.com", age=30)

# Test logging
user.log("User object created")

# Test validation
is_valid, errors = user.validate()
print(f"User valid: {is_valid}, Errors: {errors}")

# Test an invalid user
invalid_user = User(username="jo", email="invalid-email", age=15)
is_valid, errors = invalid_user.validate()
print(f"Invalid user valid: {is_valid}, Errors: {errors}")

# Test serialization
user_data = user.to_json()
print(f"Serialized user: {user_data}")

# Create a new user from json
new_user = User().from_json({
    'username': 'alice_smith',
    'email': 'alice@example.com',
    'age': 25
})
print(f"Deserialized user: {new_user.to_json()}")

# Test save method
user.save()
invalid_user.save()
</pre>

            <p><strong>Code Breakdown:</strong></p>
            <ul>
                <li>We create three mixin classes:
                    <ul>
                        <li><code>SerializationMixin</code>: Provides methods for converting objects to/from JSON-compatible dictionaries</li>
                        <li><code>ValidationMixin</code>: Provides validation capabilities based on configurable rules</li>
                        <li><code>LoggingMixin</code>: Provides logging functionality</li>
                    </ul>
                </li>
                <li>The <code>User</code> class inherits from all three mixins, gaining their functionality without establishing an "is-a" relationship with any of them</li>
                <li>Each mixin is focused on a single, well-defined responsibility, following the Single Responsibility Principle</li>
                <li>We test the combined functionality with various user objects</li>
            </ul>

            <h4>Mixin Naming Convention</h4>
            <p>By convention, mixin classes are often named with the suffix "Mixin" to clearly indicate their purpose. They should typically be designed to:</p>
            <ol>
                <li>Provide a specific, well-defined set of functionality</li>
                <li>Not depend on instance attributes being set by their own <code>__init__</code> methods</li>
                <li>Be used as additional parents in multiple inheritance, not as the primary parent</li>
            </ol>
            
            <p><strong>Real-world analogy:</strong> Mixins are like modular appliance attachments. A stand mixer can be a basic mixer, but by attaching different modules, it can become a pasta maker, a meat grinder, or a food processor. Each attachment adds specific functionality without changing the fundamental nature of the mixer. Similarly, mixins add specific capabilities to a class without changing its core identity.</p>
        </section>

        <section class="real_world_examples">
            <h3>Real-World Examples of Multiple Inheritance in Python Web Development</h3>
            <p>Let's create a file called <code>real_world_examples.py</code> that demonstrates how multiple inheritance is used in actual web development contexts:</p>
            
            <pre>
# File: multiple_inheritance/real_world_examples.py

# Example 1: Django Class-Based Views Mixins
class TemplateResponseMixin:
    """Mixin for rendering templates (simplified Django-like)"""
    template_name = None
    
    def render_to_response(self, context):
        """Render the template with the given context"""
        if self.template_name is None:
            raise ValueError("TemplateResponseMixin requires template_name to be set")
        
        return f"Rendered template {self.template_name} with context: {context}"


class ContextMixin:
    """Mixin for providing a context for template rendering"""
    
    def get_context_data(self, **kwargs):
        """Get the context for template rendering"""
        return kwargs


class View:
    """Base view class (simplified Django-like)"""
    
    def dispatch(self, request, *args, **kwargs):
        """Dispatch the request to the appropriate method"""
        handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        return handler(request, *args, **kwargs)
    
    def http_method_not_allowed(self, request, *args, **kwargs):
        """Handle methods that are not allowed"""
        return f"Method {request.method} not allowed"
    
    def get(self, request, *args, **kwargs):
        return self.http_method_not_allowed(request, *args, **kwargs)
    
    def post(self, request, *args, **kwargs):
        return self.http_method_not_allowed(request, *args, **kwargs)


class TemplateView(TemplateResponseMixin, ContextMixin, View):
    """Template view (simplified Django-like)"""
    
    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)
        return self.render_to_response(context)


# Example 2: SQLAlchemy-like Model Mixins
class TimestampMixin:
    """Mixin that adds created_at and updated_at fields"""
    
    def __init__(self):
        self.created_at = "Current timestamp"
        self.updated_at = "Current timestamp"
    
    def update_timestamp(self):
        self.updated_at = "Updated timestamp"


class SoftDeleteMixin:
    """Mixin that adds soft delete capability"""
    
    def __init__(self):
        self.deleted_at = None
    
    def delete(self):
        self.deleted_at = "Current timestamp"
        return f"{self.__class__.__name__} soft deleted"
    
    def is_deleted(self):
        return self.deleted_at is not None
    
    def restore(self):
        self.deleted_at = None
        return f"{self.__class__.__name__} restored"


class BaseModel:
    """Base model class (simplified SQLAlchemy-like)"""
    
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)
    
    def save(self):
        return f"{self.__class__.__name__} saved to database"


class User(BaseModel, TimestampMixin, SoftDeleteMixin):
    """User model with timestamps and soft delete"""
    
    def __init__(self, username, email, **kwargs):
        BaseModel.__init__(self, **kwargs)
        TimestampMixin.__init__(self)
        SoftDeleteMixin.__init__(self)
        self.username = username
        self.email = email


# Example 3: Flask-like Extension System
class FlaskExtension:
    """Base class for Flask extensions"""
    
    def init_app(self, app):
        """Initialize the extension with the Flask app"""
        return f"Extension {self.__class__.__name__} initialized with app"


class MailExtension(FlaskExtension):
    """Mixin for sending emails"""
    
    def send_mail(self, to, subject, body):
        return f"Sending email to {to} with subject '{subject}'"


class CacheExtension(FlaskExtension):
    """Mixin for caching"""
    
    def cache(self, key, value, timeout=None):
        return f"Caching {value} with key '{key}' and timeout {timeout}"
    
    def get(self, key):
        return f"Getting value for key '{key}' from cache"


class AdvancedMailExtension(MailExtension, CacheExtension):
    """Advanced mail extension with caching capabilities"""
    
    def send_cached_mail(self, to, subject, body, cache_key):
        # Check if we have a cached result
        cached_result = self.get(cache_key)
        
        # Send the email
        result = self.send_mail(to, subject, body)
        
        # Cache the result
        self.cache(cache_key, result)
        
        return result


# Test the examples
# Example 1: Django-like Views
class Request:
    def __init__(self, method):
        self.method = method

template_view = TemplateView()
template_view.template_name = "example.html"
result = template_view.dispatch(Request("GET"), id=123)
print("Django-like View Result:")
print(result)

# Example 2: SQLAlchemy-like Models
user = User(username="jane_doe", email="jane@example.com")
print("\nSQLAlchemy-like Model Example:")
print(user.save())
print(user.delete())
print(f"Is deleted: {user.is_deleted()}")
print(user.restore())
print(f"Is deleted after restore: {user.is_deleted()}")

# Example 3: Flask-like Extensions
advanced_mail = AdvancedMailExtension()
print("\nFlask-like Extension Example:")
print(advanced_mail.init_app("flask_app"))
print(advanced_mail.send_cached_mail(
    "recipient@example.com", 
    "Hello", 
    "This is a test", 
    "email:recipient@example.com"
))
</pre>

            <p><strong>Code Breakdown:</strong></p>
            <ul>
                <li><strong>Example 1:</strong> Demonstrates Django-style class-based views, which heavily use multiple inheritance and mixins. Each mixin provides a specific piece of functionality (template rendering, context preparation), and they're combined in the <code>TemplateView</code> class.</li>
                <li><strong>Example 2:</strong> Shows an SQLAlchemy-inspired approach to model composition, where models can inherit behavior like timestamping and soft deletion from mixins.</li>
                <li><strong>Example 3:</strong> Illustrates a Flask-like extension system where extensions can be combined to create more complex functionality, such as a mail extension with caching capabilities.</li>
            </ul>

            <p>These examples show how multiple inheritance and the mixin pattern are used extensively in popular Python web frameworks and libraries. By understanding these patterns, you can more effectively work with these frameworks and apply similar patterns in your own code.</p>
        </section>

        <section class="best_practices">
            <h3>Best Practices for Multiple Inheritance</h3>
            
            <h4>1. Prefer Composition Over Inheritance When Appropriate</h4>
            <p>While multiple inheritance is powerful, sometimes composition (where one class contains instances of other classes) can be clearer and more flexible. Use inheritance for "is-a" relationships and composition for "has-a" relationships.</p>
            
            <pre>
# Composition example
class Engine:
    def start(self):
        return "Engine started"

class Car:
    def __init__(self):
        self.engine = Engine()  # Composition
    
    def start(self):
        return self.engine.start()
</pre>
            
            <h4>2. Use Mixins for Behavior, Not for State</h4>
            <p>Mixins should primarily provide behavior (methods) rather than state (instance variables). This reduces the chances of attribute name conflicts.</p>
            
            <h4>3. Keep the Inheritance Hierarchy Shallow</h4>
            <p>Deep inheritance hierarchies can become hard to understand and maintain. Try to keep your inheritance tree relatively shallow to minimize complexity.</p>
            
            <h4>4. Follow Naming Conventions</h4>
            <p>Use the "Mixin" suffix for mixin classes to clearly indicate their purpose. This helps other developers understand your code's structure.</p>
            
            <h4>5. Document the Class Hierarchy</h4>
            <p>Provide clear documentation about the inheritance relationships, especially when using multiple inheritance. This helps others (and your future self) understand the code structure.</p>
            
            <h4>6. Be Careful with Method Resolution Order</h4>
            <p>Understand how Python's MRO works and be mindful of the order of parent classes in your class definition. The order can affect which methods are called when there are name conflicts.</p>
            
            <h4>7. Use super() Consistently</h4>
            <p>When overriding methods, use <code>super()</code> consistently to ensure that all parent methods are called appropriately. This is particularly important in diamond inheritance structures.</p>
            
            <pre>
# Consistent use of super()
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        super().method()
        print("B.method")

class C(A):
    def method(self):
        super().method()
        print("C.method")

class D(B, C):
    def method(self):
        super().method()
        print("D.method")

# When d.method() is called, all methods in the hierarchy will be executed
</pre>
            
            <h4>8. Avoid the Deadly Diamond of Death</h4>
            <p>Be cautious with diamond inheritance patterns. While Python handles them correctly, they can still make your code harder to understand. When using diamond inheritance, make sure you understand the MRO and how <code>super()</code> works.</p>
        </section>

        <section class="practical_exercise">
            <h3>Practical Exercise: Building a Web Framework Component System</h3>
            <p>Let's apply what we've learned to build a simple component system for a web framework, using multiple inheritance and mixins to create reusable, composable components:</p>
            
            <pre>
# Exercise: Building a component system with multiple inheritance

class Component:
    """Base class for all UI components"""
    
    def __init__(self, id=None, classes=None):
        self.id = id
        self.classes = classes or []
    
    def render(self):
        """Render the component to HTML"""
        raise NotImplementedError("Subclasses must implement render()")
    
    def get_attributes(self):
        """Get HTML attributes as a string"""
        attributes = []
        if self.id:
            attributes.append(f'id="{self.id}"')
        if self.classes:
            class_str = ' '.join(self.classes)
            attributes.append(f'class="{class_str}"')
        return ' '.join(attributes)


class ClickableMixin:
    """Mixin for clickable elements"""
    
    def __init__(self, *args, onclick=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.onclick = onclick
    
    def get_attributes(self):
        """Add onclick attribute if provided"""
        attributes = super().get_attributes()
        if self.onclick:
            onclick_attr = f'onclick="{self.onclick}"'
            attributes = f"{attributes} {onclick_attr}" if attributes else onclick_attr
        return attributes


class StyleableMixin:
    """Mixin for styling elements"""
    
    def __init__(self, *args, style=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.style = style or {}
    
    def get_attributes(self):
        """Add style attribute if styles are provided"""
        attributes = super().get_attributes()
        if self.style:
            style_str = '; '.join([f"{k}: {v}" for k, v in self.style.items()])
            style_attr = f'style="{style_str}"'
            attributes = f"{attributes} {style_attr}" if attributes else style_attr
        return attributes


class ValidatableMixin:
    """Mixin for form elements that can be validated"""
    
    def __init__(self, *args, required=False, pattern=None, minlength=None, maxlength=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.required = required
        self.pattern = pattern
        self.minlength = minlength
        self.maxlength = maxlength
    
    def get_attributes(self):
        """Add validation attributes"""
        attributes = super().get_attributes()
        validation_attrs = []
        
        if self.required:
            validation_attrs.append('required')
        if self.pattern:
            validation_attrs.append(f'pattern="{self.pattern}"')
        if self.minlength is not None:
            validation_attrs.append(f'minlength="{self.minlength}"')
        if self.maxlength is not None:
            validation_attrs.append(f'maxlength="{self.maxlength}"')
        
        return f"{attributes} {' '.join(validation_attrs)}" if attributes else ' '.join(validation_attrs)


class Button(Component, ClickableMixin, StyleableMixin):
    """Button component"""
    
    def __init__(self, text, type="button", *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.text = text
        self.type = type
    
    def render(self):
        attributes = self.get_attributes()
        attributes_str = f" {attributes}" if attributes else ""
        return f'<button type="{self.type}"{attributes_str}>{self.text}</button>'


class Input(Component, ValidatableMixin, StyleableMixin):
    """Input component"""
    
    def __init__(self, name, type="text", value=None, placeholder=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.name = name
        self.type = type
        self.value = value
        self.placeholder = placeholder
    
    def render(self):
        attributes = self.get_attributes()
        name_attr = f'name="{self.name}"'
        type_attr = f'type="{self.type}"'
        value_attr = f'value="{self.value}"' if self.value is not None else ''
        placeholder_attr = f'placeholder="{self.placeholder}"' if self.placeholder is not None else ''
        
        all_attrs = ' '.join(filter(None, [attributes, name_attr, type_attr, value_attr, placeholder_attr]))
        return f'<input {all_attrs}>'


class Form(Component, StyleableMixin):
    """Form component that can contain other components"""
    
    def __init__(self, action="", method="post", children=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.action = action
        self.method = method
        self.children = children or []
    
    def add_child(self, child):
        """Add a child component to the form"""
        self.children.append(child)
    
    def render(self):
        attributes = self.get_attributes()
        action_attr = f'action="{self.action}"'
        method_attr = f'method="{self.method}"'
        
        all_attrs = ' '.join(filter(None, [attributes, action_attr, method_attr]))
        
        children_html = '\n'.join([child.render() for child in self.children])
        return f'<form {all_attrs}>\n{children_html}\n</form>'


# Test the component system
button = Button(
    "Click Me", 
    id="submit-btn", 
    classes=["btn", "btn-primary"],
    onclick="submitForm()",
    style={"background-color": "blue", "color": "white"}
)

email_input = Input(
    name="email", 
    type="email", 
    placeholder="Enter your email",
    required=True,
    pattern=r"[^@]+@[^@]+\.[^@]+",
    style={"width": "100%", "padding": "10px"}
)

form = Form(
    action="/submit", 
    method="post",
    id="contact-form",
    classes=["form", "contact-form"],
    style={"margin": "20px"}
)

form.add_child(email_input)
form.add_child(button)

print("Rendered Button:")
print(button.render())
print("\nRendered Input:")
print(email_input.render())
print("\nRendered Form:")
print(form.render())
</pre>

            <p><strong>Exercise Explanation:</strong></p>
            <p>In this exercise, we've created a component system for building HTML elements with multiple inheritance and mixins:</p>
            <ol>
                <li><code>Component</code>: The base class for all UI components</li>
                <li>Mixin classes for specific functionality:
                    <ul>
                        <li><code>ClickableMixin</code>: Adds click handling</li>
                        <li><code>StyleableMixin</code>: Adds CSS styling</li>
                        <li><code>ValidatableMixin</code>: Adds form validation attributes</li>
                    </ul>
                </li>
                <li>Concrete component classes that combine these mixins:
                    <ul>
                        <li><code>Button</code>: A clickable, styleable button</li>
                        <li><code>Input</code>: A validatable, styleable input field</li>
                        <li><code>Form</code>: A container for other components</li>
                    </ul>
                </li>
            </ol>
            
            <p>This system demonstrates how multiple inheritance can create flexible, composable components that share functionality through mixins. Each mixin adds a specific capability, and components can mix and match these capabilities as needed.</p>
            
            <p>The use of <code>super().__init__(*args, **kwargs)</code> and <code>super().get_attributes()</code> ensures that all parent classes' methods are called appropriately, avoiding common pitfalls in multiple inheritance.</p>
            
            <p>This pattern is similar to how many Python web frameworks like Django and Flask structure their components, and understanding it will help you work more effectively with these frameworks and create your own extensible systems.</p>
        </section>

        <section class="key_takeaways">
            <h3>Key Takeaways</h3>
            <ul>
                <li><strong>Multiple inheritance</strong> allows a class to inherit attributes and methods from more than one parent class, enabling code reuse and composition of behavior.</li>
                <li>The <strong>Method Resolution Order (MRO)</strong> determines the order in which Python searches for methods in a multiple inheritance hierarchy. Python uses the C3 linearization algorithm to establish a consistent MRO.</li>
                <li>The <strong>diamond problem</strong> occurs when a class inherits from two classes that both inherit from a common base class. Python solves this through its MRO and the use of <code>super()</code>.</li>
                <li><strong>Mixins</strong> are a powerful pattern in multiple inheritance, providing specific, well-defined functionality that can be "mixed in" to other classes without establishing an "is-a" relationship.</li>
                <li>Multiple inheritance and mixins are widely used in Python web frameworks like Django and Flask, allowing for flexible, composable components.</li>
                <li>Best practices include preferring composition when appropriate, using mixins primarily for behavior rather than state, keeping inheritance hierarchies shallow, and carefully considering the method resolution order.</li>
            </ul>
        </section>

        <section class="assignment">
            <h3>Assignment: Extend a Web Application with Mixins and Multiple Inheritance</h3>
            <p>For today's assignment, you'll extend a web application by implementing mixins and multiple inheritance to add reusable functionality to various components.</p>
            
            <h4>Requirements:</h4>
            <ol>
                <li>Create at least three mixin classes that provide specific functionality:
                    <ul>
                        <li>A logging mixin that adds logging capabilities</li>
                        <li>A serialization mixin that adds JSON serialization/deserialization</li>
                        <li>A third mixin of your choice (e.g., caching, validation, authentication)</li>
                    </ul>
                </li>
                <li>Implement at least two base classes that represent core components of a web application (e.g., Model, Controller, View)</li>
                <li>Create at least three concrete classes that use multiple inheritance to combine the base classes and mixins</li>
                <li>Design your class hierarchy to avoid common pitfalls of multiple inheritance:
                    <ul>
                        <li>Use <code>super()</code> consistently to call parent methods</li>
                        <li>Be mindful of method resolution order</li>
                        <li>Avoid attribute name conflicts</li>
                    </ul>
                </li>
                <li>Write a demonstration script that shows how your classes interact and how the mixed-in functionality enhances the application</li>
                <li>Include docstrings and comments to explain your code's structure and design decisions</li>
            </ol>
            
            <h4>Bonus Challenges:</h4>
            <ol>
                <li>Implement a diamond inheritance pattern and demonstrate your understanding of how Python resolves method calls in this situation</li>
                <li>Create a mixin that adds asynchronous capabilities to appropriate classes</li>
                <li>Design a plugin system that uses multiple inheritance to extend application functionality</li>
                <li>Create a real-world example that mimics a feature from a popular Python web framework (e.g., Django's class-based views or SQLAlchemy's models)</li>
            </ol>
            
            <p>Submit your work as a Python module with clear structure and organization. Be prepared to explain your design choices and how multiple inheritance enhances your application's modularity and reusability.</p>
        </section>

        <section class="further_reading">
            <h3>Further Reading and Resources</h3>
            <ul>
                <li><a href="https://docs.python.org/3/tutorial/classes.html#multiple-inheritance" target="_blank">Python Official Documentation: Multiple Inheritance</a></li>
                <li><a href="https://www.python.org/download/releases/2.3/mro/" target="_blank">Python Method Resolution Order (C3 Linearization)</a></li>
                <li><a href="https://realpython.com/inheritance-composition-python/" target="_blank">Real Python: Inheritance and Composition</a></li>
                <li><a href="https://docs.djangoproject.com/en/stable/topics/class-based-views/mixins/" target="_blank">Django Documentation: Class-Based Views Mixins</a></li>
                <li><a href="https://docs.sqlalchemy.org/en/14/orm/extensions/declarative/mixins.html" target="_blank">SQLAlchemy Documentation: Mixin and Custom Base Classes</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
