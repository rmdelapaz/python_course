<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classes and Objects in Object-Oriented Programming</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Classes and Objects in Object-Oriented Programming</h1>
        <h2>Week 3: Monday Morning Session</h2>
    </header>

    <main>
        <section class="lesson-intro">
            <h3>Lesson Overview</h3>
            <p>Welcome to this deep dive into classes and objects - the fundamental building blocks of Object-Oriented Programming. Today we'll explore what classes and objects are, how they relate to each other, and how to create and use them effectively in Python. By the end of this session, you'll have a strong understanding of these core OOP concepts and be ready to apply them in your own code.</p>

        </section>

        <section>
            <h3>Understanding Classes and Objects</h3>
            
            <h4>The Conceptual Foundation</h4>
            <p>To truly understand classes and objects, let's start with a conceptual foundation:</p>
            
            <ul>
                <li><strong>Class:</strong> A blueprint or template that defines the structure and behavior for a category of objects</li>
                <li><strong>Object:</strong> A specific instance created from a class</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Real-world analogy:</strong> Think about the relationship between a blueprint for a house and the actual houses built from that blueprint:</p>
                <ul>
                    <li>The <strong>blueprint</strong> (class) defines what all houses of that type will have: the layout, number of rooms, dimensions, etc.</li>
                    <li>Each actual <strong>house</strong> (object) is a physical instance built according to that blueprint</li>
                    <li>You can build many houses (objects) from the same blueprint (class)</li>
                    <li>Each house (object) will have the same structure but can have different colors, furniture, and residents</li>
                </ul>
            </div>
            
            <p>Similarly, in programming:</p>
            <ul>
                <li>A <strong>class</strong> defines a data structure with attributes (variables) and methods (functions)</li>
                <li>An <strong>object</strong> is a concrete instance of the class with its own unique data</li>
                <li>You can create many objects from the same class</li>
                <li>Each object has the same structure but can contain different data values</li>
            </ul>
        </section>

        <section>
            <h3>Defining Classes in Python</h3>
            
            <p>In Python, we use the <code>class</code> keyword to define a class. Here's the basic syntax:</p>
            
            <div class="code-example">
                <pre><code>class ClassName:
    # Class attributes
    class_attribute = value
    
    # Constructor method
    def __init__(self, param1, param2):
        # Instance attributes
        self.attribute1 = param1
        self.attribute2 = param2
    
    # Instance methods
    def method_name(self, parameters):
        # Method body
        pass</code></pre>
            </div>
            
            <p>Let's break down the components of a class:</p>
            
            <h4>Class Name</h4>
            <p>By convention, class names in Python use CamelCase notation (each word starts with a capital letter, with no underscores). For example: <code>Person</code>, <code>BankAccount</code>, <code>ShoppingCart</code>.</p>
            
            <h4>Class Attributes</h4>
            <p>Class attributes are variables that belong to the class itself. They're shared by all instances of the class. They're defined directly in the class body, outside of any methods.</p>
            
            <h4>The Constructor Method (<code>__init__</code>)</h4>
            <p>The <code>__init__</code> method is a special method that gets called when you create a new object from the class. It's used to initialize the object with specific values. This is where you typically define instance attributes.</p>
            
            <h4>The <code>self</code> Parameter</h4>
            <p>The <code>self</code> parameter refers to the instance of the class that's being created or operated on. It's a convention in Python to name this parameter "self", though technically you could use any name (but don't - it would confuse other programmers reading your code).</p>
            
            <h4>Instance Attributes</h4>
            <p>Instance attributes are variables that belong to individual objects. Each object has its own copy of these attributes, which can have different values. They're typically defined in the <code>__init__</code> method.</p>
            
            <h4>Instance Methods</h4>
            <p>Instance methods are functions defined inside a class that operate on instance attributes. They always take <code>self</code> as their first parameter, which allows them to access and modify the object's attributes.</p>
            
            <div class="concept-highlight">
                <p><strong>Important distinction:</strong> Class attributes are shared by all instances, while instance attributes are unique to each instance. Think of class attributes as traits shared by all members of a species, and instance attributes as characteristics unique to individual organisms.</p>
            </div>
        </section>

        <section>
            <h3>Creating and Using Objects</h3>
            
            <p>Once you've defined a class, you can create objects (instances) from it. This is called instantiation. Here's how you create an object in Python:</p>
            
            <div class="code-example">
                <pre><code># Creating an object
object_name = ClassName(arguments)</code></pre>
            </div>
            
            <p>When you create an object, Python automatically calls the <code>__init__</code> method with the arguments you provide. This initializes the object with specific attribute values.</p>
            
            <h4>Accessing Attributes and Methods</h4>
            <p>Once you have an object, you can access its attributes and methods using dot notation:</p>
            
            <div class="code-example">
                <pre><code># Accessing an attribute
value = object_name.attribute_name

# Calling a method
result = object_name.method_name(arguments)</code></pre>
            </div>
            
            <p>Let's see a complete example with a <code>Person</code> class:</p>
            
            <div class="code-example">
                <pre><code>class Person:
    # Class attribute
    species = "Homo sapiens"
    
    # Constructor
    def __init__(self, name, age):
        # Instance attributes
        self.name = name
        self.age = age
    
    # Instance method
    def greet(self):
        return f"Hello, my name is {self.name} and I am {self.age} years old."
    
    # Another instance method
    def celebrate_birthday(self):
        self.age += 1
        return f"Happy birthday! {self.name} is now {self.age} years old."

# Creating objects
alice = Person("Alice", 30)
bob = Person("Bob", 25)

# Accessing attributes
print(alice.name)            # Output: Alice
print(bob.age)               # Output: 25
print(Person.species)        # Output: Homo sapiens (class attribute)

# Calling methods
print(alice.greet())         # Output: Hello, my name is Alice and I am 30 years old.
print(bob.celebrate_birthday())  # Output: Happy birthday! Bob is now 26 years old.
print(bob.age)               # Output: 26 (the attribute was modified by the method)</code></pre>
            </div>
            
            <p>In this example:</p>
            <ul>
                <li>We define a <code>Person</code> class with one class attribute (<code>species</code>) and two instance attributes (<code>name</code> and <code>age</code>)</li>
                <li>We create two Person objects: <code>alice</code> and <code>bob</code></li>
                <li>We access their attributes using dot notation</li>
                <li>We call methods on the objects, which can both return values and modify the object's state</li>
            </ul>
        </section>

        <section>
            <h3>Understanding Object Identity and References</h3>
            
            <p>When you create an object in Python, what you really have is a reference to that object. This has important implications for how objects behave when copied or compared.</p>
            
            <h4>Object Identity</h4>
            <p>Each object has a unique identity, which you can check with the <code>id()</code> function. Two different objects will have different identities, even if they have the same attribute values:</p>
            
            <div class="code-example">
                <pre><code>alice1 = Person("Alice", 30)
alice2 = Person("Alice", 30)

print(alice1 == alice2)  # Output: False (by default, == compares identity)
print(id(alice1))        # Output: some number
print(id(alice2))        # Output: a different number</code></pre>
            </div>
            
            <h4>Object References</h4>
            <p>When you assign an object to a new variable, you're not creating a new object - you're creating a new reference to the same object:</p>
            
            <div class="code-example">
                <pre><code>original = Person("Charlie", 40)
reference = original  # 'reference' now points to the same object as 'original'

print(original.name)    # Output: Charlie
print(reference.name)   # Output: Charlie

# Modifying through one reference affects the object for all references
reference.name = "Charles"
print(original.name)    # Output: Charles (changed because it's the same object)
print(id(original) == id(reference))  # Output: True (same identity)</code></pre>
            </div>
            
            <div class="concept-highlight">
                <p><strong>Analogy:</strong> Think of an object like a house, and a variable like an address card. If you give someone a copy of your address card, you're not giving them a new house - you're giving them directions to the same house. If they go to that house and paint it blue, when you go home, your house will also be blue, because it's the same house.</p>
            </div>
        </section>

        <section>
            <h3>Practical Example: Building a BankAccount Class</h3>
            
            <p>Let's work through a practical example of a <code>BankAccount</code> class to see how classes and objects work in a real-world context:</p>
            
            <div class="code-example">
                <pre><code>class BankAccount:
    # Class attribute
    bank_name = "Python National Bank"
    
    def __init__(self, account_holder, account_number, balance=0):
        # Instance attributes
        self.account_holder = account_holder
        self.account_number = account_number
        self.balance = balance
        self.transactions = []  # List to store transaction history
    
    def deposit(self, amount):
        if amount > 0:
            self.balance += amount
            self.transactions.append(f"Deposit: +${amount}")
            return f"Deposited ${amount}. New balance: ${self.balance}"
        else:
            return "Deposit amount must be positive"
    
    def withdraw(self, amount):
        if amount <= 0:
            return "Withdrawal amount must be positive"
        
        if amount > self.balance:
            return "Insufficient funds"
            
        self.balance -= amount
        self.transactions.append(f"Withdrawal: -${amount}")
        return f"Withdrew ${amount}. New balance: ${self.balance}"
    
    def get_balance(self):
        return f"Current balance: ${self.balance}"
    
    def get_transaction_history(self):
        if not self.transactions:
            return "No transactions yet"
        
        history = "Transaction history:\n"
        for transaction in self.transactions:
            history += f"- {transaction}\n"
        return history

# Creating bank account objects
alice_account = BankAccount("Alice Smith", "12345", 1000)
bob_account = BankAccount("Bob Johnson", "67890")

# Using the bank accounts
print(alice_account.get_balance())  # Output: Current balance: $1000
print(bob_account.get_balance())    # Output: Current balance: $0

print(alice_account.deposit(500))   # Output: Deposited $500. New balance: $1500
print(bob_account.deposit(100))     # Output: Deposited $100. New balance: $100

print(alice_account.withdraw(200))  # Output: Withdrew $200. New balance: $1300
print(bob_account.withdraw(150))    # Output: Insufficient funds

print(alice_account.get_transaction_history())
# Output:
# Transaction history:
# - Deposit: +$500
# - Withdrawal: -$200</code></pre>
            </div>
            
            <p>This example demonstrates several important aspects of classes and objects:</p>
            <ul>
                <li><strong>Initialization with parameters:</strong> The <code>__init__</code> method sets up the account with initial values, including a default value for <code>balance</code></li>
                <li><strong>Data validation:</strong> The methods check for valid inputs before performing operations</li>
                <li><strong>State management:</strong> The object maintains its state (balance, transaction history) between method calls</li>
                <li><strong>Encapsulation:</strong> The account's data and the operations on that data are bundled together in a single unit</li>
                <li><strong>Multiple instances:</strong> We can create multiple accounts, each with its own unique data</li>
            </ul>
        </section>

        <section>
            <h3>Class Methods vs. Instance Methods</h3>
            
            <p>So far, we've focused on instance methods, which operate on individual objects. Python also supports class methods, which operate on the class itself rather than on instances.</p>
            
            <h4>Class Methods</h4>
            <p>Class methods are defined using the <code>@classmethod</code> decorator. They take <code>cls</code> (the class) as their first parameter instead of <code>self</code> (an instance):</p>
            
            <div class="code-example">
                <pre><code>class BankAccount:
    # Class attributes
    bank_name = "Python National Bank"
    accounts = 0  # Counter for the number of accounts
    
    def __init__(self, account_holder, account_number, balance=0):
        self.account_holder = account_holder
        self.account_number = account_number
        self.balance = balance
        self.transactions = []
        
        # Increment the account counter
        BankAccount.accounts += 1
    
    # Regular instance methods (as before)...
    
    # Class method
    @classmethod
    def get_total_accounts(cls):
        return f"Total accounts at {cls.bank_name}: {cls.accounts}"
    
    # Another class method - an alternative constructor
    @classmethod
    def create_joint_account(cls, holder1, holder2, account_number, balance=0):
        joint_name = f"{holder1} & {holder2}"
        return cls(joint_name, account_number, balance)

# Using instance methods
alice_account = BankAccount("Alice Smith", "12345", 1000)
bob_account = BankAccount("Bob Johnson", "67890")

# Using a class method
print(BankAccount.get_total_accounts())  # Output: Total accounts at Python National Bank: 2

# Using an alternative constructor
joint_account = BankAccount.create_joint_account("Alice Smith", "Bob Johnson", "54321", 2000)
print(joint_account.account_holder)  # Output: Alice Smith & Bob Johnson
print(joint_account.balance)         # Output: 2000</code></pre>
            </div>
            
            <p>Class methods are useful for:</p>
            <ul>
                <li>Operations that involve class attributes rather than instance attributes</li>
                <li>Creating alternative constructors</li>
                <li>Factory methods that return instances of the class</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Analogy:</strong> If a class is a factory that produces objects, then instance methods are instructions for operating individual products, while class methods are instructions for operating the factory itself.</p>
            </div>
        </section>

        <section>
            <h3>Static Methods</h3>
            
            <p>Python also supports static methods, which are associated with a class but don't operate on either the class or its instances. They're defined using the <code>@staticmethod</code> decorator:</p>
            
            <div class="code-example">
                <pre><code>class BankAccount:
    # Class attributes, constructor, instance methods, class methods as before...
    
    # Static method
    @staticmethod
    def validate_account_number(account_number):
        # Check if the account number is a 5-digit string
        return len(account_number) == 5 and account_number.isdigit()

# Using a static method
print(BankAccount.validate_account_number("12345"))  # Output: True
print(BankAccount.validate_account_number("ABC"))    # Output: False</code></pre>
            </div>
            
            <p>Static methods are useful for utility functions that are related to the class's purpose but don't need to access or modify class or instance data.</p>
            
            <div class="concept-highlight">
                <p><strong>When to use each type of method:</strong></p>
                <ul>
                    <li>Use <strong>instance methods</strong> when you need to access or modify instance attributes</li>
                    <li>Use <strong>class methods</strong> when you need to access or modify class attributes, or create alternative constructors</li>
                    <li>Use <strong>static methods</strong> when you want to associate a utility function with a class but don't need to access any class or instance data</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Classes in the Python Ecosystem</h3>
            
            <p>Understanding classes and objects is essential because they're used extensively throughout the Python ecosystem:</p>
            
            <h4>Built-in Classes</h4>
            <p>Many of Python's built-in data types are implemented as classes:</p>
            <ul>
                <li><code>list</code>, <code>dict</code>, <code>set</code>, <code>str</code>, etc. are all classes</li>
                <li>When you call <code>my_list = [1, 2, 3]</code>, you're creating an instance of the <code>list</code> class</li>
                <li>Methods like <code>append()</code>, <code>pop()</code>, etc. are instance methods of these classes</li>
            </ul>
            
            <div class="code-example">
                <pre><code># These are equivalent
my_list1 = [1, 2, 3]
my_list2 = list([1, 2, 3])

# These are also equivalent
my_dict1 = {"name": "Alice", "age": 30}
my_dict2 = dict(name="Alice", age=30)

# These are methods on class instances
my_list1.append(4)
value = my_dict1.get("name")</code></pre>
            </div>
            
            <h4>Python Libraries</h4>
            <p>Most Python libraries and frameworks use classes to organize their code:</p>
            <ul>
                <li>Flask: <code>app = Flask(__name__)</code> creates an instance of the <code>Flask</code> class</li>
                <li>Django: Models are classes that inherit from <code>django.db.models.Model</code></li>
                <li>Pandas: <code>DataFrame</code> is a class with methods like <code>head()</code>, <code>describe()</code>, etc.</li>
                <li>Pygame: <code>Surface</code>, <code>Rect</code>, etc. are classes with methods for game development</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Real-world application:</strong> When developing a web application with Django (which we'll cover in Week 10), you'll define model classes that represent database tables. For example:</p>
                <pre><code>from django.db import models

class Product(models.Model):
    name = models.CharField(max_length=100)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    in_stock = models.BooleanField(default=True)
    
    def discount(self, percentage):
        """Apply a discount to the product price."""
        self.price = self.price * (1 - percentage / 100)
        self.save()
        
# Django will automatically create a database table based on this class
# Each row in the table will be an instance of the Product class</code></pre>
            </div>
        </section>

        <section>
            <h3>Best Practices for Classes and Objects</h3>
            
            <h4>Naming Conventions</h4>
            <ul>
                <li>Class names should use CamelCase: <code>BankAccount</code>, <code>Person</code>, <code>ShoppingCart</code></li>
                <li>Method and attribute names should use snake_case: <code>get_balance()</code>, <code>account_number</code></li>
                <li>Private attributes and methods (not meant to be accessed directly) should be prefixed with an underscore: <code>_balance</code>, <code>_calculate_interest()</code></li>
            </ul>
            
            <h4>Design Principles</h4>
            <ul>
                <li><strong>Single Responsibility Principle:</strong> Each class should have one reason to change. A class should do one thing and do it well.</li>
                <li><strong>Encapsulation:</strong> Keep internal details hidden. Provide a clean public interface.</li>
                <li><strong>DRY (Don't Repeat Yourself):</strong> Avoid duplicating code across different methods or classes.</li>
                <li><strong>YAGNI (You Aren't Gonna Need It):</strong> Don't add features until they're actually needed.</li>
            </ul>
            
            <h4>Common Mistakes to Avoid</h4>
            <ul>
                <li><strong>Too many responsibilities:</strong> Classes should have a single, well-defined purpose.</li>
                <li><strong>Overexposing internals:</strong> Don't make all attributes public if they don't need to be.</li>
                <li><strong>Ignoring class relationships:</strong> Think about how your classes relate to each other.</li>
                <li><strong>Reinventing the wheel:</strong> Use Python's built-in classes and libraries when appropriate.</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Tip:</strong> When designing a class, ask yourself: "What is this class responsible for?" If your answer includes the word "and," you might need to split it into multiple classes.</p>
            </div>
        </section>

        <section>
            <h3>Advanced Topic: Dunder Methods</h3>
            
            <p>Python classes can implement special methods called "dunder methods" (short for "double underscore") that allow custom classes to work with Python's built-in operations and functions.</p>
            
            <p>We've already seen <code>__init__</code>, but there are many others:</p>
            
            <div class="code-example">
                <pre><code>class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # String representation for developers (debugging)
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
    
    # String representation for users
    def __str__(self):
        return f"({self.x}, {self.y})"
    
    # Enable + operator
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    
    # Enable == operator
    def __eq__(self, other):
        if not isinstance(other, Point):
            return False
        return self.x == other.x and self.y == other.y
    
    # Enable < operator (for sorting)
    def __lt__(self, other):
        return (self.x**2 + self.y**2) < (other.x**2 + other.y**2)
    
    # Make the object callable
    def __call__(self, z=0):
        return (self.x, self.y, z)

# Create points
p1 = Point(1, 2)
p2 = Point(3, 4)

# String representations
print(repr(p1))  # Output: Point(1, 2)
print(p1)        # Output: (1, 2)

# Operators
p3 = p1 + p2     # Uses __add__
print(p3)        # Output: (4, 6)

# Equality
print(p1 == p2)  # Output: False (uses __eq__)
print(p1 == Point(1, 2))  # Output: True

# Comparison
points = [Point(3, 4), Point(1, 2), Point(5, 1)]
sorted_points = sorted(points)  # Uses __lt__
print([str(p) for p in sorted_points])  # Output: ['(1, 2)', '(5, 1)', '(3, 4)']

# Callable
coordinates = p1()  # Uses __call__
print(coordinates)  # Output: (1, 2, 0)</code></pre>
            </div>
            
            <p>These special methods let your custom classes integrate seamlessly with Python's syntax and built-in functions. We'll cover these in more detail later in the course.</p>
        </section>

        <section>
            <h3>Hands-on Exercise: Building a Simple Class</h3>
            
            <p>Let's consolidate our understanding with a hands-on exercise. Try implementing a <code>Rectangle</code> class with the following requirements:</p>
            
            <ol>
                <li>It should have <code>width</code> and <code>height</code> attributes</li>
                <li>It should have methods to calculate the area and perimeter</li>
                <li>It should be able to determine if it's a square</li>
                <li>It should have a method to return a scaled version of itself</li>
                <li>It should have appropriate string representation methods</li>
            </ol>
            
            <div class="code-example">
                <p>Solution:</p>
                <pre><code>class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
    
    def is_square(self):
        return self.width == self.height
    
    def scale(self, factor):
        return Rectangle(self.width * factor, self.height * factor)
    
    def __str__(self):
        return f"Rectangle(width={self.width}, height={self.height})"
    
    def __repr__(self):
        return f"Rectangle({self.width}, {self.height})"

# Testing the Rectangle class
rect1 = Rectangle(5, 3)
print(f"Area: {rect1.area()}")         # Output: Area: 15
print(f"Perimeter: {rect1.perimeter()}")  # Output: Perimeter: 16
print(f"Is square: {rect1.is_square()}")  # Output: Is square: False

rect2 = Rectangle(4, 4)
print(f"Is square: {rect2.is_square()}")  # Output: Is square: True

rect3 = rect1.scale(2)
print(rect3)  # Output: Rectangle(width=10, height=6)</code></pre>
            </div>
        </section>

        <section>
            <h3>Conclusion</h3>
            <p>In this session, we've covered the fundamentals of classes and objects in Python:</p>
            <ul>
                <li>What classes and objects are and how they relate to each other</li>
                <li>How to define classes with attributes and methods</li>
                <li>How to create and use objects</li>
                <li>The difference between class and instance attributes and methods</li>
                <li>How to work with special methods</li>
                <li>Best practices for designing and implementing classes</li>
            </ul>
            
            <p>Classes and objects are powerful tools for organizing code and modeling real-world entities. As you continue your journey in Object-Oriented Programming, you'll build on these fundamentals to create more complex and powerful systems.</p>
            
            <p>In the next session, we'll explore more advanced OOP concepts, including inheritance, polymorphism, and abstraction, which will allow you to create relationships between classes and build more sophisticated object-oriented designs.</p>
            
            <div class="practice-exercise">
                <h4>Practice Exercise</h4>
                <p>Try designing and implementing a class for another real-world entity of your choice. Some ideas:</p>
                <ul>
                    <li>A <code>Book</code> class with title, author, and methods to track reading progress</li>
                    <li>A <code>Student</code> class with name, ID, and methods to track grades</li>
                    <li>A <code>ShoppingCart</code> class with methods to add/remove items and calculate totals</li>
                </ul>
                <p>Remember to think about what attributes and methods would be appropriate, and consider whether any special methods would make your class more intuitive to use.</p>
            </div>
        </section>

        <section class="additional-resources">
            <h3>Additional Resources</h3>
            <ul>
                <li><a href="https://docs.python.org/3/tutorial/classes.html" target="_blank">Python Official Documentation on Classes</a></li>
                <li><a href="https://realpython.com/python3-object-oriented-programming/" target="_blank">Real Python: OOP in Python 3</a></li>
                <li><a href="https://realpython.com/python-repr-vs-str/" target="_blank">Real Python: String Representations</a></li>
                <li><a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" target="_blank">Python Special Method Names</a></li>
                <li>Recommended Book: "Fluent Python" by Luciano Ramalho (Chapters on Classes and Objects)</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
