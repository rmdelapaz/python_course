<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Attributes and Methods in Object-Oriented Programming</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Attributes and Methods in Object-Oriented Programming</h1>
        <h2>Week 3: Monday Morning Session</h2>
    </header>

    <main>
        <section class="lesson-intro">
            <h3>Lesson Overview</h3>
            <p>Welcome to our exploration of attributes and methods - the building blocks that give objects their characteristics and behaviors in Object-Oriented Programming (OOP). Today's session will demystify how we define and use these essential components to create powerful, flexible, and reusable code in Python.</p>
            

        </section>

        <section>
            <h3>Understanding Attributes and Methods</h3>
            
            <p>In Object-Oriented Programming, classes serve as blueprints for objects, and these objects are composed of two main elements:</p>
            
            <ul>
                <li><strong>Attributes</strong>: The data or properties that objects hold (the "has-a" relationships)</li>
                <li><strong>Methods</strong>: The functions or actions that objects can perform (the "can-do" capabilities)</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Real-world analogy:</strong> Think of a car. A car has attributes like color, make, model, current speed, and fuel level. These are its properties or characteristics. A car can also perform actions like accelerate, brake, turn, and honk its horn. These are its methods or behaviors.</p>
                
                <p>In programming terms:</p>
                <ul>
                    <li>Attributes are like the adjectives that describe an object</li>
                    <li>Methods are like the verbs that describe what an object can do</li>
                </ul>
            </div>
            
            <p>Let's explore each of these concepts in depth, examining how they work in Python's implementation of OOP.</p>
        </section>

        <section>
            <h3>Attributes in Python</h3>
            
            <p>Attributes are variables that store data within a class or instance. In Python, there are two main types of attributes:</p>
            
            <h4>Class Attributes</h4>
            <p>Class attributes belong to the class itself rather than any specific instance. They are defined directly within the class but outside of any methods. All instances of the class share the same class attributes, and if a class attribute is modified, the change affects all instances.</p>
            
            <h4>Instance Attributes</h4>
            <p>Instance attributes belong to a specific instance of a class. They are typically defined in the <code>__init__</code> method and are prefixed with <code>self.</code> to indicate they belong to the instance being created. Each instance has its own copy of instance attributes, which can have different values across instances.</p>
            
            <div class="code-example">
                <pre><code>class Car:
    # Class attribute
    wheels = 4  # All cars typically have 4 wheels
    
    def __init__(self, make, model, color, fuel_level=100):
        # Instance attributes
        self.make = make
        self.model = model
        self.color = color
        self.fuel_level = fuel_level
        self.speed = 0  # Car starts at 0 speed

# Creating car instances
tesla = Car("Tesla", "Model 3", "Red")
toyota = Car("Toyota", "Corolla", "Blue", 75)

# Accessing class attributes
print(Car.wheels)       # Output: 4
print(tesla.wheels)     # Output: 4 (accessed through instance)
print(toyota.wheels)    # Output: 4 (accessed through instance)

# Accessing instance attributes
print(tesla.make)       # Output: Tesla
print(tesla.color)      # Output: Red
print(toyota.model)     # Output: Corolla
print(toyota.fuel_level)  # Output: 75

# Modifying instance attributes
tesla.speed = 60
print(tesla.speed)      # Output: 60
print(toyota.speed)     # Output: 0 (unchanged)

# Modifying class attribute (affects ALL instances)
Car.wheels = 6
print(Car.wheels)       # Output: 6
print(tesla.wheels)     # Output: 6
print(toyota.wheels)    # Output: 6</code></pre>
            </div>
            
            <div class="concept-highlight">
                <p><strong>Important distinction:</strong> Class attributes are shared among all instances, while instance attributes are unique to each instance. Think of class attributes as traits common to the entire species, while instance attributes are characteristics unique to each individual.</p>
            </div>
            
            <h4>Attribute Best Practices</h4>
            <p>When working with attributes in Python, consider these best practices:</p>
            
            <ul>
                <li><strong>Initialize all instance attributes in <code>__init__</code>:</strong> This makes your code more readable and prevents AttributeError exceptions</li>
                <li><strong>Use class attributes for constants or default values:</strong> Values that are the same across all instances</li>
                <li><strong>Be cautious with mutable class attributes:</strong> Lists, dictionaries, and other mutable objects as class attributes can cause unexpected behavior</li>
                <li><strong>Use naming conventions:</strong> By Python convention, prefix "private" attributes with an underscore (_) to indicate they shouldn't be accessed directly</li>
            </ul>
            
            <div class="code-example">
                <pre><code># Caution with mutable class attributes
class BadExample:
    items = []  # This list is shared by ALL instances!
    
    def add_item(self, item):
        self.items.append(item)  # Modifies the class attribute

instance1 = BadExample()
instance2 = BadExample()

instance1.add_item("apple")
print(instance1.items)  # Output: ['apple']
print(instance2.items)  # Output: ['apple'] - Surprise! instance2's list has the item too!

# Better approach
class GoodExample:
    def __init__(self):
        self.items = []  # Each instance gets its own list
    
    def add_item(self, item):
        self.items.append(item)

instance1 = GoodExample()
instance2 = GoodExample()

instance1.add_item("apple")
print(instance1.items)  # Output: ['apple']
print(instance2.items)  # Output: [] - This is what we want!</code></pre>
            </div>
        </section>

        <section>
            <h3>Dynamic Attributes in Python</h3>
            
            <p>Unlike some OOP languages, Python allows the dynamic addition of attributes to instances after they've been created. This flexibility can be both powerful and dangerous if not used carefully.</p>
            
            <div class="code-example">
                <pre><code>class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

alice = Person("Alice", 30)

# Adding an attribute dynamically
alice.email = "alice@example.com"
print(alice.email)  # Output: alice@example.com

# But this only affects the 'alice' instance
bob = Person("Bob", 25)
# print(bob.email)  # This would raise an AttributeError</code></pre>
            </div>
            
            <p>To restrict this behavior and enforce a more rigid attribute structure, you can use the <code>__slots__</code> class variable:</p>
            
            <div class="code-example">
                <pre><code>class PersonWithSlots:
    __slots__ = ['name', 'age']  # Only these attributes are allowed
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

charlie = PersonWithSlots("Charlie", 35)
# charlie.email = "charlie@example.com"  # This would raise an AttributeError</code></pre>
            </div>
            
            <p>Using <code>__slots__</code> also makes your classes more memory-efficient, which can be important when creating many instances.</p>
        </section>

        <section>
            <h3>Property Decorators: Controlled Attribute Access</h3>
            
            <p>In many cases, you want to control how attributes are accessed or modified. Python's property decorators let you define methods that act like attributes, giving you more control while maintaining a clean interface.</p>
            
            <div class="code-example">
                <pre><code>class Temperature:
    def __init__(self, celsius=0):
        self._celsius = celsius  # Private-by-convention attribute
    
    # Getter method (called when accessing the attribute)
    @property
    def celsius(self):
        return self._celsius
    
    # Setter method (called when modifying the attribute)
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:  # Absolute zero check
            raise ValueError("Temperature below absolute zero is not possible")
        self._celsius = value
    
    # Another property that depends on celsius
    @property
    def fahrenheit(self):
        return (self._celsius * 9/5) + 32
    
    # Setter for fahrenheit
    @fahrenheit.setter
    def fahrenheit(self, value):
        self.celsius = (value - 32) * 5/9  # Convert and use the celsius setter

# Using properties
temp = Temperature(25)  # 25Â°C

# Accessing properties
print(temp.celsius)      # Output: 25
print(temp.fahrenheit)   # Output: 77.0

# Setting properties with validation
temp.celsius = 30
print(temp.celsius)      # Output: 30

# Setting derived properties
temp.fahrenheit = 68
print(temp.celsius)      # Output: 20.0

# Validation in action
try:
    temp.celsius = -300  # Below absolute zero
except ValueError as e:
    print(e)  # Output: Temperature below absolute zero is not possible</code></pre>
            </div>
            
            <p>Properties give you the benefits of encapsulation while maintaining a clean, attribute-like interface:</p>
            <ul>
                <li>You can add validation logic</li>
                <li>You can compute values on-the-fly</li>
                <li>You can trigger side effects when attributes are accessed or modified</li>
                <li>You can maintain backward compatibility when implementation details change</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Analogy:</strong> Think of properties like a secure mailbox. From the outside, it looks like a simple way to drop off or pick up mail (get/set values). But behind the scenes, there's sophisticated processing happening - mail gets sorted, validated, and potentially transformed before it reaches its destination.</p>
            </div>
        </section>

        <section>
            <h3>Methods in Python</h3>
            
            <p>Methods are functions defined inside a class that describe the behaviors of its instances. Methods define what objects can do and how they can interact with their attributes and the outside world.</p>
            
            <p>In Python, there are several types of methods:</p>
            
            <h4>Instance Methods</h4>
            <p>These are the most common type of methods. They take <code>self</code> as their first parameter, which refers to the instance on which the method is called. Instance methods can access and modify the instance's attributes.</p>
            
            <h4>Class Methods</h4>
            <p>These methods are bound to the class rather than its instances. They take <code>cls</code> as their first parameter, which refers to the class itself. Class methods are defined using the <code>@classmethod</code> decorator and can access and modify class-level attributes.</p>
            
            <h4>Static Methods</h4>
            <p>These methods don't operate on either the instance or the class. They're defined using the <code>@staticmethod</code> decorator and don't take <code>self</code> or <code>cls</code> as their first parameter. They're essentially regular functions that are logically related to the class.</p>
            
            <div class="code-example">
                <pre><code>class MathOperations:
    pi = 3.14159  # Class attribute
    
    def __init__(self, value):
        self.value = value  # Instance attribute
    
    # Instance method
    def square(self):
        return self.value ** 2
    
    # Class method
    @classmethod
    def circle_area(cls, radius):
        return cls.pi * radius ** 2
    
    # Static method
    @staticmethod
    def add(x, y):
        return x + y

# Creating an instance
math_ops = MathOperations(4)

# Calling instance method
print(math_ops.square())  # Output: 16

# Calling class method
area = MathOperations.circle_area(5)
print(area)  # Output: 78.53975

# Calling static method
sum_result = MathOperations.add(10, 20)
print(sum_result)  # Output: 30</code></pre>
            </div>
            
            <div class="concept-highlight">
                <p><strong>When to use each type of method:</strong></p>
                <ul>
                    <li>Use <strong>instance methods</strong> when you need to access or modify instance-specific data</li>
                    <li>Use <strong>class methods</strong> when you need to access or modify class attributes, or when you want to create alternative constructors</li>
                    <li>Use <strong>static methods</strong> for utility functions that are related to the class's domain but don't need access to instance or class data</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Method Implementation Patterns</h3>
            
            <p>Let's explore some common patterns for implementing methods in your classes:</p>
            
            <h4>Accessor Methods (Getters)</h4>
            <p>Methods that return the value of a specific attribute, often with some additional processing or formatting:</p>
            
            <div class="code-example">
                <pre><code>class User:
    def __init__(self, first_name, last_name, birth_year):
        self.first_name = first_name
        self.last_name = last_name
        self.birth_year = birth_year
    
    # Accessor method
    def get_full_name(self):
        return f"{self.first_name} {self.last_name}"
    
    # Accessor with calculation
    def get_age(self, current_year):
        return current_year - self.birth_year

user = User("Ada", "Lovelace", 1815)
print(user.get_full_name())  # Output: Ada Lovelace
print(user.get_age(2025))    # Output: 210</code></pre>
            </div>
            
            <h4>Mutator Methods (Setters)</h4>
            <p>Methods that modify the state of an object by changing its attributes, often with validation:</p>
            
            <div class="code-example">
                <pre><code>class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self._balance = balance  # Private-by-convention
    
    # Mutator method with validation
    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        self._balance += amount
        return self._balance
    
    # Another mutator with validation
    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("Withdrawal amount must be positive")
        if amount > self._balance:
            raise ValueError("Insufficient funds")
        self._balance -= amount
        return self._balance
    
    # Accessor method
    def get_balance(self):
        return self._balance

account = BankAccount("Alice", 1000)
print(account.get_balance())  # Output: 1000
account.deposit(500)
print(account.get_balance())  # Output: 1500
account.withdraw(200)
print(account.get_balance())  # Output: 1300</code></pre>
            </div>
            
            <h4>Helper Methods</h4>
            <p>These are internal methods that help other methods do their job. They're typically prefixed with an underscore to indicate they're not meant to be called directly:</p>
            
            <div class="code-example">
                <pre><code>class TextProcessor:
    def __init__(self, text):
        self.text = text
    
    # Main public method
    def get_word_count(self):
        words = self._clean_and_split()
        return len(words)
    
    # Helper method (private by convention)
    def _clean_and_split(self):
        # Remove punctuation, convert to lowercase, and split into words
        cleaned_text = ''.join(c if c.isalnum() or c.isspace() else ' ' for c in self.text.lower())
        return cleaned_text.split()
    
    # Another public method that uses the helper
    def get_unique_words(self):
        words = self._clean_and_split()
        return len(set(words))

text = "Hello, world! This is a sample text. Hello again."
processor = TextProcessor(text)
print(processor.get_word_count())    # Output: 9
print(processor.get_unique_words())  # Output: 8</code></pre>
            </div>
            
            <h4>Alternative Constructor Methods</h4>
            <p>These class methods create instances in a different way than the standard <code>__init__</code> method:</p>
            
            <div class="code-example">
                <pre><code>class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day
    
    # Standard string representation
    def __str__(self):
        return f"{self.year}-{self.month:02d}-{self.day:02d}"
    
    # Alternative constructor from string
    @classmethod
    def from_string(cls, date_string):
        year, month, day = map(int, date_string.split('-'))
        return cls(year, month, day)
    
    # Another alternative constructor
    @classmethod
    def from_timestamp(cls, timestamp):
        import datetime
        dt = datetime.datetime.fromtimestamp(timestamp)
        return cls(dt.year, dt.month, dt.day)

# Standard initialization
date1 = Date(2023, 12, 31)
print(date1)  # Output: 2023-12-31

# Using alternative constructors
date2 = Date.from_string("2025-04-15")
print(date2)  # Output: 2025-04-15

date3 = Date.from_timestamp(1609459200)  # January 1, 2021
print(date3)  # Output: 2021-01-01</code></pre>
            </div>
        </section>

        <section>
            <h3>Method Chaining</h3>
            
            <p>Method chaining is a pattern where methods return <code>self</code> (the instance), allowing multiple method calls to be chained together in a single statement. This creates more readable, fluid interfaces:</p>
            
            <div class="code-example">
                <pre><code>class StringBuilder:
    def __init__(self, initial=''):
        self.content = initial
    
    def append(self, text):
        self.content += text
        return self  # Return self for chaining
    
    def append_line(self, text):
        self.content += text + '\n'
        return self  # Return self for chaining
    
    def clear(self):
        self.content = ''
        return self  # Return self for chaining
    
    def __str__(self):
        return self.content

# Using method chaining
builder = StringBuilder("Hello")
result = builder.append(", ").append("World").append_line("!").append("How are you?")

print(result)
# Output:
# Hello, World!
# How are you?

# Without chaining, it would look like:
# builder = StringBuilder("Hello")
# builder.append(", ")
# builder.append("World")
# builder.append_line("!")
# builder.append("How are you?")</code></pre>
            </div>
            
            <p>Method chaining is common in libraries like Pandas and SQLAlchemy, where it allows for expressive, readable code.</p>
            
            <div class="concept-highlight">
                <p><strong>Analogy:</strong> Think of method chaining like giving a series of instructions to a chef: "Take the dough, add cheese, add toppings, bake for 15 minutes, and serve." Each step builds on the previous one, and the result flows naturally from one operation to the next.</p>
            </div>
        </section>

        <section>
            <h3>Special Methods (Dunder Methods)</h3>
            
            <p>Python has special method names that start and end with double underscores ("dunder" = "double underscore"). These methods allow your classes to integrate with Python's built-in functions and operators.</p>
            
            <p>We've already seen <code>__init__</code>, but there are many others:</p>
            
            <div class="code-example">
                <pre><code>class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # String representation (used by str() and print())
    def __str__(self):
        return f"({self.x}, {self.y})"
    
    # Developer representation (used in debugging)
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"
    
    # Addition (v1 + v2)
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    # Subtraction (v1 - v2)
    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)
    
    # Multiplication (v * scalar)
    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)
    
    # Length (len(v))
    def __len__(self):
        return int((self.x**2 + self.y**2)**0.5)
    
    # Equality (v1 == v2)
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

# Creating vectors
v1 = Vector(3, 4)
v2 = Vector(1, 2)

# Using special methods through operators and functions
print(v1)                  # Output: (3, 4) - uses __str__
print(repr(v1))            # Output: Vector(3, 4) - uses __repr__
v3 = v1 + v2               # Uses __add__
print(v3)                  # Output: (4, 6)
v4 = v1 - v2               # Uses __sub__
print(v4)                  # Output: (2, 2)
v5 = v2 * 3                # Uses __mul__
print(v5)                  # Output: (3, 6)
print(len(v1))             # Output: 5 - uses __len__
print(v1 == Vector(3, 4))  # Output: True - uses __eq__</code></pre>
            </div>
            
            <p>Some other useful special methods include:</p>
            <ul>
                <li><code>__getitem__</code> and <code>__setitem__</code>: For indexing operations (object[key])</li>
                <li><code>__contains__</code>: For membership tests (item in object)</li>
                <li><code>__call__</code>: Makes objects callable like functions (object())</li>
                <li><code>__enter__</code> and <code>__exit__</code>: For context managers (with statements)</li>
                <li><code>__iter__</code> and <code>__next__</code>: For iteration (for loops)</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Python's philosophy:</strong> By implementing these special methods, you allow your custom objects to behave like Python's built-in types, following the "duck typing" principle: "If it walks like a duck and quacks like a duck, then it probably is a duck." This creates a consistent, intuitive interface for your classes.</p>
            </div>
        </section>

        <section>
            <h3>Practical Example: Building a Product Inventory System</h3>
            
            <p>Let's apply our knowledge of attributes and methods to build a more complex example: a product inventory system. This will demonstrate how attributes and methods work together to create a functional application.</p>
            
            <div class="code-example">
                <pre><code>class Product:
    # Class attribute - tracks all products
    all_products = []
    
    def __init__(self, name, price, quantity=0):
        # Validate inputs
        assert price > 0, f"Price {price} must be positive"
        assert quantity >= 0, f"Quantity {quantity} must be non-negative"
        
        # Instance attributes
        self.name = name
        self.price = price
        self.quantity = quantity
        self._is_active = True
        
        # Add to class list
        Product.all_products.append(self)
    
    # Instance method
    def calculate_total_value(self):
        return self.price * self.quantity
    
    # Property for active status
    @property
    def is_active(self):
        return self._is_active
    
    # Method to discontinue product
    def discontinue(self):
        self._is_active = False
        return f"{self.name} has been discontinued"
    
    # Method to restock
    def restock(self, amount):
        if amount <= 0:
            raise ValueError("Restock amount must be positive")
        self.quantity += amount
        return f"{amount} units of {self.name} added to inventory"
    
    # Method to sell
    def sell(self, amount):
        if amount <= 0:
            raise ValueError("Sell amount must be positive")
        if amount > self.quantity:
            raise ValueError(f"Cannot sell {amount} units, only {self.quantity} available")
        self.quantity -= amount
        return f"{amount} units of {self.name} sold"
    
    # String representation
    def __str__(self):
        status = "active" if self._is_active else "discontinued"
        return f"{self.name}: ${self.price:.2f} ({self.quantity} in stock, {status})"
    
    # Class method to find product by name
    @classmethod
    def find_by_name(cls, name):
        for product in cls.all_products:
            if product.name.lower() == name.lower():
                return product
        return None
    
    # Class method to get active products
    @classmethod
    def get_active_products(cls):
        return [p for p in cls.all_products if p.is_active]
    
    # Class method to get out-of-stock products
    @classmethod
    def get_out_of_stock(cls):
        return [p for p in cls.all_products if p.quantity == 0 and p.is_active]
    
    # Static method to convert currency
    @staticmethod
    def convert_price(price, exchange_rate):
        return price * exchange_rate

# Using our Product class
# Create some products
laptop = Product("Laptop", 1200, 5)
phone = Product("Smartphone", 800, 10)
tablet = Product("Tablet", 300, 8)
headphones = Product("Wireless Headphones", 150, 15)

# Using instance methods
print(laptop)  # Output: Laptop: $1200.00 (5 in stock, active)
laptop.sell(2)
print(laptop)  # Output: Laptop: $1200.00 (3 in stock, active)
print(f"Total value of laptop inventory: ${laptop.calculate_total_value()}")  # Output: $3600.00

# Using properties
print(f"Is the phone active? {phone.is_active}")  # Output: True
phone.discontinue()
print(f"Is the phone active? {phone.is_active}")  # Output: False

# Using class methods
active_products = Product.get_active_products()
print(f"Active products: {len(active_products)}")  # Output: 3

# Sell all tablets to test out-of-stock functionality
tablet.sell(8)
out_of_stock = Product.get_out_of_stock()
print(f"Out of stock products: {len(out_of_stock)}")  # Output: 1
print(out_of_stock[0])  # Output: Tablet: $300.00 (0 in stock, active)

# Using static method
euro_price = Product.convert_price(laptop.price, 0.85)
print(f"Laptop price in euros: â¬{euro_price:.2f}")  # Output: â¬1020.00</code></pre>
            </div>
            
            <p>This example demonstrates:</p>
            <ul>
                <li><strong>Class Attributes</strong>: To track all products</li>
                <li><strong>Instance Attributes</strong>: For product-specific data</li>
                <li><strong>Property Decorators</strong>: For controlled access to attributes</li>
                <li><strong>Instance Methods</strong>: For operations on specific products</li>
                <li><strong>Class Methods</strong>: For operations across all products</li>
                <li><strong>Static Methods</strong>: For utility operations</li>
                <li><strong>Special Methods</strong>: For string representation</li>
            </ul>
        </section>

        <section>
            <h3>Best Practices for Attributes and Methods</h3>
            
            <h4>Naming Conventions</h4>
            <ul>
                <li>Use CamelCase for class names: <code>BankAccount</code>, <code>Product</code></li>
                <li>Use snake_case for attributes and methods: <code>account_number</code>, <code>calculate_interest</code></li>
                <li>Use a leading underscore for "private" attributes and methods: <code>_balance</code>, <code>_validate_input</code></li>
                <li>Use verbs for method names to indicate actions: <code>get_balance()</code>, <code>withdraw()</code>, <code>calculate_total()</code></li>
            </ul>
            
            <h4>Design Principles</h4>
            <ul>
                <li><strong>Encapsulation</strong>: Keep data (attributes) and operations (methods) together, and hide implementation details</li>
                <li><strong>Single Responsibility</strong>: Each method should do one thing well</li>
                <li><strong>Validate inputs</strong>: Check parameters in methods to prevent invalid states</li>
                <li><strong>Clear interfaces</strong>: Methods should have clear names and purposes</li>
                <li><strong>Don't repeat yourself (DRY)</strong>: Extract common functionality into helper methods</li>
            </ul>
            
            <h4>Common Mistakes to Avoid</h4>
            <ul>
                <li><strong>Exposing too much</strong>: Don't make all attributes directly accessible if they need validation</li>
                <li><strong>Methods that do too much</strong>: Break complex methods into smaller, focused ones</li>
                <li><strong>Inconsistent naming</strong>: Stick to clear conventions for better readability</li>
                <li><strong>Mutable class attributes</strong>: Be careful with lists, dictionaries as class attributes</li>
                <li><strong>Too many methods</strong>: Keep your class focused on its core responsibilities</li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Principle:</strong> Think of the "public interface" of your class as a contract with others who will use it. Design attributes and methods to be intuitive, consistent, and resistant to misuse.</p>
            </div>
        </section>

        <section>
            <h3>Attributes and Methods in the Python Ecosystem</h3>
            
            <p>Understanding attributes and methods will help you work with many Python libraries and frameworks:</p>
            
            <h4>Built-in Types</h4>
            <p>Python's built-in types have methods you've likely used:</p>
            <ul>
                <li>Lists: <code>append()</code>, <code>extend()</code>, <code>sort()</code></li>
                <li>Strings: <code>upper()</code>, <code>lower()</code>, <code>split()</code></li>
                <li>Dictionaries: <code>keys()</code>, <code>values()</code>, <code>get()</code></li>
            </ul>
            
            <h4>Pandas and Data Science</h4>
            <p>Pandas DataFrames use methods extensively for data manipulation:</p>
            <ul>
                <li><code>df.head()</code>, <code>df.describe()</code>, <code>df.groupby()</code></li>
                <li>Method chaining: <code>df.groupby('column').mean().sort_values()</code></li>
            </ul>
            
            <h4>Web Frameworks</h4>
            <p>Django and Flask rely on classes with attributes and methods:</p>
            <ul>
                <li>Django models: <code>Article.objects.filter(published=True)</code></li>
                <li>Flask: <code>app.route('/')</code>, <code>request.form.get('username')</code></li>
            </ul>
            
            <div class="concept-highlight">
                <p><strong>Real-world application:</strong> When using Django (which we'll cover later in the course), you'll define model classes where attributes become database fields and methods define business logic:</p>
                <pre><code>from django.db import models

class Order(models.Model):
    # Attributes become database fields
    customer = models.ForeignKey('Customer', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=20, choices=[
        ('pending', 'Pending'),
        ('paid', 'Paid'),
        ('shipped', 'Shipped'),
        ('delivered', 'Delivered')
    ])
    total_amount = models.DecimalField(max_digits=10, decimal_places=2)
    
    # Methods provide business logic
    def mark_as_paid(self):
        if self.status == 'pending':
            self.status = 'paid'
            self.save()
            return True
        return False
    
    def mark_as_shipped(self):
        if self.status == 'paid':
            self.status = 'shipped'
            self.save()
            return True
        return False
    
    # Property provides derived data
    @property
    def is_complete(self):
        return self.status == 'delivered'
    
    # Class method provides a way to find orders
    @classmethod
    def get_pending_orders(cls):
        return cls.objects.filter(status='pending')</code></pre>
            </div>
        </section>

        <section>
            <h3>Advanced Topics</h3>
            
            <h4>Descriptors</h4>
            <p>Descriptors provide a powerful way to customize attribute access at the class level. They implement a combination of <code>__get__</code>, <code>__set__</code>, and <code>__delete__</code> methods.</p>
            
            <div class="code-example">
                <pre><code>class PositiveNumber:
    def __init__(self):
        self.name = None  # Will be set in __set_name__
    
    def __set_name__(self, owner, name):
        self.name = name
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__[self.name]
    
    def __set__(self, instance, value):
        if value <= 0:
            raise ValueError(f"{self.name} must be positive")
        instance.__dict__[self.name] = value

class Product:
    price = PositiveNumber()
    quantity = PositiveNumber()
    
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price      # This will use the descriptor
        self.quantity = quantity  # This will use the descriptor
    
    def total_value(self):
        return self.price * self.quantity

# Using the class with descriptors
product = Product("Laptop", 1200, 5)
print(product.price)  # Output: 1200

try:
    product.price = -100  # This will raise an error
except ValueError as e:
    print(e)  # Output: price must be positive</code></pre>
            </div>
            
            <h4>Attribute Lookup Customization</h4>
            <p>You can customize attribute lookup with <code>__getattr__</code> and <code>__setattr__</code> methods:</p>
            
            <div class="code-example">
                <pre><code>class FlexibleObject:
    def __init__(self, **kwargs):
        # Initialize with provided attributes
        for key, value in kwargs.items():
            setattr(self, key, value)
        
        # Track attribute access
        self._accessed = set()
    
    def __getattr__(self, name):
        # Called when an attribute isn't found normally
        print(f"Attempting to access undefined attribute: {name}")
        return None
    
    def __setattr__(self, name, value):
        # Called for ALL attribute assignments
        if name != "_accessed" and not name.startswith("_"):
            if hasattr(self, "_accessed"):
                self._accessed.add(name)
        
        # Actually set the attribute
        super().__setattr__(name, value)
    
    def get_accessed_attributes(self):
        return list(self._accessed)

# Using the flexible object
obj = FlexibleObject(name="Test", value=42)
print(obj.name)       # Output: Test
print(obj.value)      # Output: 42
print(obj.missing)    # Output: Attempting to access undefined attribute: missing
                     # Output: None

obj.new_attr = "Hello"
print(obj.get_accessed_attributes())  # Output: ['name', 'value', 'new_attr']</code></pre>
            </div>
        </section>

        <section>
            <h3>Hands-on Exercise: Building a Student Management System</h3>
            
            <p>Let's put our knowledge of attributes and methods into practice with a hands-on exercise. Your task is to build a <code>Student</code> class that manages student information and grades.</p>
            
            <p>Requirements:</p>
            <ol>
                <li>Store student name, ID, and courses with grades</li>
                <li>Calculate GPA (on a 4.0 scale)</li>
                <li>Add and remove courses</li>
                <li>Track the number of students created</li>
                <li>Find students by ID</li>
            </ol>
            
            <div class="code-example">
                <p>Here's a solution:</p>
                <pre><code>class Student:
    # Class attributes
    all_students = []
    grade_points = {"A": 4.0, "B": 3.0, "C": 2.0, "D": 1.0, "F": 0.0}
    
    def __init__(self, name, student_id):
        # Instance attributes
        self.name = name
        self.student_id = student_id
        self.courses = {}  # course_name: grade
        
        # Add to class list
        Student.all_students.append(self)
    
    # Instance methods
    def add_course(self, course_name, grade):
        if grade not in Student.grade_points:
            raise ValueError(f"Invalid grade '{grade}'. Must be one of {list(Student.grade_points.keys())}")
        self.courses[course_name] = grade
        return f"Added {course_name} with grade {grade}"
    
    def remove_course(self, course_name):
        if course_name in self.courses:
            del self.courses[course_name]
            return f"Removed {course_name}"
        return f"{course_name} not found in student's courses"
    
    @property
    def gpa(self):
        if not self.courses:
            return 0.0
        
        total_points = sum(Student.grade_points[grade] for grade in self.courses.values())
        return total_points / len(self.courses)
    
    def get_courses(self):
        if not self.courses:
            return "No courses registered"
        
        result = f"Courses for {self.name} (ID: {self.student_id}):\\n"
        for course, grade in self.courses.items():
            result += f"- {course}: {grade}\\n"
        return result
    
    # String representation
    def __str__(self):
        return f"{self.name} (ID: {self.student_id}, GPA: {self.gpa:.2f})"
    
    # Class methods
    @classmethod
    def find_by_id(cls, student_id):
        for student in cls.all_students:
            if student.student_id == student_id:
                return student
        return None
    
    @classmethod
    def get_all_students(cls):
        return cls.all_students
    
    @classmethod
    def get_student_count(cls):
        return len(cls.all_students)

# Using the Student class
alice = Student("Alice Smith", "A123")
bob = Student("Bob Johnson", "B456")
charlie = Student("Charlie Brown", "C789")

# Adding courses
alice.add_course("Python Programming", "A")
alice.add_course("Database Systems", "B")
alice.add_course("Web Development", "A")

bob.add_course("Python Programming", "C")
bob.add_course("Mathematics", "A")

# Checking GPA
print(alice)  # Output: Alice Smith (ID: A123, GPA: 3.67)
print(bob)    # Output: Bob Johnson (ID: B456, GPA: 3.50)
print(charlie)  # Output: Charlie Brown (ID: C789, GPA: 0.00)

# Removing a course
alice.remove_course("Database Systems")
print(alice.gpa)  # Output: 4.0 (now only has A grades)

# Using class methods
print(f"Total students: {Student.get_student_count()}")  # Output: 3

found_student = Student.find_by_id("B456")
print(found_student)  # Output: Bob Johnson (ID: B456, GPA: 3.50)

print(alice.get_courses())
# Output:
# Courses for Alice Smith (ID: A123):
# - Python Programming: A
# - Web Development: A</code></pre>
            </div>
            
            <p>This example demonstrates:</p>
            <ul>
                <li>Proper use of class and instance attributes</li>
                <li>Property decorators for calculated attributes (GPA)</li>
                <li>Validation in methods</li>
                <li>Class methods for searching and counting</li>
                <li>String representation</li>
                <li>Encapsulation of related data and behavior</li>
            </ul>
        </section>

        <section>
            <h3>Conclusion</h3>
            <p>In this session, we've explored the essential components of Object-Oriented Programming in Python:</p>
            <ul>
                <li><strong>Attributes</strong>: The data and properties that objects have</li>
                <li><strong>Methods</strong>: The behaviors and actions that objects can perform</li>
            </ul>
            
            <p>We've learned about:</p>
            <ul>
                <li>Class vs. instance attributes</li>
                <li>Property decorators for controlled attribute access</li>
                <li>Different types of methods: instance, class, and static</li>
                <li>Special methods for integrating with Python's operations</li>
                <li>Patterns for effective method implementation</li>
                <li>Best practices for designing classes</li>
            </ul>
            
            <p>These concepts form the building blocks of object-oriented design. As you continue in the course, you'll see how these fundamentals enable more advanced OOP features like inheritance, polymorphism, and abstraction.</p>
            
            <div class="practice-exercise">
                <h4>Practice Exercise</h4>
                <p>Extend the Student Management System to include:</p>
                <ol>
                    <li>A method to calculate class standing (Freshman, Sophomore, Junior, Senior) based on credits completed</li>
                    <li>A way to track attendance for each course</li>
                    <li>A class method to find all students with a GPA above a certain threshold</li>
                </ol>
                <p>Remember to apply the principles we've learned about proper attribute and method design!</p>
            </div>
        </section>

        <section class="additional-resources">
            <h3>Additional Resources</h3>
            <ul>
                <li><a href="https://docs.python.org/3/tutorial/classes.html" target="_blank">Python Official Documentation on Classes</a></li>
                <li><a href="https://realpython.com/python-property/" target="_blank">Real Python: Property Decorators</a></li>
                <li><a href="https://realpython.com/instance-class-and-static-methods-demystified/" target="_blank">Real Python: Methods Demystified</a></li>
                <li><a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" target="_blank">Python Special Method Names</a></li>
                <li>Recommended Book: "Fluent Python" by Luciano Ramalho (Chapter 9: A Pythonic Object)</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
