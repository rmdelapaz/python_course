<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOM Manipulation for Python Developers</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>DOM Manipulation</h1>
        <p class="subtitle">The Bridge Between JavaScript and the Webpage</p>
    </header>

    <div class="content">
        <section>
            <h2>Introduction to the Document Object Model</h2>
            <p>Welcome to our deep dive into DOM Manipulation! As Python developers venturing into the frontend world, understanding the Document Object Model (DOM) is your gateway to creating truly interactive web applications.</p>
            
            <p>Think of the DOM as a living, breathing representation of your HTML document. If HTML is the blueprint for a building, the DOM is the actual constructed building that you can modify in real-time—adding rooms, changing colors, or even tearing down walls without rebuilding from scratch.</p>
            
            <div class="analogy">
                <h3>Analogy: The DOM as a Family Tree</h3>
                <p>Imagine an ancient family tree where each person is a node (an element). The DOM is structured like this genealogical hierarchy:</p>
                <ul>
                    <li>The document itself is the original ancestor</li>
                    <li>The <code>&lt;html&gt;</code> element is the first descendant</li>
                    <li>Elements like <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> are its children</li>
                    <li>Every element can have multiple children</li>
                    <li>Elements can have attributes (like traits passed down)</li>
                    <li>Text content is like the personal stories of each family member</li>
                </ul>
                <p>With JavaScript, you can find any family member, learn about them, modify their traits, add new members, or even remove them from the tree.</p>
            </div>
            
            <p>Python developers might recognize similarities to working with XML or HTML using libraries like BeautifulSoup. The key difference? The DOM is <em>live</em> and <em>interactive</em>—changes are immediately reflected on the page.</p>
        </section>

        <section>
            <h2>The DOM and Browser Rendering</h2>
            
            <p>Before we dive into manipulation, let's understand how the browser creates and uses the DOM:</p>
            
            <ol>
                <li><strong>Parsing:</strong> Browser receives HTML and parses it</li>
                <li><strong>DOM Construction:</strong> Creates a tree-like object model in memory</li>
                <li><strong>Render Tree:</strong> Combines DOM with CSS (CSSOM) to determine visual appearance</li>
                <li><strong>Layout:</strong> Calculates size and position of all elements</li>
                <li><strong>Paint:</strong> Draws pixels to the screen</li>
            </ol>
            
            <p>When you modify the DOM with JavaScript, you trigger parts of this process again. Understanding this helps you write more efficient code.</p>
            
            <div class="real-world">
                <h3>Real-World Impact: Performance</h3>
                <p>Imagine you need to add 1,000 items to a list. Updating the DOM one by one would trigger 1,000 reflows and repaints. Instead, you could:</p>
                <pre><code>// Inefficient approach
const list = document.getElementById('myList');
for (let i = 0; i < 1000; i++) {
    list.innerHTML += `&lt;li&gt;Item ${i}&lt;/li&gt;`;  // Forces reflow each time
}

// Better approach
const list = document.getElementById('myList');
let html = '';
for (let i = 0; i < 1000; i++) {
    html += `&lt;li&gt;Item ${i}&lt;/li&gt;`;
}
list.innerHTML = html;  // Single reflow

// Best approach
const list = document.getElementById('myList');
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
    const item = document.createElement('li');
    item.textContent = `Item ${i}`;
    fragment.appendChild(item);
}
list.appendChild(fragment);  // Single reflow, no string parsing</code></pre>
            </div>
        </section>

        <section>
            <h2>Accessing DOM Elements</h2>
            
            <p>Before you can manipulate elements, you need to find them. JavaScript provides several methods to access DOM elements:</p>
            
            <div class="code-example">
                <h3>Element Selection Methods</h3>
                <pre><code>// By ID (returns a single element)
const header = document.getElementById('page-header');

// By class name (returns a live HTMLCollection)
const paragraphs = document.getElementsByClassName('content-paragraph');

// By tag name (returns a live HTMLCollection)
const allDivs = document.getElementsByTagName('div');

// By CSS selector (returns first matching element)
const firstButton = document.querySelector('.btn-primary');

// By CSS selector (returns all matching elements as a NodeList)
const allButtons = document.querySelectorAll('.btn');

// Finding elements relative to other elements
const parentElement = someElement.parentNode;
const children = someElement.children;
const nextSibling = someElement.nextElementSibling;
const previousSibling = someElement.previousElementSibling;</code></pre>
            </div>
            
            <div class="comparison">
                <h3>Python Comparison: BeautifulSoup vs. JavaScript DOM</h3>
                <table>
                    <tr>
                        <th>BeautifulSoup (Python)</th>
                        <th>DOM (JavaScript)</th>
                    </tr>
                    <tr>
                        <td><code>soup.find(id="header")</code></td>
                        <td><code>document.getElementById("header")</code></td>
                    </tr>
                    <tr>
                        <td><code>soup.find_all("p", class_="content")</code></td>
                        <td><code>document.querySelectorAll("p.content")</code></td>
                    </tr>
                    <tr>
                        <td><code>element.parent</code></td>
                        <td><code>element.parentNode</code></td>
                    </tr>
                    <tr>
                        <td><code>element.find_next_sibling()</code></td>
                        <td><code>element.nextElementSibling</code></td>
                    </tr>
                </table>
            </div>
            
            <div class="best-practice">
                <h3>Best Practices for Element Selection</h3>
                <ul>
                    <li><strong>Use <code>getElementById</code> when possible:</strong> It's the fastest selection method</li>
                    <li><strong>Prefer <code>querySelector/querySelectorAll</code> for complex selections:</strong> They're more versatile</li>
                    <li><strong>Be aware of live vs. static collections:</strong> <code>getElementsByClassName</code> returns a live collection that updates automatically when elements are added/removed</li>
                    <li><strong>Cache DOM references:</strong> Don't re-query the DOM repeatedly</li>
                </ul>
            </div>
            
            <div class="example">
                <h3>Practical Example: Tabbed Interface</h3>
                <pre><code>// HTML structure
// &lt;div class="tab-container"&gt;
//   &lt;div class="tabs"&gt;
//     &lt;button class="tab active" data-tab="tab1"&gt;Tab 1&lt;/button&gt;
//     &lt;button class="tab" data-tab="tab2"&gt;Tab 2&lt;/button&gt;
//     &lt;button class="tab" data-tab="tab3"&gt;Tab 3&lt;/button&gt;
//   &lt;/div&gt;
//   &lt;div class="tab-content active" id="tab1"&gt;Content for tab 1&lt;/div&gt;
//   &lt;div class="tab-content" id="tab2"&gt;Content for tab 2&lt;/div&gt;
//   &lt;div class="tab-content" id="tab3"&gt;Content for tab 3&lt;/div&gt;
// &lt;/div&gt;

// JavaScript implementation
document.addEventListener('DOMContentLoaded', () => {
    // Cache DOM elements
    const tabContainer = document.querySelector('.tab-container');
    const tabs = tabContainer.querySelectorAll('.tab');
    const tabContents = tabContainer.querySelectorAll('.tab-content');
    
    // Add click event to each tab
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            // Get the target tab content
            const targetId = tab.getAttribute('data-tab');
            const targetContent = document.getElementById(targetId);
            
            // Remove active class from all tabs and contents
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));
            
            // Add active class to clicked tab and target content
            tab.classList.add('active');
            targetContent.classList.add('active');
        });
    });
});</code></pre>
            </div>
        </section>

        <section>
            <h2>Manipulating Element Content</h2>
            
            <p>Once you've selected elements, you can modify their content using various properties:</p>
            
            <div class="code-example">
                <h3>Content Modification</h3>
                <pre><code>// Text content (safe, no HTML parsing)
element.textContent = 'New text content';
const currentText = element.textContent;

// Inner HTML (parses HTML, potential security risk with user input)
element.innerHTML = '&lt;strong&gt;Bold text&lt;/strong&gt; and normal text';
const currentHTML = element.innerHTML;

// Outer HTML (includes the element itself)
element.outerHTML = '&lt;div class="new-wrapper"&gt;Replaced content&lt;/div&gt;';

// Value (for form elements)
inputElement.value = 'New input value';
const currentValue = inputElement.value;</code></pre>
            </div>
            
            <div class="security-note">
                <h3>Security Alert: innerHTML and XSS</h3>
                <p>Be extremely cautious when using <code>innerHTML</code> with user-provided content. It can lead to Cross-Site Scripting (XSS) vulnerabilities:</p>
                <pre><code>// DANGEROUS - Never do this with user input!
const userInput = "&lt;img src='x' onerror='alert(\"Hacked!\")' /&gt;";
element.innerHTML = userInput;  // Will execute the script!

// SAFER - Use textContent for user input
element.textContent = userInput;  // Safely displays as text

// For sanitized HTML, consider a library like DOMPurify
// import DOMPurify from 'dompurify';
// element.innerHTML = DOMPurify.sanitize(userInput);</code></pre>
            </div>
            
            <p>As Python developers, you might be familiar with similar concerns when using template engines like Jinja2, which also need to escape user input to prevent injection attacks.</p>
        </section>

        <section>
            <h2>Creating and Modifying Elements</h2>
            
            <p>The DOM API allows you to create, modify, and remove elements dynamically:</p>
            
            <div class="code-example">
                <h3>Creating Elements</h3>
                <pre><code>// Create a new element
const newDiv = document.createElement('div');

// Create text node
const textNode = document.createTextNode('This is a text node');

// Create a document fragment (container for holding elements)
const fragment = document.createDocumentFragment();</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Adding Elements to the DOM</h3>
                <pre><code>// Append child to the end
parentElement.appendChild(newElement);

// Insert before a specific element
parentElement.insertBefore(newElement, referenceElement);

// Modern methods (better browser support required)
parentElement.append(element1, element2, 'text');  // Append multiple
parentElement.prepend(element);  // Insert at beginning
referenceElement.before(element);  // Insert before
referenceElement.after(element);  // Insert after
element.replaceWith(newElement);  // Replace</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Removing Elements</h3>
                <pre><code>// Remove a child element (old way)
parentElement.removeChild(childElement);

// Remove self (modern way)
element.remove();

// Clear all children
while (element.firstChild) {
    element.removeChild(element.firstChild);
}
// Or more simply:
element.innerHTML = '';</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Cloning Elements</h3>
                <pre><code>// Clone without event listeners and child elements
const shallowClone = element.cloneNode(false);

// Clone with all descendants and content
const deepClone = element.cloneNode(true);</code></pre>
            </div>
            
            <div class="real-world">
                <h3>Real-World Example: Dynamic Comment System</h3>
                <pre><code>function createCommentElement(comment) {
    // Create the comment container
    const commentEl = document.createElement('div');
    commentEl.className = 'comment';
    
    // Create avatar
    const avatar = document.createElement('img');
    avatar.className = 'comment-avatar';
    avatar.src = comment.authorAvatar || '/images/default-avatar.png';
    avatar.alt = `${comment.author}'s avatar`;
    
    // Create comment content
    const contentDiv = document.createElement('div');
    contentDiv.className = 'comment-content';
    
    // Create header with author and date
    const header = document.createElement('div');
    header.className = 'comment-header';
    
    const author = document.createElement('span');
    author.className = 'comment-author';
    author.textContent = comment.author;
    
    const date = document.createElement('span');
    date.className = 'comment-date';
    date.textContent = new Date(comment.timestamp).toLocaleString();
    
    header.appendChild(author);
    header.appendChild(date);
    
    // Create comment text
    const text = document.createElement('p');
    text.className = 'comment-text';
    text.textContent = comment.text;
    
    // Create comment actions
    const actions = document.createElement('div');
    actions.className = 'comment-actions';
    
    const replyBtn = document.createElement('button');
    replyBtn.textContent = 'Reply';
    replyBtn.addEventListener('click', () => handleReply(comment.id));
    
    const likeBtn = document.createElement('button');
    likeBtn.textContent = `Like (${comment.likes || 0})`;
    likeBtn.addEventListener('click', () => handleLike(comment.id));
    
    actions.appendChild(replyBtn);
    actions.appendChild(likeBtn);
    
    // Assemble the comment element
    contentDiv.appendChild(header);
    contentDiv.appendChild(text);
    contentDiv.appendChild(actions);
    
    commentEl.appendChild(avatar);
    commentEl.appendChild(contentDiv);
    
    return commentEl;
}

// Usage
function displayComments(comments) {
    const commentsContainer = document.getElementById('comments-container');
    
    // Clear existing comments
    commentsContainer.innerHTML = '';
    
    if (comments.length === 0) {
        const noComments = document.createElement('p');
        noComments.textContent = 'No comments yet. Be the first to comment!';
        commentsContainer.appendChild(noComments);
        return;
    }
    
    // Create a fragment to hold all comments
    const fragment = document.createDocumentFragment();
    
    // Add each comment to the fragment
    comments.forEach(comment => {
        const commentElement = createCommentElement(comment);
        fragment.appendChild(commentElement);
    });
    
    // Add all comments to the DOM in a single operation
    commentsContainer.appendChild(fragment);
}</code></pre>
            </div>
            
            <div class="analogy">
                <h3>Analogy: DOM Manipulation as Cooking</h3>
                <p>Creating and modifying DOM elements is like cooking a meal:</p>
                <ul>
                    <li><code>createElement</code> is gathering ingredients (creating raw elements)</li>
                    <li>Setting properties (<code>textContent</code>, attributes) is preparing the ingredients</li>
                    <li><code>appendChild</code>/<code>insertBefore</code> is combining ingredients in the cooking pot (the parent element)</li>
                    <li><code>documentFragment</code> is like a prep bowl for combining ingredients before adding to the final dish</li>
                    <li><code>cloneNode</code> is like doubling a recipe</li>
                    <li><code>remove</code> is taking something out of the dish</li>
                </ul>
                <p>Just as a good chef prepares ingredients before cooking, a good developer prepares DOM elements before adding them to the document.</p>
            </div>
        </section>

        <section>
            <h2>Working with Element Attributes</h2>
            
            <p>HTML elements have attributes that define their behavior and appearance. JavaScript provides several ways to work with these attributes:</p>
            
            <div class="code-example">
                <h3>Standard Attributes</h3>
                <pre><code>// Get attribute
const href = linkElement.getAttribute('href');

// Set attribute
buttonElement.setAttribute('disabled', 'true');

// Check if attribute exists
const hasTarget = linkElement.hasAttribute('target');

// Remove attribute
imageElement.removeAttribute('alt');

// Direct property access for standard attributes
imageElement.src = '/images/new-image.jpg';
linkElement.href = 'https://example.com';
buttonElement.disabled = true;</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Data Attributes</h3>
                <p>HTML5 introduced data attributes (<code>data-*</code>) for storing custom data:</p>
                <pre><code>// HTML: &lt;div id="user" data-user-id="123" data-role="admin"&gt;&lt;/div&gt;

const userElement = document.getElementById('user');

// Access via dataset property (camelCase)
const userId = userElement.dataset.userId;  // "123"
const role = userElement.dataset.role;      // "admin"

// Modify data attributes
userElement.dataset.lastLogin = "2023-06-15";
delete userElement.dataset.role;</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Working with Classes</h3>
                <p>The <code>classList</code> API provides an elegant way to work with CSS classes:</p>
                <pre><code>// Add a class
element.classList.add('highlight');

// Remove a class
element.classList.remove('inactive');

// Toggle a class (add if absent, remove if present)
element.classList.toggle('expanded');

// Check if element has a class
const isActive = element.classList.contains('active');

// Replace one class with another
element.classList.replace('loading', 'loaded');

// Add multiple classes
element.classList.add('visible', 'animated', 'fadeIn');</code></pre>
            </div>
            
            <div class="best-practice">
                <h3>Best Practices for Working with Attributes</h3>
                <ul>
                    <li>Use direct properties (<code>element.src</code>) when available, for better performance</li>
                    <li>Use <code>dataset</code> for custom data rather than inventing attributes</li>
                    <li>Use <code>classList</code> instead of manipulating the <code>className</code> string</li>
                    <li>Set <code>disabled</code>, <code>checked</code>, etc. as boolean properties, not attributes</li>
                </ul>
            </div>
        </section>

        <section>
            <h2>Styling Elements with JavaScript</h2>
            
            <p>JavaScript allows you to directly manipulate an element's style or work with computed styles:</p>
            
            <div class="code-example">
                <h3>Inline Styles</h3>
                <pre><code>// Get/set individual style properties (camelCase for CSS properties)
element.style.color = 'blue';
element.style.backgroundColor = '#f0f0f0';
element.style.marginTop = '20px';
const fontSize = element.style.fontSize;

// Bulk style updates
Object.assign(element.style, {
    color: 'white',
    backgroundColor: 'black',
    padding: '10px',
    borderRadius: '4px'
});</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Computed Styles</h3>
                <pre><code>// Get the actual computed style (after CSS is applied)
const styles = window.getComputedStyle(element);
const width = styles.width;  // "300px"
const display = styles.display;  // "block"

// Get specific property
const opacity = window.getComputedStyle(element).getPropertyValue('opacity');</code></pre>
            </div>
            
            <div class="best-practice">
                <h3>CSS Classes vs. Inline Styles</h3>
                <p>In most cases, it's better to add/remove CSS classes rather than setting inline styles:</p>
                <pre><code>// Instead of this
element.style.color = 'red';
element.style.fontWeight = 'bold';
element.style.backgroundColor = 'yellow';

// Do this
element.classList.add('error-message');</code></pre>
                <p>Benefits of the class-based approach:</p>
                <ul>
                    <li>Better separation of concerns (HTML, CSS, JS)</li>
                    <li>Easier to maintain and update styles</li>
                    <li>Better performance (browser can optimize class changes)</li>
                    <li>Respects CSS specificity rules</li>
                </ul>
            </div>
            
            <div class="real-world">
                <h3>Real-World Example: CSS Animation Control</h3>
                <pre><code>// Simple animation system using classes
function animateElement(element, animationName, duration = 1000) {
    return new Promise(resolve => {
        // Apply animation class
        element.classList.add(animationName);
        
        // Set duration through inline style
        element.style.animationDuration = `${duration}ms`;
        
        // Listen for animation end
        function handleAnimationEnd() {
            element.classList.remove(animationName);
            element.removeEventListener('animationend', handleAnimationEnd);
            resolve();
        }
        
        element.addEventListener('animationend', handleAnimationEnd);
    });
}

// Usage
async function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Animate in
    await animateElement(notification, 'fade-in', 300);
    
    // Wait 3 seconds
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // Animate out
    await animateElement(notification, 'fade-out', 300);
    
    // Remove from DOM
    notification.remove();
}</code></pre>
            </div>
        </section>

        <section>
            <h2>Event Handling</h2>
            
            <p>Events are the core of interactive web applications. They allow JavaScript to respond to user actions and system events.</p>
            
            <div class="code-example">
                <h3>Adding Event Listeners</h3>
                <pre><code>// Basic event listener
element.addEventListener('click', function(event) {
    console.log('Element clicked!');
});

// With arrow function
element.addEventListener('mouseover', (event) => {
    element.classList.add('hovered');
});

// With named function for later removal
function handleChange(event) {
    console.log('Value changed to:', event.target.value);
}
inputElement.addEventListener('change', handleChange);

// Removing event listeners
inputElement.removeEventListener('change', handleChange);</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Common Events</h3>
                <table>
                    <tr>
                        <th>Category</th>
                        <th>Events</th>
                    </tr>
                    <tr>
                        <td>Mouse</td>
                        <td>click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave</td>
                    </tr>
                    <tr>
                        <td>Keyboard</td>
                        <td>keydown, keyup, keypress</td>
                    </tr>
                    <tr>
                        <td>Form</td>
                        <td>submit, reset, change, input, focus, blur</td>
                    </tr>
                    <tr>
                        <td>Document</td>
                        <td>DOMContentLoaded, load, unload, beforeunload</td>
                    </tr>
                    <tr>
                        <td>Touch</td>
                        <td>touchstart, touchend, touchmove, touchcancel</td>
                    </tr>
                </table>
            </div>
            
            <div class="code-example">
                <h3>The Event Object</h3>
                <pre><code>element.addEventListener('click', (event) => {
    // Event properties
    console.log(event.type);     // "click"
    console.log(event.target);   // The element that triggered the event
    console.log(event.currentTarget); // The element the listener is attached to
    
    // Mouse event properties
    console.log(event.clientX, event.clientY); // Mouse position
    console.log(event.button);   // Mouse button (0=left, 1=middle, 2=right)
    
    // Keyboard event properties
    // (for keydown/keyup events)
    console.log(event.key);      // Key value ("a", "Enter", etc.)
    console.log(event.code);     // Physical key ("KeyA", "Enter")
    console.log(event.ctrlKey);  // Whether Ctrl was pressed
    console.log(event.shiftKey); // Whether Shift was pressed
    
    // Event control
    event.preventDefault();      // Prevent default behavior
    event.stopPropagation();     // Stop event bubbling
});</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Event Propagation (Bubbling and Capturing)</h3>
                <p>Events in the DOM propagate in three phases:</p>
                <ol>
                    <li><strong>Capturing Phase:</strong> Event travels down from the window to the target element</li>
                    <li><strong>Target Phase:</strong> Event reaches the target element</li>
                    <li><strong>Bubbling Phase:</strong> Event bubbles up from the target back to the window</li>
                </ol>
                <pre><code>// By default, listeners handle the bubbling phase
// Set the third parameter to true to handle the capturing phase
element.addEventListener('click', handler, true);  // Capture phase

// Stopping propagation
element.addEventListener('click', (event) => {
    event.stopPropagation();  // Prevents further bubbling
});</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Event Delegation</h3>
                <p>Instead of attaching events to many elements, attach one to a parent:</p>
                <pre><code>// Without delegation (inefficient for many items)
document.querySelectorAll('.menu-item').forEach(item => {
    item.addEventListener('click', handleItemClick);
});

// With delegation (better performance)
document.querySelector('.menu').addEventListener('click', (event) => {
    // Check if clicked element or its parent has the class we want
    const menuItem = event.target.closest('.menu-item');
    
    if (menuItem) {
        // Handle the menu item click
        console.log('Menu item clicked:', menuItem.textContent);
    }
});</code></pre>
            </div>
            
            <div class="analogy">
                <h3>Analogy: Event Bubbling as News Traveling</h3>
                <p>Event bubbling is like news traveling through a neighborhood:</p>
                <ol>
                    <li>Something happens at a specific house (the target element)</li>
                    <li>The homeowner knows first (target phase)</li>
                    <li>Then neighbors on the same street find out (parent elements)</li>
                    <li>Then the next neighborhood over (ancestors)</li>
                    <li>Finally, the whole town knows (document/window)</li>
                </ol>
                <p>Event delegation is like having one reporter at the town square, rather than placing a reporter at every house.</p>
            </div>
            
            <div class="real-world">
                <h3>Real-World Example: Interactive Todo List</h3>
                <pre><code>document.addEventListener('DOMContentLoaded', () => {
    const todoList = document.getElementById('todo-list');
    const newTodoForm = document.getElementById('new-todo-form');
    
    // Form submission - Add new todo
    newTodoForm.addEventListener('submit', (event) => {
        event.preventDefault();
        
        const todoInput = document.getElementById('new-todo-input');
        const todoText = todoInput.value.trim();
        
        if (todoText) {
            addTodoItem(todoText);
            todoInput.value = '';
        }
    });
    
    // Event delegation for the entire list
    todoList.addEventListener('click', (event) => {
        const target = event.target;
        
        // Handle "complete" button click
        if (target.classList.contains('todo-complete')) {
            const todoItem = target.closest('.todo-item');
            todoItem.classList.toggle('completed');
        }
        
        // Handle "delete" button click
        if (target.classList.contains('todo-delete')) {
            const todoItem = target.closest('.todo-item');
            
            // Add removing animation
            todoItem.classList.add('removing');
            
            // Remove after animation completes
            todoItem.addEventListener('animationend', () => {
                todoItem.remove();
            });
        }
    });
    
    function addTodoItem(text) {
        const todoItem = document.createElement('li');
        todoItem.className = 'todo-item';
        
        todoItem.innerHTML = `
            <span class="todo-text">${text}</span>
            <div class="todo-actions">
                <button class="todo-complete" aria-label="Mark as complete">✓</button>
                <button class="todo-delete" aria-label="Delete">×</button>
            </div>
        `;
        
        todoList.appendChild(todoItem);
    }
});</code></pre>
            </div>
        </section>

        <section>
            <h2>Form Handling</h2>
            
            <p>Working with forms is a common task in web development. JavaScript makes it easy to validate, collect, and submit form data.</p>
            
            <div class="code-example">
                <h3>Form Access and Submission</h3>
                <pre><code>// Get a form by ID
const form = document.getElementById('registration-form');

// Get form elements
const emailInput = form.elements.email; // By name attribute
const passwordInput = form.querySelector('#password'); // By CSS selector

// Handle form submission
form.addEventListener('submit', (event) => {
    event.preventDefault(); // Prevent default form submission
    
    // Validate form
    if (validateForm()) {
        // Get form data
        const formData = new FormData(form);
        
        // Send data to server (we'll cover this later)
        submitFormData(formData);
    }
});</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Form Data Collection</h3>
                <pre><code>// Using FormData API
const formData = new FormData(form);

// Get individual values
const email = formData.get('email');
const password = formData.get('password');

// Get all values (for multiple select/checkbox)
const interests = formData.getAll('interests');

// Convert to object
const formDataObj = Object.fromEntries(formData.entries());

// Manual collection
const formDataManual = {
    email: form.elements.email.value,
    password: form.elements.password.value,
    remember: form.elements.remember.checked,
    interests: Array.from(form.querySelectorAll('[name="interests"]:checked')).map(el => el.value)
};</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Form Validation</h3>
                <pre><code>// Basic form validation
function validateForm() {
    let isValid = true;
    
    // Clear previous error messages
    form.querySelectorAll('.error-message').forEach(el => el.remove());
    
    // Validate email
    const emailInput = form.elements.email;
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    
    if (!emailRegex.test(emailInput.value)) {
        showError(emailInput, 'Please enter a valid email address');
        isValid = false;
    }
    
    // Validate password
    const passwordInput = form.elements.password;
    
    if (passwordInput.value.length < 8) {
        showError(passwordInput, 'Password must be at least 8 characters');
        isValid = false;
    }
    
    return isValid;
}

// Show error message next to input
function showError(inputElement, message) {
    // Add error class to input
    inputElement.classList.add('is-invalid');
    
    // Create error message element
    const errorElement = document.createElement('div');
    errorElement.className = 'error-message';
    errorElement.textContent = message;
    
    // Insert after input
    inputElement.parentNode.insertBefore(errorElement, inputElement.nextSibling);
    
    // Focus the first invalid input
    if (!form.querySelector(':focus')) {
        inputElement.focus();
    }
}</code></pre>
            </div>
            
            <div class="code-example">
                <h3>HTML5 Form Validation</h3>
                <p>Modern browsers support built-in form validation:</p>
                <pre><code>&lt;!-- HTML with validation attributes -->
&lt;form id="registration-form">
    &lt;div>
        &lt;label for="email">Email:&lt;/label>
        &lt;input 
            type="email" 
            id="email" 
            name="email" 
            required 
            pattern="[^@\s]+@[^@\s]+\.[^@\s]+"
        >
    &lt;/div>
    &lt;div>
        &lt;label for="password">Password:&lt;/label>
        &lt;input 
            type="password" 
            id="password" 
            name="password" 
            required 
            minlength="8"
        >
    &lt;/div>
    &lt;button type="submit">Register&lt;/button>
&lt;/form>

// JavaScript for HTML5 validation
form.addEventListener('submit', (event) => {
    if (!form.checkValidity()) {
        event.preventDefault();
        // Show custom styling for invalid fields
        form.classList.add('was-validated');
    }
});</code></pre>
            </div>
            
            <div class="real-world">
                <h3>Real-World Example: Dynamic Form with Validation</h3>
                <pre><code>document.addEventListener('DOMContentLoaded', () => {
    const form = document.getElementById('registration-form');
    const passwordInput = document.getElementById('password');
    const confirmInput = document.getElementById('confirm-password');
    const passwordStrength = document.getElementById('password-strength');
    const submitButton = document.querySelector('button[type="submit"]');
    
    // Disable submit initially
    submitButton.disabled = true;
    
    // Live validation for passwords
    passwordInput.addEventListener('input', validatePasswords);
    confirmInput.addEventListener('input', validatePasswords);
    
    // Show password strength as user types
    passwordInput.addEventListener('input', updatePasswordStrength);
    
    function validatePasswords() {
        const password = passwordInput.value;
        const confirm = confirmInput.value;
        
        // Check if passwords match
        if (password && confirm) {
            if (password !== confirm) {
                confirmInput.setCustomValidity('Passwords do not match');
            } else {
                confirmInput.setCustomValidity('');
            }
        }
        
        // Enable submit only if form is valid
        submitButton.disabled = !form.checkValidity();
    }
    
    function updatePasswordStrength() {
        const password = passwordInput.value;
        
        // Calculate strength (simplified)
        let strength = 0;
        
        if (password.length >= 8) strength++;
        if (/[A-Z]/.test(password)) strength++;
        if (/[a-z]/.test(password)) strength++;
        if (/[0-9]/.test(password)) strength++;
        if (/[^A-Za-z0-9]/.test(password)) strength++;
        
        // Update UI
        passwordStrength.className = 'strength-meter';
        
        switch (strength) {
            case 0:
            case 1:
                passwordStrength.classList.add('weak');
                passwordStrength.textContent = 'Weak';
                break;
            case 2:
            case 3:
                passwordStrength.classList.add('medium');
                passwordStrength.textContent = 'Medium';
                break;
            case 4:
            case 5:
                passwordStrength.classList.add('strong');
                passwordStrength.textContent = 'Strong';
                break;
        }
    }
    
    // Handle form submission
    form.addEventListener('submit', (event) => {
        event.preventDefault();
        
        // Create FormData object
        const formData = new FormData(form);
        
        // Convert to JSON for sending to backend
        const data = Object.fromEntries(formData.entries());
        
        // Send to backend (simulate API call)
        console.log('Sending registration data:', data);
        
        // Show success message
        form.innerHTML = '<h2>Registration Successful!</h2><p>Thank you for registering!</p>';
    });
});</code></pre>
            </div>
        </section>

        <section>
            <h2>DOM Traversal</h2>
            
            <p>DOM traversal allows you to navigate through the DOM tree, accessing parent, child, and sibling elements:</p>
            
            <div class="code-example">
                <h3>Parent Relationships</h3>
                <pre><code>// Direct parent
const parent = element.parentNode;  // Any node type
const parentElement = element.parentElement;  // Only element nodes

// All ancestors
function getAllAncestors(element) {
    const ancestors = [];
    let current = element.parentElement;
    
    while (current) {
        ancestors.push(current);
        current = current.parentElement;
    }
    
    return ancestors;
}

// Find closest ancestor matching a selector
const closestForm = element.closest('form');</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Child Relationships</h3>
                <pre><code>// All child nodes (including text nodes, comments, etc.)
const childNodes = element.childNodes;

// Only element children
const children = element.children;

// First and last child
const firstChild = element.firstChild;  // Can be any node type
const firstElementChild = element.firstElementChild;  // Only element nodes
const lastChild = element.lastChild;
const lastElementChild = element.lastElementChild;

// Count children
const childCount = element.childElementCount;</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Sibling Relationships</h3>
                <pre><code>// Next sibling
const nextSibling = element.nextSibling;  // Can be any node type
const nextElementSibling = element.nextElementSibling;  // Only element nodes

// Previous sibling
const prevSibling = element.previousSibling;
const prevElementSibling = element.previousElementSibling;

// Get all siblings
function getAllSiblings(element) {
    const siblings = [];
    let sibling = element.parentNode.firstChild;
    
    while (sibling) {
        if (sibling.nodeType === 1 && sibling !== element) {
            siblings.push(sibling);
        }
        sibling = sibling.nextSibling;
    }
    
    return siblings;
}</code></pre>
            </div>
            
            <div class="comparison">
                <h3>Python Comparison: XML/HTML Parsing</h3>
                <p>DOM traversal is similar to navigating XML/HTML trees in Python libraries:</p>
                <table>
                    <tr>
                        <th>JavaScript DOM</th>
                        <th>Python BeautifulSoup</th>
                    </tr>
                    <tr>
                        <td><code>element.parentNode</code></td>
                        <td><code>element.parent</code></td>
                    </tr>
                    <tr>
                        <td><code>element.children</code></td>
                        <td><code>element.children</code></td>
                    </tr>
                    <tr>
                        <td><code>element.nextElementSibling</code></td>
                        <td><code>element.next_sibling</code></td>
                    </tr>
                    <tr>
                        <td><code>element.querySelector(selector)</code></td>
                        <td><code>element.select_one(selector)</code></td>
                    </tr>
                </table>
            </div>
            
            <div class="real-world">
                <h3>Real-World Example: Collapsible Tree Menu</h3>
                <pre><code>document.addEventListener('DOMContentLoaded', () => {
    const treeMenu = document.getElementById('tree-menu');
    
    // Toggle submenu visibility when clicking on a parent item
    treeMenu.addEventListener('click', (event) => {
        // Find the closest tree-item that was clicked
        const treeItem = event.target.closest('.tree-item');
        
        if (!treeItem) return;
        
        // Only handle clicks on items with children
        const submenu = treeItem.querySelector('.submenu');
        if (submenu) {
            // Toggle expanded state
            treeItem.classList.toggle('expanded');
            
            // Stop event from reaching parent tree items
            event.stopPropagation();
        }
    });
    
    // Function to expand a path to a specific item by ID
    function expandPathToItem(itemId) {
        const targetItem = document.getElementById(itemId);
        
        if (targetItem) {
            // Find all parent tree items
            let current = targetItem.parentElement;
            
            while (current) {
                if (current.classList.contains('submenu')) {
                    // Find the parent tree item and expand it
                    const parentItem = current.parentElement;
                    if (parentItem.classList.contains('tree-item')) {
                        parentItem.classList.add('expanded');
                    }
                }
                current = current.parentElement;
            }
            
            // Highlight the target item
            targetItem.classList.add('highlighted');
            
            // Scroll into view
            targetItem.scrollIntoView({
                behavior: 'smooth',
                block: 'center'
            });
        }
    }
    
    // Example usage
    // expandPathToItem('nested-item-3-2-1');
});</code></pre>
            </div>
        </section>

        <section>
            <h2>Performance Considerations</h2>
            
            <p>DOM manipulation can be expensive in terms of performance. Here are some best practices to keep your applications responsive:</p>
            
            <div class="best-practice">
                <h3>Minimize DOM Access</h3>
                <ul>
                    <li>Cache DOM references instead of repeatedly querying the DOM</li>
                    <li>Batch DOM updates to reduce reflows and repaints</li>
                    <li>Use DocumentFragment for multiple additions</li>
                </ul>
            </div>
            
            <div class="code-example">
                <h3>Bad vs. Good DOM Manipulation</h3>
                <pre><code>// BAD: Multiple separate DOM operations
function addItems(items) {
    const list = document.getElementById('myList');
    
    items.forEach(item => {
        // This causes a reflow for EACH item
        list.innerHTML += `&lt;li>${item}&lt;/li>`;
    });
}

// BETTER: Single DOM operation
function addItems(items) {
    const list = document.getElementById('myList');
    
    // Build complete HTML string
    const html = items.map(item => `&lt;li>${item}&lt;/li>`).join('');
    
    // Single DOM update
    list.innerHTML += html;
}

// BEST: Use DocumentFragment
function addItems(items) {
    const list = document.getElementById('myList');
    
    // Create a fragment (doesn't cause reflows)
    const fragment = document.createDocumentFragment();
    
    // Build all elements in memory
    items.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        fragment.appendChild(li);
    });
    
    // Single DOM insertion
    list.appendChild(fragment);
}</code></pre>
            </div>
            
            <div class="best-practice">
                <h3>Avoid Forced Synchronous Layouts</h3>
                <p>Reading and then writing to the DOM in a loop can cause layout thrashing:</p>
                <pre><code>// BAD: Causes layout thrashing
function resizeElements(elements) {
    elements.forEach(element => {
        // Read (forces layout)
        const height = element.offsetHeight;
        
        // Write (invalidates layout)
        element.style.height = (height * 2) + 'px';
    });
}

// BETTER: Separate reads and writes
function resizeElements(elements) {
    // Read phase
    const heights = elements.map(element => element.offsetHeight);
    
    // Write phase
    elements.forEach((element, i) => {
        element.style.height = (heights[i] * 2) + 'px';
    });
}</code></pre>
            </div>
            
            <div class="best-practice">
                <h3>Use Efficient Selectors</h3>
                <p>Some selectors are faster than others:</p>
                <ol>
                    <li>ID selectors (<code>#myId</code>)</li>
                    <li>Class selectors (<code>.myClass</code>)</li>
                    <li>Tag selectors (<code>div</code>)</li>
                    <li>Descendant selectors (<code>div p</code>)</li>
                    <li>Attribute selectors (<code>[data-value="foo"]</code>)</li>
                    <li>Pseudo-classes and pseudo-elements (<code>:hover</code>, <code>::before</code>)</li>
                </ol>
            </div>
            
            <div class="best-practice">
                <h3>Event Delegation</h3>
                <p>For multiple similar elements (like list items), use event delegation instead of individual listeners.</p>
            </div>
            
            <div class="real-world">
                <h3>Real-World Example: Virtual List</h3>
                <p>For very large lists, render only visible items:</p>
                <pre><code>class VirtualList {
    constructor(container, itemHeight, totalItems, renderItem) {
        this.container = container;
        this.itemHeight = itemHeight;
        this.totalItems = totalItems;
        this.renderItem = renderItem;
        
        // Create list elements
        this.listElement = document.createElement('div');
        this.listElement.style.position = 'relative';
        this.listElement.style.height = `${totalItems * itemHeight}px`;
        
        // Create viewport for visible items
        this.viewport = document.createElement('div');
        this.viewport.style.overflow = 'auto';
        this.viewport.style.position = 'relative';
        this.viewport.style.height = '100%';
        
        this.viewport.appendChild(this.listElement);
        this.container.appendChild(this.viewport);
        
        // State
        this.visibleItems = [];
        this.visibleRange = { start: 0, end: 0 };
        
        // Initialize
        this.viewport.addEventListener('scroll', this.handleScroll.bind(this));
        this.updateVisibleItems();
    }
    
    handleScroll() {
        requestAnimationFrame(() => {
            this.updateVisibleItems();
        });
    }
    
    updateVisibleItems() {
        const scrollTop = this.viewport.scrollTop;
        const viewportHeight = this.viewport.clientHeight;
        
        // Calculate visible range with buffer
        const buffer = 5;
        const startIndex = Math.max(0, Math.floor(scrollTop / this.itemHeight) - buffer);
        const endIndex = Math.min(
            this.totalItems - 1,
            Math.ceil((scrollTop + viewportHeight) / this.itemHeight) + buffer
        );
        
        // Only update if visible range changed
        if (startIndex !== this.visibleRange.start || endIndex !== this.visibleRange.end) {
            this.visibleRange = { start: startIndex, end: endIndex };
            this.renderVisibleItems();
        }
    }
    
    renderVisibleItems() {
        // Remove existing items
        while (this.listElement.firstChild) {
            this.listElement.removeChild(this.listElement.firstChild);
        }
        
        // Create fragment for batch insertion
        const fragment = document.createDocumentFragment();
        
        // Render visible items
        for (let i = this.visibleRange.start; i <= this.visibleRange.end; i++) {
            const item = document.createElement('div');
            item.style.position = 'absolute';
            item.style.top = `${i * this.itemHeight}px`;
            item.style.height = `${this.itemHeight}px`;
            item.style.width = '100%';
            
            // Render item content
            this.renderItem(item, i);
            
            fragment.appendChild(item);
        }
        
        // Add all items in single DOM operation
        this.listElement.appendChild(fragment);
    }
}

// Usage
const container = document.getElementById('list-container');
const virtualList = new VirtualList(
    container,
    50, // Item height in pixels
    10000, // Total number of items
    (itemElement, index) => {
        itemElement.textContent = `Item ${index}`;
        
        if (index % 2 === 0) {
            itemElement.style.backgroundColor = '#f0f0f0';
        }
    }
);</code></pre>
            </div>
        </section>

        <section>
            <h2>Connecting with Python Flask Backend</h2>
            
            <p>In a full stack application, your DOM manipulation skills directly integrate with your Python backend through APIs. Here's a typical pattern:</p>
            
            <div class="code-example">
                <h3>Frontend-Backend Integration</h3>
                <pre><code>// Frontend JavaScript
document.addEventListener('DOMContentLoaded', () => {
    // Query DOM
    const productList = document.getElementById('product-list');
    const loadingIndicator = document.getElementById('loading');
    const errorMessage = document.getElementById('error');
    
    // Fetch products from Flask API
    fetch('/api/products')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(products => {
            // Hide loading indicator
            loadingIndicator.style.display = 'none';
            
            // Create product elements
            const fragment = document.createDocumentFragment();
            
            products.forEach(product => {
                const productEl = createProductElement(product);
                fragment.appendChild(productEl);
            });
            
            // Update DOM
            productList.appendChild(fragment);
        })
        .catch(error => {
            // Show error message
            loadingIndicator.style.display = 'none';
            errorMessage.textContent = `Failed to load products: ${error.message}`;
            errorMessage.style.display = 'block';
        });
    
    function createProductElement(product) {
        const element = document.createElement('div');
        element.className = 'product-card';
        element.dataset.productId = product.id;
        
        element.innerHTML = `
            <img src="${product.image}" alt="${product.name}" class="product-image">
            <h3 class="product-name">${product.name}</h3>
            <p class="product-price">$${product.price.toFixed(2)}</p>
            <button class="add-to-cart-btn">Add to Cart</button>
        `;
        
        // Add event listener
        const addButton = element.querySelector('.add-to-cart-btn');
        addButton.addEventListener('click', () => addToCart(product.id));
        
        return element;
    }
    
    function addToCart(productId) {
        // Show loading state on button
        const button = document.querySelector(`[data-product-id="${productId}"] .add-to-cart-btn`);
        const originalText = button.textContent;
        button.disabled = true;
        button.textContent = 'Adding...';
        
        // Send request to Flask backend
        fetch('/api/cart/add', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ product_id: productId, quantity: 1 })
        })
            .then(response => response.json())
            .then(data => {
                // Update cart counter
                document.getElementById('cart-count').textContent = data.cart_total;
                
                // Reset button with success indication
                button.textContent = 'Added!';
                button.classList.add('success');
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                    button.classList.remove('success');
                }, 2000);
            })
            .catch(error => {
                // Show error on button
                button.textContent = 'Error!';
                button.classList.add('error');
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                    button.classList.remove('error');
                }, 2000);
                
                console.error('Add to cart error:', error);
            });
    }
});</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Corresponding Flask Backend Code</h3>
                <pre><code># Python Flask Backend
from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy
from flask_login import current_user, login_required

app = Flask(__name__)
db = SQLAlchemy(app)

# Product model
class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    price = db.Column(db.Float, nullable=False)
    image = db.Column(db.String(200))
    
# Cart model
class CartItem(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    quantity = db.Column(db.Integer, default=1)
    
# API routes
@app.route('/api/products')
def get_products():
    products = Product.query.all()
    return jsonify([{
        'id': p.id,
        'name': p.name,
        'price': p.price,
        'image': p.image
    } for p in products])

@app.route('/api/cart/add', methods=['POST'])
@login_required
def add_to_cart():
    data = request.json
    product_id = data.get('product_id')
    quantity = data.get('quantity', 1)
    
    # Check if product exists
    product = Product.query.get_or_404(product_id)
    
    # Check if item already in cart
    cart_item = CartItem.query.filter_by(
        user_id=current_user.id, 
        product_id=product_id
    ).first()
    
    if cart_item:
        # Update quantity
        cart_item.quantity += quantity
    else:
        # Add new item
        cart_item = CartItem(
            user_id=current_user.id,
            product_id=product_id,
            quantity=quantity
        )
        db.session.add(cart_item)
    
    db.session.commit()
    
    # Get total items in cart
    cart_total = CartItem.query.filter_by(user_id=current_user.id).count()
    
    return jsonify({
        'success': True,
        'cart_total': cart_total
    })
</code></pre>
            </div>
        </section>

        <section>
            <h2>Advanced DOM Techniques</h2>
            
            <div class="code-example">
                <h3>Custom Events</h3>
                <p>Create and dispatch custom events for component communication:</p>
                <pre><code>// Create custom event
const productAddedEvent = new CustomEvent('productAdded', {
    detail: { productId: 123, name: 'Laptop', price: 999 },
    bubbles: true,  // Event bubbles up through DOM
    cancelable: true  // Event can be canceled
});

// Dispatch event
document.getElementById('product-123').dispatchEvent(productAddedEvent);

// Listen for custom event
document.addEventListener('productAdded', (event) => {
    console.log('Product added:', event.detail);
    updateCart(event.detail);
});</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Intersection Observer</h3>
                <p>Detect when elements enter or exit the viewport:</p>
                <pre><code>// Create observer
const observer = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            // Element is visible
            console.log('Element is visible:', entry.target);
            entry.target.classList.add('visible');
            
            // Stop observing if needed
            observer.unobserve(entry.target);
        }
    });
}, {
    root: null,  // Viewport
    rootMargin: '0px',
    threshold: 0.1  // 10% of element must be visible
});

// Start observing elements
document.querySelectorAll('.lazy-load').forEach(el => {
    observer.observe(el);
});</code></pre>
            </div>
            
            <div class="code-example">
                <h3>Mutation Observer</h3>
                <p>React to changes in the DOM:</p>
                <pre><code>// Create observer
const observer = new MutationObserver((mutations) => {
    mutations.forEach(mutation => {
        if (mutation.type === 'childList') {
            console.log('Child nodes changed:', mutation.addedNodes, mutation.removedNodes);
        } else if (mutation.type === 'attributes') {
            console.log('Attribute changed:', mutation.attributeName);
        }
    });
});

// Start observing
observer.observe(document.getElementById('watched-element'), {
    childList: true,  // Watch for child changes
    attributes: true,  // Watch for attribute changes
    subtree: true,  // Watch all descendants too
    characterData: true  // Watch for text changes
});</code></pre>
            </div>
            
            <div class="real-world">
                <h3>Real-World Example: Infinite Scroll with Intersection Observer</h3>
                <pre><code>class InfiniteScroll {
    constructor(container, loadMore, options = {}) {
        this.container = container;
        this.loadMore = loadMore;
        this.page = 1;
        this.loading = false;
        this.finished = false;
        
        // Default options
        this.options = {
            threshold: 0.1,
            loadMargin: '200px',
            ...options
        };
        
        // Create observer
        this.observer = new IntersectionObserver(this.handleIntersection.bind(this), {
            root: null,
            rootMargin: this.options.loadMargin,
            threshold: this.options.threshold
        });
        
        // Start observing
        this.observer.observe(this.container.querySelector('.load-more-trigger'));
    }
    
    handleIntersection(entries) {
        entries.forEach(entry => {
            if (entry.isIntersecting && !this.loading && !this.finished) {
                this.loadMoreItems();
            }
        });
    }
    
    async loadMoreItems() {
        try {
            this.loading = true;
            
            // Show loading indicator
            const loadingIndicator = this.container.querySelector('.loading-indicator');
            loadingIndicator.style.display = 'block';
            
            // Load more items
            const items = await this.loadMore(this.page++);
            
            // Hide loading indicator
            loadingIndicator.style.display = 'none';
            
            if (items.length === 0) {
                this.finished = true;
                this.container.querySelector('.no-more-items').style.display = 'block';
                return;
            }
            
            // Add items to container
            const itemsContainer = this.container.querySelector('.items-container');
            
            // Create fragment for batch insertion
            const fragment = document.createDocumentFragment();
            
            items.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'item';
                
                // Create item content
                itemElement.innerHTML = `
                    <h3>${item.title}</h3>
                    <p>${item.description}</p>
                `;
                
                fragment.appendChild(itemElement);
            });
            
            // Add all items in single operation
            itemsContainer.appendChild(fragment);
            
            this.loading = false;
        } catch (error) {
            console.error('Error loading more items:', error);
            this.loading = false;
            
            // Show error message
            const errorElement = this.container.querySelector('.error-message');
            errorElement.textContent = 'Failed to load more items. Please try again.';
            errorElement.style.display = 'block';
        }
    }
}

// Usage
const infiniteScroll = new InfiniteScroll(
    document.getElementById('content-feed'),
    async (page) => {
        // Fetch data from backend
        const response = await fetch(`/api/feed?page=${page}`);
        return response.json();
    }
);</code></pre>
            </div>
        </section>

        <section>
            <h2>Browser Compatibility</h2>
            
            <p>Different browsers may implement DOM APIs differently. Here are strategies for dealing with browser inconsistencies:</p>
            
            <div class="best-practice">
                <h3>Feature Detection</h3>
                <pre><code>// Check if a feature is available
if ('IntersectionObserver' in window) {
    // Use Intersection Observer
} else {
    // Fallback implementation
}

// Check for method support
if (Element.prototype.closest) {
    // Use element.closest()
} else {
    // Polyfill or alternative approach
}</code></pre>
            </div>
            
            <div class="best-practice">
                <h3>Using Polyfills</h3>
                <p>Polyfills add missing functionality to older browsers:</p>
                <pre><code>// Example polyfill for Element.matches()
if (!Element.prototype.matches) {
    Element.prototype.matches = 
        Element.prototype.matchesSelector ||
        Element.prototype.mozMatchesSelector ||
        Element.prototype.msMatchesSelector ||
        Element.prototype.oMatchesSelector ||
        Element.prototype.webkitMatchesSelector ||
        function(s) {
            const matches = (this.document || this.ownerDocument).querySelectorAll(s);
            let i = matches.length;
            while (--i >= 0 && matches.item(i) !== this) {}
            return i > -1;
        };
}</code></pre>
            </div>
            
            <div class="best-practice">
                <h3>Testing Across Browsers</h3>
                <ul>
                    <li>Use browser testing services (BrowserStack, LambdaTest)</li>
                    <li>Virtual machines with different browser versions</li>
                    <li>Test on real devices when possible</li>
                    <li>Prioritize testing based on your target audience</li>
                </ul>
            </div>
        </section>

        <section>
            <h2>The DOM and Security</h2>
            
            <div class="security-note">
                <h3>Cross-Site Scripting (XSS)</h3>
                <p>XSS attacks occur when untrusted content is added to the DOM:</p>
                <pre><code>// UNSAFE - Directly inserting user input
const userComment = userInput.value;
commentBox.innerHTML = userComment;  // Potential XSS vulnerability

// SAFE - Use textContent for user-generated content
commentBox.textContent = userComment;  // Escapes HTML</code></pre>
            </div>
            
            <div class="security-note">
                <h3>Content Security Policy (CSP)</h3>
                <p>CSP helps prevent XSS by controlling what resources can execute:</p>
                <pre><code>&lt;!-- Example CSP header -->
&lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'">

// JavaScript created by innerHTML won't execute with strict CSP
element.innerHTML = '&lt;button onclick="alert(\'XSS\')">Click me&lt;/button>';  // Won't work with CSP

// Instead, use proper DOM methods
const button = document.createElement('button');
button.textContent = 'Click me';
button.addEventListener('click', () => alert('Safe click!'));
element.appendChild(button);  // Works with CSP</code></pre>
            </div>
            
            <div class="security-note">
                <h3>DOM-based Vulnerabilities</h3>
                <p>Other DOM-based security concerns:</p>
                <ul>
                    <li><strong>CSRF (Cross-Site Request Forgery):</strong> Use CSRF tokens in forms</li>
                    <li><strong>Open Redirects:</strong> Validate URLs before redirecting</li>
                    <li><strong>DOM Clobbering:</strong> Be careful with element IDs that match property names</li>
                </ul>
            </div>
            
            <div class="comparison">
                <h3>Similarities to Flask Security</h3>
                <table>
                    <tr>
                        <th>Flask/Python</th>
                        <th>JavaScript/DOM</th>
                    </tr>
                    <tr>
                        <td>Jinja2 autoescape</td>
                        <td>textContent vs innerHTML</td>
                    </tr>
                    <tr>
                        <td>CSRF protection in Flask-WTF</td>
                        <td>CSRF tokens in forms</td>
                    </tr>
                    <tr>
                        <td>Input validation with WTForms</td>
                        <td>Client-side form validation</td>
                    </tr>
                    <tr>
                        <td>SQLAlchemy ORM prevents SQL injection</td>
                        <td>Avoiding eval() and new Function()</td>
                    </tr>
                </table>
            </div>
        </section>

        <section>
            <h2>Integrating with Frontend Frameworks</h2>
            
            <p>While raw DOM manipulation is powerful, modern web development often uses frameworks to abstract and organize DOM operations:</p>
            
            <div class="comparison">
                <h3>Raw DOM vs. Framework Approach</h3>
                <pre><code>// Vanilla DOM
function renderTodo(todo) {
    const li = document.createElement('li');
    li.textContent = todo.text;
    li.dataset.id = todo.id;
    
    if (todo.completed) {
        li.classList.add('completed');
    }
    
    const deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';
    deleteButton.addEventListener('click', () => deleteTodo(todo.id));
    
    li.appendChild(deleteButton);
    todoList.appendChild(li);
}

// React approach
function TodoItem({ todo, onDelete }) {
    return (
        &lt;li className={todo.completed ? 'completed' : ''} data-id={todo.id}>
            {todo.text}
            &lt;button onClick={() => onDelete(todo.id)}>Delete&lt;/button>
        &lt;/li>
    );
}

// Vue approach
&lt;li :class="{ completed: todo.completed }" :data-id="todo.id">
    {{ todo.text }}
    &lt;button @click="deleteTodo(todo.id)">Delete&lt;/button>
&lt;/li></code></pre>
            </div>
            
            <div class="best-practice">
                <h3>When to Use Raw DOM vs. Frameworks</h3>
                <table>
                    <tr>
                        <th>Use Raw DOM When</th>
                        <th>Use Frameworks When</th>
                    </tr>
                    <tr>
                        <td>Building small, simple applications</td>
                        <td>Building complex, data-driven applications</td>
                    </tr>
                    <tr>
                        <td>Adding minimal interactivity to static pages</td>
                        <td>Managing many UI components and states</td>
                    </tr>
                    <tr>
                        <td>Performance is absolutely critical</td>
                        <td>Development speed and maintainability are priorities</td>
                    </tr>
                    <tr>
                        <td>You need to understand how things work under the hood</td>
                        <td>You want to follow established patterns and practices</td>
                    </tr>
                </table>
            </div>
            
            <div class="real-world">
                <h3>Hybrid Approach: Framework with DOM Manipulation</h3>
                <p>Sometimes you need to combine frameworks with direct DOM access:</p>
                <pre><code>// React component with direct DOM manipulation
import React, { useEffect, useRef } from 'react';

function ChartsComponent({ data }) {
    const chartRef = useRef(null);
    
    useEffect(() => {
        if (chartRef.current && data) {
            // Direct DOM manipulation for complex visualization
            const chart = new ComplexChart(chartRef.current);
            chart.setData(data);
            chart.render();
            
            // Cleanup on unmount
            return () => chart.destroy();
        }
    }, [data]);
    
    return &lt;div ref={chartRef} className="chart-container">&lt;/div>;
}</code></pre>
            </div>
        </section>

        <section>
            <h2>Exercises and Practice</h2>
            
            <div class="exercise">
                <h3>Exercise 1: Interactive Product List</h3>
                <p>Create a dynamic product list with the following features:</p>
                <ul>
                    <li>Products can be sorted by name, price, or rating</li>
                    <li>Products can be filtered by category</li>
                    <li>Each product has an "Add to Cart" button</li>
                    <li>Clicking on a product shows a modal with details</li>
                </ul>
                <p>HTML structure:</p>
                <pre><code>&lt;div id="product-container">
    &lt;div class="controls">
        &lt;div class="sorting">
            &lt;label for="sort-select">Sort by:&lt;/label>
            &lt;select id="sort-select">
                &lt;option value="name">Name&lt;/option>
                &lt;option value="price-asc">Price (Low to High)&lt;/option>
                &lt;option value="price-desc">Price (High to Low)&lt;/option>
                &lt;option value="rating">Rating&lt;/option>
            &lt;/select>
        &lt;/div>
        
        &lt;div class="filtering">
            &lt;label for="category-filter">Category:&lt;/label>
            &lt;select id="category-filter">
                &lt;option value="all">All Categories&lt;/option>
                &lt;option value="electronics">Electronics&lt;/option>
                &lt;option value="clothing">Clothing&lt;/option>
                &lt;option value="home">Home&lt;/option>
            &lt;/select>
        &lt;/div>
    &lt;/div>
    
    &lt;div id="products-list">&lt;/div>
    
    &lt;div id="product-modal" class="modal">
        &lt;div class="modal-content">
            &lt;span class="close">&amp;times;&lt;/span>
            &lt;div id="modal-product-details">&lt;/div>
        &lt;/div>
    &lt;/div>
&lt;/div></code></pre>
            </div>
            
            <div class="exercise">
                <h3>Exercise 2: Form Validation</h3>
                <p>Create a registration form with real-time validation:</p>
                <ul>
                    <li>Username (letters and numbers only, 3-20 characters)</li>
                    <li>Email (valid email format)</li>
                    <li>Password (at least 8 characters, including uppercase, lowercase, and numbers)</li>
                    <li>Password confirmation (must match password)</li>
                    <li>Show validation feedback as the user types</li>
                    <li>Submit button is only enabled when all fields are valid</li>
                </ul>
            </div>
            
            <div class="exercise">
                <h3>Exercise 3: Dynamic Quiz Application</h3>
                <p>Create a quiz application that:</p>
                <ul>
                    <li>Loads questions from a JSON file</li>
                    <li>Shows one question at a time</li>
                    <li>Provides immediate feedback on answers</li>
                    <li>Tracks user score</li>
                    <li>Shows a summary at the end</li>
                </ul>
                <p>Connect this to a Flask backend that stores questions and scores.</p>
            </div>
        </section>

        <section>
            <h2>Further Learning Resources</h2>
            
            <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">MDN Web Docs: Document Object Model (DOM)</a></li>
                <li><a href="https://javascript.info/document">JavaScript.info: Document</a></li>
                <li><a href="https://domenlightenment.com/">DOM Enlightenment</a> by Cody Lindley</li>
                <li><a href="https://eloquentjavascript.net/14_dom.html">Eloquent JavaScript: The Document Object Model</a></li>
                <li><a href="https://web.dev/articles/critical-rendering-path">Critical Rendering Path</a> by Google Developers</li>
            </ul>
        </section>

        <section>
            <h2>Conclusion and Key Takeaways</h2>
            
            <ul>
                <li>The DOM is a programmatic representation of your HTML document</li>
                <li>DOM manipulation allows you to create dynamic, interactive web applications</li>
                <li>Understanding the DOM is essential for frontend development, even when using frameworks</li>
                <li>Performance optimization is important for smooth user experiences</li>
                <li>Security considerations are crucial when manipulating the DOM</li>
                <li>The DOM is the bridge between your JavaScript code and what users see and interact with</li>
            </ul>
            
            <p>As Python developers expanding into full stack development, your mastery of DOM manipulation completes your toolkit, allowing you to build complete web applications from database to user interface.</p>
        </section>
    </div>

    <footer>
        <p>&copy; 2025 Full Stack Python Web Development Course</p>
        <p>Location: <code>/lectures/week3/tuesday/dom_manipulation.html</code></p>
    </footer>
</body>
</html>
