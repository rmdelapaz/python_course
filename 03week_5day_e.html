<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Project Structure for Web Applications</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 3: Python Fundamentals (Part 2)</h2>
        <h3>Friday Morning: Python Project Structure for Web Applications</h3>
    </header>

    <main>
        <section class="lecture_intro">
            <h2>Building a Solid Foundation: Project Structure for Web Applications</h2>
            <p>Welcome to our session on Python project structure for web applications! Today, we'll explore one of the most fundamental but often overlooked aspects of successful web development: how to organize your code and files effectively.</p>
            
            <p>As we prepare to dive into web frameworks in the coming weeks, understanding how to structure your Python web applications becomes crucial. The organization of your project can greatly impact its maintainability, scalability, and the ease with which new team members can understand and contribute to it.</p>
        </section>

        <section>
            <h2>Why Project Structure Matters</h2>
            
            <p><strong>Analogy:</strong> Think of your project structure as the blueprint for a building. Without a clear, well-thought-out blueprint, even the finest materials and skilled workers will struggle to create a functional, durable structure. Similarly, without a good project organization, even excellent code and talented developers will struggle to build a maintainable application.</p>
            
            <p>The benefits of a well-structured project include:</p>
            
            <ul>
                <li><strong>Improved maintainability:</strong> Everyone knows where to find specific components</li>
                <li><strong>Better collaboration:</strong> Teams can work on different parts without conflicts</li>
                <li><strong>Easier onboarding:</strong> New developers can quickly understand the architecture</li>
                <li><strong>Simpler testing:</strong> Modular components are easier to test in isolation</li>
                <li><strong>Streamlined deployment:</strong> Clear separation of configuration and code</li>
                <li><strong>Enhanced scalability:</strong> Well-organized code can grow without becoming chaotic</li>
            </ul>
            
            <p><strong>Real-world Impact:</strong> Major tech companies, including those building Python web applications like Instagram, Dropbox, and Pinterest, have dedicated significant effort to creating optimal project structures that allow hundreds of developers to work effectively on the same codebase.</p>
        </section>

        <section>
            <h2>Common Python Project Structure Patterns</h2>
            
            <p>Let's explore the most common patterns for structuring Python web applications:</p>
            
            <h3>The Simple Flask Application</h3>
            
            <p>For small, straightforward applications, a simple structure might look like this:</p>
            
            <pre><code>my_flask_app/
├── app.py               # Application entry point
├── config.py            # Configuration settings
├── requirements.txt     # Dependencies
├── static/              # Static files (CSS, JS, images)
│   ├── css/
│   ├── js/
│   └── images/
├── templates/           # HTML templates
│   ├── base.html
│   ├── index.html
│   └── other_pages/
└── venv/                # Virtual environment (not in version control)</code></pre>
            
            <p><strong>When to use:</strong> Simple applications, prototypes, learning projects, or microservices that perform a single function.</p>
            
            <p><strong>Limitations:</strong> Quickly becomes unwieldy as the application grows. Logic and presentation become mixed, making maintenance challenging.</p>
            
            <h3>The Package-Based Structure</h3>
            
            <p>As applications grow, organizing code into a proper Python package provides more structure:</p>
            
            <pre><code>my_web_app/
├── myapp/                    # Main package
│   ├── __init__.py           # Package initialization
│   ├── models.py             # Data models
│   ├── routes.py             # URL route definitions
│   ├── forms.py              # Form definitions
│   ├── static/               # Static files
│   │   ├── css/
│   │   ├── js/
│   │   └── images/
│   └── templates/            # Templates
│       ├── base.html
│       └── pages/
├── config.py                 # Configuration
├── requirements.txt          # Dependencies
├── run.py                    # Application entry point
└── README.md                 # Documentation</code></pre>
            
            <p><strong>When to use:</strong> Medium-sized applications where a simple structure is becoming insufficient, but full modularity isn't yet necessary.</p>
            
            <p><strong>Advantages:</strong> Clear separation of code into logical files, better import mechanisms as a package.</p>
            
            <h3>The Modular Blueprint Structure</h3>
            
            <p>For larger applications, breaking functionality into modules or "blueprints" (in Flask terminology) provides better organization:</p>
            
            <pre><code>my_web_app/
├── myapp/
│   ├── __init__.py           # App initialization, blueprint registration
│   ├── extensions.py         # Flask extensions initialization
│   ├── models/               # Database models
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── product.py
│   ├── auth/                 # Authentication module
│   │   ├── __init__.py
│   │   ├── routes.py
│   │   ├── models.py
│   │   ├── forms.py
│   │   └── templates/
│   │       └── auth/
│   ├── admin/                # Admin panel module
│   │   ├── __init__.py
│   │   ├── routes.py
│   │   └── templates/
│   │       └── admin/
│   ├── public/               # Public-facing module
│   │   ├── __init__.py
│   │   ├── routes.py
│   │   └── templates/
│   │       └── public/
│   ├── static/
│   └── templates/
│       └── base.html
├── migrations/               # Database migrations
├── tests/                    # Test suite
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_auth.py
│   └── test_models.py
├── config.py
├── requirements.txt
├── requirements-dev.txt
├── run.py
└── README.md</code></pre>
            
            <p><strong>When to use:</strong> Larger applications with distinct, separable features or when multiple developers work on different parts of the application.</p>
            
            <p><strong>Advantages:</strong> Logical separation of concerns, ability to work on modules independently.</p>
            
            <h3>The Domain-Driven Design Structure</h3>
            
            <p>For complex applications, organizing by business domain rather than technical function can be more effective:</p>
            
            <pre><code>my_web_app/
├── myapp/
│   ├── __init__.py
│   ├── extensions.py
│   ├── core/                  # Shared core functionality
│   │   ├── __init__.py
│   │   ├── database.py
│   │   ├── security.py
│   │   └── utils.py
│   ├── users/                 # Users domain
│   │   ├── __init__.py
│   │   ├── models.py
│   │   ├── services.py        # Business logic
│   │   ├── schemas.py         # Serialization/validation
│   │   ├── views.py           # API/route handlers
│   │   └── tests/             # Domain-specific tests
│   ├── products/              # Products domain
│   │   ├── __init__.py
│   │   ├── models.py
│   │   ├── services.py
│   │   ├── schemas.py
│   │   ├── views.py
│   │   └── tests/
│   ├── orders/                # Orders domain
│   │   ├── __init__.py
│   │   ├── models.py
│   │   ├── services.py
│   │   ├── schemas.py
│   │   ├── views.py
│   │   └── tests/
│   ├── static/
│   └── templates/
├── migrations/
├── tests/                     # Integration tests
├── config.py
├── requirements/              # Split requirements
│   ├── base.txt
│   ├── dev.txt
│   └── prod.txt
├── wsgi.py                    # WSGI entry point
└── README.md</code></pre>
            
            <p><strong>When to use:</strong> Complex enterprise applications with clear business domains and complex business logic.</p>
            
            <p><strong>Advantages:</strong> Focuses on business domains rather than technical layers, making it easier to understand the business purpose of code.</p>
            
            <h3>The Hexagonal Architecture</h3>
            
            <p>For applications with complex business logic and multiple interfaces (web, API, CLI), a hexagonal (ports and adapters) structure can be effective:</p>
            
            <pre><code>my_web_app/
├── myapp/
│   ├── __init__.py
│   ├── domain/               # Business logic, domain models, and rules
│   │   ├── __init__.py
│   │   ├── user/
│   │   │   ├── __init__.py
│   │   │   ├── entities.py   # Domain models
│   │   │   ├── repositories.py  # Abstract repositories
│   │   │   ├── services.py   # Business logic
│   │   │   └── exceptions.py
│   │   └── order/
│   │       ├── __init__.py
│   │       ├── entities.py
│   │       ├── repositories.py
│   │       ├── services.py
│   │       └── exceptions.py
│   ├── interfaces/           # User interfaces (ports)
│   │   ├── __init__.py
│   │   ├── web/              # Web interface
│   │   │   ├── __init__.py
│   │   │   ├── routes.py
│   │   │   ├── forms.py
│   │   │   └── templates/
│   │   └── api/              # API interface
│   │       ├── __init__.py
│   │       ├── routes.py
│   │       └── schemas.py
│   └── infrastructure/       # Technical implementations (adapters)
│       ├── __init__.py
│       ├── database.py
│       ├── repositories/     # Concrete repositories
│       │   ├── __init__.py
│       │   ├── sql_user_repository.py
│       │   └── sql_order_repository.py
│       ├── security.py
│       └── external_services.py  # 3rd party services
├── config/                   # Configuration
│   ├── __init__.py
│   ├── development.py
│   ├── production.py
│   └── testing.py
├── tests/
├── requirements/
├── wsgi.py
└── README.md</code></pre>
            
            <p><strong>When to use:</strong> Complex applications with rich domain logic and multiple interfaces/entry points.</p>
            
            <p><strong>Advantages:</strong> Strong separation of concerns, business logic isolated from technical details, adaptable to changing requirements.</p>
            
            <p><strong>Metaphor:</strong> Think of this architecture as a hexagon with your core business logic in the center, protected from the outside world. All interactions with external systems (databases, web, API) go through well-defined ports (interfaces) that are implemented by adapters. This keeps your business logic pure and free from external dependencies.</p>
        </section>

        <section>
            <h2>Shared Components Across Structures</h2>
            
            <p>Regardless of the structure you choose, certain components are commonly found in Python web applications:</p>
            
            <h3>Entry Points</h3>
            
            <p>Files that start the application:</p>
            
            <pre><code># run.py (for development)
from myapp import create_app

app = create_app()

if __name__ == '__main__':
    app.run(debug=True)

# wsgi.py (for production)
from myapp import create_app

app = create_app()

# Used by WSGI servers like Gunicorn
# gunicorn wsgi:app</code></pre>
            
            <h3>Application Factory</h3>
            
            <p>A function that creates and configures the application:</p>
            
            <pre><code># myapp/__init__.py
from flask import Flask

def create_app(config_object='config.ProductionConfig'):
    """Application factory function."""
    app = Flask(__name__)
    app.config.from_object(config_object)
    
    # Initialize extensions
    from myapp.extensions import db, migrate
    db.init_app(app)
    migrate.init_app(app, db)
    
    # Register blueprints
    from myapp.auth.routes import auth_bp
    from myapp.public.routes import public_bp
    app.register_blueprint(auth_bp)
    app.register_blueprint(public_bp)
    
    return app</code></pre>
            
            <p><strong>Advantages:</strong> Allows creating multiple instances with different configurations (e.g., testing vs. production), easier extension initialization.</p>
            
            <h3>Configuration</h3>
            
            <p>Separating configuration from code:</p>
            
            <pre><code># config.py
import os

class Config:
    """Base configuration."""
    SECRET_KEY = os.environ.get('SECRET_KEY', 'dev-key-please-change')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

class DevelopmentConfig(Config):
    """Development configuration."""
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///dev.db'

class ProductionConfig(Config):
    """Production configuration."""
    DEBUG = False
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
    
class TestingConfig(Config):
    """Testing configuration."""
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'</code></pre>
            
            <p><strong>Best Practice:</strong> Use environment variables for sensitive values and production settings.</p>
            
            <h3>Models</h3>
            
            <p>Representing database entities:</p>
            
            <pre><code># myapp/models/user.py
from myapp.extensions import db
from werkzeug.security import generate_password_hash, check_password_hash

class User(db.Model):
    """User model for authentication."""
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)
        
    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
        
    def __repr__(self):
        return f'&lt;User {self.username}&gt;'</code></pre>
            
            <h3>Views/Routes</h3>
            
            <p>Handling HTTP requests:</p>
            
            <pre><code># myapp/auth/routes.py
from flask import Blueprint, render_template, redirect, url_for, flash
from flask_login import login_user, logout_user, login_required

from myapp.auth.forms import LoginForm, RegisterForm
from myapp.models.user import User
from myapp.extensions import db

auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user and user.check_password(form.password.data):
            login_user(user)
            return redirect(url_for('main.index'))
        flash('Invalid username or password')
    return render_template('auth/login.html', form=form)</code></pre>
            
            <h3>Templates</h3>
            
            <p>Separating presentation from logic:</p>
            
            <pre><code>&lt;!-- myapp/templates/base.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;{% block title %}My Web App{% endblock %}&lt;/title&gt;
    &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;
        &lt;nav&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;a href="{{ url_for('public.index') }}"&gt;Home&lt;/a&gt;&lt;/li&gt;
                {% if current_user.is_authenticated %}
                    &lt;li&gt;&lt;a href="{{ url_for('auth.logout') }}"&gt;Logout&lt;/a&gt;&lt;/li&gt;
                {% else %}
                    &lt;li&gt;&lt;a href="{{ url_for('auth.login') }}"&gt;Login&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href="{{ url_for('auth.register') }}"&gt;Register&lt;/a&gt;&lt;/li&gt;
                {% endif %}
            &lt;/ul&gt;
        &lt;/nav&gt;
    &lt;/header&gt;
    
    &lt;main&gt;
        {% block content %}{% endblock %}
    &lt;/main&gt;
    
    &lt;footer&gt;
        &lt;p&gt;© {{ now.year }} My Web App&lt;/p&gt;
    &lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
            
            <h3>Static Files</h3>
            
            <p>Organizing CSS, JavaScript, and images:</p>
            
            <pre><code>static/
├── css/
│   ├── main.css           # Main stylesheets
│   ├── components/        # Component-specific styles
│   └── vendor/            # Third-party CSS
├── js/
│   ├── main.js            # Main JavaScript
│   ├── components/        # Component-specific scripts
│   └── vendor/            # Third-party scripts
└── images/
    ├── logo.png
    ├── icons/
    └── backgrounds/</code></pre>
            
            <p><strong>Best Practice:</strong> Consider using a frontend build system for complex static assets.</p>
            
            <h3>Tests</h3>
            
            <p>Organizing tests to mirror the application structure:</p>
            
            <pre><code>tests/
├── conftest.py           # Shared fixtures
├── test_config.py        # Configuration tests
├── functional/           # End-to-end tests
│   ├── test_auth.py
│   └── test_public.py
└── unit/                 # Unit tests
    ├── test_models.py
    └── test_forms.py</code></pre>
            
            <pre><code># tests/conftest.py
import pytest
from myapp import create_app
from myapp.extensions import db as _db

@pytest.fixture
def app():
    """Create and configure a Flask app for testing."""
    app = create_app('config.TestingConfig')
    with app.app_context():
        _db.create_all()
        yield app
        _db.session.remove()
        _db.drop_all()
        
@pytest.fixture
def client(app):
    """A test client for the app."""
    return app.test_client()

@pytest.fixture
def db(app):
    """Database for testing."""
    return _db</code></pre>
        </section>

        <section>
            <h2>Framework-Specific Structure Considerations</h2>
            
            <p>Different frameworks have their own conventions and best practices for project structure:</p>
            
            <h3>Flask</h3>
            
            <ul>
                <li><strong>Flexibility:</strong> Flask is minimal and allows many different structures</li>
                <li><strong>Blueprints:</strong> Key to modularizing Flask applications</li>
                <li><strong>Application Factory:</strong> Recommended for anything beyond trivial apps</li>
                <li><strong>Extensions:</strong> Often initialized in a separate module</li>
            </ul>
            
            <p><strong>Recommended Structure:</strong> The Modular Blueprint structure works well for most Flask applications.</p>
            
            <h3>Django</h3>
            
            <p>Django follows a more opinionated structure:</p>
            
            <pre><code>my_django_project/
├── manage.py              # Command-line utility
├── myproject/             # Project package
│   ├── __init__.py
│   ├── settings/          # Split settings
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── development.py
│   │   └── production.py
│   ├── urls.py            # Main URL configuration
│   ├── asgi.py            # ASGI configuration
│   └── wsgi.py            # WSGI configuration
├── apps/                  # Custom application modules
│   ├── users/             # Users app
│   │   ├── __init__.py
│   │   ├── admin.py
│   │   ├── apps.py
│   │   ├── migrations/
│   │   ├── models.py
│   │   ├── tests.py
│   │   ├── urls.py
│   │   └── views.py
│   └── products/          # Products app
│       ├── __init__.py
│       ├── admin.py
│       ├── apps.py
│       ├── migrations/
│       ├── models.py
│       ├── tests.py
│       ├── urls.py
│       └── views.py
├── templates/             # Global templates
│   └── base.html
├── static/                # Global static files
├── media/                 # User-uploaded files
├── requirements/
│   ├── base.txt
│   ├── dev.txt
│   └── prod.txt
└── README.md</code></pre>
            
            <p><strong>Key Differences:</strong></p>
            <ul>
                <li>Django encourages "apps" as the unit of modularity</li>
                <li>Each app includes its own models, views, templates, and static files</li>
                <li>Project settings are centralized</li>
                <li>Admin interface is a built-in feature with configuration</li>
            </ul>
            
            <h3>FastAPI</h3>
            
            <p>FastAPI works well with modern, modular structures:</p>
            
            <pre><code>my_fastapi_app/
├── app/
│   ├── __init__.py
│   ├── main.py            # FastAPI application creation and configuration
│   ├── core/              # Core functionality
│   │   ├── __init__.py
│   │   ├── config.py      # Settings using Pydantic
│   │   ├── security.py    # Authentication and permissions
│   │   └── database.py    # Database connection
│   ├── api/               # API endpoints
│   │   ├── __init__.py
│   │   ├── dependencies.py # Shared dependencies
│   │   ├── v1/            # API version 1
│   │   │   ├── __init__.py
│   │   │   ├── endpoints/ # Grouped by resource
│   │   │   │   ├── users.py
│   │   │   │   └── items.py
│   │   │   └── router.py  # Combined router
│   ├── models/            # SQLAlchemy models
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── item.py
│   ├── schemas/           # Pydantic schemas/models
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── item.py
│   ├── crud/              # CRUD operations
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── item.py
│   └── services/          # Business logic
│       ├── __init__.py
│       └── user_service.py
├── tests/
├── alembic/               # Migrations
├── .env                   # Environment variables
├── requirements.txt
└── README.md</code></pre>
            
            <p><strong>Key Features:</strong></p>
            <ul>
                <li>API-first design with endpoints organized by resource</li>
                <li>Clear separation between data models (SQLAlchemy) and API schemas (Pydantic)</li>
                <li>Often includes API versioning from the start</li>
                <li>Dependency injection used heavily for shared components</li>
            </ul>
            
            <p><strong>Real-world Example:</strong> The FastAPI official project generator (<code>fastapi-users</code>) follows a similar structure to make it easy to get started with best practices.</p>
        </section>

        <section>
            <h2>Making Structure Decisions</h2>
            
            <p>Choosing the right structure depends on various factors:</p>
            
            <h3>Factors to Consider</h3>
            
            <ul>
                <li><strong>Team Size:</strong> Larger teams need more explicit structure</li>
                <li><strong>Project Lifespan:</strong> Long-lived projects benefit from clearer organization</li>
                <li><strong>Project Complexity:</strong> More features require more modularization</li>
                <li><strong>Team Experience:</strong> Match complexity to team expertise</li>
                <li><strong>Framework Conventions:</strong> Follow established patterns when possible</li>
            </ul>
            
            <h3>Decision Framework</h3>
            
            <p>Use this simplified framework to decide on structure:</p>
            
            <table>
                <tr>
                    <th>Project Type</th>
                    <th>Recommended Structure</th>
                </tr>
                <tr>
                    <td>Simple web app, single developer</td>
                    <td>Simple Flask Application</td>
                </tr>
                <tr>
                    <td>Medium app, small team</td>
                    <td>Package-Based Structure</td>
                </tr>
                <tr>
                    <td>Complex app, multiple developers</td>
                    <td>Modular Blueprint Structure</td>
                </tr>
                <tr>
                    <td>Enterprise app, complex domains</td>
                    <td>Domain-Driven Design or Hexagonal Architecture</td>
                </tr>
            </table>
            
            <p><strong>Metaphor:</strong> Think of project structure like clothing. A simple t-shirt (simple structure) works for a quick errand, but you'll need a specialized outfit (complex structure) for extreme mountain climbing. Choose the structure that fits your project's complexity and needs.</p>
            
            <h3>Evolution, Not Revolution</h3>
            
            <p>It's important to recognize that project structures evolve:</p>
            <ul>
                <li>Start with simpler structures and refactor as needed</li>
                <li>Identify pain points in your current structure</li>
                <li>Gradually migrate toward better organization</li>
                <li>Use code reviews to maintain structural integrity</li>
            </ul>
            
            <p><strong>Real-world Example:</strong> Flask itself started as a simple application and evolved into a blueprint structure as its complexity grew. Many successful web applications follow this pattern of progressive organization.</p>
        </section>

        <section>
            <h2>Best Practices for Project Structure</h2>
            
            <p>Regardless of the specific structure you choose, follow these principles:</p>
            
            <h3>Separation of Concerns</h3>
            
            <p>Keep different types of functionality in separate modules:</p>
            <ul>
                <li><strong>Presentation:</strong> Templates, forms, views/routes</li>
                <li><strong>Business Logic:</strong> Services, domain models</li>
                <li><strong>Data Access:</strong> Database models, repositories</li>
                <li><strong>Configuration:</strong> Settings, environment variables</li>
            </ul>
            
            <p><strong>Analogy:</strong> Like keeping ingredients, cooking utensils, and dining plates in different kitchen cabinets - it makes everything easier to find and use.</p>
            
            <h3>Don't Repeat Yourself (DRY)</h3>
            
            <p>Organize code to minimize duplication:</p>
            <ul>
                <li>Extract common functionality into utility functions</li>
                <li>Use inheritance and composition for shared behaviors</li>
                <li>Create centralized configuration</li>
            </ul>
            
            <pre><code># myapp/core/utils.py
def paginate_query(query, page, per_page):
    """Paginate a SQLAlchemy query."""
    return query.paginate(page=page, per_page=per_page, error_out=False)

# In multiple views
from myapp.core.utils import paginate_query

# Later in a view
users = paginate_query(User.query, page, 20)</code></pre>
            
            <h3>Consistency is Key</h3>
            
            <ul>
                <li>Use consistent naming conventions</li>
                <li>Follow patterns throughout the codebase</li>
                <li>Document structural decisions</li>
                <li>Create templates for new components</li>
            </ul>
            
            <p><strong>Naming Conventions Example:</strong></p>
            <ul>
                <li>Modules: Singular, lowercase with underscores (<code>user.py</code>, <code>product_category.py</code>)</li>
                <li>Classes: Singular, PascalCase (<code>User</code>, <code>ProductCategory</code>)</li>
                <li>Blueprints: Named with purpose and suffix (<code>auth_bp</code>, <code>admin_bp</code>)</li>
                <li>Packages: Plural, lowercase with underscores (<code>models</code>, <code>views</code>, <code>api_endpoints</code>)</li>
            </ul>
            
            <h3>Configuration Management</h3>
            
            <ul>
                <li>Separate configuration from code</li>
                <li>Use environment variables for sensitive values</li>
                <li>Create different configs for different environments</li>
                <li>Never commit sensitive keys to version control</li>
            </ul>
            
            <pre><code># .env (not in version control)
SECRET_KEY=your-very-secret-key
DATABASE_URL=postgresql://user:pass@localhost/dbname

# Using the config
import os
from dotenv import load_dotenv

load_dotenv()  # Load environment variables from .env

SECRET_KEY = os.environ.get('SECRET_KEY')
DATABASE_URL = os.environ.get('DATABASE_URL')</code></pre>
            
            <h3>Configuration vs. Code: What Goes Where</h3>
            
            <p>Clear guidelines on what should be configuration vs. code:</p>
            
            <table>
                <tr>
                    <th>Configuration (config.py, .env)</th>
                    <th>Code (Python modules)</th>
                </tr>
                <tr>
                    <td>Database connection strings</td>
                    <td>Database model definitions</td>
                </tr>
                <tr>
                    <td>API keys and secrets</td>
                    <td>API client implementation</td>
                </tr>
                <tr>
                    <td>Feature flags</td>
                    <td>Feature implementation</td>
                </tr>
                <tr>
                    <td>Environment-specific settings</td>
                    <td>Application logic</td>
                </tr>
                <tr>
                    <td>Logging levels and destinations</td>
                    <td>Logging setup code</td>
                </tr>
            </table>
        </section>

        <section>
            <h2>Project Structure in a Team Environment</h2>
            
            <p>When working with teams, project structure becomes even more important:</p>
            
            <h3>Documentation</h3>
            
            <p>Document your structure for team members:</p>
            
            <pre><code># README.md section on project structure
## Project Structure

This project follows a modular blueprint structure:

- `myapp/`: Main package
  - `__init__.py`: Application factory
  - `auth/`: Authentication module
  - `admin/`: Admin panel module
  - `public/`: Public-facing pages
  - `models/`: Database models
  - `static/`: Static assets
  - `templates/`: HTML templates
- `migrations/`: Database migrations
- `tests/`: Test suite
- `config.py`: Configuration classes

### Module Structure

Each module (auth, admin, public) follows this structure:
- `__init__.py`: Blueprint creation
- `routes.py`: View functions and routes
- `forms.py`: WTForms definitions
- `templates/`: Module-specific templates</code></pre>
            
            <h3>Onboarding</h3>
            
            <p>Make it easy for new team members to understand the structure:</p>
            <ul>
                <li>Include structure documentation in onboarding materials</li>
                <li>Create a visual diagram of the architecture</li>
                <li>Explain the reasoning behind structural decisions</li>
                <li>Highlight where common tasks should be implemented</li>
            </ul>
            
            <h3>Contribution Guidelines</h3>
            
            <p>Set clear rules for maintaining the structure:</p>
            
            <pre><code># CONTRIBUTING.md section
## Code Organization

- New features should be implemented as blueprints in their own module
- Keep models in the `models/` directory, one model per file
- Place shared utilities in `core/utils.py`
- Add tests for all new functionality
- Follow existing naming conventions
- Update documentation when changing structure</code></pre>
            
            <h3>Code Reviews</h3>
            
            <p>Use code reviews to enforce structural consistency:</p>
            <ul>
                <li>Check that new code follows the established structure</li>
                <li>Look for code that belongs in a different module</li>
                <li>Identify opportunities for refactoring to improve organization</li>
                <li>Ensure documentation is updated</li>
            </ul>
        </section>

        <section>
            <h2>Practical Example: Refactoring for Better Structure</h2>
            
            <p>Let's look at a practical example of refactoring a simple Flask application into a better structure.</p>
            
            <h3>Starting Point: Simple Flask App</h3>
            
            <pre><code># app.py - Everything in one file
from flask import Flask, render_template, request, redirect, url_for, flash
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
login_manager = LoginManager(app)
login_manager.login_view = 'login'

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)
        
    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        user = User.query.filter_by(username=username).first()
        if user and user.check_password(password):
            login_user(user)
            return redirect(url_for('index'))
        flash('Invalid username or password')
    return render_template('login.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('index'))

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if User.query.filter_by(username=username).first():
            flash('Username already exists')
        else:
            user = User(username=username)
            user.set_password(password)
            db.session.add(user)
            db.session.commit()
            flash('Registration successful')
            return redirect(url_for('login'))
    return render_template('register.html')

if __name__ == '__main__':
    db.create_all()
    app.run(debug=True)</code></pre>
            
            <h3>Refactored Structure: Package-Based</h3>
            
            <p>Reorganize into a proper package structure:</p>
            
            <pre><code>my_flask_app/
├── myapp/
│   ├── __init__.py
│   ├── models.py
│   ├── auth.py
│   ├── routes.py
│   ├── templates/
│   │   ├── base.html
│   │   ├── index.html
│   │   ├── login.html
│   │   └── register.html
│   └── static/
├── config.py
├── requirements.txt
└── run.py</code></pre>
            
            <pre><code># config.py
import os

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY', 'dev-key')
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL', 'sqlite:///app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

# myapp/__init__.py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager

from config import Config

db = SQLAlchemy()
login_manager = LoginManager()
login_manager.login_view = 'auth.login'

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)
    
    db.init_app(app)
    login_manager.init_app(app)
    
    from myapp import models
    
    from myapp.auth import auth_bp
    app.register_blueprint(auth_bp)
    
    from myapp.routes import main_bp
    app.register_blueprint(main_bp)
    
    return app

# myapp/models.py
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash

from myapp import db, login_manager

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)
        
    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

# myapp/auth.py
from flask import Blueprint, render_template, redirect, url_for, flash, request
from flask_login import login_user, logout_user, login_required

from myapp import db
from myapp.models import User

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        user = User.query.filter_by(username=username).first()
        if user and user.check_password(password):
            login_user(user)
            return redirect(url_for('main.index'))
        flash('Invalid username or password')
    return render_template('login.html')

@auth_bp.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('main.index'))

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if User.query.filter_by(username=username).first():
            flash('Username already exists')
        else:
            user = User(username=username)
            user.set_password(password)
            db.session.add(user)
            db.session.commit()
            flash('Registration successful')
            return redirect(url_for('auth.login'))
    return render_template('register.html')

# myapp/routes.py
from flask import Blueprint, render_template

main_bp = Blueprint('main', __name__)

@main_bp.route('/')
def index():
    return render_template('index.html')

# run.py
from myapp import create_app, db

app = create_app()

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)</code></pre>
            
            <h3>Key Improvements</h3>
            
            <ul>
                <li><strong>Separation of Concerns:</strong> Models, views, and configuration are now separate</li>
                <li><strong>Extensibility:</strong> Easy to add new blueprints for additional features</li>
                <li><strong>Application Factory:</strong> Allows for different configurations and testing</li>
                <li><strong>Blueprint Organization:</strong> Routes are grouped by functionality</li>
                <li><strong>Configuration Management:</strong> Environment variables and config classes</li>
            </ul>
            
            <p><strong>Result:</strong> The application is now more maintainable, testable, and easier to extend with new features.</p>
        </section>

        <section>
            <h2>Further Evolution: Moving to Blueprints</h2>
            
            <p>As the application grows, you might refactor further to a modular blueprint structure:</p>
            
            <pre><code>my_flask_app/
├── myapp/
│   ├── __init__.py
│   ├── extensions.py
│   ├── models/
│   │   ├── __init__.py
│   │   └── user.py
│   ├── auth/
│   │   ├── __init__.py
│   │   ├── routes.py
│   │   ├── forms.py
│   │   └── templates/
│   │       └── auth/
│   │           ├── login.html
│   │           └── register.html
│   ├── main/
│   │   ├── __init__.py
│   │   ├── routes.py
│   │   └── templates/
│   │       └── main/
│   │           └── index.html
│   ├── templates/
│   │   └── base.html
│   └── static/
├── migrations/
├── tests/
├── config.py
├── requirements.txt
└── run.py</code></pre>
            
            <p>With this structure, each feature area becomes fully encapsulated with its own routes, forms, and templates.</p>
        </section>

        <section>
            <h2>Conclusion</h2>
            
            <p>A well-designed project structure is a fundamental building block of successful web applications. As we've explored:</p>
            
            <ul>
                <li>Various structural patterns exist, from simple to complex</li>
                <li>The right structure depends on your project's specific needs</li>
                <li>Structure should evolve as your application grows</li>
                <li>Consistency and separation of concerns are key principles</li>
                <li>Documentation helps teams maintain structural integrity</li>
            </ul>
            
            <p>As we move forward in our web development journey, the structures we've discussed today will serve as templates for organizing our applications. In the coming weeks, as we dive into Flask, Django, and other frameworks, we'll see these patterns in action and understand how they contribute to building maintainable, scalable web applications.</p>
            
            <p><strong>Final Analogy:</strong> Think of project structure as architecture. A well-designed building isn't just about aesthetics—it's about creating spaces that people can navigate intuitively, that can withstand time and changing needs, and that make the intended activities efficient and pleasant. A good project structure serves the same purpose for your code and the developers who work with it.</p>
        </section>

        <section class="resources">
            <h2>Additional Resources</h2>
            <ul>
                <li><a href="https://flask.palletsprojects.com/en/2.0.x/patterns/packages/" target="_blank">Flask Application Patterns</a></li>
                <li><a href="https://docs.djangoproject.com/en/3.2/intro/tutorial01/" target="_blank">Django Project Structure</a></li>
                <li><a href="https://fastapi.tiangolo.com/tutorial/bigger-applications/" target="_blank">FastAPI Project Organization</a></li>
                <li><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xv-a-better-application-structure" target="_blank">Miguel Grinberg's Flask Mega-Tutorial: Application Structure</a></li>
                <li><a href="https://www.pythonforthelab.com/blog/how-to-use-google-style-docstrings-with-sphinx/" target="_blank">Python Project Documentation with Sphinx</a></li>
                <li><a href="https://12factor.net/" target="_blank">The Twelve-Factor App Methodology</a></li>
                <li><a href="https://www.cosmicpython.com/" target="_blank">Cosmic Python: Architecture Patterns</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>Python Full Stack Developer Course - File: week3_friday_project_structure.html</p>
        <p>Located in course root directory</p>
    </footer>
</body>
</html>
