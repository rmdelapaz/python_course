<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS Display Properties: Understanding Layout Building Blocks</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>CSS Display Properties: Understanding Layout Building Blocks</h1>
        <h2>Week 4: Tuesday Afternoon Session</h2>
    </header>

    <main>
        <section class="lecture_intro">
            <h3>The Power of Display Properties</h3>
            <p>Welcome to our deep dive into CSS display properties! Now that we've explored CSS positioning, we're ready to tackle another fundamental aspect of creating layouts: the <code>display</code> property. This property determines how an element behaves in the flow of a document and interacts with surrounding elements.</p>
            
            <p>The <code>display</code> property is one of the most important CSS properties for controlling layout. It affects not only how an element is displayed, but also how its children are arranged, how much space it takes up, and how it interacts with other elements. By mastering display properties, you'll gain powerful tools for creating layouts that are both visually appealing and flexible.</p>
        </section>

        <section class="file_locations">
            <h3>File Organization</h3>
            <p>For today's session, we'll use the following files:</p>
            <ul>
                <li><strong>CSS File:</strong> <code>styles/display_properties.css</code> in your styles folder</li>
                <li><strong>HTML File:</strong> <code>display_examples.html</code> in your project root</li>
            </ul>
            <p>Make sure to create these files and link them properly before we begin the exercises.</p>
        </section>

        <section class="display_fundamentals">
            <h3>Understanding the Display Property</h3>
            <p>The <code>display</code> property is a core building block of CSS layouts. It defines how elements behave in the document flow and how they interact with other elements.</p>

            <h4>The Anatomy of Display</h4>
            <p>At its core, the <code>display</code> property determines two things:</p>
            <ul>
                <li><strong>The outer display type:</strong> How the element participates in flow layout (block, inline, etc.)</li>
                <li><strong>The inner display type:</strong> How the element's children are laid out (e.g., flex, grid)</li>
            </ul>

            <p><strong>Real-world analogy:</strong> Think of display properties like different types of containers. Some containers (like block elements) take up an entire shelf, while others (like inline elements) sit next to each other on the same shelf. Some containers have special internal organization systems (like flex or grid) that determine how items inside them are arranged.</p>
        </section>

        <section class="display_values">
            <h3>Common Display Values</h3>
            <p>Let's explore the most commonly used display values and understand their behaviors:</p>

            <h4>Block Display</h4>
            <p>When an element has <code>display: block</code>:</p>
            <ul>
                <li>It starts on a new line</li>
                <li>It stretches to fill the width of its container by default</li>
                <li>Width, height, margin, and padding properties are respected</li>
                <li>Examples: <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>, <code>&lt;section&gt;</code></li>
            </ul>

            <pre><code>/* Block display example */
.block-element {
    display: block;
    width: 50%;
    margin: 20px auto;
    padding: 15px;
    background-color: #e9ecef;
}</code></pre>

            <p><strong>Real-world analogy:</strong> Block elements are like paragraphs in a book—each one starts on a new line, has a clear beginning and end, and takes up the full width of the page by default.</p>

            <h4>Inline Display</h4>
            <p>When an element has <code>display: inline</code>:</p>
            <ul>
                <li>It flows with the text (doesn't start on a new line)</li>
                <li>It only takes up as much width as necessary</li>
                <li>Width and height properties are ignored</li>
                <li>Only horizontal margins and padding are respected (not vertical)</li>
                <li>Examples: <code>&lt;span&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;em&gt;</code>, <code>&lt;strong&gt;</code></li>
            </ul>

            <pre><code>/* Inline display example */
.inline-element {
    display: inline;
    background-color: #d1ecf1;
    padding: 0 10px; /* Horizontal padding works */
    margin: 0 5px; /* Horizontal margin works */
    /* width and height would be ignored */
}</code></pre>

            <p><strong>Real-world analogy:</strong> Inline elements are like words in a sentence—they flow from left to right, wrapping to a new line when they run out of space, and they only take up as much space as they need.</p>

            <h4>Inline-Block Display</h4>
            <p>When an element has <code>display: inline-block</code>:</p>
            <ul>
                <li>It flows with the text like an inline element</li>
                <li>It respects width, height, margin, and padding properties like a block element</li>
                <li>It's a hybrid that combines features of both inline and block</li>
                <li>Examples: <code>&lt;img&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;input&gt;</code></li>
            </ul>

            <pre><code>/* Inline-block display example */
.inline-block-element {
    display: inline-block;
    width: 150px;
    height: 100px;
    margin: 10px;
    padding: 15px;
    background-color: #d4edda;
    vertical-align: middle; /* Controls alignment with other inline elements */
}</code></pre>

            <p><strong>Real-world analogy:</strong> Inline-block elements are like photos in a text document—they flow with the text (inline), but they maintain their dimensions (block), allowing you to place them within text while still controlling their size.</p>

            <h4>None Display</h4>
            <p>When an element has <code>display: none</code>:</p>
            <ul>
                <li>It's completely removed from the document flow</li>
                <li>It doesn't take up any space</li>
                <li>It and all its children are invisible and non-interactive</li>
                <li>Screen readers will ignore these elements (important for accessibility)</li>
            </ul>

            <pre><code>/* None display example */
.hidden-element {
    display: none; /* Element disappears completely */
}

/* Compare with visibility: hidden */
.invisible-element {
    visibility: hidden; /* Element is invisible but still takes up space */
}</code></pre>

            <p><strong>Important distinction:</strong> <code>display: none</code> removes the element completely, while <code>visibility: hidden</code> keeps the element in the layout but makes it invisible. Think of <code>display: none</code> as removing a book from the shelf, while <code>visibility: hidden</code> is like placing an invisible book on the shelf that still takes up space.</p>

            <h4>Flex Display</h4>
            <p>When an element has <code>display: flex</code>:</p>
            <ul>
                <li>It becomes a flex container</li>
                <li>Its children become flex items with new layout behaviors</li>
                <li>It enables powerful alignment and distribution features</li>
                <li>It provides one-dimensional layout control (in a row or column)</li>
            </ul>

            <pre><code>/* Flex display example */
.flex-container {
    display: flex;
    justify-content: space-between; /* Horizontal distribution */
    align-items: center; /* Vertical alignment */
    height: 200px;
    background-color: #f8f9fa;
}

.flex-item {
    width: 100px;
    height: 100px;
    background-color: #6c757d;
    color: white;
}</code></pre>

            <p><strong>Real-world analogy:</strong> Flexbox is like a smart bookshelf with adjustable dividers that can automatically resize and rearrange books to make the most efficient use of space, while also keeping them perfectly aligned.</p>
            <p>We'll cover Flexbox in much more detail in our next session, as it's a powerful layout system deserving of its own deep dive.</p>

            <h4>Grid Display</h4>
            <p>When an element has <code>display: grid</code>:</p>
            <ul>
                <li>It becomes a grid container</li>
                <li>Its children become grid items</li>
                <li>It enables two-dimensional layout (rows and columns)</li>
                <li>It allows precise placement in both dimensions</li>
            </ul>

            <pre><code>/* Grid display example */
.grid-container {
    display: grid;
    grid-template-columns: 1fr 2fr 1fr; /* Three columns with proportional widths */
    grid-template-rows: 100px 200px; /* Two rows with fixed heights */
    gap: 20px; /* Spacing between grid items */
    background-color: #f8f9fa;
}

.grid-item {
    background-color: #6c757d;
    color: white;
}</code></pre>

            <p><strong>Real-world analogy:</strong> CSS Grid is like a spreadsheet or table layout system—it creates a framework of rows and columns, allowing elements to be placed precisely within the cells, span multiple cells, and align perfectly in two dimensions.</p>
            <p>We'll explore CSS Grid in depth in a future session.</p>
        </section>

        <section class="table_display">
            <h3>Table-Related Display Properties</h3>
            <p>CSS provides display values that mimic HTML table behavior without requiring table markup:</p>

            <h4>Table Display Types</h4>
            <ul>
                <li><code>display: table</code> - Creates a block-level table</li>
                <li><code>display: table-row</code> - Creates a table row</li>
                <li><code>display: table-cell</code> - Creates a table cell</li>
                <li><code>display: table-header-group</code> - Creates a header group (like <code>&lt;thead&gt;</code>)</li>
                <li><code>display: table-footer-group</code> - Creates a footer group (like <code>&lt;tfoot&gt;</code>)</li>
                <li><code>display: table-caption</code> - Creates a caption for the table</li>
            </ul>

            <pre><code>/* Table display example */
.table {
    display: table;
    width: 100%;
    border-collapse: collapse;
}

.table-row {
    display: table-row;
}

.table-cell {
    display: table-cell;
    padding: 10px;
    border: 1px solid #dee2e6;
}

.table-header {
    display: table-cell;
    font-weight: bold;
    background-color: #f8f9fa;
    padding: 10px;
    border: 1px solid #dee2e6;
}</code></pre>

            <p><strong>When to use:</strong> Table display properties are useful when you need table-like layout (equal height columns, cell alignment) but want to use semantic HTML elements instead of <code>&lt;table&gt;</code> tags. However, in most cases, Flexbox or Grid provide more powerful and flexible alternatives.</p>
        </section>

        <section class="display_flow">
            <h3>Understanding Flow and Layout Contexts</h3>
            <p>Each display value creates a different layout context, influencing how elements are rendered and interact.</p>

            <h4>Block Formatting Context (BFC)</h4>
            <p>A Block Formatting Context is a region where block boxes are laid out. Important properties:</p>
            <ul>
                <li>Contains floats (prevents them from affecting elements outside)</li>
                <li>Prevents margin collapsing between elements inside and outside</li>
                <li>Created by elements with certain display values or CSS properties</li>
            </ul>

            <p><strong>Elements that create a BFC:</strong></p>
            <ul>
                <li>Elements with <code>display: flow-root</code></li>
                <li>Elements with <code>overflow</code> values other than <code>visible</code></li>
                <li>Flex containers and grid containers</li>
                <li>Floated elements</li>
                <li>Absolutely positioned elements</li>
            </ul>

            <pre><code>/* Creating a BFC to contain floats */
.clearfix {
    display: flow-root; /* Modern approach to contain floats */
}

/* Alternative method */
.clearfix-alt {
    overflow: auto; /* Also creates a BFC */
}</code></pre>

            <p><strong>Real-world analogy:</strong> A Block Formatting Context is like a room with its own rules where furniture (elements) is arranged independently from the rest of the house. What happens in this room stays in this room—the arrangement of furniture inside doesn't affect the arrangement outside.</p>

            <h4>Inline Formatting Context (IFC)</h4>
            <p>An Inline Formatting Context is created by a container with inline or inline-block elements. In an IFC:</p>
            <ul>
                <li>Elements are laid out horizontally, starting at the top</li>
                <li>Horizontal margins, borders, and padding are respected</li>
                <li>Vertical alignment can be controlled with <code>vertical-align</code></li>
                <li>Line height affects the spacing between lines</li>
            </ul>

            <pre><code>/* Controlling inline element alignment */
.text-container {
    line-height: 1.5;
    font-size: 16px;
}

.superscript {
    vertical-align: super;
    font-size: 0.8em;
}

.baseline {
    vertical-align: baseline; /* Default */
}

.middle {
    vertical-align: middle;
}</code></pre>

            <p><strong>Real-world analogy:</strong> An Inline Formatting Context is like text flowing in a paragraph. Each word (inline element) sits next to the others, flowing from left to right, and wrapping to the next line when needed. Some words might be slightly raised or lowered (like superscript or subscript), but they all flow together in the same paragraph.</p>
        </section>

        <section class="responsive_display">
            <h3>Responsive Display Properties</h3>
            <p>Display properties play a crucial role in responsive design:</p>

            <h4>Media Queries for Display Changes</h4>
            <p>Using media queries, we can change how elements display based on screen size:</p>

            <pre><code>/* Responsive display changes */
.card-container {
    display: flex;
    flex-wrap: wrap;
}

.card {
    flex: 0 0 calc(33.333% - 20px);
    margin: 10px;
}

/* Tablet layout */
@media (max-width: 768px) {
    .card {
        flex: 0 0 calc(50% - 20px);
    }
}

/* Mobile layout */
@media (max-width: 480px) {
    .card-container {
        display: block; /* Switch to vertical stacking */
    }
    
    .card {
        width: 100%;
        margin: 10px 0;
    }
}

/* Show/hide elements responsively */
.desktop-only {
    display: block;
}

.mobile-only {
    display: none;
}

@media (max-width: 768px) {
    .desktop-only {
        display: none;
    }
    
    .mobile-only {
        display: block;
    }
}</code></pre>

            <h4>Mobile Navigation Patterns</h4>
            <p>Responsive navigation often uses display changes:</p>

            <pre><code>/* Mobile navigation styles */
.main-nav {
    display: flex;
}

.nav-toggle {
    display: none; /* Hidden on desktop */
}

@media (max-width: 768px) {
    .main-nav {
        display: none; /* Hidden by default on mobile */
    }
    
    .main-nav.active {
        display: block; /* Show when active */
    }
    
    .nav-toggle {
        display: block; /* Show on mobile */
    }
    
    .nav-item {
        display: block; /* Stack vertically */
        width: 100%;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
}</code></pre>

            <p><strong>Real-world example:</strong> Think of it like transforming a side-by-side bookshelf (horizontal navigation) into a stack of books (vertical navigation) when space becomes limited, with a button to hide/show the stack when needed.</p>
        </section>

        <section class="display_accessibility">
            <h3>Accessibility and Display Properties</h3>
            <p>How your display choices affect users with disabilities:</p>

            <h4>Screen Reader Considerations</h4>
            <p><code>display: none</code> completely removes elements from accessibility tree:</p>

            <pre><code>/* Accessibility-friendly hiding */
/* Completely hidden from all users */
.hidden {
    display: none;
}

/* Visually hidden but accessible to screen readers */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
}</code></pre>

            <p><strong>When to use each:</strong> Use <code>display: none</code> for content that should be hidden from all users. Use <code>.sr-only</code> for content that should be available to screen readers but not visible on screen (like labels or additional context).</p>

            <h4>Focus Management</h4>
            <p>Be careful with toggling display for interactive elements:</p>

            <pre><code>/* Accessibility issue with display: none */
.dropdown {
    position: relative;
}

.dropdown-menu {
    display: none;
}

.dropdown-menu.active {
    display: block;
}

/* Better approach for accessibility */
.dropdown-menu {
    /* Still in document for keyboard users */
    visibility: hidden;
    opacity: 0;
    /* Prevent interaction when hidden */
    pointer-events: none;
    /* Smooth transition */
    transition: opacity 0.3s, visibility 0s 0.3s;
}

.dropdown-menu.active {
    visibility: visible;
    opacity: 1;
    pointer-events: auto;
    transition: opacity 0.3s;
}</code></pre>

            <p><strong>Key consideration:</strong> Using <code>visibility: hidden</code> instead of <code>display: none</code> for interactive elements allows them to remain in the document flow, making them more accessible to keyboard users when they become visible.</p>
        </section>

        <section class="display_performance">
            <h3>Performance Considerations</h3>
            <p>Display properties can impact rendering performance:</p>

            <h4>Layout Recalculation</h4>
            <p>Changing display properties can trigger expensive layouts:</p>

            <pre><code>/* Performance issue: triggering layout */
button.onclick = function() {
    document.querySelector('.element').style.display = 'block';
    // Triggers layout recalculation
    console.log(document.querySelector('.element').offsetHeight);
    document.querySelector('.element').style.color = 'red';
    // More layout work
}

/* Better performance: batch changes */
button.onclick = function() {
    const element = document.querySelector('.element');
    // Group all style changes
    element.style.display = 'block';
    element.style.color = 'red';
    // Read layout property once at the end
    console.log(element.offsetHeight);
}</code></pre>

            <h4>Animation Considerations</h4>
            <p>Avoid animating display changes:</p>

            <pre><code>/* Not animatable */
.element {
    display: none;
    transition: display 0.3s; /* Won't work */
}

/* Better approach */
.element {
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0s 0.3s;
}

.element.active {
    opacity: 1;
    visibility: visible;
    transition: opacity 0.3s;
}</code></pre>

            <p><strong>Why it matters:</strong> The <code>display</code> property isn't animatable. For smooth transitions, use properties like <code>opacity</code> combined with <code>visibility</code>.</p>
        </section>

        <section class="assignment">
            <h3>Today's Assignment: Display Property Exploration</h3>
            <p>Now it's your turn to apply what you've learned about CSS display properties.</p>
            
            <h4>Assignment Requirements:</h4>
            <ol>
                <li>Create a new file called <code>styles/display_exploration.css</code></li>
                <li>Create a corresponding HTML file called <code>display_exploration.html</code></li>
                <li>Build a page that demonstrates multiple display properties:
                    <ul>
                        <li>Create a navigation bar using <code>inline-block</code> display</li>
                        <li>Create a card layout section using <code>flex</code> display</li>
                        <li>Create a content grid section using <code>grid</code> display</li>
                        <li>Implement a dropdown menu that toggles using <code>display: none/block</code></li>
                        <li>Create a comparison section showing the differences between display types</li>
                    </ul>
                </li>
                <li>Make your page responsive:
                    <ul>
                        <li>Use media queries to change display properties at different breakpoints</li>
                        <li>Create a mobile navigation menu that shows/hides</li>
                        <li>Ensure all content is accessible and readable at all screen sizes</li>
                    </ul>
                </li>
                <li>Add detailed comments explaining your display choices and how they affect layout</li>
            </ol>
            
            <p><strong>Bonus challenges:</strong></p>
            <ul>
                <li>Create a tabbed interface using display properties</li>
                <li>Implement an image gallery with different display methods</li>
                <li>Create a pricing table using table display properties</li>
                <li>Implement a masonry-style layout without JavaScript</li>
                <li>Create an accordion component with smooth transitions</li>
            </ul>
            
            <p>Submit your completed assignment by pushing both your HTML and CSS files to your course repository.</p>
        </section>

        <section class="conclusion">
            <h3>Wrapping Up</h3>
            <p>Congratulations! You've now explored the powerful world of CSS display properties and have the tools to control how elements behave in your layouts.</p>
            
            <p>Key takeaways from today's session:</p>
            <ul>
                <li>The <code>display</code> property controls both outer behavior (block, inline) and inner layout (flex, grid)</li>
                <li>Each display value creates a different layout context with specific rules</li>
                <li>Modern layout techniques like Flexbox and Grid provide powerful alternatives to older methods</li>
                <li>Display properties are crucial for responsive design</li>
                <li>Consider accessibility implications when changing display properties</li>
                <li>Performance can be affected by how and when you modify display values</li>
            </ul>
            
            <p>Understanding display properties is foundational to mastering CSS layout. In our next session, we'll dive deeper into Flexbox, one of the most powerful modern layout systems that builds on the display property concepts we've covered today.</p>
            
            <p>Any questions before we wrap up?</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
