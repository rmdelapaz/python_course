<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testing Responsive Designs - Python Full Stack Web Developer Course</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Python Full Stack Web Developer Course</h1>
        <h2>Week 4: Wednesday Afternoon - Testing Responsive Designs</h2>
    </header>

    <main>
        <section class="introduction">
            <h2>Introduction to Responsive Design Testing</h2>
            <p>Testing responsive designs is an essential skill for modern web developers. With users accessing websites on countless devices—from tiny smartwatches to massive desktop monitors—ensuring your site works well everywhere is critical to success.</p>
            
            <p>Think of responsive design testing as similar to a chef tasting a dish at various temperatures. A soup might taste perfect when hot but reveal flaws when lukewarm. Similarly, your website might look flawless on your development machine but break completely on a smartphone.</p>
            
            <div class="file-location">
                <p><strong>File Location:</strong> Create a new file in your project at <code>04week/04week_3day_afternoon_testing.html</code></p>
            </div>
        </section>

        <section class="why-test">
            <h2>Why Test Responsive Designs?</h2>
            <p>Responsive design testing isn't just about checking if your site "looks good" on different screens. It's a comprehensive approach to ensuring usability, functionality, and performance across all potential user environments.</p>
            
            <p>Consider these statistics:</p>
            <ul>
                <li>Over 50% of global web traffic comes from mobile devices</li>
                <li>Users are 5x more likely to abandon tasks if a site isn't optimized for mobile</li>
                <li>Search engines like Google prioritize mobile-friendly websites in rankings</li>
                <li>The average person uses 3-4 different devices to access the internet</li>
            </ul>
            
            <p>When we fail to test responsive designs, we risk creating digital environments that:</p>
            <ul>
                <li><strong>Exclude users:</strong> Like building a store with doorways too narrow for some customers</li>
                <li><strong>Damage reputation:</strong> A broken mobile experience suggests overall poor quality</li>
                <li><strong>Lower conversion rates:</strong> Frustrated users rarely become customers</li>
                <li><strong>Waste development time:</strong> Fixing responsive issues after launch is far more time-consuming than addressing them during development</li>
            </ul>
        </section>

        <section class="testing-dimensions">
            <h2>The Five Dimensions of Responsive Testing</h2>
            <p>Comprehensive responsive testing goes beyond just checking how your layout adapts to different screen sizes. Think of it as a five-dimensional audit:</p>
            
            <ol>
                <li><strong>Layout Adaptability:</strong> How your design elements rearrange across different viewport sizes</li>
                <li><strong>Content Readability:</strong> Whether text, images, and media remain accessible and legible</li>
                <li><strong>Interactive Usability:</strong> How controls and navigation function on touch vs. pointer devices</li>
                <li><strong>Performance Metrics:</strong> Speed and resource consumption across different devices</li>
                <li><strong>Feature Parity:</strong> Ensuring all functionality remains available regardless of device</li>
            </ol>
            
            <p>Just as a house must be inspected for structural integrity, electrical safety, plumbing, insulation, and legal compliance, a responsive website requires similarly multifaceted testing.</p>
        </section>

        <section class="browser-tools">
            <h2>Browser Developer Tools</h2>
            <p>Your browser's built-in developer tools are the first line of defense for responsive testing. They're like having an adjustable mannequin that can represent countless body types when designing clothes.</p>
            
            <h3>Chrome DevTools Device Mode</h3>
            <p>Chrome's Device Mode is one of the most comprehensive tools for responsive testing:</p>
            
            <h4>Accessing Device Mode:</h4>
            <ol>
                <li>Open Chrome Developer Tools (F12 or Right-click → Inspect)</li>
                <li>Click the "Toggle Device Toolbar" icon (Ctrl+Shift+M)</li>
            </ol>
            
            <h4>Key Features:</h4>
            <ul>
                <li><strong>Viewport Size Controls:</strong> Manually adjust width and height</li>
                <li><strong>Device Presets:</strong> Simulate specific devices (iPhones, Pixels, etc.)</li>
                <li><strong>Orientation Toggle:</strong> Switch between portrait and landscape</li>
                <li><strong>Network Throttling:</strong> Simulate slower connections</li>
                <li><strong>User Agent Switching:</strong> Test device-specific server responses</li>
                <li><strong>Media Queries Inspector:</strong> Visualize breakpoint transitions</li>
            </ul>
            
            <div class="code-example">
                <h4>Using Media Query Inspector</h4>
                <pre><code>/* In your CSS */
@media (max-width: 768px) {
    .container {
        flex-direction: column;
    }
}

/* In Chrome DevTools: */
/* 1. Open Developer Tools */
/* 2. Click "..." menu → More tools → Media queries */
/* 3. A bar will appear showing your breakpoints */
/* 4. Click on a breakpoint to jump to that viewport width */</code></pre>
            </div>
            
            <p><strong>Real-world application:</strong> When building a dashboard interface for a Python data application, use Device Mode to ensure data visualizations remain legible and interactive across different screen sizes.</p>
            
            <h3>Firefox Responsive Design Mode</h3>
            <p>Firefox offers some unique features for responsive testing:</p>
            
            <h4>Accessing Responsive Design Mode:</h4>
            <ol>
                <li>Open Firefox Developer Tools (F12 or Right-click → Inspect)</li>
                <li>Click the "Responsive Design Mode" icon (Ctrl+Shift+M)</li>
            </ol>
            
            <h4>Unique Features:</h4>
            <ul>
                <li><strong>Touch Simulation:</strong> Test touch events without a touchscreen</li>
                <li><strong>Screenshot Capture:</strong> Easily document how your site looks at different sizes</li>
                <li><strong>Device Pixel Ratio Simulation:</strong> Test on high-DPI displays</li>
            </ul>
            
            <p><strong>Practical tip:</strong> Firefox's touch event simulation is particularly useful for testing Flask/Django admin interfaces, which often have complex UI controls that need careful testing on touch devices.</p>
        </section>

        <section class="breakpoint-testing">
            <h2>Systematic Breakpoint Testing</h2>
            <p>Rather than randomly resizing your browser, adopt a systematic approach to testing breakpoints. Think of it like a quality control inspector checking products at specific checkpoints in a manufacturing line.</p>
            
            <h3>Common Breakpoint Categories</h3>
            <ul>
                <li><strong>Small Mobile:</strong> 320px - 480px</li>
                <li><strong>Large Mobile:</strong> 481px - 767px</li>
                <li><strong>Tablet:</strong> 768px - 1023px</li>
                <li><strong>Desktop:</strong> 1024px - 1279px</li>
                <li><strong>Large Desktop:</strong> 1280px and above</li>
            </ul>
            
            <p>These aren't just arbitrary ranges—they reflect common device dimensions. Testing at the upper and lower bounds of each range helps catch edge cases.</p>
            
            <h3>Critical Testing Points</h3>
            <p>Pay special attention to these specific widths:</p>
            <ul>
                <li><strong>320px:</strong> Minimum width for most mobile devices</li>
                <li><strong>375px:</strong> iPhone SE and similar compact smartphones</li>
                <li><strong>768px:</strong> iPad and most tablets in portrait orientation</li>
                <li><strong>1024px:</strong> iPad Pro and tablets in landscape orientation</li>
                <li><strong>1px above and below your breakpoints:</strong> Catch transition bugs</li>
            </ul>
            
            <div class="code-example">
                <h4>Defining Custom Breakpoints in Chrome DevTools</h4>
                <pre><code>/* After opening Device Mode in Chrome: */
/* 1. Click "Add custom device" in the device dropdown */
/* 2. Create presets for your project's critical testing points */
/* 3. Save them for quick access during testing */</code></pre>
            </div>
            
            <p><strong>Real-world example:</strong> When developing a Python e-commerce application, you might need additional breakpoints at 896px for specific product grid layouts that transition from 3 columns to 2 columns.</p>
        </section>

        <section class="testing-methodologies">
            <h2>Testing Methodologies: Mobile-First vs. Desktop-Down</h2>
            <p>There are two primary approaches to testing responsive designs, each with distinct advantages:</p>
            
            <h3>Mobile-First Testing</h3>
            <p>Start with the smallest viewport and gradually expand:</p>
            <ol>
                <li>Begin at 320px width</li>
                <li>Slowly increase the viewport width</li>
                <li>Observe how elements adapt at each breakpoint</li>
                <li>Note any awkward transitions or layout shifts</li>
            </ol>
            
            <p><strong>Advantages:</strong> This approach aligns with mobile-first development methodology. It prioritizes the most constrained environment first, ensuring content remains accessible in its most compressed form.</p>
            
            <p>Think of this like designing a compact apartment first, then seeing how the design principles scale to a mansion—rather than trying to cram mansion features into an apartment.</p>
            
            <h3>Desktop-Down Testing</h3>
            <p>Start with a full desktop viewport and gradually reduce:</p>
            <ol>
                <li>Begin at maximum width (e.g., 1920px)</li>
                <li>Gradually decrease the viewport width</li>
                <li>Watch for breakages and awkward wrapping</li>
                <li>Identify where new breakpoints might be needed</li>
            </ol>
            
            <p><strong>Advantages:</strong> This helps identify content that becomes problematic as space constraints increase, particularly helpful for complex layouts or data-heavy applications.</p>
            
            <p><strong>Best practice:</strong> Use both approaches as complementary techniques. Mobile-first testing for information architecture and content priority; desktop-down for identifying complex layout issues.</p>
        </section>

        <section class="device-testing">
            <h2>Real Device Testing</h2>
            <p>While browser tools are invaluable, nothing replaces testing on actual devices. Browser emulation is like a flight simulator—extremely useful but not identical to flying a real aircraft.</p>
            
            <h3>Minimum Device Testing Set</h3>
            <p>If resources are limited, test on at least:</p>
            <ul>
                <li>An older, smaller smartphone (e.g., iPhone SE or budget Android)</li>
                <li>A current-generation larger smartphone</li>
                <li>A tablet (preferably both orientations)</li>
                <li>A laptop/desktop with various window sizes</li>
            </ul>
            
            <h3>Device Labs</h3>
            <p>Not everyone has access to multiple devices. Consider these alternatives:</p>
            <ul>
                <li><strong>Company device library:</strong> Many organizations maintain a set of test devices</li>
                <li><strong>Testing services:</strong> BrowserStack, LambdaTest, or Sauce Labs provide remote access to real devices</li>
                <li><strong>Community labs:</strong> Some coworking spaces and tech hubs offer device testing facilities</li>
                <li><strong>Friends and family:</strong> Informal testing across different personal devices</li>
            </ul>
            
            <p><strong>Python developer insight:</strong> When building Flask or Django applications, testing on real devices is particularly important for form submissions, file uploads, and camera/microphone access—features that emulators often handle differently than real devices.</p>
        </section>

        <section class="automated-testing">
            <h2>Automated Responsive Testing</h2>
            <p>Manual testing is essential but time-consuming. Automated testing tools can help catch regressions and test across many configurations quickly. Think of it as having a quality control team that never sleeps.</p>
            
            <h3>Visual Regression Testing</h3>
            <p>These tools capture screenshots at various viewport sizes and compare them to baseline images, highlighting visual differences:</p>
            <ul>
                <li><strong>Percy:</strong> Cloud-based visual testing with CI integration</li>
                <li><strong>BackstopJS:</strong> Local visual regression testing</li>
                <li><strong>Puppeteer:</strong> Headless Chrome automation for custom tests</li>
            </ul>
            
            <div class="code-example">
                <h4>Simple Visual Test with Puppeteer</h4>
                <pre><code># Install with pip if using with Python
# pip install pyppeteer

import asyncio
from pyppeteer import launch

async def capture_responsive_screenshots():
    browser = await launch()
    page = await browser.newPage()
    await page.goto('http://localhost:5000')  # Your Flask app
    
    # Test multiple viewport sizes
    viewports = [
        {'width': 375, 'height': 667},  # iPhone
        {'width': 768, 'height': 1024},  # iPad
        {'width': 1440, 'height': 900}   # Desktop
    ]
    
    for i, viewport in enumerate(viewports):
        await page.setViewport(viewport)
        await page.screenshot({
            'path': f'screenshot_{viewport["width"]}x{viewport["height"]}.png'
        })
        print(f"Captured screenshot at {viewport['width']}x{viewport['height']}")
    
    await browser.close()

asyncio.get_event_loop().run_until_complete(capture_responsive_screenshots())</code></pre>
            </div>
            
            <h3>Cross-Browser Testing Services</h3>
            <p>These platforms provide comprehensive testing across browsers, devices, and screen sizes:</p>
            <ul>
                <li><strong>BrowserStack Responsive:</strong> Live and automated testing across real devices</li>
                <li><strong>LambdaTest:</strong> Smart visual regression with detailed reports</li>
                <li><strong>Sauce Labs:</strong> Enterprise-grade testing infrastructure</li>
            </ul>
            
            <p><strong>Integration with Python projects:</strong> Many of these services offer APIs and Python SDKs that can be integrated into your Flask or Django testing workflow, allowing you to automate responsive testing as part of your continuous integration pipeline.</p>
        </section>

        <section class="checklist">
            <h2>Comprehensive Responsive Testing Checklist</h2>
            <p>Use this checklist for thorough responsive testing—it's your quality assurance framework, similar to how airplane pilots use pre-flight checklists to ensure nothing is overlooked:</p>
            
            <h3>Layout Testing</h3>
            <ul>
                <li>✅ Content remains visible without horizontal scrolling (except where intentional)</li>
                <li>✅ Important elements are not cut off or obscured</li>
                <li>✅ Spacing remains appropriate (not too cramped or too sparse)</li>
                <li>✅ Content stacking order makes logical sense on smaller screens</li>
                <li>✅ Aspect ratios of images and videos are maintained</li>
                <li>✅ Tables adapt appropriately (horizontal scroll, reflow, or collapse)</li>
            </ul>
            
            <h3>Navigation Testing</h3>
            <ul>
                <li>✅ Mobile navigation (hamburger menu, etc.) functions correctly</li>
                <li>✅ All navigation links remain accessible</li>
                <li>✅ Dropdowns and submenus are usable on touch devices</li>
                <li>✅ Active/current page indicators remain visible</li>
                <li>✅ Search functionality is accessible across devices</li>
            </ul>
            
            <h3>Touch Interaction</h3>
            <ul>
                <li>✅ Touch targets are sufficiently large (minimum 44×44px)</li>
                <li>✅ Interactive elements have appropriate spacing</li>
                <li>✅ Hover-dependent features have touch equivalents</li>
                <li>✅ Touch gestures (swipe, pinch-zoom) work as expected</li>
                <li>✅ Forms are easily completed using on-screen keyboards</li>
            </ul>
            
            <h3>Content Readability</h3>
            <ul>
                <li>✅ Text is legible without zooming (minimum 16px for body text)</li>
                <li>✅ Sufficient contrast between text and background</li>
                <li>✅ Line lengths are comfortable for reading (45-75 characters)</li>
                <li>✅ Critical information isn't hidden behind truncation or "read more" links</li>
                <li>✅ Images include appropriate alt text for screen readers</li>
            </ul>
            
            <h3>Performance</h3>
            <ul>
                <li>✅ Page load times are reasonable on mobile networks</li>
                <li>✅ Images are appropriately sized for different devices</li>
                <li>✅ Animations and transitions don't cause lag on lower-end devices</li>
                <li>✅ Resources load in order of importance (critical CSS first)</li>
                <li>✅ Memory usage remains manageable on resource-constrained devices</li>
            </ul>
            
            <p><strong>Python web application note:</strong> In Python web frameworks like Django and Flask, server-rendered HTML templates should include viewport-specific optimizations, such as serving different image sizes based on screen dimensions or implementing lazy loading patterns.</p>
        </section>

        <section class="python-integration">
            <h2>Integrating Responsive Testing in Python Web Applications</h2>
            <p>As Python developers building web applications, you have several opportunities to integrate responsive testing into your workflow:</p>
            
            <h3>Server-Side Responsive Techniques</h3>
            <p>Python backends can complement client-side responsive approaches:</p>
            
            <div class="code-example">
                <h4>Flask Route with Device Detection</h4>
                <pre><code>from flask import Flask, render_template, request
from user_agents import parse

app = Flask(__name__)

@app.route('/')
def home():
    # Parse the user agent
    user_agent = parse(request.headers.get('User-Agent'))
    
    # Determine device type
    template_data = {
        'is_mobile': user_agent.is_mobile,
        'is_tablet': user_agent.is_tablet,
        'is_desktop': user_agent.is_pc,
        'browser_family': user_agent.browser.family
    }
    
    # Could serve optimized content based on device type
    if user_agent.is_mobile:
        template_data['image_quality'] = 'low'
    else:
        template_data['image_quality'] = 'high'
    
    return render_template('home.html', **template_data)</code></pre>
            </div>
            
            <div class="code-example">
                <h4>Corresponding Jinja2 Template</h4>
                <pre><code>&lt;!-- home.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Responsive Python App&lt;/title&gt;
    
    &lt;!-- Conditionally load device-specific resources --&gt;
    {% if is_mobile %}
        &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/mobile.css') }}"&gt;
    {% elif is_tablet %}
        &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/tablet.css') }}"&gt;
    {% else %}
        &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/desktop.css') }}"&gt;
    {% endif %}
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Responsive image loading --&gt;
    &lt;div class="hero-image"&gt;
        {% if image_quality == 'low' %}
            &lt;img src="{{ url_for('static', filename='images/hero-small.jpg') }}" alt="Hero Image"&gt;
        {% else %}
            &lt;img src="{{ url_for('static', filename='images/hero-large.jpg') }}" alt="Hero Image"&gt;
        {% endif %}
    &lt;/div&gt;
    
    &lt;!-- Content appropriate to device context --&gt;
    {% if is_mobile %}
        &lt;div class="mobile-nav"&gt;
            &lt;!-- Simplified mobile navigation --&gt;
        &lt;/div&gt;
    {% else %}
        &lt;nav class="main-nav"&gt;
            &lt;!-- Full navigation --&gt;
        &lt;/nav&gt;
    {% endif %}
&lt;/body&gt;
&lt;/html&gt;</code></pre>
            </div>
            
            <h3>Automated Testing in Django</h3>
            <p>Django's testing framework can be extended for responsive testing:</p>
            
            <div class="code-example">
                <h4>Django Test Case with Selenium</h4>
                <pre><code>from django.test import LiveServerTestCase
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

class ResponsiveTestCase(LiveServerTestCase):
    def setUp(self):
        chrome_options = Options()
        chrome_options.add_argument("--headless")
        self.browser = webdriver.Chrome(options=chrome_options)
        
    def tearDown(self):
        self.browser.quit()
        
    def test_responsive_nav_menu(self):
        # Test desktop navigation
        self.browser.set_window_size(1366, 768)
        self.browser.get(self.live_server_url)
        desktop_nav = self.browser.find_element_by_id('main-nav')
        self.assertTrue(desktop_nav.is_displayed())
        
        # Test mobile navigation (hamburger menu should be visible)
        self.browser.set_window_size(375, 667)
        self.browser.get(self.live_server_url)
        mobile_nav = self.browser.find_element_by_id('mobile-nav-toggle')
        self.assertTrue(mobile_nav.is_displayed())
        
        # Test hamburger menu functionality
        mobile_nav.click()
        mobile_menu = self.browser.find_element_by_id('mobile-menu')
        self.assertTrue(mobile_menu.is_displayed())</code></pre>
            </div>
            
            <p><strong>Real-world application:</strong> In a Python-powered e-commerce site, you might use these techniques to:</p>
            <ul>
                <li>Serve appropriately sized product images to reduce bandwidth on mobile devices</li>
                <li>Simplify complex dashboard visualizations for smaller screens</li>
                <li>Adjust form validation to be more touch-friendly on mobile</li>
                <li>Test shopping cart workflows across different device contexts</li>
            </ul>
        </section>

        <section class="media-queries">
            <h2>Testing Media Query Debugging Techniques</h2>
            <p>Media queries are the backbone of responsive design, but they can be challenging to debug. Here are specialized techniques for testing them:</p>
            
            <h3>Media Query Debugger Bookmarklet</h3>
            <p>Create a bookmarklet that highlights active media queries:</p>
            
            <div class="code-example">
                <pre><code>// Create a bookmark with this code as the URL
javascript:(function(){
    const mediaQueries = [];
    const styleSheets = document.styleSheets;
    
    for (let i = 0; i < styleSheets.length; i++) {
        try {
            const cssRules = styleSheets[i].cssRules || styleSheets[i].rules;
            for (let j = 0; j < cssRules.length; j++) {
                if (cssRules[j].type === CSSRule.MEDIA_RULE) {
                    const media = cssRules[j].media.mediaText;
                    if (window.matchMedia(media).matches) {
                        mediaQueries.push(media);
                    }
                }
            }
        } catch (e) {
            console.log('Cannot read rules from stylesheet', e);
        }
    }
    
    // Display active media queries
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.right = '0';
    overlay.style.backgroundColor = 'rgba(0,0,0,0.8)';
    overlay.style.color = 'white';
    overlay.style.padding = '20px';
    overlay.style.zIndex = '9999';
    overlay.style.maxHeight = '50vh';
    overlay.style.overflow = 'auto';
    
    overlay.innerHTML = `
        <h2>Active Media Queries (${mediaQueries.length})</h2>
        <ul>${mediaQueries.map(q => `<li>${q}</li>`).join('')}</ul>
        <button id="close-mq-debug" style="padding: 5px 10px;">Close</button>
    `;
    
    document.body.appendChild(overlay);
    document.getElementById('close-mq-debug').addEventListener('click', function() {
        document.body.removeChild(overlay);
    });
})();</code></pre>
            </div>
            
            <h3>Testing Print Media Queries</h3>
            <p>Don't forget to test print styles—they're an often-overlooked aspect of responsive design:</p>
            
            <div class="code-example">
                <h4>CSS Print Styles</h4>
                <pre><code>/* Print-specific styles */
@media print {
    /* Hide navigation, footers, ads */
    nav, footer, .ads, .no-print {
        display: none !important;
    }
    
    /* Ensure dark text on white background for readability */
    body {
        color: #000;
        background: #fff;
    }
    
    /* Ensure links show their URLs */
    a[href]:after {
        content: " (" attr(href) ")";
    }
    
    /* Force page breaks before important sections */
    h1, h2 {
        page-break-before: always;
    }
    
    /* Prevent breaks within elements */
    pre, blockquote, figure {
        page-break-inside: avoid;
    }
}

/* Testing print styles in Chrome: */
/* 1. Open Developer Tools */
/* 2. Click the "..." menu → More tools → Rendering */
/* 3. In the Rendering panel, set "Emulate CSS media type" to "print" */</code></pre>
            </div>
            
            <p><strong>Python application tip:</strong> For data-heavy Flask or Django applications, print media queries are particularly important for reports, dashboards, and data tables that users might want to print for offline reference.</p>
        </section>

        <section class="accessibility">
            <h2>Responsive Design and Accessibility Testing</h2>
            <p>Responsive design and accessibility are deeply interconnected. Think of them as two sides of the same coin—both ensure your content is available to everyone regardless of how they access it.</p>
            
            <h3>Combined Testing Approach</h3>
            <p>When testing responsive designs, simultaneously check for these accessibility concerns:</p>
            
            <ul>
                <li><strong>Keyboard Navigation:</strong> Test keyboard tab order at different viewport sizes</li>
                <li><strong>Touch Target Size:</strong> Ensure interactive elements remain usable for people with motor impairments (44×44px minimum)</li>
                <li><strong>Text Resizing:</strong> Test with browser text zoom (up to 200%) without breaking layouts</li>
                <li><strong>Screen Reader Announcements:</strong> Verify that responsive layout changes don't affect content order in ways that confuse screen readers</li>
                <li><strong>Contrast at Different Sizes:</strong> Check that text maintains sufficient contrast when resized</li>
            </ul>
            
            <div class="code-example">
                <h4>Integrating with Python and WCAG Validation</h4>
                <pre><code>import requests
from bs4 import BeautifulSoup

def check_accessibility(url):
    """Basic accessibility check for a webpage"""
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    
    issues = []
    
    # Check for images without alt text
    images = soup.find_all('img')
    for img in images:
        if not img.get('alt'):
            issues.append(f"Image missing alt text: {img}")
    
    # Check for form inputs without labels
    inputs = soup.find_all('input')
    for input_field in inputs:
        input_id = input_field.get('id')
        if input_id:
            label = soup.find('label', attrs={'for': input_id})
            if not label:
                issues.append(f"Input missing associated label: {input_field}")
    
    # Check for heading hierarchy
    headings = []
    for i in range(1, 7):
        headings.extend([(i, h) for h in soup.find_all(f'h{i}')])
    
    headings.sort(key=lambda x: x[1].sourcepos if hasattr(x[1], 'sourcepos') else 0)
    
    prev_level = 0
    for level, heading in headings:
        if level > prev_level + 1:
            issues.append(f"Heading level skipped: {heading}")
        prev_level = level
    
    return issues</code></pre>
            </div>
            
            <p><strong>Real-world testing combination:</strong> When testing a Python web application's responsive design, use a combination of:</p>
            <ul>
                <li>Browser DevTools for layout testing</li>
                <li>WAVE or axe browser extensions for accessibility audits</li>
                <li>Automated testing for both responsive breakpoints and WCAG compliance</li>
                <li>Manual screen reader testing at different viewport sizes</li>
            </ul>
        </section>

        <section class="performance-testing">
            <h2>Responsive Performance Testing</h2>
            <p>Performance is a critical aspect of responsive design. Mobile users often have slower connections and less powerful devices, yet many responsive tests ignore performance aspects.</p>
            
            <h3>Key Performance Metrics to Test</h3>
            <ul>
                <li><strong>Load Time:</strong> Test initial page load across different simulated connection speeds</li>
                <li><strong>Time to Interactive:</strong> Measure how quickly users can interact with your page</li>
                <li><strong>Layout Shifts:</strong> Identify elements that move as the page loads (Cumulative Layout Shift)</li>
                <li><strong>Resource Loading:</strong> Check if appropriate images are loaded for different viewports</li>
                <li><strong>Memory Usage:</strong> Monitor JavaScript memory consumption on resource-constrained devices</li>
            </ul>
            
            <div class="code-example">
                <h4>Using Lighthouse in Chrome DevTools</h4>
                <pre><code>/* To analyze performance across device types: */
/* 1. Open Chrome DevTools */
/* 2. Select the "Lighthouse" tab */
/* 3. Select device type (Mobile or Desktop) */
/* 4. Check "Performance" category */
/* 5. Click "Generate report" */

/* Key metrics to review: */
/* - First Contentful Paint */
/* - Speed Index */
/* - Time to Interactive */
/* - Total Blocking Time */
/* - Cumulative Layout Shift */</code></pre>
            </div>
            
            <p><strong>Python developer insight:</strong> For Flask and Django applications, server-side rendering time can vary significantly by device class. Use timing middleware to measure backend performance across different user agent types:</p>
            
            <div class="code-example">
                <h4>Flask Performance Monitoring Example</h4>
                <pre><code>from flask import Flask, request, g
import time
import logging
from user_agents import parse

app = Flask(__name__)

@app.before_request
def start_timer():
    g.start = time.time()
    ua_string = request.headers.get('User-Agent', '')
    g.user_agent = parse(ua_string)

@app.after_request
def log_request(response):
    if hasattr(g, 'start'):
        total_time = time.time() - g.start
        device_type = 'mobile' if g.user_agent.is_mobile else 'tablet' if g.user_agent.is_tablet else 'desktop'
        
        logging.info(
            'Path: %s | Device: %s | Time: %.2fms',
            request.path,
            device_type,
            total_time * 1000
        )
    return response</code></pre>
            </div>
        </section>

        <section class="exercises">
            <h2>Practice Exercises</h2>
            <p>Apply these responsive testing techniques to your projects with these hands-on exercises:</p>
            
            <h3>Exercise 1: Systematic Breakpoint Audit</h3>
            <ol>
                <li>Open an existing project (or the sample Flask application provided in class)</li>
                <li>Create a spreadsheet with columns for each key breakpoint (320px, 768px, 1024px, etc.)</li>
                <li>Add rows for different components (navigation, forms, cards, tables, etc.)</li>
                <li>Test each component at each breakpoint</li>
                <li>Document issues found and solutions implemented</li>
            </ol>
            
            <h3>Exercise 2: Device Lab Testing</h3>
            <ol>
                <li>Form groups of 3-4 students</li>
                <li>Have each group member bring different devices</li>
                <li>Create a testing rotation where each person's project is tested on all devices</li>
                <li>Document device-specific issues that weren't caught in emulation</li>
                <li>Compare notes on common problems across different projects</li>
            </ol>
            
            <h3>Exercise 3: Responsive Testing Automation</h3>
            <ol>
                <li>Choose a Python web application (Flask or Django)</li>
                <li>Implement the screenshot capture script from the automated testing section</li>
                <li>Expand it to test at least 5 different viewport sizes</li>
                <li>Add basic image comparison to detect layout changes</li>
                <li>Integrate it into your development workflow</li>
            </ol>
            
            <p><strong>Bonus Challenge:</strong> Create a responsive testing dashboard for your Python application that automatically captures and compares screenshots at different viewport sizes whenever you push code to your repository.</p>
        </section>

        <section class="further-resources">
            <h2>Further Resources</h2>
            <p>To deepen your understanding of responsive design testing, explore these resources:</p>
            
            <ul>
                <li><a href="https://developers.google.com/web/tools/chrome-devtools/device-mode" target="_blank">Chrome DevTools: Device Mode</a></li>
                <li><a href="https://developer.mozilla.org/en-US/docs/Tools/Responsive_Design_Mode" target="_blank">Firefox: Responsive Design Mode</a></li>
                <li><a href="https://www.browserstack.com/responsive" target="_blank">BrowserStack Responsive</a></li>
                <li><a href="https://web.dev/responsive-web-design-basics/" target="_blank">Web.dev: Responsive Design Basics</a></li>
                <li><a href="https://github.com/GoogleChrome/lighthouse" target="_blank">Lighthouse</a></li>
                <li><a href="https://testmysite.withgoogle.com/" target="_blank">Test My Site (Google)</a></li>
            </ul>
        </section>

        <section class="conclusion">
            <h2>Conclusion</h2>
            <p>Effective responsive design testing is more than checking layouts at different screen sizes—it's a comprehensive approach to ensuring your web application works well for all users, regardless of how they access it.</p>
            
            <p>As Python developers building web applications, your testing approach should integrate both frontend responsiveness and backend performance considerations. The combination of client-side techniques (CSS media queries, JavaScript breakpoint detection) with server-side optimizations (user agent detection, adaptive content delivery) creates truly responsive experiences.</p>
            
            <p>Remember that responsive testing is not a one-time activity but an ongoing process throughout development. By incorporating the systematic testing approaches outlined in this session, you'll build more resilient, accessible, and user-friendly Python web applications that truly work everywhere.</p>
            
            <div class="next-steps">
                <p><strong>Next Session:</strong> Tomorrow morning, we'll explore Document Object Model (DOM) introduction and continuing our journey into frontend development for Python developers.</p>
            </div>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
