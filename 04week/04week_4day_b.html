<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selecting DOM Elements</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Selecting DOM Elements</h1>
        <h2>Week 4: Web Fundamentals - Thursday Morning Session</h2>
    </header>

    <main>
        <section class="lecture_intro">
            <h3>The Art of Finding Elements in the DOM</h3>
            <p>Welcome to our deep dive into selecting DOM elements! Now that we understand what the Document Object Model is, we need to master how to find and select specific elements within it. This is a fundamental skill that serves as the foundation for all DOM manipulation.</p>
            
            <p>This lecture belongs to Week 4: Web Fundamentals and is part of our Python Full Stack Developer course. You'll find this content in the folder structure: <code>/04week/04week_4day_b.html</code></p>
        </section>

        <section class="why_select_elements">
            <h3>Why We Need to Select Elements</h3>
            <p>Before we jump into the how, let's understand the why. Selecting DOM elements is the crucial first step in any dynamic interaction with a webpage. Think of it as the "find" before the "change" - we need to locate elements before we can:</p>
            
            <ul>
                <li>Modify their content or appearance</li>
                <li>Respond to user interactions with them</li>
                <li>Create, move, or remove them from the page</li>
                <li>Read their current state or value</li>
                <li>Trigger animations or transitions</li>
            </ul>
            
            <p><strong>Treasure Hunt Metaphor:</strong> Selecting DOM elements is like a treasure hunt. The DOM is your map of an island, and JavaScript gives you different tools (selectors) to find specific treasures (elements). Some tools help you find a unique treasure by its special mark (ID), others help you find all treasures of a certain type (tag name), and some let you find treasures based on complex criteria (CSS selectors).</p>
        </section>

        <section class="selector_methods">
            <h3>Core DOM Selection Methods</h3>
            <p>JavaScript provides several built-in methods to select elements from the DOM. Each has its own strengths and use cases:</p>
            
            <div class="selection_method">
                <h4>getElementById</h4>
                <p>The most straightforward method when you need to find a single element with a unique identifier.</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;div id="unique-element"&gt;This element has a unique ID&lt;/div&gt;

// JavaScript:
const element = document.getElementById('unique-element');

// Returns a direct reference to the element or null if not found</code></pre>
                </div>
                
                <p><strong>Real-world analogy:</strong> This is like finding a person by their unique social security number or passport ID - there can only be one match.</p>
                
                <p><strong>Best used when:</strong> You need to find a specific, unique element that has an ID attribute. This is the fastest selector because browsers can optimize lookups by ID.</p>
            </div>
            
            <div class="selection_method">
                <h4>getElementsByClassName</h4>
                <p>Used when you need to find all elements that share a specific class name.</p>
                
                <div class="code_example">
                    <pre><code>// HTML: 
// &lt;div class="user-card"&gt;User 1&lt;/div&gt;
// &lt;div class="user-card active"&gt;User 2&lt;/div&gt;
// &lt;div class="user-card"&gt;User 3&lt;/div&gt;

// JavaScript:
const userCards = document.getElementsByClassName('user-card');

// Returns a live HTMLCollection of all matching elements
console.log(userCards.length); // 3
userCards[0].textContent = 'Updated User 1';</code></pre>
                </div>
                
                <p><strong>Real-world analogy:</strong> This is like calling all students wearing the school uniform in a classroom - multiple people will respond.</p>
                
                <p><strong>Best used when:</strong> You need to work with multiple elements that share characteristics (styling, behavior, purpose).</p>
                
                <p><strong>Important note:</strong> Returns a live HTMLCollection, meaning it automatically updates if elements are added or removed from the DOM that match the class.</p>
            </div>
            
            <div class="selection_method">
                <h4>getElementsByTagName</h4>
                <p>Selects all elements of a specified HTML tag type.</p>
                
                <div class="code_example">
                    <pre><code>// HTML: Various paragraph elements throughout the page

// JavaScript:
const paragraphs = document.getElementsByTagName('p');

// Returns a live HTMLCollection of all paragraph elements
console.log(`This page has ${paragraphs.length} paragraphs`);

// Iterate through all paragraphs
for (let i = 0; i < paragraphs.length; i++) {
    paragraphs[i].style.color = 'blue';
}</code></pre>
                </div>
                
                <p><strong>Real-world analogy:</strong> This is like gathering all the books in a library, regardless of their content or which shelf they're on.</p>
                
                <p><strong>Best used when:</strong> You need to work with all elements of a specific type, such as all images, all paragraphs, all list items, etc.</p>
            </div>
            
            <div class="selection_method">
                <h4>querySelector</h4>
                <p>A powerful, flexible method that uses CSS selector syntax to find the first matching element.</p>
                
                <div class="code_example">
                    <pre><code>// HTML: Various elements with different attributes

// JavaScript:
// Select the first paragraph inside a div with class 'content'
const firstContentParagraph = document.querySelector('div.content p');

// Select an element with a specific attribute
const emailInput = document.querySelector('input[type="email"]');

// Select an element using a more complex CSS selector
const activeMenuItem = document.querySelector('nav li.active a');

// Returns the first matching element or null if none found</code></pre>
                </div>
                
                <p><strong>Real-world analogy:</strong> This is like a sophisticated search engine that can find exactly what you're looking for based on multiple criteria, but only returns the first result.</p>
                
                <p><strong>Best used when:</strong> You need to find a specific element using complex criteria, and you only need the first match.</p>
            </div>
            
            <div class="selection_method">
                <h4>querySelectorAll</h4>
                <p>Similar to querySelector, but returns all matching elements rather than just the first one.</p>
                
                <div class="code_example">
                    <pre><code>// HTML: Various elements with different attributes

// JavaScript:
// Select all paragraphs with a specific class
const highlightedParagraphs = document.querySelectorAll('p.highlighted');

// Select all links inside the navigation
const navLinks = document.querySelectorAll('nav a');

// Select multiple elements using comma-separated selectors
const headings = document.querySelectorAll('h1, h2, h3');

// Returns a static NodeList of all matching elements
console.log(headings.length);

// Loop through results using forEach
navLinks.forEach(link => {
    link.target = '_blank'; // Make all nav links open in new tab
});</code></pre>
                </div>
                
                <p><strong>Real-world analogy:</strong> This is like a search engine that returns all results matching your criteria, not just the top one.</p>
                
                <p><strong>Best used when:</strong> You need to find multiple elements using complex criteria.</p>
                
                <p><strong>Important note:</strong> Returns a static NodeList, which does not automatically update when the DOM changes (unlike HTMLCollection).</p>
            </div>
        </section>

        <section class="selection_comparisons">
            <h3>Comparing Selection Methods</h3>
            
            <table class="comparison_table">
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Returns</th>
                        <th>Live?</th>
                        <th>Performance</th>
                        <th>Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>getElementById</td>
                        <td>Single Element or null</td>
                        <td>N/A</td>
                        <td>Fastest</td>
                        <td>When you need one specific element with a unique ID</td>
                    </tr>
                    <tr>
                        <td>getElementsByClassName</td>
                        <td>HTMLCollection</td>
                        <td>Yes</td>
                        <td>Fast</td>
                        <td>When you need all elements with a specific class</td>
                    </tr>
                    <tr>
                        <td>getElementsByTagName</td>
                        <td>HTMLCollection</td>
                        <td>Yes</td>
                        <td>Fast</td>
                        <td>When you need all elements of a specific tag</td>
                    </tr>
                    <tr>
                        <td>querySelector</td>
                        <td>Single Element or null</td>
                        <td>N/A</td>
                        <td>Slower</td>
                        <td>When you need the first element matching complex criteria</td>
                    </tr>
                    <tr>
                        <td>querySelectorAll</td>
                        <td>NodeList</td>
                        <td>No</td>
                        <td>Slowest</td>
                        <td>When you need all elements matching complex criteria</td>
                    </tr>
                </tbody>
            </table>
            
            <p><strong>Database Query Metaphor:</strong> If the DOM is a database of elements, these selection methods are like different types of database queries. Some are highly optimized for specific tasks (like getElementById for primary key lookups), while others allow complex queries with multiple conditions (like querySelectorAll for full table scans with multiple WHERE clauses).</p>
        </section>

        <section class="css_selectors">
            <h3>CSS Selector Syntax for querySelector/querySelectorAll</h3>
            <p>The real power of querySelector and querySelectorAll comes from their ability to use the full CSS selector syntax. Let's explore some of the most useful selectors:</p>
            
            <div class="selector_category">
                <h4>Basic Selectors</h4>
                <ul>
                    <li><code>#id</code> - Selects element with specific ID</li>
                    <li><code>.class</code> - Selects elements with specific class</li>
                    <li><code>tag</code> - Selects elements by tag name</li>
                    <li><code>*</code> - Selects all elements</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>document.querySelector('#main-header');  // Element with ID main-header
document.querySelectorAll('.item');     // All elements with class item
document.querySelector('button');       // First button element
document.querySelectorAll('*');         // All elements in the document</code></pre>
                </div>
            </div>
            
            <div class="selector_category">
                <h4>Combinators</h4>
                <ul>
                    <li><code>ancestor descendant</code> - Descendant selector (any level)</li>
                    <li><code>parent > child</code> - Direct child selector</li>
                    <li><code>prev + next</code> - Adjacent sibling selector</li>
                    <li><code>prev ~ siblings</code> - General sibling selector</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>document.querySelectorAll('nav a');        // All links inside nav elements
document.querySelectorAll('ul > li');      // Only direct li children of ul
document.querySelector('h2 + p');          // First paragraph after an h2
document.querySelectorAll('h2 ~ p');       // All paragraphs that are siblings of h2</code></pre>
                </div>
            </div>
            
            <div class="selector_category">
                <h4>Attribute Selectors</h4>
                <ul>
                    <li><code>[attribute]</code> - Elements with the attribute</li>
                    <li><code>[attribute="value"]</code> - Exact attribute value match</li>
                    <li><code>[attribute^="value"]</code> - Attribute value starts with</li>
                    <li><code>[attribute$="value"]</code> - Attribute value ends with</li>
                    <li><code>[attribute*="value"]</code> - Attribute value contains</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>document.querySelectorAll('[data-role]');              // Elements with data-role attribute
document.querySelectorAll('[type="checkbox"]');        // Elements with type="checkbox"
document.querySelectorAll('[href^="https"]');         // Links that start with https
document.querySelectorAll('[src$=".jpg"]');           // Images with jpg extension
document.querySelectorAll('[title*="user"]');         // Elements with "user" in the title</code></pre>
                </div>
            </div>
            
            <div class="selector_category">
                <h4>Pseudo-classes</h4>
                <ul>
                    <li><code>:first-child</code> - First child element</li>
                    <li><code>:last-child</code> - Last child element</li>
                    <li><code>:nth-child(n)</code> - Nth child element</li>
                    <li><code>:not(selector)</code> - Elements that don't match the selector</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>document.querySelector('li:first-child');           // First li in its parent
document.querySelector('li:last-child');            // Last li in its parent
document.querySelectorAll('tr:nth-child(even)');    // Even-numbered table rows
document.querySelectorAll('input:not([type="hidden"])'); // All visible inputs</code></pre>
                </div>
            </div>
            
            <div class="selector_category">
                <h4>Combining Multiple Selectors</h4>
                <p>You can combine selectors for extremely precise targeting:</p>
                
                <div class="code_example">
                    <pre><code>// First paragraph with class "intro" inside a section with class "content"
document.querySelector('section.content p.intro');

// All checked checkboxes with a specific name
document.querySelectorAll('input[type="checkbox"][name="interests"]:checked');

// All links in the main navigation that open in a new tab
document.querySelectorAll('nav.main-nav a[target="_blank"]');

// All h2 headings with a data attribute, but not with a specific class
document.querySelectorAll('h2[data-section]:not(.hidden)');</code></pre>
                </div>
            </div>
        </section>

        <section class="collection_handling">
            <h3>Working with Element Collections</h3>
            <p>Once you've selected multiple elements, you need to know how to work with the collections that are returned:</p>
            
            <div class="collection_type">
                <h4>HTMLCollection (from getElementsByClassName and getElementsByTagName)</h4>
                <ul>
                    <li>Array-like object, but not an actual array</li>
                    <li>Accessible by index: <code>collection[0]</code></li>
                    <li>Has a <code>length</code> property</li>
                    <li>Live collection - updates automatically when DOM changes</li>
                    <li>Cannot use array methods like <code>forEach</code> directly</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>const buttons = document.getElementsByClassName('btn');

// Looping through HTMLCollection using for loop
for (let i = 0; i < buttons.length; i++) {
    buttons[i].disabled = false;
}

// Converting to an array (if you need array methods)
const buttonsArray = Array.from(buttons);
buttonsArray.forEach(button => {
    button.addEventListener('click', handleClick);
});</code></pre>
                </div>
            </div>
            
            <div class="collection_type">
                <h4>NodeList (from querySelectorAll)</h4>
                <ul>
                    <li>Array-like object, similar to HTMLCollection</li>
                    <li>Accessible by index: <code>nodeList[0]</code></li>
                    <li>Has a <code>length</code> property</li>
                    <li>Static collection - does not update when DOM changes</li>
                    <li>Supports <code>forEach</code> method (modern browsers)</li>
                    <li>Does not support other array methods like <code>map</code> or <code>filter</code> directly</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>const links = document.querySelectorAll('a.external');

// Using forEach directly (modern browsers)
links.forEach(link => {
    link.setAttribute('rel', 'noopener noreferrer');
});

// For older browsers or if you need other array methods
const linksArray = Array.from(links);
const httpLinks = linksArray.filter(link => 
    link.href.startsWith('http:')
);</code></pre>
                </div>
            </div>
            
            <p><strong>Library Metaphor:</strong> If the DOM is a library, HTMLCollection is like a dynamic shelf that automatically updates when books are added or removed from the library that match your criteria. NodeList is like a static snapshot of books that matched your criteria at a specific moment in time - it won't change even if the actual library contents change.</p>
        </section>

        <section class="scoping_selectors">
            <h3>Scoping Your Selectors</h3>
            <p>All the selection methods we've seen can be called on the <code>document</code> object, which selects from the entire page. However, you can narrow the search scope by selecting from a specific parent element:</p>
            
            <div class="code_example">
                <pre><code>// Find all paragraphs in the entire document
const allParagraphs = document.querySelectorAll('p');

// Find a specific section first
const aboutSection = document.getElementById('about');

// Then find only paragraphs within that section
const aboutParagraphs = aboutSection.querySelectorAll('p');

// This is often more efficient and easier to manage
console.log(`Document has ${allParagraphs.length} paragraphs total`);
console.log(`About section has ${aboutParagraphs.length} paragraphs`);</code></pre>
            </div>
            
            <p><strong>City Map Metaphor:</strong> Think of the DOM as a city map. Searching from <code>document</code> is like looking for all coffee shops in the entire city. Scoping your selector is like first identifying a specific neighborhood (parent element), then only looking for coffee shops within that neighborhood - much more efficient!</p>
            
            <h4>Benefits of Scoping Selectors:</h4>
            <ul>
                <li><strong>Performance:</strong> Searching a smaller portion of the DOM is faster</li>
                <li><strong>Clarity:</strong> Makes your intent clearer - "find elements within this container"</li>
                <li><strong>Reliability:</strong> Less likely to select unintended elements with the same selector elsewhere on the page</li>
                <li><strong>Component-based thinking:</strong> Aligns with modern component-based development practices</li>
            </ul>
        </section>

        <section class="checking_elements">
            <h3>Checking If Elements Exist</h3>
            <p>When selecting elements, it's important to verify that the element was actually found before trying to work with it:</p>
            
            <div class="code_example">
                <pre><code>// Single element methods return null if no match is found
const mainNav = document.getElementById('main-navigation');

if (mainNav) {
    // Safe to work with the element
    mainNav.classList.add('active');
} else {
    // Handle the case where the element doesn't exist
    console.warn('Navigation element not found');
}

// Collection methods return empty collections, not null
const slideImages = document.querySelectorAll('.slider img');

if (slideImages.length > 0) {
    // We have images to work with
    setupSlideshow(slideImages);
} else {
    // No images found
    console.warn('No slider images found');
}</code></pre>
            </div>
            
            <p><strong>Defensive Programming Metaphor:</strong> Checking if elements exist before working with them is like looking both ways before crossing a street - a simple safety check that prevents accidents. In programming, these accidents are often errors like "Cannot read property 'classList' of null" that crash your JavaScript.</p>
        </section>

        <section class="practical_examples">
            <h3>Real-World Examples</h3>
            
            <div class="example">
                <h4>Example 1: Form Validation</h4>
                <div class="code_example">
                    <pre><code>// First, select the form and relevant elements
const registrationForm = document.getElementById('registration-form');
const emailInput = document.querySelector('#registration-form input[type="email"]');
const passwordInput = document.querySelector('#registration-form input[type="password"]');
const submitButton = document.querySelector('#registration-form button[type="submit"]');
const errorMessages = document.querySelectorAll('#registration-form .error-message');

// Add event listener to the form
registrationForm.addEventListener('submit', function(event) {
    let hasErrors = false;
    
    // Clear previous error messages
    errorMessages.forEach(msg => {
        msg.textContent = '';
        msg.style.display = 'none';
    });
    
    // Validate email
    if (!emailInput.value.includes('@')) {
        const emailError = emailInput.nextElementSibling;
        emailError.textContent = 'Please enter a valid email address';
        emailError.style.display = 'block';
        hasErrors = true;
    }
    
    // Validate password length
    if (passwordInput.value.length < 8) {
        const passwordError = passwordInput.nextElementSibling;
        passwordError.textContent = 'Password must be at least 8 characters';
        passwordError.style.display = 'block';
        hasErrors = true;
    }
    
    // Prevent form submission if there are errors
    if (hasErrors) {
        event.preventDefault();
    }
});</code></pre>
                </div>
            </div>
            
            <div class="example">
                <h4>Example 2: Creating a Tab Interface</h4>
                <div class="code_example">
                    <pre><code>// Select tab container
const tabContainer = document.querySelector('.tab-container');

// Select all tab buttons
const tabButtons = tabContainer.querySelectorAll('.tab-button');

// Select all tab content panels
const tabPanels = tabContainer.querySelectorAll('.tab-panel');

// Set up click event for all buttons
tabButtons.forEach((button, index) => {
    button.addEventListener('click', () => {
        // Remove active class from all buttons and panels
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabPanels.forEach(panel => panel.classList.remove('active'));
        
        // Add active class to clicked button and corresponding panel
        button.classList.add('active');
        tabPanels[index].classList.add('active');
    });
});</code></pre>
                </div>
            </div>
            
            <div class="example">
                <h4>Example 3: Dynamic Content Filtering</h4>
                <div class="code_example">
                    <pre><code>// Select filter buttons and all items
const filterButtons = document.querySelectorAll('.filter-btn');
const items = document.querySelectorAll('.portfolio-item');

// Add click events to filter buttons
filterButtons.forEach(button => {
    button.addEventListener('click', () => {
        // Get category from data attribute
        const filterValue = button.getAttribute('data-filter');
        
        // Update active button
        filterButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        
        // Show/hide items based on category
        items.forEach(item => {
            if (filterValue === 'all') {
                item.style.display = 'block';
            } else {
                const itemCategory = item.getAttribute('data-category');
                if (itemCategory === filterValue) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            }
        });
    });
});</code></pre>
                </div>
            </div>
        </section>

        <section class="selection_challenges">
            <h3>Common Challenges and Solutions</h3>
            
            <div class="challenge">
                <h4>Challenge: Selecting Elements That Don't Exist Yet</h4>
                <p>When elements are added dynamically after your JavaScript runs, direct selectors won't find them.</p>
                
                <div class="code_example">
                    <pre><code>// Problem: This won't work for dynamically added buttons
document.querySelectorAll('.action-button').forEach(button => {
    button.addEventListener('click', handleAction);
});

// Solution: Event delegation - attach the event listener to a parent element
document.getElementById('button-container').addEventListener('click', function(event) {
    // Check if clicked element or its parent is an action button
    const button = event.target.closest('.action-button');
    if (button) {
        handleAction(event);
    }
});</code></pre>
                </div>
            </div>
            
            <div class="challenge">
                <h4>Challenge: Working with HTML Collections in Loops</h4>
                <p>When removing elements from a live collection inside a loop, unexpected behavior can occur because the collection updates in real time.</p>
                
                <div class="code_example">
                    <pre><code>// Problem: This can skip elements because the collection updates as items are removed
const items = document.getElementsByClassName('item');
for (let i = 0; i < items.length; i++) {
    if (items[i].textContent === 'Remove me') {
        items[i].parentNode.removeChild(items[i]);
        // The collection is now shorter, and indices have shifted!
    }
}

// Solution: Convert to an array first or iterate backwards
const itemsArray = Array.from(document.getElementsByClassName('item'));
itemsArray.forEach(item => {
    if (item.textContent === 'Remove me') {
        item.parentNode.removeChild(item);
    }
});</code></pre>
                </div>
            </div>
            
            <div class="challenge">
                <h4>Challenge: Selecting Elements Inside iframes</h4>
                <p>The document object only refers to the current document, not embedded documents like iframes.</p>
                
                <div class="code_example">
                    <pre><code>// Problem: This won't find elements in an iframe
document.querySelectorAll('iframe .some-class');

// Solution: Access the iframe's document first
const iframe = document.getElementById('my-iframe');
const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
const elements = iframeDocument.querySelectorAll('.some-class');</code></pre>
                </div>
            </div>
        </section>

        <section class="performance_considerations">
            <h3>Performance Best Practices</h3>
            <p>Selecting elements efficiently can have a significant impact on your application's performance:</p>
            
            <ul>
                <li><strong>Be specific:</strong> Narrow down selectors to improve performance (e.g., <code>#sidebar a</code> instead of just <code>a</code>)</li>
                <li><strong>Cache selectors:</strong> Save references to elements you'll use multiple times</li>
                <li><strong>Use IDs when possible:</strong> <code>getElementById</code> is significantly faster than other selectors</li>
                <li><strong>Avoid unnecessary selectors:</strong> Don't select more elements than you need</li>
                <li><strong>Be careful with universal selectors:</strong> <code>*</code> or <code>a > *</code> can be very slow</li>
                <li><strong>Right-to-left evaluation:</strong> Remember that CSS selectors are evaluated from right to left</li>
            </ul>
            
            <div class="code_example">
                <h4>Good vs. Poor Performance Examples:</h4>
                <pre><code>// Poor performance - very broad selector, checks every element
document.querySelectorAll('div a');

// Better performance - starts with a specific container
document.getElementById('main-nav').querySelectorAll('a');

// Poor performance - selects all elements, then filters
document.querySelectorAll('*').forEach(el => {
    if (el.dataset.important === 'true') {
        // do something
    }
});

// Better performance - uses an attribute selector directly
document.querySelectorAll('[data-important="true"]');

// Good practice - cache selectors used repeatedly
const mainContainer = document.getElementById('main');
const mainNavigation = document.getElementById('nav');

// Now use these cached references instead of selecting again
mainContainer.classList.add('loaded');
const links = mainNavigation.querySelectorAll('a');</code></pre>
            </div>
            
            <p><strong>Power Grid Metaphor:</strong> Think of DOM selection like drawing electricity from a power grid. You want to be as direct and efficient as possible. Using <code>getElementById</code> is like having a dedicated power line straight to your house. Using broad selectors like <code>document.querySelectorAll('div')</code> is like trying to power your house by tapping into every power line in the neighborhood - inefficient and wasteful.</p>
        </section>

        <section class="modern_approaches">
            <h3>Modern Approaches to DOM Selection</h3>
            <p>While the methods we've covered are fundamental, modern web development often includes additional techniques:</p>
            
            <div class="modern_approach">
                <h4>Data Attributes for JavaScript Hooks</h4>
                <p>Using <code>data-*</code> attributes provides a clean separation between CSS styling and JavaScript functionality:</p>
                
                <div class="code_example">
                    <pre><code>&lt;!-- HTML -->
&lt;button data-action="save" data-target="form">Save&lt;/button>
&lt;button data-action="delete" data-target="form">Delete&lt;/button>

// JavaScript
document.querySelectorAll('[data-action]').forEach(button => {
    button.addEventListener('click', () => {
        const action = button.dataset.action;
        const target = button.dataset.target;
        
        console.log(`Performing ${action} on ${target}`);
        // Perform the relevant action
    });
});</code></pre>
                </div>
            </div>
            
            <div class="modern_approach">
                <h4>Element References in JavaScript Frameworks</h4>
                <p>Modern frameworks like React, Vue, and Angular have their own ways of referencing elements:</p>
                
                <div class="code_example">
                    <pre><code>// React example with useRef hook
function MyComponent() {
    const inputRef = useRef(null);
    
    const focusInput = () => {
        inputRef.current.focus();
    };
    
    return (
        &lt;div>
            &lt;input ref={inputRef} type="text" />
            &lt;button onClick={focusInput}>Focus the input&lt;/button>
        &lt;/div>
    );
}

// Vue example with template refs
&lt;template>
    &lt;div>
        &lt;input ref="inputElement" type="text" />
        &lt;button @click="focusInput">Focus the input&lt;/button>
    &lt;/div>
&lt;/template>

&lt;script>
export default {
    methods: {
        focusInput() {
            this.$refs.inputElement.focus();
        }
    }
}
&lt;/script></code></pre>
                </div>
            </div>
        </section>

        <section class="practice_exercises">
            <h3>Practice Exercises</h3>
            
            <div class="exercise">
                <h4>Exercise 1: Element Scavenger Hunt</h4>
                <ol>
                    <li>Create an HTML page with various nested elements, including different IDs, classes, and attributes</li>
                    <li>Write JavaScript to find elements using different selection methods</li>
                    <li>Compare the results of different selection techniques for the same elements</li>
                    <li>Test the performance of different selectors using console.time()</li>
                </ol>
            </div>
            
            <div class="exercise">
                <h4>Exercise 2: Interactive Element Selector</h4>
                <ol>
                    <li>Create a page with a textarea for entering CSS selectors</li>
                    <li>Add a button that, when clicked, executes the selector and highlights all matching elements on the page</li>
                    <li>Display the number of elements found</li>
                    <li>Add a feature to show the HTML of the first matching element</li>
                </ol>
            </div>
            
            <div class="exercise">
                <h4>Exercise 3: DOM Selection Utility Library</h4>
                <ol>
                    <li>Create a small utility library with functions that simplify common DOM selection patterns</li>
                    <li>Include methods for selecting parents, children, siblings, etc.</li>
                    <li>Add methods for filtering selections based on text content or attributes</li>
                    <li>Test your library on a complex HTML page</li>
                </ol>
            </div>
        </section>

        <section class="summary">
            <h3>Lecture Summary</h3>
            <p>Today we've explored the critical skill of selecting elements from the DOM, the foundation for all JavaScript interactions with web pages. We've covered:</p>
            
            <ul>
                <li>Core DOM selection methods: getElementById, getElementsByClassName, getElementsByTagName, querySelector, and querySelectorAll</li>
                <li>The differences between HTMLCollection and NodeList</li>
                <li>Using CSS selector syntax for precise element targeting</li>
                <li>Scoping selectors to specific containers for better performance and organization</li>
                <li>Handling element collections effectively</li>
                <li>Best practices for performance and maintainability</li>
                <li>Common challenges and their solutions</li>
                <li>Modern approaches to element selection</li>
            </ul>
            
            <p>In our next session, we'll build on this foundation to explore how to manipulate DOM elements by changing their content, attributes, and styles.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
        <p>This lecture: <code>/04week/04week_4day_b.html</code></p>
    </footer>
</body>
</html>
