<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manipulating DOM Content</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Manipulating DOM Content</h1>
        <h2>Week 4: Web Fundamentals - Thursday Morning Session</h2>
    </header>

    <main>
        <section class="lecture_intro">
            <h3>The Power of Dynamic Content Manipulation</h3>
            <p>Welcome to our exploration of DOM content manipulation! Now that we know how to select elements from the Document Object Model, it's time to learn how to change them, which is where the true magic of JavaScript and web interactivity begins.</p>
            
            <p>This lecture belongs to Week 4: Web Fundamentals and is part of our Python Full Stack Developer course. You'll find this content in the folder structure: <code>/04week/04week_4day_c.html</code></p>
            
            <p>In this session, we'll cover the various ways to modify DOM elements, from changing text and HTML content to updating attributes, manipulating styles, and creating entirely new elements from scratch.</p>
        </section>

        <section class="why_manipulate">
            <h3>Why Manipulate the DOM?</h3>
            <p>Before diving into the technical aspects, let's understand the purpose and power of DOM manipulation:</p>
            
            <ul>
                <li><strong>Dynamic User Experiences:</strong> Update content without page refreshes</li>
                <li><strong>Interactivity:</strong> Respond to user actions in real-time</li>
                <li><strong>Data Visualization:</strong> Represent changing data visually</li>
                <li><strong>Form Validation:</strong> Provide immediate feedback on user inputs</li>
                <li><strong>Content Personalization:</strong> Tailor the interface to user preferences</li>
                <li><strong>Progressive Enhancement:</strong> Add advanced functionality for capable browsers</li>
            </ul>
            
            <p><strong>Orchestra Conductor Metaphor:</strong> Think of DOM manipulation as conducting an orchestra. The HTML document provides the sheet music (structure), CSS sets the tone and mood (presentation), but JavaScript is the conductor who brings it all to life, directing when instruments play, adjusting volume, and even improvising new sections in response to the audience's reactions.</p>
        </section>

        <section class="text_content">
            <h3>Changing Text Content</h3>
            <p>Let's start with one of the most common operations: modifying the text inside an element.</p>
            
            <div class="manipulation_method">
                <h4>textContent</h4>
                <p>The <code>textContent</code> property sets or returns the text content of an element and all its descendants.</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;p id="greeting"&gt;Hello, World!&lt;/p&gt;

// Getting text content
const greeting = document.getElementById('greeting');
console.log(greeting.textContent); // "Hello, World!"

// Setting text content
greeting.textContent = "Hello, JavaScript!";
// Now the paragraph displays: Hello, JavaScript!</code></pre>
                </div>
                
                <p><strong>Key features of textContent:</strong></p>
                <ul>
                    <li>Gets/sets text content of element and all descendant elements</li>
                    <li>Ignores HTML tags within the content (treats them as text)</li>
                    <li>Returns hidden elements' text (even if display:none)</li>
                    <li>Preserves whitespace, line breaks, etc.</li>
                </ul>
            </div>
            
            <div class="manipulation_method">
                <h4>innerText</h4>
                <p>The <code>innerText</code> property is similar to <code>textContent</code> but with some important differences in how it handles content:</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;div id="content"&gt;&lt;p&gt;Visible text&lt;/p&gt;&lt;p style="display:none"&gt;Hidden text&lt;/p&gt;&lt;/div&gt;

const content = document.getElementById('content');
console.log(content.innerText); // "Visible text" (ignores hidden text)
console.log(content.textContent); // "Visible text Hidden text" (includes hidden text)

// Setting innerText
content.innerText = "New visible content";
// This replaces all inner elements with just text</code></pre>
                </div>
                
                <p><strong>Key features of innerText:</strong></p>
                <ul>
                    <li>Aware of CSS styling (ignores hidden text)</li>
                    <li>Tries to preserve visual formatting</li>
                    <li>May trigger reflow (performance implication)</li>
                    <li>Not part of DOM standard (though widely supported)</li>
                </ul>
            </div>
            
            <div class="comparison">
                <h4>When to use textContent vs. innerText</h4>
                <p><strong>Use textContent when:</strong></p>
                <ul>
                    <li>You need all text regardless of visibility</li>
                    <li>Performance is critical (doesn't trigger reflow)</li>
                    <li>You want to preserve exactly what's in the DOM</li>
                </ul>
                
                <p><strong>Use innerText when:</strong></p>
                <ul>
                    <li>You want to get text as visually rendered</li>
                    <li>You need to respect CSS styling in text retrieval</li>
                    <li>You're building something that mirrors user-visible text</li>
                </ul>
                
                <p><strong>Book Metaphor:</strong> Think of <code>textContent</code> as getting all the text from a manuscript, including editor's notes and crossed-out sections. <code>innerText</code> is like reading only what's printed in the final published book, respecting the formatting and layout decisions.</p>
            </div>
            
            <div class="practical_example">
                <h4>Practical Example: Dynamic Greeting</h4>
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;h2 id="time-greeting"&gt;Good day!&lt;/h2&gt;

function updateGreeting() {
    const greeting = document.getElementById('time-greeting');
    const hour = new Date().getHours();
    
    let greetingText = "Good day!";
    
    if (hour < 12) {
        greetingText = "Good morning!";
    } else if (hour < 18) {
        greetingText = "Good afternoon!";
    } else {
        greetingText = "Good evening!";
    }
    
    greeting.textContent = greetingText;
}

// Call immediately and then update every hour
updateGreeting();
setInterval(updateGreeting, 3600000); // 3600000 ms = 1 hour</code></pre>
                </div>
            </div>
        </section>

        <section class="html_content">
            <h3>Changing HTML Content</h3>
            <p>Sometimes we need to insert structured content with HTML tags, not just plain text.</p>
            
            <div class="manipulation_method">
                <h4>innerHTML</h4>
                <p>The <code>innerHTML</code> property gets or sets the HTML content inside an element.</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;div id="user-profile"&gt;&lt;p&gt;Loading profile...&lt;/p&gt;&lt;/div&gt;

const profile = document.getElementById('user-profile');

// Getting innerHTML
console.log(profile.innerHTML); // "&lt;p&gt;Loading profile...&lt;/p&gt;"

// Setting innerHTML with HTML structure
profile.innerHTML = `
    &lt;h3&gt;User Profile&lt;/h3&gt;
    &lt;img src="avatar.jpg" alt="User Avatar"&gt;
    &lt;p&gt;Name: Alex Johnson&lt;/p&gt;
    &lt;p&gt;Role: Developer&lt;/p&gt;
    &lt;a href="/profile/edit"&gt;Edit Profile&lt;/a&gt;
`;</code></pre>
                </div>
                
                <p><strong>Security Warning:</strong> <code>innerHTML</code> can lead to cross-site scripting (XSS) vulnerabilities if used with untrusted content. Never use it with user input without proper sanitization!</p>
                
                <div class="code_example">
                    <pre><code>// DANGEROUS - don't do this:
const userComment = userInput; // potentially malicious input
commentBox.innerHTML = userComment; // could execute scripts!

// SAFER:
// Option 1: Use textContent instead
commentBox.textContent = userComment;

// Option 2: Use a sanitization library
const sanitizedContent = DOMPurify.sanitize(userComment);
commentBox.innerHTML = sanitizedContent;</code></pre>
                </div>
            </div>
            
            <div class="manipulation_method">
                <h4>insertAdjacentHTML</h4>
                <p>A more precise way to insert HTML at specific positions relative to an element.</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;div id="container"&gt;&lt;h2&gt;Main Title&lt;/h2&gt;&lt;/div&gt;

const container = document.getElementById('container');

// Insert HTML before the container element's opening tag
container.insertAdjacentHTML('beforebegin', '&lt;p&gt;Before the container&lt;/p&gt;');

// Insert HTML after the container element's opening tag
container.insertAdjacentHTML('afterbegin', '&lt;p&gt;At the start of the container&lt;/p&gt;');

// Insert HTML before the container element's closing tag
container.insertAdjacentHTML('beforeend', '&lt;p&gt;At the end of the container&lt;/p&gt;');

// Insert HTML after the container element's closing tag
container.insertAdjacentHTML('afterend', '&lt;p&gt;After the container&lt;/p&gt;');</code></pre>
                </div>
                
                <p>The resulting HTML would look like:</p>
                <pre>
&lt;p&gt;Before the container&lt;/p&gt;
&lt;div id="container"&gt;
    &lt;p&gt;At the start of the container&lt;/p&gt;
    &lt;h2&gt;Main Title&lt;/h2&gt;
    &lt;p&gt;At the end of the container&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;After the container&lt;/p&gt;
                </pre>
                
                <p><strong>House Renovation Metaphor:</strong> If <code>innerHTML</code> is like gutting a room and completely redoing it, <code>insertAdjacentHTML</code> is like carefully adding fixtures in specific locations without disturbing the existing structure. The first approach is faster for complete overhauls, but the second is more precise and doesn't require rebuilding everything.</p>
            </div>
            
            <div class="practical_example">
                <h4>Practical Example: Dynamic Content Loading</h4>
                <div class="code_example">
                    <pre><code>// HTML: 
// &lt;div id="article-container"&gt;
//   &lt;button id="load-more"&gt;Load More Articles&lt;/button&gt;
// &lt;/div&gt;

document.getElementById('load-more').addEventListener('click', function() {
    // In a real app, this would come from an API
    const newArticles = [
        { title: "New Feature Released", content: "Exciting new features available now!" },
        { title: "Industry Trends", content: "See what's happening in tech this month." }
    ];
    
    const container = document.getElementById('article-container');
    
    // Create HTML for each new article
    newArticles.forEach(article => {
        const articleHTML = `
            &lt;article class="news-item"&gt;
                &lt;h3&gt;${article.title}&lt;/h3&gt;
                &lt;p&gt;${article.content}&lt;/p&gt;
                &lt;a href="#"&gt;Read more&lt;/a&gt;
            &lt;/article&gt;
        `;
        
        // Insert before the "Load More" button
        container.insertAdjacentHTML('beforeend', articleHTML);
    });
});</code></pre>
                </div>
            </div>
        </section>

        <section class="attributes">
            <h3>Manipulating Attributes</h3>
            <p>Manipulating element attributes allows us to control an element's behavior, appearance, and relationships.</p>
            
            <div class="attribute_methods">
                <h4>Standard Attribute Methods</h4>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;img id="profile-pic" src="default.jpg" alt="Profile Picture"&gt;

const profilePic = document.getElementById('profile-pic');

// Get attribute value
const currentSrc = profilePic.getAttribute('src');
console.log(currentSrc); // "default.jpg"

// Set attribute value
profilePic.setAttribute('src', 'new-profile.jpg');
profilePic.setAttribute('alt', 'User Profile Picture');

// Check if attribute exists
const hasAlt = profilePic.hasAttribute('alt'); // true

// Remove attribute
profilePic.removeAttribute('data-temp');</code></pre>
                </div>
                
                <p>These methods work with any attribute, including custom data attributes.</p>
            </div>
            
            <div class="attribute_properties">
                <h4>Direct Attribute Properties</h4>
                <p>Many common attributes can be accessed and modified directly as properties of the element object:</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;a id="main-link" href="https://example.com"&gt;Visit Example&lt;/a&gt;

const link = document.getElementById('main-link');

// Get attribute via property
console.log(link.href); // "https://example.com"

// Set attribute via property
link.href = "https://newsite.com";
link.target = "_blank"; // Makes the link open in a new tab
link.title = "Go to New Site";</code></pre>
                </div>
                
                <p><strong>Note:</strong> Using properties sometimes gives different values than getAttribute:</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;a id="home" href="/home"&gt;Home&lt;/a&gt;

const homeLink = document.getElementById('home');

console.log(homeLink.getAttribute('href')); // "/home" (exactly as written in HTML)
console.log(homeLink.href); // "https://example.com/home" (absolute URL)</code></pre>
                </div>
            </div>
            
            <div class="data_attributes">
                <h4>Data Attributes</h4>
                <p>Custom <code>data-*</code> attributes provide a clean way to store extra information in HTML elements:</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;button id="product-btn" data-product-id="1234" data-category="electronics"&gt;Add to Cart&lt;/button&gt;

const productBtn = document.getElementById('product-btn');

// Using getAttribute
const productId = productBtn.getAttribute('data-product-id'); // "1234"

// Using the dataset property (cleaner)
console.log(productBtn.dataset.productId); // "1234"
console.log(productBtn.dataset.category); // "electronics"

// Modifying data attributes
productBtn.dataset.price = "99.99";
productBtn.dataset.inStock = "true";

// Resulting HTML would now include:
// data-product-id="1234" data-category="electronics" data-price="99.99" data-in-stock="true"</code></pre>
                </div>
                
                <p><strong>Note:</strong> When accessing data attributes via the <code>dataset</code> property, the attribute names are converted from kebab-case to camelCase (e.g., <code>data-product-id</code> becomes <code>dataset.productId</code>).</p>
            </div>
            
            <div class="practical_example">
                <h4>Practical Example: Image Gallery</h4>
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div id="current-image-container"&gt;
//   &lt;img id="current-image" src="default.jpg" alt="Gallery Image"&gt;
// &lt;/div&gt;
// &lt;div id="thumbnails"&gt;
//   &lt;img class="thumb" data-full-src="image1.jpg" src="thumb1.jpg" alt="Thumbnail 1"&gt;
//   &lt;img class="thumb" data-full-src="image2.jpg" src="thumb2.jpg" alt="Thumbnail 2"&gt;
//   &lt;img class="thumb" data-full-src="image3.jpg" src="thumb3.jpg" alt="Thumbnail 3"&gt;
// &lt;/div&gt;

const thumbs = document.querySelectorAll('.thumb');
const currentImage = document.getElementById('current-image');

thumbs.forEach(thumb => {
    thumb.addEventListener('click', function() {
        // Update the main image src from the thumbnail's data attribute
        const fullSrc = this.dataset.fullSrc;
        currentImage.src = fullSrc;
        
        // Update the alt text
        currentImage.alt = this.alt;
        
        // Add active class to selected thumbnail and remove from others
        thumbs.forEach(t => t.classList.remove('active'));
        this.classList.add('active');
    });
});</code></pre>
                </div>
            </div>
        </section>

        <section class="css_manipulation">
            <h3>Manipulating CSS and Styles</h3>
            <p>JavaScript gives us several ways to change an element's appearance dynamically.</p>
            
            <div class="style_property">
                <h4>The style Property</h4>
                <p>The most direct way to change inline styles of an element:</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;div id="highlight-box"&gt;Important content&lt;/div&gt;

const box = document.getElementById('highlight-box');

// Set individual style properties
box.style.backgroundColor = 'yellow';
box.style.color = '#333';
box.style.padding = '10px';
box.style.borderRadius = '5px';
box.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';

// Note: CSS property names are written in camelCase in JavaScript
// For example: background-color becomes backgroundColor</code></pre>
                </div>
                
                <p><strong>Important limitations:</strong></p>
                <ul>
                    <li>Only affects inline styles (high specificity)</li>
                    <li>Can't access styles from stylesheets or computed styles</li>
                    <li>Setting individual properties can be verbose</li>
                </ul>
            </div>
            
            <div class="style_csstext">
                <h4>cssText for Multiple Styles</h4>
                <p>Set multiple styles at once with a single property:</p>
                
                <div class="code_example">
                    <pre><code>// Set multiple styles at once
box.style.cssText = 'background-color: yellow; color: #333; padding: 10px; border-radius: 5px;';

// Or append to existing styles
box.style.cssText += 'margin-top: 20px; font-weight: bold;';</code></pre>
                </div>
                
                <p><strong>Note:</strong> Using <code>cssText</code> replaces all existing inline styles unless you append to it.</p>
            </div>
            
            <div class="classlist_manipulation">
                <h4>Working with Classes</h4>
                <p>Often a better approach is to toggle predefined CSS classes instead of setting inline styles:</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;div id="notification" class="info"&gt;This is an information message&lt;/div&gt;

const notification = document.getElementById('notification');

// Add a class
notification.classList.add('visible');

// Remove a class
notification.classList.remove('info');

// Toggle a class (add if not present, remove if present)
notification.classList.toggle('expanded');

// Replace one class with another
notification.classList.replace('info', 'warning');

// Check if element has a class
if (notification.classList.contains('warning')) {
    console.log('This is a warning notification');
}

// Get all classes as a DOMTokenList
console.log(notification.classList);

// Get all classes as a string
console.log(notification.className); // "warning visible"

// Set all classes at once (replaces existing classes)
notification.className = 'error urgent';</code></pre>
                </div>
                
                <p><strong>Benefits of using classes:</strong></p>
                <ul>
                    <li>Keeps presentation logic in CSS where it belongs</li>
                    <li>Easier to maintain and update styles</li>
                    <li>Better performance than inline styles for frequent changes</li>
                    <li>Enables animation and transition effects</li>
                </ul>
                
                <p><strong>Wardrobe Metaphor:</strong> Think of CSS classes as complete outfits hanging in your closet. Rather than choosing individual garments every time (inline styles), you can simply switch between pre-coordinated outfits (classes) with a single action. This is faster, more consistent, and easier to update later when fashion trends change.</p>
            </div>
            
            <div class="computed_styles">
                <h4>Reading Computed Styles</h4>
                <p>To read the actual applied styles (from stylesheets, not just inline):</p>
                
                <div class="code_example">
                    <pre><code>// Get computed style object
const computedStyle = window.getComputedStyle(element);

// Read specific properties
const bgColor = computedStyle.backgroundColor;
const fontSize = computedStyle.fontSize;

// For pseudo-elements like ::before and ::after
const beforeContent = window.getComputedStyle(element, '::before').content;</code></pre>
                </div>
                
                <p><strong>Note:</strong> Computed style values are read-only; you can't modify them directly.</p>
            </div>
            
            <div class="practical_example">
                <h4>Practical Example: Theme Switcher</h4>
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;button id="theme-toggle"&gt;Switch to Dark Mode&lt;/button&gt;
// &lt;div id="content" class="light-theme"&gt;... content here ...&lt;/div&gt;

// CSS (would be in a separate file):
// .light-theme { background-color: white; color: #333; }
// .dark-theme { background-color: #222; color: #eee; }

const themeToggle = document.getElementById('theme-toggle');
const content = document.getElementById('content');

themeToggle.addEventListener('click', function() {
    // Toggle between themes
    if (content.classList.contains('light-theme')) {
        content.classList.replace('light-theme', 'dark-theme');
        themeToggle.textContent = 'Switch to Light Mode';
        
        // Save preference in localStorage
        localStorage.setItem('theme', 'dark');
    } else {
        content.classList.replace('dark-theme', 'light-theme');
        themeToggle.textContent = 'Switch to Dark Mode';
        
        // Save preference in localStorage
        localStorage.setItem('theme', 'light');
    }
});

// Apply saved theme preference on page load
document.addEventListener('DOMContentLoaded', function() {
    const savedTheme = localStorage.getItem('theme');
    
    if (savedTheme === 'dark') {
        content.classList.replace('light-theme', 'dark-theme');
        themeToggle.textContent = 'Switch to Light Mode';
    }
});</code></pre>
                </div>
            </div>
        </section>

        <section class="creating_elements">
            <h3>Creating and Adding Elements</h3>
            <p>Beyond modifying existing elements, JavaScript allows us to create entirely new elements and insert them into the DOM.</p>
            
            <div class="createElement">
                <h4>Creating Elements from Scratch</h4>
                
                <div class="code_example">
                    <pre><code>// Create a new element
const newParagraph = document.createElement('p');

// Add content to it
newParagraph.textContent = 'This paragraph was created with JavaScript.';

// Add attributes
newParagraph.id = 'dynamic-paragraph';
newParagraph.className = 'highlight info';
newParagraph.setAttribute('data-created', Date.now());

// Add styles
newParagraph.style.color = '#0066cc';
newParagraph.style.fontSize = '18px';

// Create a nested element
const link = document.createElement('a');
link.href = 'https://example.com';
link.textContent = 'Learn more';

// Add the link to the paragraph
newParagraph.appendChild(link);</code></pre>
                </div>
                
                <p>At this point, we've created a complete element structure in memory, but it's not yet part of the document.</p>
            </div>
            
            <div class="adding_to_dom">
                <h4>Adding Elements to the DOM</h4>
                <p>Several methods for inserting elements into the document:</p>
                
                <div class="code_example">
                    <pre><code>// Get container to add the new element to
const container = document.getElementById('content-container');

// Method 1: Append to the end of container
container.appendChild(newParagraph);

// Method 2: Insert before a specific element
const existingElement = document.getElementById('existing-element');
container.insertBefore(newParagraph, existingElement);

// Method 3: Replace an existing element
container.replaceChild(newParagraph, existingElement);

// Method 4: Modern append/prepend methods
container.append(newParagraph); // Add to the end
container.prepend(newParagraph); // Add to the beginning

// Method 5: Insert adjacent to an element
existingElement.after(newParagraph); // After the element
existingElement.before(newParagraph); // Before the element</code></pre>
                </div>
                
                <p><strong>Note:</strong> The newer methods (append, prepend, before, after) aren't supported in older browsers but are more intuitive.</p>
            </div>
            
            <div class="document_fragments">
                <h4>Using Document Fragments</h4>
                <p>When adding multiple elements, using a DocumentFragment improves performance:</p>
                
                <div class="code_example">
                    <pre><code>// Create a document fragment (a lightweight container)
const fragment = document.createDocumentFragment();

// Create and add multiple elements to the fragment
for (let i = 1; i <= 100; i++) {
    const listItem = document.createElement('li');
    listItem.textContent = `Item ${i}`;
    fragment.appendChild(listItem);
}

// Add the entire fragment to the DOM in one operation
document.getElementById('long-list').appendChild(fragment);

// This causes only one reflow/repaint instead of 100!</code></pre>
                </div>
                
                <p><strong>Construction Metaphor:</strong> Think of DocumentFragment as an off-site construction area where you assemble a complex structure before moving it into place. Rather than building directly on a busy street (the live DOM) and causing traffic disruptions with each small addition, you build the entire structure in a workshop and then move it into place in one efficient operation.</p>
            </div>
            
            <div class="cloning_elements">
                <h4>Cloning Existing Elements</h4>
                <p>Sometimes it's easier to clone an existing element than to create one from scratch:</p>
                
                <div class="code_example">
                    <pre><code>// HTML: &lt;div id="template-card" class="card"&gt;...card content...&lt;/div&gt;

// Get the template element
const templateCard = document.getElementById('template-card');

// Clone it (the true parameter clones all descendants too)
const newCard = templateCard.cloneNode(true);

// Modify the clone
newCard.id = 'card-' + Date.now();
newCard.querySelector('.card-title').textContent = 'New Card';
newCard.querySelector('.card-image').src = 'new-image.jpg';

// Add the clone to the container
document.getElementById('card-container').appendChild(newCard);</code></pre>
                </div>
            </div>
            
            <div class="practical_example">
                <h4>Practical Example: Dynamic Todo List</h4>
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;form id="todo-form"&gt;
//   &lt;input type="text" id="todo-input" placeholder="Add a new task"&gt;
//   &lt;button type="submit"&gt;Add&lt;/button&gt;
// &lt;/form&gt;
// &lt;ul id="todo-list"&gt;&lt;/ul&gt;

document.getElementById('todo-form').addEventListener('submit', function(event) {
    event.preventDefault(); // Prevent form submission
    
    const input = document.getElementById('todo-input');
    const todoText = input.value.trim();
    
    if (todoText === '') return; // Don't add empty tasks
    
    // Create new list item
    const listItem = document.createElement('li');
    listItem.className = 'todo-item';
    
    // Create text span
    const textSpan = document.createElement('span');
    textSpan.textContent = todoText;
    textSpan.className = 'todo-text';
    
    // Create delete button
    const deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';
    deleteButton.className = 'delete-btn';
    deleteButton.addEventListener('click', function() {
        listItem.remove(); // Modern method to remove an element
    });
    
    // Create complete checkbox
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.className = 'complete-checkbox';
    checkbox.addEventListener('change', function() {
        if (this.checked) {
            textSpan.classList.add('completed');
        } else {
            textSpan.classList.remove('completed');
        }
    });
    
    // Assemble the list item
    listItem.appendChild(checkbox);
    listItem.appendChild(textSpan);
    listItem.appendChild(deleteButton);
    
    // Add to the list
    document.getElementById('todo-list').appendChild(listItem);
    
    // Clear the input
    input.value = '';
    input.focus();
});</code></pre>
                </div>
            </div>
        </section>

        <section class="removing_elements">
            <h3>Removing Elements</h3>
            <p>There are several ways to remove elements from the DOM:</p>
            
            <div class="removal_methods">
                <h4>Removal Methods</h4>
                
                <div class="code_example">
                    <pre><code>// Method 1: Using removeChild (traditional)
const parent = document.getElementById('container');
const childToRemove = document.getElementById('old-element');
parent.removeChild(childToRemove);

// Method 2: Using remove (modern)
document.getElementById('old-element').remove();

// Method 3: Replace with nothing
parent.replaceChild(document.createTextNode(''), childToRemove);

// Method 4: Clear all children
while (parent.firstChild) {
    parent.removeChild(parent.firstChild);
}

// Method 5: Clear all children (modern)
parent.innerHTML = '';

// Method 6: Hide instead of remove (if you might need it later)
document.getElementById('old-element').style.display = 'none';</code></pre>
                </div>
                
                <p><strong>Important note:</strong> Using <code>innerHTML = ''</code> is simple but can cause memory leaks if you had event listeners attached to the removed elements. The other methods are safer.</p>
            </div>
            
            <div class="practical_example">
                <h4>Practical Example: Filtered List</h4>
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div id="filter-controls"&gt;
//   &lt;button data-filter="all" class="active"&gt;All&lt;/button&gt;
//   &lt;button data-filter="active"&gt;Active&lt;/button&gt;
//   &lt;button data-filter="completed"&gt;Completed&lt;/button&gt;
// &lt;/div&gt;
// &lt;ul id="task-list"&gt;
//   &lt;li class="task-item" data-status="active"&gt;Task 1&lt;/li&gt;
//   &lt;li class="task-item" data-status="completed"&gt;Task 2&lt;/li&gt;
//   &lt;li class="task-item" data-status="active"&gt;Task 3&lt;/li&gt;
// &lt;/ul&gt;

const filterButtons = document.querySelectorAll('#filter-controls button');
const taskItems = document.querySelectorAll('.task-item');

filterButtons.forEach(button => {
    button.addEventListener('click', function() {
        const filter = this.dataset.filter;
        
        // Update active button
        filterButtons.forEach(btn => btn.classList.remove('active'));
        this.classList.add('active');
        
        // Show/hide tasks based on filter
        taskItems.forEach(item => {
            if (filter === 'all' || item.dataset.status === filter) {
                item.style.display = ''; // Reset to default display
            } else {
                item.style.display = 'none';
            }
        });
    });
});</code></pre>
                </div>
            </div>
        </section>

        <section class="dom_traversal">
            <h3>Traversing the DOM</h3>
            <p>Once you have a reference to an element, you can navigate to related elements without re-querying the DOM:</p>
            
            <div class="traversal_properties">
                <h4>Parent, Child, and Sibling Relationships</h4>
                
                <div class="code_example">
                    <pre><code>// Start with a reference element
const listItem = document.querySelector('li.selected');

// Navigate to parent
const list = listItem.parentElement; // or parentNode

// Navigate to siblings
const previousItem = listItem.previousElementSibling; // or previousSibling
const nextItem = listItem.nextElementSibling; // or nextSibling

// Navigate to children
const firstChild = list.firstElementChild; // or firstChild
const lastChild = list.lastElementChild; // or lastChild
const allChildren = list.children; // HTMLCollection of all direct children

// Navigate to all descendants
const allDescendants = list.querySelectorAll('*');</code></pre>
                </div>
                
                <p><strong>Element vs. Node:</strong> Properties with "Element" in the name skip text nodes and only give element nodes. Without "Element" in the name, they include all node types (elements, text, comments).</p>
                
                <p><strong>Family Tree Metaphor:</strong> DOM traversal is like navigating a family tree. From any person (element), you can find their parent, their children, their siblings, their ancestors, and their descendants. Just as you might ask a family member about their relatives instead of consulting the full family records, traversing from a known element is often more efficient than querying the entire DOM.</p>
            </div>
            
            <div class="practical_example">
                <h4>Practical Example: Accordion Menu</h4>
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div class="accordion"&gt;
//   &lt;div class="accordion-item"&gt;
//     &lt;button class="accordion-header"&gt;Section 1&lt;/button&gt;
//     &lt;div class="accordion-content"&gt;Content for section 1...&lt;/div&gt;
//   &lt;/div&gt;
//   &lt;div class="accordion-item"&gt;
//     &lt;button class="accordion-header"&gt;Section 2&lt;/button&gt;
//     &lt;div class="accordion-content"&gt;Content for section 2...&lt;/div&gt;
//   &lt;/div&gt;
// &lt;/div&gt;

document.querySelectorAll('.accordion-header').forEach(header => {
    header.addEventListener('click', function() {
        // Toggle active class on the header
        this.classList.toggle('active');
        
        // Get the content panel using traversal (it's the next sibling)
        const content = this.nextElementSibling;
        
        // Toggle the content visibility
        if (content.style.maxHeight) {
            content.style.maxHeight = null;
        } else {
            content.style.maxHeight = content.scrollHeight + 'px';
        }
        
        // Optional: Close other sections
        const allItems = this.parentElement.parentElement.children;
        
        for (let item of allItems) {
            // Skip the current item
            if (item === this.parentElement) continue;
            
            // Get header and content of other items
            const otherHeader = item.querySelector('.accordion-header');
            const otherContent = item.querySelector('.accordion-content');
            
            // Close them
            otherHeader.classList.remove('active');
            otherContent.style.maxHeight = null;
        }
    });
});</code></pre>
                </div>
            </div>
        </section>

        <section class="performance_considerations">
            <h3>Performance Considerations</h3>
            <p>DOM manipulation can be expensive in terms of performance. Here are some best practices:</p>
            
            <ul>
                <li><strong>Minimize DOM Operations:</strong> Batch changes when possible</li>
                <li><strong>Use Document Fragments:</strong> For adding multiple elements</li>
                <li><strong>Cache DOM References:</strong> Store elements you use repeatedly in variables</li>
                <li><strong>Avoid Frequent Layout Changes:</strong> Group read operations and write operations</li>
                <li><strong>Use Classes Instead of Many Style Changes:</strong> Toggle predefined classes</li>
                <li><strong>Be Careful with Expensive Properties:</strong> Accessing certain properties (like offsetWidth) can trigger layout recalculations</li>
            </ul>
            
            <div class="code_example">
                <h4>Performance Example: Bad vs. Good Approach</h4>
                <pre><code>// BAD APPROACH (causes many reflows)
for (let i = 0; i < 100; i++) {
    const newItem = document.createElement('div');
    newItem.textContent = `Item ${i}`;
    document.getElementById('container').appendChild(newItem); // Each append causes reflow
    console.log(newItem.offsetHeight); // Forces layout calculation
}

// GOOD APPROACH (single reflow)
const fragment = document.createDocumentFragment();
const container = document.getElementById('container');

for (let i = 0; i < 100; i++) {
    const newItem = document.createElement('div');
    newItem.textContent = `Item ${i}`;
    fragment.appendChild(newItem);
}

container.appendChild(fragment); // Single reflow
</code></pre>
            </div>
            
            <p><strong>Traffic Metaphor:</strong> Think of DOM operations like road construction. Making many small changes during rush hour (while the page is rendering) creates traffic jams (poor performance). It's better to bundle all your changes into a single construction project, complete it quickly, and then let traffic flow normally again.</p>
        </section>

        <section class="practical_applications">
            <h3>Real-World Applications</h3>
            
            <div class="form_validation">
                <h4>Form Validation and Feedback</h4>
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;form id="registration-form"&gt;
//   &lt;div class="form-group"&gt;
//     &lt;label for="email"&gt;Email:&lt;/label&gt;
//     &lt;input type="email" id="email" name="email"&gt;
//     &lt;div class="error-message" id="email-error"&gt;&lt;/div&gt;
//   &lt;/div&gt;
//   &lt;div class="form-group"&gt;
//     &lt;label for="password"&gt;Password:&lt;/label&gt;
//     &lt;input type="password" id="password" name="password"&gt;
//     &lt;div class="error-message" id="password-error"&gt;&lt;/div&gt;
//   &lt;/div&gt;
//   &lt;button type="submit"&gt;Register&lt;/button&gt;
// &lt;/form&gt;

document.getElementById('registration-form').addEventListener('submit', function(e) {
    let isValid = true;
    
    // Clear previous errors
    document.querySelectorAll('.error-message').forEach(el => {
        el.textContent = '';
        el.style.display = 'none';
    });
    
    // Validate email
    const emailInput = document.getElementById('email');
    const emailError = document.getElementById('email-error');
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    
    if (!emailRegex.test(emailInput.value)) {
        emailError.textContent = 'Please enter a valid email address';
        emailError.style.display = 'block';
        emailInput.classList.add('invalid');
        isValid = false;
    } else {
        emailInput.classList.remove('invalid');
        emailInput.classList.add('valid');
    }
    
    // Validate password
    const passwordInput = document.getElementById('password');
    const passwordError = document.getElementById('password-error');
    
    if (passwordInput.value.length < 8) {
        passwordError.textContent = 'Password must be at least 8 characters';
        passwordError.style.display = 'block';
        passwordInput.classList.add('invalid');
        isValid = false;
    } else {
        passwordInput.classList.remove('invalid');
        passwordInput.classList.add('valid');
    }
    
    // Prevent form submission if invalid
    if (!isValid) {
        e.preventDefault();
    }
});</code></pre>
                </div>
            </div>
            
            <div class="dynamic_content_loading">
                <h4>Infinite Scroll Implementation</h4>
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div id="posts-container"&gt;&lt;/div&gt;
// &lt;div id="loading-indicator" style="display: none;"&gt;Loading...&lt;/div&gt;

let page = 1;
let isLoading = false;

// Function to load more content
function loadMorePosts() {
    if (isLoading) return;
    
    isLoading = true;
    document.getElementById('loading-indicator').style.display = 'block';
    
    // In a real app, this would be an API call
    fetch(`/api/posts?page=${page}`)
        .then(response => response.json())
        .then(data => {
            const container = document.getElementById('posts-container');
            const fragment = document.createDocumentFragment();
            
            data.posts.forEach(post => {
                const postElement = document.createElement('article');
                postElement.className = 'post';
                
                postElement.innerHTML = `
                    &lt;h2&gt;${post.title}&lt;/h2&gt;
                    &lt;p class="meta"&gt;By ${post.author} on ${post.date}&lt;/p&gt;
                    &lt;div class="content"&gt;${post.excerpt}&lt;/div&gt;
                    &lt;a href="/post/${post.id}" class="read-more"&gt;Read more&lt;/a&gt;
                `;
                
                fragment.appendChild(postElement);
            });
            
            container.appendChild(fragment);
            page++;
            isLoading = false;
            document.getElementById('loading-indicator').style.display = 'none';
        })
        .catch(error => {
            console.error('Error loading posts:', error);
            isLoading = false;
            document.getElementById('loading-indicator').style.display = 'none';
        });
}

// Check if scrolled near bottom
window.addEventListener('scroll', function() {
    if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500) {
        loadMorePosts();
    }
});

// Initial load
loadMorePosts();</code></pre>
                </div>
            </div>
        </section>

        <section class="modern_alternatives">
            <h3>Modern Alternatives to Direct DOM Manipulation</h3>
            <p>While direct DOM manipulation is a fundamental skill, modern web development often uses higher-level abstractions:</p>
            
            <div class="template_literals">
                <h4>Template Literals and Interpolation</h4>
                <div class="code_example">
                    <pre><code>// Create HTML with template literals
function createUserCard(user) {
    return `
        &lt;div class="user-card" id="user-${user.id}"&gt;
            &lt;img src="${user.avatar}" alt="${user.name}"&gt;
            &lt;h3&gt;${user.name}&lt;/h3&gt;
            &lt;p&gt;${user.email}&lt;/p&gt;
            &lt;button data-user-id="${user.id}" class="contact-btn"&gt;Contact&lt;/button&gt;
        &lt;/div&gt;
    `;
}

// Use it to add content
document.getElementById('users-container').innerHTML = 
    users.map(user => createUserCard(user)).join('');</code></pre>
                </div>
            </div>
            
            <div class="virtual_dom">
                <h4>Virtual DOM Approaches</h4>
                <p>Libraries like React use a virtual DOM to optimize actual DOM manipulations:</p>
                
                <div class="code_example">
                    <pre><code>// React example
function UserCard({ user }) {
    return (
        &lt;div className="user-card" id={`user-${user.id}`}&gt;
            &lt;img src={user.avatar} alt={user.name} /&gt;
            &lt;h3&gt;{user.name}&lt;/h3&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
            &lt;button onClick={() => contactUser(user.id)}&gt;Contact&lt;/button&gt;
        &lt;/div&gt;
    );
}

// React handles the DOM updates efficiently
function UserList({ users }) {
    return (
        &lt;div className="users-container"&gt;
            {users.map(user => &lt;UserCard key={user.id} user={user} /&gt;)}
        &lt;/div&gt;
    );
}</code></pre>
                </div>
                
                <p><strong>Blueprint Metaphor:</strong> If direct DOM manipulation is like manually constructing a building brick by brick, the virtual DOM approach is like working with a detailed blueprint. You make all your changes to the blueprint (virtual DOM), then the framework (like React) figures out the most efficient way to update the actual building (real DOM) to match your new design, minimizing construction disruption.</p>
            </div>
        </section>

        <section class="practice_exercises">
            <h3>Practice Exercises</h3>
            
            <div class="exercise">
                <h4>Exercise 1: Dynamic Content Tabs</h4>
                <p>Create a tabbed interface where clicking on different tabs displays different content panels. This exercise will practice:</p>
                <ul>
                    <li>Modifying content</li>
                    <li>Changing classes</li>
                    <li>Event handling</li>
                    <li>DOM traversal</li>
                </ul>
            </div>
            
            <div class="exercise">
                <h4>Exercise 2: Interactive Form Builder</h4>
                <p>Create a drag-and-drop form builder that allows users to add different types of input fields to a form. This exercise will practice:</p>
                <ul>
                    <li>Creating elements</li>
                    <li>Setting attributes</li>
                    <li>Appending to the DOM</li>
                    <li>Working with event listeners</li>
                </ul>
            </div>
            
            <div class="exercise">
                <h4>Exercise 3: DOM Manipulation Utility Library</h4>
                <p>Build a small utility library with functions that simplify common DOM manipulation tasks, such as:</p>
                <ul>
                    <li>A function to toggle multiple classes</li>
                    <li>A function to create and append elements with attributes in one step</li>
                    <li>A function to easily replace elements</li>
                    <li>A function to animate element changes (opacity, height, etc.)</li>
                </ul>
            </div>
        </section>

        <section class="summary">
            <h3>Lecture Summary</h3>
            <p>Today we've explored the world of DOM content manipulation, the core of dynamic web interactivity. We've covered:</p>
            
            <ul>
                <li>Changing text content with <code>textContent</code> and <code>innerText</code></li>
                <li>Modifying HTML structure with <code>innerHTML</code> and <code>insertAdjacentHTML</code></li>
                <li>Working with element attributes through methods and properties</li>
                <li>Manipulating CSS and classes for styling changes</li>
                <li>Creating, adding, and removing elements</li>
                <li>Traversing the DOM to access related elements</li>
                <li>Performance considerations for efficient DOM manipulation</li>
                <li>Real-world applications and modern alternatives</li>
            </ul>
            
            <p>With these skills, you can create dynamic, interactive web experiences that respond to user actions in real-time without requiring page refreshes. In our next session, we'll build on this foundation to explore event handling in depth, allowing us to respond to user interactions like clicks, keypresses, and form submissions.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    
    </footer>
</body>
</html>
