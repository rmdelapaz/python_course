<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Handling</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Event Handling</h1>
        <h2>Week 4: Web Fundamentals - Thursday Morning Session</h2>
    </header>

    <main>
        <section class="lecture_intro">
            <h3>Understanding Events: The Heartbeat of Interactive Web Applications</h3>
            <p>Welcome to our exploration of JavaScript event handling! Now that we've learned how to select and manipulate DOM elements, we're ready to make our web pages truly interactive by responding to user actions.</p>
            
            <p>This lecture belongs to Week 4: Web Fundamentals and is part of our Python Full Stack Developer course. You'll find this content in the folder structure: <code>/04week/04week_4day_d.html</code></p>
            
            <p>Events are at the core of interactive web applications. They allow our code to listen for and respond to actions like clicks, keypresses, form submissions, and even system events like page loading. Without events, our web pages would be static documents with no way to interact with users.</p>
        </section>

        <section class="events_basics">
            <h3>What Are Events?</h3>
            <p>In JavaScript, events are signals that something has happened in the browser. These signals can come from various sources:</p>
            
            <ul>
                <li><strong>User Actions:</strong> Clicks, keypresses, mouse movements, form submissions</li>
                <li><strong>Browser Actions:</strong> Page loading, window resizing, focus changes</li>
                <li><strong>Network Events:</strong> Requests completing, resources loading</li>
                <li><strong>Time-based Events:</strong> Timeouts, intervals</li>
                <li><strong>API Events:</strong> Geolocation updates, device orientation changes</li>
            </ul>
            
            <p><strong>Postal Service Metaphor:</strong> Think of events as a postal service for your web page. Different parts of the page can "mail" notifications when something happens, and your JavaScript code can "subscribe" to receive these notifications at specific addresses (event listeners). When an event occurs, all subscribers get notified and can respond accordingly.</p>
            
            <div class="event_anatomy">
                <h4>Anatomy of an Event</h4>
                <p>Events are represented by event objects that contain information about what happened:</p>
                <ul>
                    <li><strong>Type:</strong> What kind of event occurred (click, keypress, etc.)</li>
                    <li><strong>Target:</strong> The element that triggered the event</li>
                    <li><strong>Timestamp:</strong> When the event occurred</li>
                    <li><strong>Additional Properties:</strong> Event-specific details (cursor position, key pressed, etc.)</li>
                    <li><strong>Methods:</strong> Functions to control the event's behavior</li>
                </ul>
            </div>
        </section>

        <section class="event_types">
            <h3>Common Types of Events</h3>
            <p>JavaScript can handle a wide variety of events. Here are some of the most commonly used categories:</p>
            
            <div class="event_category">
                <h4>Mouse Events</h4>
                <ul>
                    <li><code>click</code>: When an element is clicked</li>
                    <li><code>dblclick</code>: When an element is double-clicked</li>
                    <li><code>mousedown</code>: When a mouse button is pressed down</li>
                    <li><code>mouseup</code>: When a mouse button is released</li>
                    <li><code>mousemove</code>: When the mouse cursor moves</li>
                    <li><code>mouseover</code>: When the cursor enters an element</li>
                    <li><code>mouseout</code>: When the cursor leaves an element</li>
                    <li><code>mouseenter</code>: Like mouseover, but doesn't bubble</li>
                    <li><code>mouseleave</code>: Like mouseout, but doesn't bubble</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>// Example of handling a click event
document.getElementById('my-button').addEventListener('click', function(event) {
    console.log('Button was clicked!');
    console.log('Mouse position:', event.clientX, event.clientY);
});</code></pre>
                </div>
            </div>
            
            <div class="event_category">
                <h4>Keyboard Events</h4>
                <ul>
                    <li><code>keydown</code>: When a key is pressed down</li>
                    <li><code>keyup</code>: When a key is released</li>
                    <li><code>keypress</code>: When a key is pressed (character keys only)</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>// Example of handling a keydown event
document.addEventListener('keydown', function(event) {
    console.log('Key pressed:', event.key);
    console.log('Key code:', event.keyCode); // Deprecated but still used
    console.log('Modifier keys:', event.ctrlKey, event.shiftKey, event.altKey);
});</code></pre>
                </div>
            </div>
            
            <div class="event_category">
                <h4>Form Events</h4>
                <ul>
                    <li><code>submit</code>: When a form is submitted</li>
                    <li><code>change</code>: When an input's value changes (after losing focus)</li>
                    <li><code>input</code>: When an input's value changes (immediately)</li>
                    <li><code>focus</code>: When an element receives focus</li>
                    <li><code>blur</code>: When an element loses focus</li>
                    <li><code>reset</code>: When a form is reset</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>// Example of handling a form submission
document.getElementById('login-form').addEventListener('submit', function(event) {
    event.preventDefault(); // Stop the form from actually submitting
    
    const username = document.getElementById('username').value;
    const password = document.getElementById('password').value;
    
    // Form validation logic
    if (username === '' || password === '') {
        alert('Please fill in all fields');
    } else {
        // AJAX form submission or other logic here
        console.log('Form submitted with:', username, password);
    }
});</code></pre>
                </div>
            </div>
            
            <div class="event_category">
                <h4>Document/Window Events</h4>
                <ul>
                    <li><code>load</code>: When the page finishes loading</li>
                    <li><code>DOMContentLoaded</code>: When the DOM is ready (before resources)</li>
                    <li><code>resize</code>: When the window is resized</li>
                    <li><code>scroll</code>: When the document or element is scrolled</li>
                    <li><code>beforeunload</code>: Before the page is unloaded (closing or navigating)</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>// Example of DOM ready event
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM is fully loaded and parsed');
    // Safe to manipulate DOM elements here
});

// Example of window resize event
window.addEventListener('resize', function() {
    console.log('Window dimensions:', window.innerWidth, window.innerHeight);
});</code></pre>
                </div>
            </div>
            
            <div class="event_category">
                <h4>Touch Events</h4>
                <ul>
                    <li><code>touchstart</code>: When a touch point is placed on the screen</li>
                    <li><code>touchend</code>: When a touch point is removed from the screen</li>
                    <li><code>touchmove</code>: When a touch point is moved along the screen</li>
                    <li><code>touchcancel</code>: When a touch point has been disrupted</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>// Example of handling a touch event
document.getElementById('touch-area').addEventListener('touchstart', function(event) {
    console.log('Touch started!');
    console.log('Number of touch points:', event.touches.length);
    
    // Prevent scrolling/zooming
    event.preventDefault();
});</code></pre>
                </div>
            </div>
        </section>

        <section class="event_listeners">
            <h3>Event Listeners: Responding to Events</h3>
            <p>To respond to events, we need to "listen" for them using event listeners. JavaScript provides several ways to attach event listeners to elements:</p>
            
            <div class="listener_method">
                <h4>Method 1: addEventListener (Recommended)</h4>
                <p>The modern and most flexible way to handle events:</p>
                
                <div class="code_example">
                    <pre><code>// Basic syntax
element.addEventListener(eventType, handlerFunction, options);

// Example
const button = document.getElementById('submit-button');

button.addEventListener('click', function(event) {
    console.log('Button clicked!');
});

// Using a named function
function handleClick(event) {
    console.log('Button clicked!');
    console.log('Event object:', event);
}

button.addEventListener('click', handleClick);

// With options (third parameter)
button.addEventListener('click', handleClick, {
    once: true,           // Only trigger once
    capture: false,       // Use bubbling phase (default)
    passive: true         // Promise not to call preventDefault()
});</code></pre>
                </div>
                
                <p><strong>Benefits of addEventListener:</strong></p>
                <ul>
                    <li>Allows multiple listeners for the same event</li>
                    <li>Can remove specific listeners later</li>
                    <li>Provides additional options</li>
                    <li>Doesn't override existing listeners</li>
                    <li>Clear separation between HTML and JavaScript</li>
                </ul>
            </div>
            
            <div class="listener_method">
                <h4>Method 2: Event Handler Properties</h4>
                <p>A simpler but more limited approach:</p>
                
                <div class="code_example">
                    <pre><code>// Syntax
element.oneventname = handlerFunction;

// Example
const button = document.getElementById('submit-button');

button.onclick = function(event) {
    console.log('Button clicked!');
};

// Using a named function
function handleClick(event) {
    console.log('Button clicked!');
}

button.onclick = handleClick;

// This will OVERWRITE the previous handler!
button.onclick = function() {
    console.log('New handler - the previous one is gone');
};</code></pre>
                </div>
                
                <p><strong>Limitations:</strong></p>
                <ul>
                    <li>Only one handler per event type per element</li>
                    <li>Can't use capture phase</li>
                    <li>Less control over how events are handled</li>
                </ul>
            </div>
            
            <div class="listener_method">
                <h4>Method 3: Inline Event Handlers (Not Recommended)</h4>
                <p>The oldest method, written directly in HTML:</p>
                
                <div class="code_example">
                    <pre><code>&lt;!-- HTML with inline event handler -->
&lt;button onclick="handleClick(event)">Click Me&lt;/button>

&lt;!-- Or with direct code -->
&lt;button onclick="alert('Button clicked!')">Click Me&lt;/button>

// JavaScript
function handleClick(event) {
    console.log('Button clicked!');
}</code></pre>
                </div>
                
                <p><strong>Why to avoid this approach:</strong></p>
                <ul>
                    <li>Mixes HTML and JavaScript (poor separation of concerns)</li>
                    <li>Performance issues with complex handlers</li>
                    <li>Limited access to the event object</li>
                    <li>Difficult to manage and maintain</li>
                    <li>Can lead to security risks like XSS</li>
                </ul>
            </div>
            
            <div class="removing_listeners">
                <h4>Removing Event Listeners</h4>
                <p>For events that should only happen under certain conditions, you may need to remove event listeners:</p>
                
                <div class="code_example">
                    <pre><code>// Adding a listener
function handleClick(event) {
    console.log('Button clicked!');
}

button.addEventListener('click', handleClick);

// Removing the listener - MUST use the same function reference
button.removeEventListener('click', handleClick);

// This WON'T work (anonymous function)
button.addEventListener('click', function() {
    console.log('Click handled');
});

// This attempt to remove will fail because it's a different function reference
button.removeEventListener('click', function() {
    console.log('Click handled');
});</code></pre>
                </div>
                
                <p><strong>Tip:</strong> Always store function references in variables if you plan to remove them later.</p>
                
                <div class="code_example">
                    <pre><code>// Correct approach for removing listeners
const handleHover = function() {
    console.log('Element hovered');
};

// Add the listener
element.addEventListener('mouseover', handleHover);

// Later, remove the same listener
element.removeEventListener('mouseover', handleHover);</code></pre>
                </div>
            </div>
        </section>

        <section class="event_object">
            <h3>The Event Object: Understanding What Happened</h3>
            <p>When an event occurs, JavaScript passes an event object to your handler function. This object contains details about the event that can be extremely useful:</p>
            
            <div class="common_properties">
                <h4>Common Event Object Properties</h4>
                <ul>
                    <li><code>event.type</code>: The type of event (e.g., "click", "keydown")</li>
                    <li><code>event.target</code>: The element that triggered the event</li>
                    <li><code>event.currentTarget</code>: The element that the listener is attached to</li>
                    <li><code>event.timeStamp</code>: When the event occurred</li>
                    <li><code>event.bubbles</code>: Whether the event bubbles up through the DOM</li>
                    <li><code>event.cancelable</code>: Whether the event can be canceled</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>document.getElementById('my-button').addEventListener('click', function(event) {
    console.log('Event type:', event.type);
    console.log('Target element:', event.target);
    console.log('Current target:', event.currentTarget);
    console.log('Time of event:', event.timeStamp);
});</code></pre>
                </div>
            </div>
            
            <div class="event_specific">
                <h4>Event-Specific Properties</h4>
                <p>Different event types provide additional information relevant to that event:</p>
                
                <h5>Mouse Events:</h5>
                <ul>
                    <li><code>event.clientX/clientY</code>: Coordinates relative to the viewport</li>
                    <li><code>event.pageX/pageY</code>: Coordinates relative to the document</li>
                    <li><code>event.screenX/screenY</code>: Coordinates relative to the screen</li>
                    <li><code>event.button</code>: Which mouse button was pressed</li>
                    <li><code>event.altKey/ctrlKey/shiftKey/metaKey</code>: Modifier keys</li>
                </ul>
                
                <h5>Keyboard Events:</h5>
                <ul>
                    <li><code>event.key</code>: The key value (e.g., "a", "Enter")</li>
                    <li><code>event.code</code>: The physical key (e.g., "KeyA", "Enter")</li>
                    <li><code>event.keyCode</code>: Numeric key code (deprecated)</li>
                    <li><code>event.altKey/ctrlKey/shiftKey/metaKey</code>: Modifier keys</li>
                    <li><code>event.repeat</code>: Whether the key is being held down</li>
                </ul>
                
                <h5>Form Events:</h5>
                <ul>
                    <li><code>event.value</code>: Current value of the form element</li>
                    <li><code>event.checked</code>: For checkboxes and radio buttons</li>
                    <li><code>event.selected</code>: For select options</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>// Mouse event example
document.addEventListener('mousemove', function(event) {
    // Update a div showing the current mouse position
    document.getElementById('mouse-position').textContent = 
        `Mouse at: ${event.clientX}, ${event.clientY}`;
});

// Keyboard event example
document.addEventListener('keydown', function(event) {
    // Check for specific keys
    if (event.key === 'Escape') {
        closeModal();
    }
    
    // Check for keyboard shortcuts
    if (event.ctrlKey && event.key === 's') {
        event.preventDefault(); // Prevent browser's save dialog
        saveDocument();
    }
});</code></pre>
                </div>
            </div>
            
            <div class="event_methods">
                <h4>Important Event Methods</h4>
                <p>The event object also provides methods to control event behavior:</p>
                
                <ul>
                    <li><code>event.preventDefault()</code>: Stops the default browser behavior</li>
                    <li><code>event.stopPropagation()</code>: Stops the event from bubbling/capturing</li>
                    <li><code>event.stopImmediatePropagation()</code>: Stops other listeners on the same element</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>// Prevent default behavior of a link
document.querySelector('a.stay-here').addEventListener('click', function(event) {
    event.preventDefault(); // Prevent navigating to the link
    console.log('Link was clicked, but page did not navigate');
});

// Prevent form submission
document.querySelector('form').addEventListener('submit', function(event) {
    if (!validateForm()) {
        event.preventDefault(); // Don't submit if validation fails
    }
});</code></pre>
                </div>
            </div>
        </section>

        <section class="event_propagation">
            <h3>Event Propagation: Bubbling and Capturing</h3>
            <p>When an event occurs on an element, it doesn't just fire there. Events in JavaScript propagate through the DOM in two phases:</p>
            
            <ol>
                <li><strong>Capturing Phase:</strong> The event travels down from the document root to the target element</li>
                <li><strong>Bubbling Phase:</strong> The event bubbles up from the target back to the document root</li>
            </ol>
            
            <p><strong>Ripple Metaphor:</strong> Think of event propagation like dropping a stone into a pond. The ripples first travel from the edge of the pond inward (capturing phase), then from the point of impact outward (bubbling phase). Each element the ripple passes can detect and respond to it.</p>
            
            <div class="visual_explanation">
                <h4>Visual Representation of Event Propagation</h4>
                <pre>
                    CAPTURING PHASE (1)       BUBBLING PHASE (2)
                          ↓                          ↑
                    +--------------+           +--------------+
                    |   document   |           |   document   |
                    +--------------+           +--------------+
                          ↓                          ↑
                    +--------------+           +--------------+
                    |     html     |           |     html     |
                    +--------------+           +--------------+
                          ↓                          ↑
                    +--------------+           +--------------+
                    |     body     |           |     body     |
                    +--------------+           +--------------+
                          ↓                          ↑
                    +--------------+           +--------------+
                    |     div      |           |     div      |
                    +--------------+           +--------------+
                          ↓                          ↑
                    +--------------+           +--------------+
                    |    button    |           |    button    |
                    +--------------+           +--------------+
                          ↓                          ↑
                    +======EVENT======+      +======EVENT======+
                </pre>
            </div>
            
            <div class="code_example">
                <h4>Example of Event Bubbling</h4>
                <pre><code>// HTML:
// &lt;div id="outer"&gt;
//   &lt;div id="middle"&gt;
//     &lt;button id="inner"&gt;Click Me&lt;/button&gt;
//   &lt;/div&gt;
// &lt;/div&gt;

// Add click listeners to all elements
document.getElementById('outer').addEventListener('click', function() {
    console.log('Outer div clicked');
});

document.getElementById('middle').addEventListener('click', function() {
    console.log('Middle div clicked');
});

document.getElementById('inner').addEventListener('click', function() {
    console.log('Button clicked');
});

// When the button is clicked, the console will show:
// "Button clicked"
// "Middle div clicked"
// "Outer div clicked"
// This is because the event bubbles up from the target element.</code></pre>
            </div>
            
            <div class="using_capture">
                <h4>Using the Capturing Phase</h4>
                <p>By default, event listeners are triggered during the bubbling phase. To use the capturing phase instead, set the third parameter of addEventListener to true or {capture: true}:</p>
                
                <div class="code_example">
                    <pre><code>// Same HTML structure as above

// Register a listener for the capturing phase
document.getElementById('outer').addEventListener('click', function() {
    console.log('Outer div clicked - CAPTURE');
}, true); // true enables capturing phase

document.getElementById('middle').addEventListener('click', function() {
    console.log('Middle div clicked - CAPTURE');
}, true);

document.getElementById('inner').addEventListener('click', function() {
    console.log('Button clicked - CAPTURE');
}, true);

// When the button is clicked, the console will show:
// "Outer div clicked - CAPTURE"
// "Middle div clicked - CAPTURE"
// "Button clicked - CAPTURE"
// This is the reverse order from bubbling</code></pre>
                </div>
            </div>
            
            <div class="stopping_propagation">
                <h4>Stopping Event Propagation</h4>
                <p>Sometimes you want to prevent an event from continuing its journey through the DOM:</p>
                
                <div class="code_example">
                    <pre><code>// Prevent event bubbling
document.getElementById('middle').addEventListener('click', function(event) {
    console.log('Middle div clicked');
    event.stopPropagation(); // Event stops here, won't reach outer div
});

// Stop all handlers on this element
document.getElementById('inner').addEventListener('click', function(event) {
    console.log('First button handler');
    event.stopImmediatePropagation(); // Prevents other handlers on this element
});

// This handler won't run if the button is clicked
document.getElementById('inner').addEventListener('click', function() {
    console.log('Second button handler - this will not run');
});</code></pre>
                </div>
                
                <p><strong>Important Note:</strong> Be careful with <code>stopPropagation()</code>. It can break functionality that relies on event bubbling, like analytics tracking or delegate event handlers. Use it only when necessary.</p>
            </div>
        </section>

        <section class="event_delegation">
            <h3>Event Delegation: Efficient Event Handling</h3>
            <p>Event delegation is a technique that leverages event bubbling to handle events efficiently. Instead of attaching event listeners to many similar elements, you attach a single listener to a common ancestor.</p>
            
            <p><strong>Management Metaphor:</strong> Think of event delegation like a corporate management structure. Instead of the CEO (your JavaScript) trying to directly manage every individual employee (element), they delegate responsibility to department managers (parent elements). When employees have concerns (events), they report to their manager, who can handle common issues and only escalate unique situations to the CEO.</p>
            
            <div class="delegation_benefits">
                <h4>Benefits of Event Delegation</h4>
                <ul>
                    <li><strong>Memory Efficiency:</strong> Fewer event listeners = less memory use</li>
                    <li><strong>Dynamic Elements:</strong> Works with elements added to the DOM after page load</li>
                    <li><strong>Less Code:</strong> Simpler, more maintainable code</li>
                    <li><strong>Improved Performance:</strong> Especially with many similar elements</li>
                </ul>
            </div>
            
            <div class="code_example">
                <h4>Traditional Approach vs. Event Delegation</h4>
                <pre><code>// HTML:
// &lt;ul id="task-list"&gt;
//   &lt;li&gt;&lt;span&gt;Task 1&lt;/span&gt; &lt;button class="delete"&gt;Delete&lt;/button&gt;&lt;/li&gt;
//   &lt;li&gt;&lt;span&gt;Task 2&lt;/span&gt; &lt;button class="delete"&gt;Delete&lt;/button&gt;&lt;/li&gt;
//   &lt;li&gt;&lt;span&gt;Task 3&lt;/span&gt; &lt;button class="delete"&gt;Delete&lt;/button&gt;&lt;/li&gt;
// &lt;/ul&gt;

// TRADITIONAL APPROACH: Add a listener to each button
const deleteButtons = document.querySelectorAll('#task-list .delete');
deleteButtons.forEach(button => {
    button.addEventListener('click', function() {
        this.parentElement.remove();
    });
});

// Problems with this approach:
// 1. New items added dynamically won't have listeners
// 2. Many event listeners in memory
// 3. Need to update code if structure changes

// EVENT DELEGATION APPROACH: One listener on the parent
document.getElementById('task-list').addEventListener('click', function(event) {
    // Check if the clicked element is a delete button
    if (event.target.classList.contains('delete')) {
        // Find the li parent and remove it
        event.target.closest('li').remove();
    }
});</code></pre>
            </div>
            
            <div class="delegation_implementation">
                <h4>Implementing Event Delegation</h4>
                <p>To implement event delegation effectively:</p>
                
                <ol>
                    <li>Identify a common parent element for all target elements</li>
                    <li>Add a single event listener to that parent</li>
                    <li>Use <code>event.target</code> to determine which specific element was interacted with</li>
                    <li>Check if the target (or one of its ancestors) matches your selector</li>
                    <li>Perform the appropriate action</li>
                </ol>
                
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div id="products"&gt;
//   &lt;div class="product" data-id="1"&gt;
//     &lt;h3&gt;Product 1&lt;/h3&gt;
//     &lt;button class="view"&gt;View&lt;/button&gt;
//     &lt;button class="add-to-cart"&gt;Add to Cart&lt;/button&gt;
//     &lt;button class="favorite"&gt;Favorite&lt;/button&gt;
//   &lt;/div&gt;
//   &lt;div class="product" data-id="2"&gt;...&lt;/div&gt;
//   &lt;div class="product" data-id="3"&gt;...&lt;/div&gt;
// &lt;/div&gt;

document.getElementById('products').addEventListener('click', function(event) {
    // Find the product container
    const product = event.target.closest('.product');
    
    // If click wasn't within a product, exit early
    if (!product) return;
    
    // Get the product ID
    const productId = product.dataset.id;
    
    // Determine which button was clicked
    if (event.target.classList.contains('view')) {
        viewProductDetails(productId);
    } 
    else if (event.target.classList.contains('add-to-cart')) {
        addProductToCart(productId);
    } 
    else if (event.target.classList.contains('favorite')) {
        toggleFavoriteStatus(productId);
    }
});

function viewProductDetails(id) {
    console.log(`Viewing details for product ${id}`);
    // Navigate to product page or show modal
}

function addProductToCart(id) {
    console.log(`Adding product ${id} to cart`);
    // Add to cart logic
}

function toggleFavoriteStatus(id) {
    console.log(`Toggling favorite status for product ${id}`);
    // Update favorite status
}</code></pre>
                </div>
                
                <p>The <code>closest()</code> method is particularly useful in event delegation. It traverses up from the target element to find the first ancestor that matches the selector, or returns null if none is found.</p>
            </div>
        </section>

        <section class="custom_events">
            <h3>Custom Events: Creating Your Own Events</h3>
            <p>JavaScript allows you to create and dispatch your own custom events, which can be useful for building component-based applications:</p>
            
            <div class="creating_custom_events">
                <h4>Creating and Dispatching Custom Events</h4>
                
                <div class="code_example">
                    <pre><code>// Basic custom event
const simpleEvent = new Event('myCustomEvent');

// Dispatch the event
document.getElementById('myElement').dispatchEvent(simpleEvent);

// Custom event with additional data
const detailedEvent = new CustomEvent('productAdded', {
    bubbles: true, // Allow event to bubble up the DOM
    cancelable: true, // Allow event to be canceled
    detail: { // Custom data to pass with the event
        productId: 123,
        productName: 'Wireless Headphones',
        price: 79.99
    }
});

// Dispatch the detailed event
document.dispatchEvent(detailedEvent);

// Listen for the custom event
document.addEventListener('productAdded', function(event) {
    console.log('Product added!', event.detail);
    updateCartCount(event.detail.price);
});</code></pre>
                </div>
            </div>
            
            <div class="custom_events_example">
                <h4>Practical Example: Component Communication</h4>
                <p>Custom events can be used to create a publish-subscribe pattern between components:</p>
                
                <div class="code_example">
                    <pre><code>// Shopping cart component
const ShoppingCart = {
    items: [],
    
    addItem: function(product) {
        this.items.push(product);
        
        // Announce that the cart has changed
        const event = new CustomEvent('cartUpdated', {
            bubbles: true,
            detail: {
                itemCount: this.items.length,
                totalPrice: this.calculateTotal(),
                lastItemAdded: product
            }
        });
        
        document.dispatchEvent(event);
    },
    
    calculateTotal: function() {
        return this.items.reduce((total, item) => total + item.price, 0);
    }
};

// Cart summary display component
document.addEventListener('DOMContentLoaded', function() {
    // Listen for cart updates
    document.addEventListener('cartUpdated', function(event) {
        // Update the cart display
        document.getElementById('cart-count').textContent = event.detail.itemCount;
        document.getElementById('cart-total').textContent = `$${event.detail.totalPrice.toFixed(2)}`;
        
        // Show notification about the added item
        showNotification(`Added: ${event.detail.lastItemAdded.name}`);
    });
});

// Product listing component
document.getElementById('product-list').addEventListener('click', function(event) {
    if (event.target.classList.contains('add-to-cart')) {
        const productElement = event.target.closest('.product');
        const product = {
            id: productElement.dataset.id,
            name: productElement.dataset.name,
            price: parseFloat(productElement.dataset.price)
        };
        
        ShoppingCart.addItem(product);
    }
});</code></pre>
                </div>
                
                <p><strong>Component Communication Metaphor:</strong> Custom events are like a bulletin board system where different parts of your application can post notices (dispatch events) and interested parties can subscribe to those notices (add event listeners). Components don't need to know about each other directly; they just need to agree on the notice format.</p>
            </div>
        </section>

        <section class="debouncing_throttling">
            <h3>Optimizing Events: Debouncing and Throttling</h3>
            <p>Some events like scroll, resize, and mousemove can fire many times per second. Processing each event can be expensive and lead to performance issues. Debouncing and throttling are techniques to limit how often your event handlers run.</p>
            
            <div class="debouncing">
                <h4>Debouncing</h4>
                <p>Debouncing ensures that a function is only executed after a certain amount of time has passed since it was last invoked. Think of it like waiting until someone stops typing before processing their search query.</p>
                
                <div class="code_example">
                    <pre><code>// Basic debounce function
function debounce(func, delay) {
    let timeoutId;
    
    return function(...args) {
        // Clear previous timeout
        clearTimeout(timeoutId);
        
        // Set new timeout
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

// Example: Search input that updates results only after typing stops
const searchInput = document.getElementById('search-input');

const debouncedSearch = debounce(function(e) {
    console.log('Searching for:', e.target.value);
    fetchSearchResults(e.target.value);
}, 300); // Wait 300ms after typing stops

searchInput.addEventListener('input', debouncedSearch);</code></pre>
                </div>
                
                <p><strong>Elevator Metaphor:</strong> Debouncing is like an elevator that waits until no new people have entered for a few seconds before starting its journey. If someone new enters during the waiting period, the timer resets.</p>
            </div>
            
            <div class="throttling">
                <h4>Throttling</h4>
                <p>Throttling limits how often a function can be called over time. It ensures the function executes at a regular interval, regardless of how many times the event is triggered.</p>
                
                <div class="code_example">
                    <pre><code>// Basic throttle function
function throttle(func, limit) {
    let inThrottle = false;
    
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            
            setTimeout(() => {
                inThrottle = false;
            }, limit);
        }
    };
}

// Example: Limiting how often we respond to scroll events
const handleScroll = throttle(function() {
    console.log('Scroll position:', window.scrollY);
    checkElementsInViewport();
}, 100); // Execute at most every 100ms

window.addEventListener('scroll', handleScroll);</code></pre>
                </div>
                
                <p><strong>Highway Toll Metaphor:</strong> Throttling is like a highway toll booth that only allows one car through every few seconds, no matter how many cars are waiting. Unlike debouncing, which waits for a quiet period, throttling ensures regular processing at a sustainable rate.</p>
            </div>
            
            <div class="when_to_use">
                <h4>When to Use Each Technique</h4>
                <ul>
                    <li><strong>Use Debouncing When:</strong>
                        <ul>
                            <li>The final state is what matters (search inputs, form validation)</li>
                            <li>You want to wait for a "quiet period" before acting</li>
                            <li>Processing during intermediate states would be wasteful</li>
                        </ul>
                    </li>
                    <li><strong>Use Throttling When:</strong>
                        <ul>
                            <li>Regular updates are needed (infinite scroll, progress updates)</li>
                            <li>You need to ensure some feedback during continuous events</li>
                            <li>You want to limit the rate of potentially expensive operations</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </section>

        <section class="event_best_practices">
            <h3>Event Handling Best Practices</h3>
            
            <div class="performance">
                <h4>Performance Considerations</h4>
                <ul>
                    <li><strong>Use Event Delegation</strong> for groups of similar elements</li>
                    <li><strong>Remove Unnecessary Listeners</strong> when they're no longer needed</li>
                    <li><strong>Debounce/Throttle</strong> handlers for frequently firing events</li>
                    <li><strong>Keep Handlers Small</strong> and focused on their specific task</li>
                    <li><strong>Avoid Anonymous Functions</strong> if you need to remove listeners later</li>
                    <li><strong>Be Careful with this Context</strong> when using arrow functions</li>
                </ul>
            </div>
            
            <div class="accessibility">
                <h4>Accessibility Considerations</h4>
                <ul>
                    <li><strong>Use Semantic Elements</strong> with built-in event handling (buttons, links)</li>
                    <li><strong>Add Keyboard Support</strong> alongside mouse/touch events</li>
                    <li><strong>Don't Rely Solely on Hover</strong> events (mobile has no hover)</li>
                    <li><strong>Respect User Preferences</strong> like reduced motion</li>
                    <li><strong>Ensure Focus Management</strong> for custom UI components</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>// Bad: Div acting as a button with only click handling
&lt;div onclick="submitForm()" class="button-like"&gt;Submit&lt;/div&gt;

// Good: Using a button element with proper keyboard accessibility
&lt;button type="button" onclick="submitForm()"&gt;Submit&lt;/button&gt;

// Even better: Separate JavaScript from HTML
&lt;button type="button" id="submit-button"&gt;Submit&lt;/button&gt;

// JavaScript
document.getElementById('submit-button').addEventListener('click', submitForm);</code></pre>
                </div>
            </div>
            
            <div class="maintainability">
                <h4>Code Organization and Maintainability</h4>
                <ul>
                    <li><strong>Separate Logic from Handlers</strong> - event handlers should call functions, not contain complex logic</li>
                    <li><strong>Namespace Your Events</strong> especially when creating custom events</li>
                    <li><strong>Document Your Events</strong> including what data they contain</li>
                    <li><strong>Use Consistent Patterns</strong> across your application</li>
                </ul>
                
                <div class="code_example">
                    <pre><code>// Poor organization - logic inside event handler
button.addEventListener('click', function(event) {
    // Complex logic here...
    const userData = fetchUserData();
    
    if (userData.isLoggedIn) {
        if (userData.hasPurchased) {
            showPremiumContent();
        } else {
            if (userData.freeTrialsRemaining > 0) {
                offerFreeTrial();
            } else {
                showPurchaseDialog();
            }
        }
    } else {
        redirectToLogin();
    }
});

// Better organization - separate logic from handler
button.addEventListener('click', handleAccessRequest);

function handleAccessRequest(event) {
    const userData = fetchUserData();
    
    if (!userData.isLoggedIn) {
        return redirectToLogin();
    }
    
    if (userData.hasPurchased) {
        return showPremiumContent();
    }
    
    userData.freeTrialsRemaining > 0 ? offerFreeTrial() : showPurchaseDialog();
}</code></pre>
                </div>
            </div>
        </section>

        <section class="browser_compatibility">
            <h3>Browser Compatibility Considerations</h3>
            <p>While modern browsers have largely standardized event handling, there are still some things to be aware of:</p>
            
            <ul>
                <li><strong>Old IE Support:</strong> IE &lt; 9 used <code>attachEvent</code> instead of <code>addEventListener</code></li>
                <li><strong>Event Object Differences:</strong> Properties like <code>event.target</code> vs <code>event.srcElement</code></li>
                <li><strong>Default Prevention:</strong> <code>preventDefault()</code> vs <code>returnValue = false</code></li>
                <li><strong>Touch Events:</strong> Not all browsers support the same touch event properties</li>
                <li><strong>Passive Listeners:</strong> A newer feature not supported in older browsers</li>
            </ul>
            
            <p>For modern web development, you generally don't need to worry about most of these issues, but if you need to support older browsers, consider using a polyfill or feature detection library.</p>
            
            <div class="feature_detection">
                <h4>Using Feature Detection</h4>
                
                <div class="code_example">
                    <pre><code>// Check if addEventListener is supported
const addEvent = function(element, event, handler) {
    if (element.addEventListener) {
        element.addEventListener(event, handler, false);
    } else if (element.attachEvent) {
        element.attachEvent('on' + event, handler);
    } else {
        element['on' + event] = handler;
    }
};

// Example usage
addEvent(document.getElementById('my-button'), 'click', function() {
    console.log('Button clicked!');
});</code></pre>
                </div>
                
                <p>For most modern applications, you can just use <code>addEventListener</code> directly, as it's supported in all current browsers.</p>
            </div>
        </section>

        <section class="practical_examples">
            <h3>Complete Practical Examples</h3>
            
            <div class="example">
                <h4>Example 1: Tabbed Interface</h4>
                
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div class="tabs"&gt;
//   &lt;div class="tab-buttons"&gt;
//     &lt;button class="tab-button active" data-tab="tab1"&gt;Tab 1&lt;/button&gt;
//     &lt;button class="tab-button" data-tab="tab2"&gt;Tab 2&lt;/button&gt;
//     &lt;button class="tab-button" data-tab="tab3"&gt;Tab 3&lt;/button&gt;
//   &lt;/div&gt;
//   &lt;div class="tab-content"&gt;
//     &lt;div id="tab1" class="tab-panel active"&gt;Content for Tab 1&lt;/div&gt;
//     &lt;div id="tab2" class="tab-panel"&gt;Content for Tab 2&lt;/div&gt;
//     &lt;div id="tab3" class="tab-panel"&gt;Content for Tab 3&lt;/div&gt;
//   &lt;/div&gt;
// &lt;/div&gt;

// CSS (simplified):
// .tab-panel { display: none; }
// .tab-panel.active { display: block; }
// .tab-button { background: #f0f0f0; }
// .tab-button.active { background: #fff; }

// JavaScript with event delegation
document.querySelector('.tab-buttons').addEventListener('click', function(event) {
    // Check if a tab button was clicked
    if (event.target.classList.contains('tab-button')) {
        // Get the tab ID from data attribute
        const tabId = event.target.dataset.tab;
        
        // Remove active class from all buttons and panels
        document.querySelectorAll('.tab-button').forEach(button => {
            button.classList.remove('active');
        });
        
        document.querySelectorAll('.tab-panel').forEach(panel => {
            panel.classList.remove('active');
        });
        
        // Add active class to clicked button and corresponding panel
        event.target.classList.add('active');
        document.getElementById(tabId).classList.add('active');
    }
});</code></pre>
                </div>
            </div>
            
            <div class="example">
                <h4>Example 2: Image Gallery with Keyboard Navigation</h4>
                
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div class="gallery"&gt;
//   &lt;div class="main-image"&gt;
//     &lt;img id="current-image" src="image1.jpg" alt="Gallery Image 1"&gt;
//   &lt;/div&gt;
//   &lt;div class="thumbnails"&gt;
//     &lt;img class="thumb active" data-src="image1.jpg" src="thumb1.jpg" alt="Thumbnail 1"&gt;
//     &lt;img class="thumb" data-src="image2.jpg" src="thumb2.jpg" alt="Thumbnail 2"&gt;
//     &lt;img class="thumb" data-src="image3.jpg" src="thumb3.jpg" alt="Thumbnail 3"&gt;
//     &lt;img class="thumb" data-src="image4.jpg" src="thumb4.jpg" alt="Thumbnail 4"&gt;
//   &lt;/div&gt;
//   &lt;div class="controls"&gt;
//     &lt;button id="prev"&gt;Previous&lt;/button&gt;
//     &lt;button id="next"&gt;Next&lt;/button&gt;
//   &lt;/div&gt;
// &lt;/div&gt;

// JavaScript
document.addEventListener('DOMContentLoaded', function() {
    const currentImage = document.getElementById('current-image');
    const thumbnails = document.querySelectorAll('.thumb');
    const prevButton = document.getElementById('prev');
    const nextButton = document.getElementById('next');
    
    let currentIndex = 0;
    
    // Function to change the active image
    function setActiveImage(index) {
        // Wrap around if index is out of bounds
        if (index < 0) index = thumbnails.length - 1;
        if (index >= thumbnails.length) index = 0;
        
        // Update currentIndex
        currentIndex = index;
        
        // Update main image
        const newSrc = thumbnails[index].dataset.src;
        currentImage.src = newSrc;
        currentImage.alt = thumbnails[index].alt;
        
        // Update active thumbnail
        thumbnails.forEach(thumb => thumb.classList.remove('active'));
        thumbnails[index].classList.add('active');
    }
    
    // Thumbnail click event using event delegation
    document.querySelector('.thumbnails').addEventListener('click', function(event) {
        if (event.target.classList.contains('thumb')) {
            const clickedIndex = Array.from(thumbnails).indexOf(event.target);
            setActiveImage(clickedIndex);
        }
    });
    
    // Previous button click
    prevButton.addEventListener('click', function() {
        setActiveImage(currentIndex - 1);
    });
    
    // Next button click
    nextButton.addEventListener('click', function() {
        setActiveImage(currentIndex + 1);
    });
    
    // Keyboard navigation
    document.addEventListener('keydown', function(event) {
        switch (event.key) {
            case 'ArrowLeft':
                setActiveImage(currentIndex - 1);
                break;
            case 'ArrowRight':
                setActiveImage(currentIndex + 1);
                break;
        }
    });
});</code></pre>
                </div>
            </div>
            
            <div class="example">
                <h4>Example 3: Drag and Drop Interface</h4>
                
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div class="kanban-board"&gt;
//   &lt;div id="todo" class="column"&gt;
//     &lt;h3&gt;To Do&lt;/h3&gt;
//     &lt;div class="task" draggable="true" data-id="task1"&gt;Task 1&lt;/div&gt;
//     &lt;div class="task" draggable="true" data-id="task2"&gt;Task 2&lt;/div&gt;
//   &lt;/div&gt;
//   &lt;div id="doing" class="column"&gt;
//     &lt;h3&gt;Doing&lt;/h3&gt;
//     &lt;div class="task" draggable="true" data-id="task3"&gt;Task 3&lt;/div&gt;
//   &lt;/div&gt;
//   &lt;div id="done" class="column"&gt;
//     &lt;h3&gt;Done&lt;/h3&gt;
//   &lt;/div&gt;
// &lt;/div&gt;

document.addEventListener('DOMContentLoaded', function() {
    // Get all draggable tasks
    const tasks = document.querySelectorAll('.task');
    const columns = document.querySelectorAll('.column');
    
    let draggedTask = null;
    
    // Add event listeners to tasks
    tasks.forEach(task => {
        // When drag starts
        task.addEventListener('dragstart', function(event) {
            draggedTask = task;
            event.dataTransfer.setData('text/plain', task.dataset.id);
            
            // Add a class for styling
            setTimeout(() => {
                task.classList.add('dragging');
            }, 0);
        });
        
        // When drag ends
        task.addEventListener('dragend', function() {
            draggedTask = null;
            task.classList.remove('dragging');
        });
    });
    
    // Add event listeners to columns
    columns.forEach(column => {
        // When dragged task enters a column
        column.addEventListener('dragenter', function(event) {
            event.preventDefault(); // Needed for drop to work
            column.classList.add('drag-over');
        });
        
        // When dragged task is over a column
        column.addEventListener('dragover', function(event) {
            event.preventDefault(); // Needed for drop to work
        });
        
        // When dragged task leaves a column
        column.addEventListener('dragleave', function() {
            column.classList.remove('drag-over');
        });
        
        // When task is dropped in a column
        column.addEventListener('drop', function(event) {
            event.preventDefault();
            column.classList.remove('drag-over');
            
            // Get the dragged task ID
            const taskId = event.dataTransfer.getData('text/plain');
            const task = document.querySelector(`.task[data-id="${taskId}"]`);
            
            // Append the task to the column
            column.appendChild(task);
            
            // Create a custom event to notify about task movement
            const taskMovedEvent = new CustomEvent('taskMoved', {
                bubbles: true,
                detail: {
                    taskId: taskId,
                    fromColumn: task.parentElement.id,
                    toColumn: column.id
                }
            });
            
            task.dispatchEvent(taskMovedEvent);
        });
    });
    
    // Listen for task movement
    document.addEventListener('taskMoved', function(event) {
        console.log(`Task ${event.detail.taskId} moved from ${event.detail.fromColumn} to ${event.detail.toColumn}`);
        
        // Here you would typically update your data model or send to server
        updateTaskStatus(event.detail.taskId, event.detail.toColumn);
    });
    
    function updateTaskStatus(taskId, newStatus) {
        // Example: send to server
        console.log(`Updating task ${taskId} status to ${newStatus}`);
        
        // In a real app, you might use fetch:
        // fetch('/api/tasks/' + taskId, {
        //   method: 'PATCH',
        //   body: JSON.stringify({ status: newStatus }),
        //   headers: { 'Content-Type': 'application/json' }
        // });
    }
});</code></pre>
                </div>
            </div>
        </section>

        <section class="practice_exercises">
            <h3>Practice Exercises</h3>
            
            <div class="exercise">
                <h4>Exercise 1: Event Delegation Todo List</h4>
                <p>Create a simple todo list application that allows users to:</p>
                <ul>
                    <li>Add new tasks through a form</li>
                    <li>Mark tasks as complete by clicking on them</li>
                    <li>Delete tasks with a delete button</li>
                    <li>Filter tasks (all, active, completed)</li>
                </ul>
                <p>Use event delegation for all interactions and include proper keyboard accessibility.</p>
            </div>
            
            <div class="exercise">
                <h4>Exercise 2: Interactive Form Validation</h4>
                <p>Create a registration form with real-time validation:</p>
                <ul>
                    <li>Validate each field as users type (email format, password strength, etc.)</li>
                    <li>Show validation feedback (success/error icons, messages)</li>
                    <li>Disable the submit button until all fields are valid</li>
                    <li>Use custom events to announce form state changes</li>
                </ul>
                <p>Implement both debounced validation (for typing) and immediate validation (on blur).</p>
            </div>
            
            <div class="exercise">
                <h4>Exercise 3: Custom Event Framework</h4>
                <p>Build a simple pub/sub (publish-subscribe) system using custom events:</p>
                <ul>
                    <li>Create functions to publish events with data</li>
                    <li>Allow multiple subscribers to listen for events</li>
                    <li>Support namespaced events (e.g., "user.login", "user.logout")</li>
                    <li>Build a small demo application showing components communicating</li>
                </ul>
                <p>Use this framework to demonstrate decoupled communication between parts of an application.</p>
            </div>
        </section>

        <section class="summary">
            <h3>Lecture Summary</h3>
            <p>Today we've explored the world of JavaScript event handling, the key to creating dynamic and interactive web applications. We've covered:</p>
            
            <ul>
                <li>The fundamentals of events and the event object</li>
                <li>Various types of events (mouse, keyboard, form, document/window)</li>
                <li>Different methods for adding event listeners</li>
                <li>Event propagation through capture and bubbling phases</li>
                <li>Event delegation for efficient handling of multiple elements</li>
                <li>Creating and working with custom events</li>
                <li>Performance optimization with debouncing and throttling</li>
                <li>Best practices for maintainable and accessible event handling</li>
                <li>Real-world examples of interactive interfaces</li>
            </ul>
            
            <p>With these skills, you can now create rich, interactive web experiences that respond naturally to user actions and system events. In our next session, we'll explore more advanced ways to enhance your web applications with dynamic features.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
        <p>This lecture: <code>/04week/04week_4day_d.html</code></p>
    </footer>
</body>
</html>
