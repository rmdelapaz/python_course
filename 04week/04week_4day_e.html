<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Fundamentals Review</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>JavaScript Fundamentals Review</h1>
        <h2>Week 4: Web Fundamentals - Thursday Morning Session</h2>
    </header>

    <main>
        <section class="lecture_intro">
            <h3>Revisiting JavaScript Core Concepts</h3>
            <p>Welcome to our JavaScript fundamentals review! As Python developers transitioning to full-stack development, understanding JavaScript is crucial for creating interactive web applications. This session will revisit key JavaScript concepts to ensure you have a solid foundation before we dive deeper into DOM manipulation and event handling.</p>
            
            <p>This lecture belongs to Week 4: Web Fundamentals and is part of our Python Full Stack Developer course. You'll find this content in the folder structure: <code>/04week/04week_4day_e.html</code></p>
            
            <p>JavaScript is the language of the web browser, enabling dynamic interactions that transform static HTML documents into interactive applications. While there are similarities between Python and JavaScript (both are high-level, interpreted languages), there are also important differences in syntax, behavior, and philosophy that we'll highlight throughout this review.</p>
        </section>

        <section class="history_evolution">
            <h3>Brief History and Evolution of JavaScript</h3>
            <p>Before diving into the syntax, let's understand where JavaScript comes from and how it has evolved:</p>
            
            <ul>
                <li><strong>1995:</strong> Created by Brendan Eich at Netscape in just 10 days, initially named "Mocha"</li>
                <li><strong>1996:</strong> Renamed to "JavaScript" (despite having no relation to Java)</li>
                <li><strong>1997:</strong> Standardized as ECMAScript (ES1)</li>
                <li><strong>1999-2009:</strong> Slow evolution (ES3, ES4 abandoned)</li>
                <li><strong>2009:</strong> ES5 introduced with important new features</li>
                <li><strong>2015:</strong> ES6/ES2015 - A major update with significant new capabilities</li>
                <li><strong>2016-Present:</strong> Yearly releases (ES2016, ES2017, etc.) with incremental improvements</li>
            </ul>
            
            <p><strong>River Metaphor:</strong> Think of JavaScript's evolution like a river that started as a small stream (simple, limited features) but has grown through tributaries and rainfall (community contributions and standards committees) into a powerful flowing river with many branches (frameworks, libraries, and dialects) that all share the same fundamental properties.</p>
            
            <div class="js_today">
                <h4>JavaScript Today</h4>
                <p>Modern JavaScript (post-ES6) has addressed many of the language's early criticisms and added powerful features:</p>
                <ul>
                    <li>Arrow functions, promises, and async/await for better asynchronous code</li>
                    <li>Classes and modules for improved code organization</li>
                    <li>Template literals, destructuring, and spread syntax for cleaner syntax</li>
                    <li>Block-scoped variables (let, const) for safer scoping</li>
                    <li>Expanded in server environments (Node.js) and desktop applications (Electron)</li>
                </ul>
            </div>
        </section>

        <section class="variables_data_types">
            <h3>Variables and Data Types</h3>
            <p>Like Python, JavaScript is dynamically typed, but with some important differences in how variables and types work.</p>
            
            <div class="variable_declaration">
                <h4>Variable Declaration</h4>
                <p>JavaScript offers three ways to declare variables, each with different behaviors:</p>
                
                <div class="code_example">
                    <pre><code>// var - function-scoped, older style (pre-ES6)
var message = "Hello, world!"; 
var count = 42;

// let - block-scoped, preferred for variables that will change
let counter = 0;
counter += 1; // counter is now 1

// const - block-scoped, for values that won't be reassigned
const PI = 3.14159;
const MAX_USERS = 100;

// Error - can't reassign a const
// PI = 3.14; // TypeError: Assignment to constant variable

// But objects and arrays declared with const can be modified
const user = { name: "Alice" };
user.name = "Bob"; // This works! Only the reference is constant
user.age = 30;     // Adding properties is fine

const numbers = [1, 2, 3];
numbers.push(4);   // This works! Array content can change</code></pre>
                </div>
                
                <p><strong>Key Differences from Python:</strong></p>
                <ul>
                    <li>JavaScript requires declaration keywords (var, let, const)</li>
                    <li>Variables have block or function scope, not just function scope like Python</li>
                    <li>No built-in concept like Python's tuples for immutable sequences</li>
                </ul>
                
                <p><strong>Container Metaphor:</strong> Think of var as a balloon that floats up to its containing function, let as a box that stays exactly where you put it, and const as a locked box where you can rearrange the contents but can't replace the entire box.</p>
            </div>
            
            <div class="primitive_types">
                <h4>Primitive Data Types</h4>
                <p>JavaScript has seven primitive (built-in) data types:</p>
                
                <div class="code_example">
                    <pre><code>// 1. String - for text
let name = "Alice";
let greeting = 'Hello';
let template = `Hello, ${name}!`; // Template literal (ES6)

// 2. Number - both integers and floating-point
let count = 42;
let price = 9.99;
let scientific = 3e8; // 3 x 10^8 (300,000,000)

// 3. Boolean - true or false
let isActive = true;
let hasPermission = false;

// 4. null - intentional absence of any value
let user = null; // user is explicitly empty

// 5. undefined - unintentionally missing value
let pet; // pet is declared but not defined
console.log(pet); // undefined

// 6. Symbol - unique and immutable (ES6)
const id1 = Symbol('id');
const id2 = Symbol('id');
console.log(id1 === id2); // false, symbols are always unique

// 7. BigInt - for integers larger than Number can represent (ES2020)
const bigNumber = 9007199254740991n; // n suffix defines a BigInt
const result = bigNumber + 1n;</code></pre>
                </div>
                
                <p><strong>Python Comparison:</strong> Unlike Python, JavaScript has a single Number type for both integers and floats. Also, empty values in JavaScript are more complex with both null (explicit emptiness) and undefined (absence of definition).</p>
            </div>
            
            <div class="complex_types">
                <h4>Objects and Reference Types</h4>
                <p>Beyond primitives, JavaScript has reference types (sometimes called "objects" broadly):</p>
                
                <div class="code_example">
                    <pre><code>// Objects - collections of key-value pairs (like Python dictionaries)
const person = {
    firstName: "Alice",
    lastName: "Johnson",
    age: 28,
    isStudent: false,
    greet: function() {
        return `Hello, my name is ${this.firstName}`;
    }
};

// Accessing object properties
console.log(person.firstName); // Dot notation
console.log(person["lastName"]); // Bracket notation
console.log(person.greet()); // Method call

// Arrays - ordered collections (similar to Python lists)
const colors = ["red", "green", "blue"];
const mixed = [1, "two", true, null, {key: "value"}]; // Mixed types

// Accessing array elements (zero-based indexing)
console.log(colors[0]); // "red"
colors.push("yellow"); // Add to the end
colors.unshift("purple"); // Add to the beginning
const lastColor = colors.pop(); // Remove from the end

// Functions - callable objects
function add(a, b) {
    return a + b;
}

// Functions as values
const multiply = function(a, b) {
    return a * b;
};

// Arrow functions (ES6)
const divide = (a, b) => a / b; // Implicit return
const square = a => a * a; // Single parameter, no parentheses needed</code></pre>
                </div>
                
                <p><strong>Key Difference from Python:</strong> JavaScript functions are first-class objects that can be assigned to variables, passed as arguments, and returned from other functions (similar to Python, but with different syntax).</p>
            </div>
            
            <div class="type_coercion">
                <h4>Type Coercion and Checking</h4>
                <p>JavaScript will automatically convert types in certain operations, which can lead to unexpected results:</p>
                
                <div class="code_example">
                    <pre><code>// Type Coercion Examples
console.log("5" + 3);     // "53" (string concatenation)
console.log("5" - 3);     // 2 (numeric subtraction)
console.log("5" * "3");   // 15 (numeric multiplication)
console.log(true + 1);    // 2 (true converts to 1)
console.log(false + 1);   // 1 (false converts to 0)
console.log(null + 1);    // 1 (null converts to 0)
console.log(undefined + 1); // NaN (undefined converts to NaN)

// Equality operators
console.log("5" == 5);    // true (loose equality, with coercion)
console.log("5" === 5);   // false (strict equality, no coercion)
console.log(0 == false);  // true (coercion)
console.log(0 === false); // false (no coercion)

// Type checking
console.log(typeof "hello");      // "string"
console.log(typeof 42);           // "number"
console.log(typeof true);         // "boolean"
console.log(typeof undefined);    // "undefined"
console.log(typeof null);         // "object" (this is a known bug in JS)
console.log(typeof {});           // "object"
console.log(typeof []);           // "object" (arrays are objects)
console.log(typeof function() {}); // "function"

// Better array checking
console.log(Array.isArray([]));   // true
console.log(Array.isArray({}));   // false</code></pre>
                </div>
                
                <p><strong>Traffic Light Metaphor:</strong> If Python's type system is like a traffic light with clear signals (red, yellow, green), JavaScript's type coercion is like a blinking yellow light where rules exist but you need extra caution. The === operator is like installing a guard rail to prevent unexpected behavior.</p>
                
                <p><strong>Python Developer Tip:</strong> Always prefer the strict equality operators (=== and !==) in JavaScript to avoid unexpected type coercion, similar to how you wouldn't rely on Python's implicit type conversion in comparisons.</p>
            </div>
        </section>

        <section class="operators_expressions">
            <h3>Operators and Expressions</h3>
            <p>JavaScript operators are similar to those in Python, with some important differences:</p>
            
            <div class="arithmetic_operators">
                <h4>Arithmetic Operators</h4>
                <div class="code_example">
                    <pre><code>// Basic arithmetic
let a = 10;
let b = 3;

console.log(a + b);  // 13 (addition)
console.log(a - b);  // 7 (subtraction)
console.log(a * b);  // 30 (multiplication)
console.log(a / b);  // 3.3333... (division - always returns floating point)
console.log(a % b);  // 1 (modulus - remainder after division)
console.log(a ** b); // 1000 (exponentiation - ES2016)

// Increment and decrement
let c = 5;
c++;        // Post-increment (c is now 6)
++c;        // Pre-increment (c is now 7)
console.log(c++); // 7 (returns current value, then increments)
console.log(++c); // 9 (increments first, then returns new value)

// Assignment operators
let d = 10;
d += 5;      // d = d + 5 (d is now 15)
d -= 3;      // d = d - 3 (d is now 12)
d *= 2;      // d = d * 2 (d is now 24)
d /= 4;      // d = d / 4 (d is now 6)
d %= 4;      // d = d % 4 (d is now 2)</code></pre>
                </div>
            </div>
            
            <div class="comparison_logical">
                <h4>Comparison and Logical Operators</h4>
                <div class="code_example">
                    <pre><code>// Comparison Operators
let x = 10;
let y = "10";
let z = 5;

console.log(x == y);   // true (loose equality)
console.log(x === y);  // false (strict equality)
console.log(x != y);   // false (loose inequality)
console.log(x !== y);  // true (strict inequality)
console.log(x > z);    // true (greater than)
console.log(x >= z);   // true (greater than or equal)
console.log(x < z);    // false (less than)
console.log(x <= z);   // false (less than or equal)

// Logical Operators
let isActive = true;
let isAdmin = false;

console.log(isActive && isAdmin); // false (logical AND)
console.log(isActive || isAdmin); // true (logical OR)
console.log(!isActive);           // false (logical NOT)

// Short-circuit evaluation (like Python)
let username = null;
let displayName = username || "Guest"; // "Guest"

// Nullish coalescing operator (ES2020)
let count = 0;
let defaultCount = 10;
// In this case, 0 is a valid count, but is falsy
let finalCount = count || defaultCount; // 10 (undesired result)
// Nullish coalescing only falls back if value is null or undefined
let betterCount = count ?? defaultCount; // 0 (better result)

// Optional chaining (ES2020)
const user = { 
    profile: null 
};
// Without optional chaining
// console.log(user.profile.name); // Error: Cannot read property 'name' of null

// With optional chaining
console.log(user.profile?.name); // undefined (no error)</code></pre>
                </div>
                
                <p><strong>Python Comparison:</strong> JavaScript's dual equality operators (== vs ===) are a key difference from Python. Also, JavaScript uses && and || instead of Python's "and" and "or" keywords.</p>
            </div>
            
            <div class="bitwise_others">
                <h4>Bitwise and Other Operators</h4>
                <div class="code_example">
                    <pre><code>// Bitwise Operators
let a = 5;  // 101 in binary
let b = 3;  // 011 in binary

console.log(a & b);   // 1 (001 in binary) - Bitwise AND
console.log(a | b);   // 7 (111 in binary) - Bitwise OR
console.log(a ^ b);   // 6 (110 in binary) - Bitwise XOR
console.log(~a);      // -6 - Bitwise NOT
console.log(a << 1);  // 10 (1010 in binary) - Left shift
console.log(a >> 1);  // 2 (010 in binary) - Right shift

// Ternary Operator (conditional)
let age = 20;
let status = age >= 18 ? "Adult" : "Minor";
console.log(status); // "Adult"

// String Operators
let greeting = "Hello";
let name = "World";
console.log(greeting + " " + name); // "Hello World"

// The typeof operator
console.log(typeof 42);         // "number"
console.log(typeof "hello");    // "string"</code></pre>
                </div>
            </div>
        </section>

        <section class="control_structures">
            <h3>Control Structures</h3>
            <p>JavaScript's control structures are syntactically different from Python but conceptually similar:</p>
            
            <div class="conditionals">
                <h4>Conditional Statements</h4>
                <div class="code_example">
                    <pre><code>// if statement
let temperature = 75;

if (temperature > 90) {
    console.log("It's hot outside!");
} else if (temperature > 70) {
    console.log("It's warm outside.");
} else if (temperature > 50) {
    console.log("It's cool outside.");
} else {
    console.log("It's cold outside!");
}

// Python developers note: JavaScript uses curly braces {} instead of indentation
// and parentheses () around conditions

// Switch statement (no direct equivalent in Python)
let day = "Monday";

switch (day) {
    case "Monday":
        console.log("Start of the work week");
        break;  // Don't forget break or you'll fall through to the next case!
    case "Tuesday":
    case "Wednesday":
    case "Thursday":
        console.log("Middle of the work week");
        break;
    case "Friday":
        console.log("End of the work week");
        break;
    case "Saturday":
    case "Sunday":
        console.log("Weekend!");
        break;
    default:
        console.log("Not a valid day");
        break;
}</code></pre>
                </div>
                
                <p><strong>The Truth About Truthiness:</strong> JavaScript considers these values as falsy:</p>
                <ul>
                    <li><code>false</code></li>
                    <li><code>0</code></li>
                    <li><code>""</code> (empty string)</li>
                    <li><code>null</code></li>
                    <li><code>undefined</code></li>
                    <li><code>NaN</code> (Not a Number)</li>
                </ul>
                <p>Everything else is considered truthy, similar to Python's truth value testing.</p>
            </div>
            
            <div class="loops">
                <h4>Loops and Iterations</h4>
                <div class="code_example">
                    <pre><code>// for loop
for (let i = 0; i < 5; i++) {
    console.log(`Iteration ${i}`);
}

// while loop
let count = 0;
while (count < 5) {
    console.log(`Count is ${count}`);
    count++;
}

// do-while loop (always executes at least once)
let x = 0;
do {
    console.log(`x is ${x}`);
    x++;
} while (x < 3);

// for...in loop (iterates over object properties)
const person = {
    name: "Alice",
    age: 30,
    job: "Developer"
};

for (let key in person) {
    console.log(`${key}: ${person[key]}`);
}

// WARNING: for...in on arrays gives indices, not values
const colors = ["red", "green", "blue"];
for (let index in colors) {
    console.log(index); // "0", "1", "2" (as strings!)
    console.log(colors[index]); // "red", "green", "blue"
}

// for...of loop (ES6) - iterates over iterable values
for (let color of colors) {
    console.log(color); // "red", "green", "blue"
}

// for...of with objects requires Object.entries(), keys(), or values()
for (let [key, value] of Object.entries(person)) {
    console.log(`${key}: ${value}`);
}

// Array methods for iteration
colors.forEach((color, index) => {
    console.log(`${index}: ${color}`);
});</code></pre>
                </div>
                
                <p><strong>Python Comparison:</strong> JavaScript's traditional for loop is quite different from Python's for loop. The for...of loop is closest to Python's for loop syntax and behavior.</p>
                
                <div class="loop_control">
                    <h4>Loop Control</h4>
                    <div class="code_example">
                        <pre><code>// break - exits the loop entirely
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break;
    }
    console.log(i); // Only logs 0 through 4
}

// continue - skips to the next iteration
for (let i = 0; i < 5; i++) {
    if (i === 2) {
        continue;
    }
    console.log(i); // Logs 0, 1, 3, 4 (skips 2)
}

// Labels (rarely used, but available)
outerLoop: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) {
            break outerLoop; // Breaks out of both loops
        }
        console.log(`i=${i}, j=${j}`);
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <section class="functions">
            <h3>Functions</h3>
            <p>Functions are first-class citizens in JavaScript, with several ways to define them:</p>
            
            <div class="function_declarations">
                <h4>Function Declarations and Expressions</h4>
                <div class="code_example">
                    <pre><code>// Function Declaration
function greet(name) {
    return `Hello, ${name}!`;
}

// Function Expression
const sayHello = function(name) {
    return `Hello, ${name}!`;
};

// Arrow Function (ES6)
const welcome = (name) => {
    return `Welcome, ${name}!`;
};

// Arrow Function with implicit return (single expression)
const hi = name => `Hi, ${name}!`;

// Immediately Invoked Function Expression (IIFE)
(function() {
    console.log("I run immediately!");
})();

// Key difference: Function declarations are hoisted, expressions are not
console.log(hoistedFunc()); // Works before declaration

function hoistedFunc() {
    return "I'm hoisted!";
}

// This would fail: console.log(notHoisted()); 
const notHoisted = function() {
    return "I'm not hoisted";
};</code></pre>
                </div>
                
                <p><strong>Theater Metaphor:</strong> If traditional functions are like actors with a script who can be called to stage multiple times, arrow functions are like voiceovers - they deliver the lines but don't bring their own context (this binding) to the performance.</p>
            </div>
            
            <div class="parameters">
                <h4>Function Parameters</h4>
                <div class="code_example">
                    <pre><code>// Default parameters (ES6)
function createUser(name, role = "user", active = true) {
    return { name, role, active };
}

console.log(createUser("Alice")); // {name: "Alice", role: "user", active: true}
console.log(createUser("Bob", "admin")); // {name: "Bob", role: "admin", active: true}

// Rest parameters (ES6)
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// Destructuring parameters (ES6)
function displayPerson({ name, age, city = "Unknown" }) {
    console.log(`${name} is ${age} years old from ${city}`);
}

displayPerson({ name: "Charlie", age: 30, city: "New York" });
displayPerson({ name: "Dave", age: 25 }); // City defaults to "Unknown"</code></pre>
                </div>
            </div>
            
            <div class="scope_closure">
                <h4>Scope and Closures</h4>
                <div class="code_example">
                    <pre><code>// Variable scope
let globalVar = "I'm global";

function scopeExample() {
    let functionVar = "I'm function-scoped";
    
    if (true) {
        let blockVar = "I'm block-scoped";
        var oldVar = "I'm function-scoped too!";
        console.log(globalVar);     // Accessible
        console.log(functionVar);   // Accessible
        console.log(blockVar);      // Accessible
    }
    
    console.log(oldVar);        // Accessible (var ignores blocks)
    // console.log(blockVar);    // Error! Not accessible outside block
}

// Closures - functions remember their lexical scope
function createCounter() {
    let count = 0;
    
    return function() {
        count++;
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// count variable is private and preserved between calls

// Closures with parameters
function multiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = multiplier(2);
const triple = multiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15</code></pre>
                </div>
                
                <p><strong>Safe Metaphor:</strong> A closure is like a safe that contains variables from its surrounding environment. The function is the combination that opens the safe, allowing access to those variables even after the outer function has finished executing.</p>
                
                <p><strong>Python Comparison:</strong> JavaScript closures are similar to Python's function closures, but with different scoping rules around blocks.</p>
            </div>
            
            <div class="this_keyword">
                <h4>The 'this' Keyword</h4>
                <p>One of the most confusing aspects of JavaScript for Python developers is the 'this' keyword:</p>
                
                <div class="code_example">
                    <pre><code>// The value of 'this' depends on how a function is called
console.log(this); // In browser: Window object; In Node.js: global object

// In a method
const person = {
    name: "Alice",
    greet: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};

person.greet(); // "Hello, my name is Alice"

// When the method is assigned to a variable
const greetFunc = person.greet;
// greetFunc(); // "Hello, my name is undefined" (this is no longer person)

// Using 'bind', 'call', or 'apply' to control 'this'
greetFunc.call(person); // "Hello, my name is Alice"

const otherPerson = { name: "Bob" };
person.greet.call(otherPerson); // "Hello, my name is Bob"

// Arrow functions and 'this'
const team = {
    members: ["Alice", "Bob"],
    leader: "Charlie",
    
    showMembers: function() {
        // Traditional function creates a new 'this' binding
        this.members.forEach(function(member) {
            // 'this' here refers to the global object, not team
            console.log(`${member} works with ${this.leader}`); // undefined leader
        });
        
        // Arrow function captures 'this' from surrounding context
        this.members.forEach(member => {
            // 'this' here still refers to team
            console.log(`${member} works with ${this.leader}`); // Charlie
        });
    }
};

team.showMembers();</code></pre>
                </div>
                
                <p><strong>Elastic Band Metaphor:</strong> Think of this as an elastic band that connects a function to an object. Regular functions create a new band, attached to whatever calls them. Arrow functions don't make their own band - they use the parent function's connection. The band can also be manually tied to objects using bind, call, or apply.</p>
                
                <p><strong>Python Comparison:</strong> This contrasts with Python's explicit self parameter in class methods. JavaScript's this is implicitly determined and can change based on call context.</p>
            </div>
        </section>

        <section class="objects_prototypes">
            <h3>Objects and Prototypes</h3>
            <p>JavaScript uses prototype-based inheritance rather than the class-based inheritance familiar to Python developers.</p>
            
            <div class="creating_objects">
                <h4>Creating Objects</h4>
                <div class="code_example">
                    <pre><code>// Object literal
const person = {
    firstName: "John",
    lastName: "Doe",
    age: 30,
    fullName: function() {
        return `${this.firstName} ${this.lastName}`;
    }
};

// Property access
console.log(person.firstName); // "John"
console.log(person["lastName"]); // "Doe"

// Dynamic properties
const key = "age";
console.log(person[key]); // 30

// Adding properties
person.email = "john@example.com";

// Deleting properties
delete person.age;

// Object property shorthand (ES6)
const name = "Alice";
const role = "developer";
const user = { name, role }; // Same as { name: name, role: role }

// Computed property names (ES6)
const propName = "job_title";
const employee = {
    [propName]: "Software Engineer"
};
console.log(employee.job_title); // "Software Engineer"

// Method shorthand (ES6)
const calculator = {
    add(a, b) {
        return a + b;
    },
    subtract(a, b) {
        return a - b;
    }
};</code></pre>
                </div>
            </div>
            
            <div class="prototype_inheritance">
                <h4>Prototype Inheritance</h4>
                <div class="code_example">
                    <pre><code>// Constructor function (pre-ES6 way to define "classes")
function Person(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
}

// Adding methods to the prototype
Person.prototype.fullName = function() {
    return `${this.firstName} ${this.lastName}`;
};

// Creating instances
const john = new Person("John", "Doe");
const jane = new Person("Jane", "Smith");

console.log(john.fullName()); // "John Doe"
console.log(jane.fullName()); // "Jane Smith"

// Inheritance using prototypes
function Employee(firstName, lastName, position) {
    // Call the parent constructor
    Person.call(this, firstName, lastName);
    this.position = position;
}

// Set up prototype chain
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

// Add methods to Employee
Employee.prototype.getRole = function() {
    return `${this.fullName()} - ${this.position}`;
};

const alice = new Employee("Alice", "Johnson", "Developer");
console.log(alice.fullName()); // "Alice Johnson" (inherited method)
console.log(alice.getRole()); // "Alice Johnson - Developer"</code></pre>
                </div>
                
                <p><strong>Family Tree Metaphor:</strong> JavaScript's prototype inheritance is like a family tree. Objects inherit traits (properties and methods) from their prototype ancestor. When you look for a property, JavaScript first checks the object itself, then its parent, grandparent, and so on up the chain.</p>
            </div>
            
            <div class="es6_classes">
                <h4>ES6 Classes</h4>
                <p>ES6 introduced a class syntax that will feel more familiar to Python developers, but under the hood it still uses prototypes:</p>
                
                <div class="code_example">
                    <pre><code>// ES6 Class syntax
class Person {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    
    fullName() {
        return `${this.firstName} ${this.lastName}`;
    }
    
    // Static method (on the class, not instances)
    static createAnonymous() {
        return new Person("John", "Doe");
    }
}

const john = new Person("John", "Smith");
console.log(john.fullName()); // "John Smith"

// Inheritance with classes
class Employee extends Person {
    constructor(firstName, lastName, position) {
        super(firstName, lastName); // Call parent constructor
        this.position = position;
    }
    
    getRole() {
        return `${this.fullName()} - ${this.position}`;
    }
    
    // Override parent method
    fullName() {
        return `${this.lastName}, ${this.firstName}`;
    }
}

const alice = new Employee("Alice", "Johnson", "Developer");
console.log(alice.fullName()); // "Johnson, Alice" (overridden method)
console.log(alice.getRole()); // "Johnson, Alice - Developer"</code></pre>
                </div>
                
                <p><strong>Python Comparison:</strong> JavaScript's ES6 classes provide syntax similar to Python classes, but with important differences in how instantiation, inheritance, and private members work.</p>
            </div>
        </section>

        <section class="arrays_collections">
            <h3>Arrays and Collections</h3>
            <p>Arrays are JavaScript's primary ordered collection type, similar to Python lists but with different methods and behaviors:</p>
            
            <div class="arrays_basics">
                <h4>Array Basics</h4>
                <div class="code_example">
                    <pre><code>// Creating arrays
const numbers = [1, 2, 3, 4, 5];
const empty = [];
const mixed = [1, "two", { three: 3 }, [4, 5]];
const created = new Array(3); // [empty Ã— 3]

// Accessing elements
console.log(numbers[0]); // 1
console.log(numbers[numbers.length - 1]); // 5

// Array properties
console.log(numbers.length); // 5

// Modifying arrays
numbers[1] = 20; // [1, 20, 3, 4, 5]

// JavaScript arrays can have "holes"
const sparse = [1, , 3]; // [1, empty, 3]
console.log(sparse.length); // 3

// Array can be modified even if declared with const
const arr = [1, 2, 3];
arr.push(4); // Works! (changes content, not reference)
// arr = [5, 6, 7]; // Error: Assignment to constant variable</code></pre>
                </div>
                
                <p><strong>Swiss Army Knife Metaphor:</strong> JavaScript arrays are like a Swiss Army knife - versatile tools that can hold different types of items, change size dynamically, and offer many built-in operations. Unlike Python's specialized tools (lists, tuples, sets), JavaScript arrays try to do a bit of everything.</p>
            </div>
            
            <div class="array_methods">
                <h4>Common Array Methods</h4>
                <div class="code_example">
                    <pre><code>const numbers = [1, 2, 3, 4, 5];
const fruits = ["apple", "banana", "cherry"];

// Mutating methods (change the original array)
numbers.push(6);     // Add to end: [1, 2, 3, 4, 5, 6]
numbers.pop();       // Remove from end: [1, 2, 3, 4, 5], returns 6
numbers.unshift(0);  // Add to beginning: [0, 1, 2, 3, 4, 5]
numbers.shift();     // Remove from beginning: [1, 2, 3, 4, 5], returns 0
numbers.splice(2, 1); // Remove 1 element at index 2: [1, 2, 4, 5]
numbers.splice(2, 0, 3); // Insert 3 at index 2: [1, 2, 3, 4, 5]
numbers.reverse();   // Reverse array: [5, 4, 3, 2, 1]
numbers.sort();      // Sort array: [1, 2, 3, 4, 5]

// Non-mutating methods (return new arrays)
const doubled = numbers.map(x => x * 2);    // [2, 4, 6, 8, 10]
const even = numbers.filter(x => x % 2 === 0); // [2, 4]
const sum = numbers.reduce((acc, x) => acc + x, 0); // 15
const allPositive = numbers.every(x => x > 0); // true
const hasEven = numbers.some(x => x % 2 === 0); // true
const found = numbers.find(x => x > 3); // 4
const foundIndex = numbers.findIndex(x => x > 3); // 3

// Searching in arrays
const cherryIndex = fruits.indexOf("cherry"); // 2
const bananaIncludes = fruits.includes("banana"); // true

// Combining arrays
const combined = numbers.concat(fruits); // [1, 2, 3, 4, 5, "apple", "banana", "cherry"]
const sliced = numbers.slice(1, 4); // [2, 3, 4] (start index, end index exclusive)

// Converting to string
const joined = fruits.join(", "); // "apple, banana, cherry"

// ES6+ array methods
const flattenedArray = [1, [2, 3], [4, [5]]].flat(); // [1, 2, 3, 4, [5]]
const deepFlattenedArray = [1, [2, 3], [4, [5]]].flat(Infinity); // [1, 2, 3, 4, 5]
const entries = fruits.entries(); // Iterator with [index, value] pairs</code></pre>
                </div>
                
                <p><strong>Python Comparison:</strong> Many of these methods are similar to Python's list methods, but with different names (e.g., append vs push) and behaviors (e.g., splice has no direct Python equivalent).</p>
            </div>
            
            <div class="additional_collections">
                <h4>Maps, Sets, and Other Collections</h4>
                <div class="code_example">
                    <pre><code>// Sets (ES6) - collections of unique values
const uniqueNumbers = new Set([1, 2, 3, 2, 1]); // {1, 2, 3}
uniqueNumbers.add(4); // {1, 2, 3, 4}
uniqueNumbers.delete(2); // {1, 3, 4}
console.log(uniqueNumbers.has(3)); // true
console.log(uniqueNumbers.size); // 3

// Maps (ES6) - key-value pairs where keys can be any type
const userRoles = new Map();
userRoles.set("john", "admin");
userRoles.set("jane", "user");
userRoles.set(john, "moderator"); // Object as key
console.log(userRoles.get("john")); // "admin"
console.log(userRoles.has("jane")); // true
userRoles.delete("jane");
console.log(userRoles.size); // 1

// Weak collections (WeakMap, WeakSet)
// Allow garbage collection of their keys
const weakMap = new WeakMap();
weakMap.set(john, "user data");
// When john object is no longer referenced elsewhere, it can be garbage collected</code></pre>
                </div>
                
                <p><strong>Python Comparison:</strong> JavaScript's Map is similar to Python's dict but allows any type as keys. JS Set is similar to Python's set but with different method names.</p>
            </div>
        </section>

        <section class="errors_exceptions">
            <h3>Error Handling</h3>
            <p>JavaScript uses a try-catch mechanism for error handling, similar to Python's try-except:</p>
            
            <div class="try_catch">
                <h4>Try-Catch-Finally</h4>
                <div class="code_example">
                    <pre><code>// Basic try-catch
try {
    // Code that might throw an error
    const result = nonExistentFunction();
    console.log(result);
} catch (error) {
    // Handle the error
    console.error("An error occurred:", error.message);
}

// Try-catch-finally
try {
    console.log("Attempting risky operation");
    if (Math.random() > 0.5) {
        throw new Error("Random failure");
    }
    console.log("Operation succeeded");
} catch (error) {
    console.error("Operation failed:", error.message);
} finally {
    console.log("Cleanup code - runs regardless of success or failure");
}

// Catching specific error types
try {
    JSON.parse("invalid json");
} catch (error) {
    if (error instanceof SyntaxError) {
        console.error("JSON parsing error:", error.message);
    } else {
        console.error("Other error:", error.message);
    }
}

// Creating custom errors
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = "ValidationError";
    }
}

function validateUser(user) {
    if (!user.name) {
        throw new ValidationError("Name is required");
    }
    if (!user.email) {
        throw new ValidationError("Email is required");
    }
    return true;
}

try {
    validateUser({ name: "Alice" });
} catch (error) {
    if (error instanceof ValidationError) {
        console.error("Validation failed:", error.message);
    } else {
        console.error("Unknown error:", error);
    }
}</code></pre>
                </div>
                
                <p><strong>Python Comparison:</strong> JavaScript's try-catch is similar to Python's try-except, but with different syntax. JavaScript doesn't have a built-in way to catch specific error types by listing them, so instanceof checks are used.</p>
            </div>
        </section>

        <section class="async_js">
            <h3>Asynchronous JavaScript Basics</h3>
            <p>JavaScript's asynchronous nature is a fundamental concept that differs from Python's primarily synchronous execution model.</p>
            
            <div class="callbacks">
                <h4>Callbacks (Traditional)</h4>
                <div class="code_example">
                    <pre><code>// Callbacks are functions passed as arguments to be executed later
function getUserData(userId, callback) {
    // Simulate async operation (e.g., API request)
    setTimeout(() => {
        const user = { id: userId, name: "Alice", role: "admin" };
        callback(user);
    }, 1000);
}

getUserData(123, function(user) {
    console.log("User data received:", user);
});

console.log("This runs before user data is received");

// Callback hell - nested callbacks
getUserData(123, function(user) {
    console.log("Got user:", user.name);
    
    getPermissions(user.role, function(permissions) {
        console.log("Got permissions:", permissions);
        
        getFeatureAccess(permissions, function(features) {
            console.log("Got features:", features);
            
            // More nested callbacks...
        });
    });
});</code></pre>
                </div>
                
                <p><strong>Restaurant Metaphor:</strong> Asynchronous JavaScript with callbacks is like ordering at a busy restaurant. After placing your order (making a request), you get a buzzer (the callback function) instead of waiting at the counter. You're free to do other things (execute other code), and when your order is ready, the buzzer calls you back to pick it up (the callback executes).</p>
            </div>
            
            <div class="promises">
                <h4>Promises (ES6)</h4>
                <div class="code_example">
                    <pre><code>// Promises represent a value that may not be available yet
function getUserData(userId) {
    return new Promise((resolve, reject) => {
        // Simulate async operation
        setTimeout(() => {
            const user = { id: userId, name: "Alice", role: "admin" };
            resolve(user); // Success case
            
            // For error case: reject(new Error("User not found"));
        }, 1000);
    });
}

// Using promises
getUserData(123)
    .then(user => {
        console.log("Got user:", user.name);
        return getPermissions(user.role); // Return another promise
    })
    .then(permissions => {
        console.log("Got permissions:", permissions);
        return getFeatureAccess(permissions); // Return another promise
    })
    .then(features => {
        console.log("Got features:", features);
    })
    .catch(error => {
        console.error("Error in promise chain:", error.message);
    })
    .finally(() => {
        console.log("Promise chain completed");
    });
    
// Promise utility methods
Promise.all([getUserData(123), getPermissions("admin")])
    .then(([user, permissions]) => {
        console.log("Both promises resolved:", user, permissions);
    });
    
Promise.race([fastAPI(), slowAPI()])
    .then(result => {
        console.log("Fastest API returned:", result);
    });</code></pre>
                </div>
            </div>
            
            <div class="async_await">
                <h4>Async/Await (ES2017)</h4>
                <div class="code_example">
                    <pre><code>// Async functions always return promises
async function getUserInfo(userId) {
    try {
        // Await pauses execution until the promise resolves
        const user = await getUserData(userId);
        console.log("Got user:", user.name);
        
        const permissions = await getPermissions(user.role);
        console.log("Got permissions:", permissions);
        
        const features = await getFeatureAccess(permissions);
        console.log("Got features:", features);
        
        return { user, permissions, features };
    } catch (error) {
        console.error("Error in async function:", error.message);
        throw error; // Re-throw or handle
    }
}

// Using async function
getUserInfo(123)
    .then(result => {
        console.log("All data:", result);
    })
    .catch(error => {
        console.error("Caught outside:", error.message);
    });
    
// Parallel operations with async/await
async function getMultipleUsers() {
    const userPromises = [getUserData(1), getUserData(2), getUserData(3)];
    const users = await Promise.all(userPromises);
    return users;
}</code></pre>
                </div>
                
                <p><strong>Python Comparison:</strong> Async/await in JavaScript is conceptually similar to Python's asyncio syntax, but with different execution model details.</p>
            </div>
        </section>

        <section class="modules">
            <h3>Modules and Imports</h3>
            <p>JavaScript has evolved multiple module systems, with ES6 modules now being the standard:</p>
            
            <div class="es6_modules">
                <h4>ES6 Modules</h4>
                <div class="code_example">
                    <pre><code>// math.js - Exporting functionality
export const PI = 3.14159;

export function square(x) {
    return x * x;
}

export function cube(x) {
    return x * x * x;
}

// Default export - only one per module
export default function multiply(a, b) {
    return a * b;
}

// app.js - Importing functionality
import multiply, { PI, square, cube } from './math.js';

console.log(PI);            // 3.14159
console.log(square(4));     // 16
console.log(cube(3));       // 27
console.log(multiply(2, 5)); // 10

// Renaming imports
import { square as getSquare } from './math.js';
console.log(getSquare(4));  // 16

// Importing everything
import * as Math from './math.js';
console.log(Math.PI);       // 3.14159
console.log(Math.square(4)); // 16
console.log(Math.default(2, 5)); // 10 (default export is under .default)</code></pre>
                </div>
                
                <p><strong>Python Comparison:</strong> ES6 modules are similar to Python's import system, but with a different syntax. JavaScript distinguishes between default and named exports, unlike Python.</p>
            </div>
            
            <div class="older_module_systems">
                <h4>Older Module Systems</h4>
                <div class="code_example">
                    <pre><code>// CommonJS (Node.js) - still widely used in Node.js
// math.js
const PI = 3.14159;

function square(x) {
    return x * x;
}

module.exports = {
    PI,
    square,
    multiply: function(a, b) {
        return a * b;
    }
};

// app.js
const math = require('./math.js');
console.log(math.PI);        // 3.14159
console.log(math.square(4)); // 16

// Destructuring in require
const { PI, multiply } = require('./math.js');
console.log(multiply(2, 5)); // 10</code></pre>
                </div>
            </div>
        </section>
        
        <section class="debugging_tools">
            <h3>Debugging and Developer Tools</h3>
            <p>JavaScript offers several ways to debug and inspect your code:</p>
            
            <div class="console_methods">
                <h4>Console Methods</h4>
                <div class="code_example">
                    <pre><code>// Basic logging
console.log("Hello, world!"); // General logging
console.info("Information"); // Informational message
console.warn("Warning"); // Warning message (yellow in most consoles)
console.error("Error!"); // Error message (red in most consoles)

// Structured output
console.table([
    { name: "Alice", age: 25 },
    { name: "Bob", age: 30 }
]); // Displays as table

// Grouping logs
console.group("User Details");
console.log("Name: Alice");
console.log("Role: Admin");
console.groupEnd();

// Timing operations
console.time("operation");
// ... some operation
console.timeEnd("operation"); // "operation: 1.23ms"

// Log with variable substitution
console.log("User %s logged in from %s", "Alice", "New York");

// Conditional logging
console.assert(1 === 2, "This will log because the assertion failed");</code></pre>
                </div>
            </div>
            
            <div class="browser_tools">
                <h4>Browser Developer Tools</h4>
                <ul>
                    <li><strong>Debugger statement:</strong> Add <code>debugger;</code> in your code to create a breakpoint</li>
                    <li><strong>Source panel:</strong> Set breakpoints, step through code, examine call stack</li>
                    <li><strong>Console panel:</strong> Interactive REPL to test code and see outputs</li>
                    <li><strong>Network panel:</strong> Monitor network requests and responses</li>
                    <li><strong>Performance panel:</strong> Analyze execution time and memory usage</li>
                </ul>
            </div>
        </section>

        <section class="python_comparison">
            <h3>JavaScript vs Python: Key Differences Summary</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>JavaScript</th>
                        <th>Python</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Syntax Structure</td>
                        <td>Curly braces for blocks</td>
                        <td>Indentation for blocks</td>
                    </tr>
                    <tr>
                        <td>Function Definition</td>
                        <td><code>function name() {}</code> or <code>const name = () => {}</code></td>
                        <td><code>def name():</code></td>
                    </tr>
                    <tr>
                        <td>Variable Declaration</td>
                        <td>Requires <code>var</code>, <code>let</code>, or <code>const</code></td>
                        <td>Direct assignment declares variables</td>
                    </tr>
                    <tr>
                        <td>Scoping</td>
                        <td>Block-scoped (<code>let</code>/<code>const</code>) or function-scoped (<code>var</code>)</td>
                        <td>Function-scoped with some block scope (modern Python)</td>
                    </tr>
                    <tr>
                        <td>Arrays/Lists</td>
                        <td>Single <code>Array</code> type with many methods</td>
                        <td>Multiple sequence types (<code>list</code>, <code>tuple</code>, etc.)</td>
                    </tr>
                    <tr>
                        <td>Objects/Dictionaries</td>
                        <td>Objects with prototype inheritance</td>
                        <td>Dictionary type with key-value pairs</td>
                    </tr>
                    <tr>
                        <td>Equality Testing</td>
                        <td><code>==</code> (with coercion) and <code>===</code> (strict)</td>
                        <td>Only <code>==</code> (strict by default)</td>
                    </tr>
                    <tr>
                        <td>Inheritance Model</td>
                        <td>Prototype-based (even when using class syntax)</td>
                        <td>Class-based</td>
                    </tr>
                    <tr>
                        <td>Asynchronous Code</td>
                        <td>Single-threaded with callbacks, promises, async/await</td>
                        <td>Multi-threaded or asyncio</td>
                    </tr>
                    <tr>
                        <td>Logical Operators</td>
                        <td><code>&&</code>, <code>||</code>, <code>!</code></td>
                        <td><code>and</code>, <code>or</code>, <code>not</code></td>
                    </tr>
                    <tr>
                        <td>Error Handling</td>
                        <td><code>try/catch/finally</code></td>
                        <td><code>try/except/finally</code></td>
                    </tr>
                    <tr>
                        <td>Method Context</td>
                        <td>Implicit <code>this</code>, context can change</td>
                        <td>Explicit <code>self</code> parameter</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="modern_practices">
            <h3>Modern JavaScript Practices</h3>
            <p>When writing modern JavaScript, consider these practices used by professional developers:</p>
            
            <ul>
                <li><strong>Use ES6+ Features:</strong> Leverage arrow functions, template literals, destructuring, and other modern syntax</li>
                <li><strong>Prefer let/const over var:</strong> Use block scoping for clearer code and fewer bugs</li>
                <li><strong>Destructuring:</strong> Extract values from objects and arrays concisely</li>
                <li><strong>Spread/Rest Operators:</strong> Use <code>...</code> for flexible function parameters and array/object manipulation</li>
                <li><strong>Async/Await:</strong> Make asynchronous code more readable</li>
                <li><strong>Default Parameters:</strong> Provide fallback values in function definitions</li>
                <li><strong>Modules:</strong> Organize code into ES6 modules</li>
                <li><strong>Shorthand Properties:</strong> Use <code>{ name }</code> instead of <code>{ name: name }</code></li>
            </ul>
            
            <div class="code_example">
                <h4>Modern Code Example</h4>
                <pre><code>// Modern JavaScript Example

// ES6 Modules
import { api } from './api.js';

// Arrow functions 
const getUser = async (id) => {
    try {
        // Template literals
        const url = `/users/${id}`;
        
        // Async/await
        const response = await api.get(url);
        
        // Destructuring
        const { name, email, role = 'user' } = response.data;
        
        // Shorthand properties and computed properties
        const timestamp = Date.now();
        const user = {
            id,
            name,
            email,
            role,
            [`lastAccessed_${timestamp}`]: new Date().toISOString()
        };
        
        // Rest/spread operators
        const publicData = { ...user };
        delete publicData.email;
        
        return publicData;
    } catch (error) {
        // Enhanced error objects in ES6+
        console.error(`Error fetching user ${id}:`, error?.message);
        throw error;
    }
};

// Array methods
const users = [
    { id: 1, name: 'Alice', active: true },
    { id: 2, name: 'Bob', active: false },
    { id: 3, name: 'Charlie', active: true }
];

// Find, filter, map, reduce
const activeUsers = users.filter(user => user.active);
const userNames = activeUsers.map(user => user.name);
const usersByName = users.reduce((acc, user) => {
    acc[user.name] = user;
    return acc;
}, {});</code></pre>
            </div>
        </section>

        <section class="practice_exercises">
            <h3>Practice Exercises</h3>
            
            <div class="exercise">
                <h4>Exercise 1: Basic JavaScript Syntax</h4>
                <p>Write JavaScript equivalents for the following Python code snippets:</p>
                <ol>
                    <li>A function that calculates factorial</li>
                    <li>Filtering a list of numbers to get only the even ones</li>
                    <li>A class representing a Circle with radius, area, and circumference</li>
                    <li>A dict comprehension that creates a dictionary with numbers as keys and their squares as values</li>
                </ol>
            </div>
            
            <div class="exercise">
                <h4>Exercise 2: Data Transformation</h4>
                <p>Given a list of users with name, age, and role properties:</p>
                <ol>
                    <li>Filter to get only adults (age >= 18)</li>
                    <li>Transform to get an array of just names</li>
                    <li>Create an object where keys are roles and values are arrays of users with that role</li>
                    <li>Find the average age of all users</li>
                </ol>
                <p>Implement using both traditional loops and modern array methods.</p>
            </div>
            
            <div class="exercise">
                <h4>Exercise 3: Async JavaScript</h4>
                <p>Create a fake API with setTimeout that simulates fetching users, posts, and comments. Then:</p>
                <ol>
                    <li>Implement with callbacks</li>
                    <li>Refactor to use Promises</li>
                    <li>Refactor again to use async/await</li>
                    <li>Add proper error handling to all implementations</li>
                </ol>
            </div>
        </section>

        <section class="summary">
            <h3>Lecture Summary</h3>
            <p>In this JavaScript fundamentals review, we've covered:</p>
            
            <ul>
                <li>JavaScript's evolution and modern features</li>
                <li>Variables, data types, and type coercion</li>
                <li>Operators and expressions</li>
                <li>Control structures (conditionals and loops)</li>
                <li>Functions, scope, and closures</li>
                <li>Objects, prototypes, and ES6 classes</li>
                <li>Arrays and collection methods</li>
                <li>Error handling with try-catch</li>
                <li>Asynchronous JavaScript basics</li>
                <li>Modules and imports</li>
                <li>Debugging tools and techniques</li>
                <li>Comparisons with Python for full-stack developers</li>
            </ul>
            
            <p>This foundation will serve as the building blocks for our DOM manipulation and event handling sessions, which will enable you to create dynamic and interactive web interfaces. Remember that as Python developers, you already understand many programming concepts - the challenge is mostly about adapting to JavaScript's syntax and behavior differences.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
        <p>This lecture: <code>/04week/04week_4day_e.html</code></p>
    </footer>
</body>
</html>
