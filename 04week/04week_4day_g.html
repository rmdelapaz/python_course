<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creating and Removing Elements</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Creating and Removing Elements</h1>
        <h2>Week 4: Web Fundamentals - Thursday Afternoon Session</h2>
    </header>

    <main>
        <section class="lecture_intro">
            <h3>Dynamic DOM Manipulation</h3>
            <p>Welcome to our session on creating and removing DOM elements! Now that we understand how to select and traverse the DOM, we'll learn how to dynamically modify document structure by adding new elements and removing existing ones.</p>
            
            <p>This lecture belongs to Week 4: Web Fundamentals and is part of our Python Full Stack Developer course. You'll find this content in the folder structure: <code>/04week/04week_4day_g.html</code></p>
            
            <p>The ability to create and remove elements is fundamental to building interactive web applications. From adding items to a shopping cart, displaying notifications, to building entire interfaces on the fly - these techniques form the foundation of dynamic web development.</p>
        </section>

        <section class="why_dynamic_elements">
            <h3>Why Create and Remove Elements Dynamically?</h3>
            <p>Before diving into the how, let's understand why dynamic element manipulation is so valuable:</p>
            
            <ul>
                <li><strong>User Interaction Response:</strong> Add or remove content based on user actions</li>
                <li><strong>Data-Driven Interfaces:</strong> Generate UI elements from data received from a server</li>
                <li><strong>Progressive Enhancement:</strong> Add additional functionality for capable browsers</li>
                <li><strong>Performance Optimization:</strong> Load or render content only when needed</li>
                <li><strong>Interactive Forms:</strong> Add or remove form fields based on user selections</li>
                <li><strong>Content Management:</strong> Allow users to add, edit, or delete content</li>
            </ul>
            
            <p><strong>Lego Building Metaphor:</strong> Think of DOM manipulation as playing with digital Lego bricks. The initial HTML gives you a starting structure, but JavaScript allows you to add new pieces, rearrange them, or remove them entirely - all while people are already using and viewing your creation. You don't need to rebuild the entire model to make changes; you can modify just the parts you need.</p>
        </section>

        <section class="creating_elements">
            <h3>Creating New Elements</h3>
            <p>JavaScript provides several methods for creating new DOM elements from scratch:</p>
            
            <div class="create_element">
                <h4>Using createElement()</h4>
                <p>The most common method for creating a new element is <code>document.createElement()</code>:</p>
                
                <div class="code_example">
                    <pre><code>// Create a new paragraph element
const newParagraph = document.createElement('p');

// Add content to the paragraph
newParagraph.textContent = 'This is a dynamically created paragraph.';

// Add attributes to the paragraph
newParagraph.id = 'dynamic-paragraph';
newParagraph.className = 'highlight info-text';
newParagraph.setAttribute('data-created', Date.now());

// Add some styling
newParagraph.style.color = '#0066cc';
newParagraph.style.fontWeight = 'bold';
newParagraph.style.padding = '10px';

// Log the element (it's not in the document yet)
console.log(newParagraph);</code></pre>
                </div>
                
                <p>The <code>createElement()</code> method creates an element node with the specified tag name. At this point, the element exists in memory but is not yet part of the document. It's like having a Lego brick in your hand that hasn't been attached to your model yet.</p>
            </div>
            
            <div class="creating_text_nodes">
                <h4>Creating Text Nodes</h4>
                <p>While <code>textContent</code> and <code>innerHTML</code> are often used to add text to elements, you can also explicitly create text nodes:</p>
                
                <div class="code_example">
                    <pre><code>// Create a text node
const textNode = document.createTextNode('This is a standalone text node.');

// Create an element to contain it
const span = document.createElement('span');

// Append the text node to the span
span.appendChild(textNode);

// Alternative: Just use textContent
const anotherSpan = document.createElement('span');
anotherSpan.textContent = 'This is easier than using createTextNode().';</code></pre>
                </div>
                
                <p>Creating separate text nodes is rarely needed in modern JavaScript, as the <code>textContent</code> property provides a simpler way to set text. However, understanding text nodes is useful for more complex DOM manipulations.</p>
            </div>
            
            <div class="creating_complex_elements">
                <h4>Creating Complex Elements</h4>
                <p>For more complex elements with nested structures, you can build them piece by piece:</p>
                
                <div class="code_example">
                    <pre><code>// Create a card component
function createUserCard(user) {
    // Create the main container
    const card = document.createElement('div');
    card.className = 'user-card';
    card.id = `user-${user.id}`;
    
    // Create the image
    const avatar = document.createElement('img');
    avatar.src = user.avatar || 'default-avatar.png';
    avatar.alt = `${user.name}'s avatar`;
    avatar.className = 'user-avatar';
    
    // Create the name heading
    const name = document.createElement('h3');
    name.textContent = user.name;
    name.className = 'user-name';
    
    // Create the email paragraph
    const email = document.createElement('p');
    email.textContent = user.email;
    email.className = 'user-email';
    
    // Create the action button
    const button = document.createElement('button');
    button.textContent = 'View Profile';
    button.className = 'profile-button';
    button.addEventListener('click', function() {
        alert(`Viewing profile for ${user.name}`);
    });
    
    // Assemble the card by appending all elements
    card.appendChild(avatar);
    card.appendChild(name);
    card.appendChild(email);
    card.appendChild(button);
    
    // Return the complete element (still not in the document)
    return card;
}

// Example usage
const user = {
    id: 123,
    name: 'Jane Smith',
    email: 'jane@example.com',
    avatar: 'https://example.com/avatars/jane.jpg'
};

const userCard = createUserCard(user);
console.log(userCard);</code></pre>
                </div>
                
                <p>This pattern of creating a function that returns a complete element structure is very common in web development. It keeps your code organized and makes it easy to create multiple similar elements.</p>
            </div>
            
            <div class="html_string_approach">
                <h4>Creating Elements from HTML Strings</h4>
                <p>An alternative approach is to create elements from HTML strings using <code>innerHTML</code> or <code>insertAdjacentHTML()</code>:</p>
                
                <div class="code_example">
                    <pre><code>// Create a temporary container
const tempContainer = document.createElement('div');

// Set its HTML content
tempContainer.innerHTML = `
    &lt;div class="user-card" id="user-${user.id}"&gt;
        &lt;img src="${user.avatar || 'default-avatar.png'}" alt="${user.name}'s avatar" class="user-avatar"&gt;
        &lt;h3 class="user-name"&gt;${user.name}&lt;/h3&gt;
        &lt;p class="user-email"&gt;${user.email}&lt;/p&gt;
        &lt;button class="profile-button"&gt;View Profile&lt;/button&gt;
    &lt;/div&gt;
`;

// Get the created element
const userCard = tempContainer.firstElementChild;

// Add event listener (can't be done in the HTML string)
userCard.querySelector('.profile-button').addEventListener('click', function() {
    alert(`Viewing profile for ${user.name}`);
});</code></pre>
                </div>
                
                <p><strong>Security Warning:</strong> When using <code>innerHTML</code> with dynamic content, especially user input, be very careful about XSS (Cross-Site Scripting) vulnerabilities. Always sanitize any content that comes from users or external sources.</p>
                
                <p><strong>Template Literal Advantage:</strong> Modern JavaScript's template literals (using backticks) make it much easier to create multi-line HTML strings with embedded expressions.</p>
            </div>
            
            <div class="document_fragments">
                <h4>Using DocumentFragment for Efficiency</h4>
                <p>When creating multiple elements to add to the DOM, using a DocumentFragment can improve performance:</p>
                
                <div class="code_example">
                    <pre><code>// Creating many elements efficiently
function createUserList(users) {
    // Create a document fragment (a lightweight container)
    const fragment = document.createDocumentFragment();
    
    // Add each user to the fragment
    users.forEach(user => {
        const userElement = createUserCard(user);
        fragment.appendChild(userElement);
    });
    
    // Return the fragment with all users
    return fragment;
}

// Example usage
const users = [
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' },
    { id: 3, name: 'Charlie', email: 'charlie@example.com' }
    // Imagine dozens or hundreds more...
];

// Get the container where we want to add the users
const userContainer = document.getElementById('user-container');

// Create all user elements and add them in one operation
const userListFragment = createUserList(users);
userContainer.appendChild(userListFragment);

// This causes only ONE reflow instead of one per user!</code></pre>
                </div>
                
                <p><strong>Performance Metaphor:</strong> Think of DocumentFragment as a staging area. Instead of adding furniture to a room one piece at a time (causing people to navigate around each new piece), you arrange everything in the hallway first, then move it all in at once, causing only one disruption.</p>
            </div>
            
            <div class="cloning_elements">
                <h4>Cloning Existing Elements</h4>
                <p>Sometimes it's easier to clone an existing element than to create a new one from scratch:</p>
                
                <div class="code_example">
                    <pre><code>// Get an existing element to clone
const originalItem = document.querySelector('.list-item');

// Clone it - the 'true' parameter means clone all descendants too
const clonedItem = originalItem.cloneNode(true);

// Modify the clone
clonedItem.id = 'new-item-' + Date.now();
clonedItem.querySelector('.item-title').textContent = 'New Item';

// Now you can add the clone to the document
document.getElementById('item-container').appendChild(clonedItem);</code></pre>
                </div>
                
                <p>Cloning is particularly useful when you need to create variations of existing complex elements, or when you want to use an element as a template.</p>
            </div>
            
            <div class="html_templates">
                <h4>Using HTML Templates</h4>
                <p>HTML provides a <code>&lt;template&gt;</code> element specifically designed for holding content that will be cloned and used later:</p>
                
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;template id="user-card-template"&gt;
//   &lt;div class="user-card"&gt;
//     &lt;img class="user-avatar"&gt;
//     &lt;h3 class="user-name"&gt;&lt;/h3&gt;
//     &lt;p class="user-email"&gt;&lt;/p&gt;
//     &lt;button class="profile-button"&gt;View Profile&lt;/button&gt;
//   &lt;/div&gt;
// &lt;/template&gt;

// JavaScript:
function createUserCardFromTemplate(user) {
    // Get the template
    const template = document.getElementById('user-card-template');
    
    // Clone the template content
    const userCard = template.content.cloneNode(true);
    
    // Get elements within the clone
    const card = userCard.querySelector('.user-card');
    const avatar = userCard.querySelector('.user-avatar');
    const name = userCard.querySelector('.user-name');
    const email = userCard.querySelector('.user-email');
    const button = userCard.querySelector('.profile-button');
    
    // Customize the elements
    card.id = `user-${user.id}`;
    avatar.src = user.avatar || 'default-avatar.png';
    avatar.alt = `${user.name}'s avatar`;
    name.textContent = user.name;
    email.textContent = user.email;
    
    // Add event listener
    button.addEventListener('click', function() {
        alert(`Viewing profile for ${user.name}`);
    });
    
    return userCard;
}

// Example usage
const userContainer = document.getElementById('user-container');
userContainer.appendChild(createUserCardFromTemplate(user));</code></pre>
                </div>
                
                <p>The <code>&lt;template&gt;</code> element is not rendered on the page but can be accessed via JavaScript. It's ideal for defining reusable structures that will be cloned multiple times.</p>
            </div>
        </section>

        <section class="adding_to_dom">
            <h3>Adding Elements to the Document</h3>
            <p>Once you've created an element, you need to insert it into the DOM to make it visible:</p>
            
            <div class="append_methods">
                <h4>Traditional Append Methods</h4>
                
                <div class="code_example">
                    <pre><code>// Get a container element
const container = document.getElementById('container');

// Create a new element
const newElement = document.createElement('div');
newElement.textContent = 'New content';

// Method 1: appendChild - adds to the end of the container
container.appendChild(newElement);

// Method 2: insertBefore - inserts before a reference element
const referenceElement = document.getElementById('existing-element');
container.insertBefore(newElement, referenceElement);

// Method 3: replaceChild - replaces an existing element
container.replaceChild(newElement, referenceElement);</code></pre>
                </div>
                
                <p>These traditional methods have been part of the DOM API for a long time and are well-supported across all browsers.</p>
            </div>
            
            <div class="modern_methods">
                <h4>Modern Insertion Methods (ES6+)</h4>
                <p>Modern browsers provide more intuitive methods for inserting elements:</p>
                
                <div class="code_example">
                    <pre><code>// Get a container and a reference element
const container = document.getElementById('container');
const referenceElement = document.getElementById('existing-element');

// Create new elements
const element1 = document.createElement('div');
element1.textContent = 'Element 1';

const element2 = document.createElement('div');
element2.textContent = 'Element 2';

// Method 1: append - adds to the end (can add multiple elements)
container.append(element1, element2, 'Text node too!'); 

// Method 2: prepend - adds to the beginning
container.prepend(element1);

// Method 3: before - inserts before the element
referenceElement.before(element1);

// Method 4: after - inserts after the element
referenceElement.after(element1);

// Method 5: replaceWith - replaces the element
referenceElement.replaceWith(element1);</code></pre>
                </div>
                
                <p>These newer methods are more intuitive and flexible, allowing you to insert multiple nodes at once and even mix element nodes with text.</p>
                
                <div class="code_example">
                    <pre><code>// Example: Insert multiple items at once
const list = document.querySelector('ul');
const items = ['Apple', 'Banana', 'Cherry'].map(fruit => {
    const li = document.createElement('li');
    li.textContent = fruit;
    return li;
});

// Add all items at once
list.append(...items); // Using spread operator with append</code></pre>
                </div>
            </div>
            
            <div class="insert_html">
                <h4>Inserting HTML Strings</h4>
                <p>For inserting content as HTML strings, these methods are available:</p>
                
                <div class="code_example">
                    <pre><code>// Method 1: innerHTML - replaces all content
container.innerHTML = '&lt;div class="new-content"&gt;New HTML content&lt;/div&gt;';

// Method 2: insertAdjacentHTML - more precise placement
// Positions: 'beforebegin', 'afterbegin', 'beforeend', 'afterend'
element.insertAdjacentHTML('beforeend', '&lt;div class="appended"&gt;Added at the end&lt;/div&gt;');
element.insertAdjacentHTML('afterbegin', '&lt;div class="prepended"&gt;Added at the beginning&lt;/div&gt;');
element.insertAdjacentHTML('beforebegin', '&lt;div&gt;Added before the element&lt;/div&gt;');
element.insertAdjacentHTML('afterend', '&lt;div&gt;Added after the element&lt;/div&gt;');</code></pre>
                </div>
                
                <p>The positions for <code>insertAdjacentHTML</code> correspond to:</p>
                <pre>
<!-- beforebegin -->
&lt;element&gt;
    <!-- afterbegin -->
    content
    <!-- beforeend -->
&lt;/element&gt;
<!-- afterend -->
                </pre>
                
                <p><strong>Warning:</strong> As with <code>innerHTML</code>, be cautious about XSS vulnerabilities when inserting HTML from untrusted sources.</p>
            </div>
        </section>

        <section class="removing_elements">
            <h3>Removing Elements from the DOM</h3>
            <p>Removing elements is just as important as adding them. JavaScript provides several methods for removal:</p>
            
            <div class="remove_methods">
                <h4>Traditional Removal Method</h4>
                
                <div class="code_example">
                    <pre><code>// Traditional method: removeChild()
// Requires parent reference and child reference
const parent = document.getElementById('container');
const childToRemove = document.getElementById('old-element');
parent.removeChild(childToRemove);

// Store the removed element if needed
const removedElement = parent.removeChild(childToRemove);
console.log('Element removed:', removedElement);
// You can add it back elsewhere if needed
document.getElementById('archive').appendChild(removedElement);</code></pre>
                </div>
                
                <p>The traditional <code>removeChild()</code> method removes a child element from its parent and returns a reference to the removed element, which you can use elsewhere if needed.</p>
            </div>
            
            <div class="modern_removal">
                <h4>Modern Removal Method</h4>
                
                <div class="code_example">
                    <pre><code>// Modern method: remove()
// Doesn't require parent reference
const elementToRemove = document.getElementById('old-element');
elementToRemove.remove();

// Remove multiple elements
document.querySelectorAll('.temporary').forEach(element => {
    element.remove();
});</code></pre>
                </div>
                
                <p>The modern <code>remove()</code> method is simpler as it doesn't require a reference to the parent element. It's supported in all modern browsers.</p>
            </div>
            
            <div class="clearing_content">
                <h4>Clearing Content Without Removing Elements</h4>
                
                <div class="code_example">
                    <pre><code>// Method 1: Clear innerHTML
container.innerHTML = '';

// Method 2: Remove all children (better for memory management)
function removeAllChildren(element) {
    while (element.firstChild) {
        element.removeChild(element.firstChild);
    }
}

removeAllChildren(document.getElementById('container'));

// Method 3: Modern alternative using textContent
container.textContent = ''; // Removes all children and replaces with nothing</code></pre>
                </div>
                
                <p>Sometimes you want to keep the container element but remove all its contents. The methods above show different approaches to clearing content.</p>
            </div>
            
            <div class="hiding_vs_removing">
                <h4>Hiding vs. Removing Elements</h4>
                
                <div class="code_example">
                    <pre><code>// Hiding an element (still in the DOM)
element.style.display = 'none';

// Show it again
element.style.display = '';

// Alternative using CSS classes
element.classList.add('hidden'); // CSS: .hidden { display: none; }
element.classList.remove('hidden'); // Show it again

// Versus removing (no longer in the DOM)
element.remove();</code></pre>
                </div>
                
                <p><strong>When to hide vs. remove:</strong></p>
                <ul>
                    <li><strong>Hide</strong> when you need to show the element again soon, or when removing would cause layout shifts</li>
                    <li><strong>Remove</strong> when the element is truly no longer needed, to free up memory and simplify the DOM</li>
                </ul>
                
                <p><strong>Theater Metaphor:</strong> Hiding an element is like an actor temporarily leaving the stage but remaining backstage - they can quickly return when needed. Removing an element is like the actor leaving the theater entirely - bringing them back requires a whole new entrance process.</p>
            </div>
        </section>

        <section class="memory_management">
            <h3>Memory Management and Performance</h3>
            <p>When creating and removing elements dynamically, it's important to consider memory management:</p>
            
            <div class="memory_leaks">
                <h4>Avoiding Memory Leaks</h4>
                
                <div class="code_example">
                    <pre><code>// Potential memory leak - storing references to removed elements
let removedElements = [];

function removeElement(id) {
    const element = document.getElementById(id);
    element.remove();
    
    // Storing reference prevents garbage collection
    removedElements.push(element);
}

// Better approach - clean up event listeners before removal
function safelyRemoveElement(id) {
    const element = document.getElementById(id);
    
    // Remove all event listeners
    element.replaceWith(element.cloneNode(true));
    
    // Now safe to remove
    element.remove();
}

// Or specifically clean up known listeners
function cleanupElement(element) {
    // Remove specific listeners
    element.removeEventListener('click', knownClickHandler);
    
    // Consider child elements that might have listeners
    element.querySelectorAll('button').forEach(button => {
        button.removeEventListener('click', buttonHandler);
    });
    
    element.remove();
}</code></pre>
                </div>
                
                <p>A common cause of memory leaks is holding onto references to DOM elements after they've been removed from the document. Event listeners can also prevent garbage collection if not properly cleaned up.</p>
            </div>
            
            <div class="performance_considerations">
                <h4>Performance Optimization</h4>
                
                <div class="code_example">
                    <pre><code>// Bad: Causes multiple reflows
const list = document.getElementById('long-list');
for (let i = 0; i < 100; i++) {
    const item = document.createElement('li');
    item.textContent = `Item ${i}`;
    list.appendChild(item); // Causes layout recalculation each time
}

// Better: Use document fragment
const list = document.getElementById('long-list');
const fragment = document.createDocumentFragment();

for (let i = 0; i < 100; i++) {
    const item = document.createElement('li');
    item.textContent = `Item ${i}`;
    fragment.appendChild(item);
}

list.appendChild(fragment); // Single reflow

// Alternative: Build HTML string
const list = document.getElementById('long-list');
let html = '';

for (let i = 0; i < 100; i++) {
    html += `&lt;li&gt;Item ${i}&lt;/li&gt;`;
}

list.innerHTML = html; // Single reflow, but careful with existing content</code></pre>
                </div>
                
                <p>When adding multiple elements, batch your DOM operations to minimize reflows and repaints, which are expensive operations that can cause performance issues.</p>
            </div>
            
            <div class="dom_reflow">
                <h4>Understanding Reflow and Repaint</h4>
                <p>DOM operations that change the layout trigger reflow (recalculation of element positions and sizes) and repaint (visual updates), which can be performance-intensive:</p>
                
                <ul>
                    <li><strong>Reflow-triggering operations:</strong> Adding/removing elements, changing element size or position, changing font, resizing the window, etc.</li>
                    <li><strong>Repaint-only operations:</strong> Changing color, background, visibility, etc. (things that don't affect layout)</li>
                </ul>
                
                <p><strong>Strategies to minimize performance impact:</strong></p>
                <ul>
                    <li>Batch DOM changes (use fragments or build HTML strings)</li>
                    <li>Modify detached elements before adding them to the DOM</li>
                    <li>Use CSS classes instead of inline style changes when possible</li>
                    <li>Consider absolute positioning for elements that move frequently</li>
                    <li>Minimize accessing properties that trigger reflow (like offsetWidth, clientHeight)</li>
                </ul>
            </div>
        </section>

        <section class="practical_applications">
            <h3>Practical Applications</h3>
            <p>Let's explore some real-world examples of creating and removing elements:</p>
            
            <div class="dynamic_list">
                <h4>Example 1: Dynamic List with Add/Remove Functionality</h4>
                
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div id="todo-app"&gt;
//   &lt;input id="new-todo" placeholder="Add a task"&gt;
//   &lt;button id="add-button"&gt;Add&lt;/button&gt;
//   &lt;ul id="todo-list"&gt;&lt;/ul&gt;
// &lt;/div&gt;

// JavaScript:
document.addEventListener('DOMContentLoaded', function() {
    const newTodoInput = document.getElementById('new-todo');
    const addButton = document.getElementById('add-button');
    const todoList = document.getElementById('todo-list');
    
    // Function to create a new todo item
    function createTodoItem(text) {
        // Create list item
        const li = document.createElement('li');
        li.className = 'todo-item';
        
        // Create text span
        const span = document.createElement('span');
        span.textContent = text;
        span.className = 'todo-text';
        
        // Create delete button
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.className = 'delete-button';
        
        // Add event listener to delete button
        deleteButton.addEventListener('click', function() {
            li.remove();
        });
        
        // Assemble the list item
        li.appendChild(span);
        li.appendChild(deleteButton);
        
        return li;
    }
    
    // Add button click handler
    addButton.addEventListener('click', function() {
        const text = newTodoInput.value.trim();
        if (text) {
            const newItem = createTodoItem(text);
            todoList.appendChild(newItem);
            newTodoInput.value = '';
            newTodoInput.focus();
        }
    });
    
    // Also handle Enter key in the input
    newTodoInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            addButton.click();
        }
    });
});</code></pre>
                </div>
                
                <p>This example creates a simple todo list where users can add new items and delete existing ones. It demonstrates creating elements with event handlers and removing elements on user action.</p>
            </div>
            
            <div class="dynamic_form">
                <h4>Example 2: Dynamic Form Fields</h4>
                
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;form id="dynamic-form"&gt;
//   &lt;div id="form-fields"&gt;
//     &lt;div class="form-row"&gt;
//       &lt;input type="text" name="name[]" placeholder="Name"&gt;
//       &lt;input type="email" name="email[]" placeholder="Email"&gt;
//       &lt;button type="button" class="remove-row"&gt;Remove&lt;/button&gt;
//     &lt;/div&gt;
//   &lt;/div&gt;
//   &lt;button type="button" id="add-row"&gt;Add Person&lt;/button&gt;
//   &lt;button type="submit"&gt;Submit&lt;/button&gt;
// &lt;/form&gt;

// JavaScript:
document.addEventListener('DOMContentLoaded', function() {
    const formFields = document.getElementById('form-fields');
    const addRowButton = document.getElementById('add-row');
    
    // Template for new rows
    function createFormRow() {
        const row = document.createElement('div');
        row.className = 'form-row';
        
        row.innerHTML = `
            &lt;input type="text" name="name[]" placeholder="Name" required&gt;
            &lt;input type="email" name="email[]" placeholder="Email" required&gt;
            &lt;button type="button" class="remove-row"&gt;Remove&lt;/button&gt;
        `;
        
        // Add event listener to the remove button
        row.querySelector('.remove-row').addEventListener('click', function() {
            // Only remove if there's more than one row
            if (formFields.children.length > 1) {
                row.remove();
            } else {
                alert('You need at least one person!');
            }
        });
        
        return row;
    }
    
    // Add row button click handler
    addRowButton.addEventListener('click', function() {
        formFields.appendChild(createFormRow());
    });
    
    // Initial setup: add event listener to the existing remove button
    document.querySelector('.remove-row').addEventListener('click', function() {
        alert('You need at least one person!');
    });
    
    // Form submission
    document.getElementById('dynamic-form').addEventListener('submit', function(e) {
        e.preventDefault();
        
        // Collect all form data
        const formData = new FormData(this);
        const names = formData.getAll('name[]');
        const emails = formData.getAll('email[]');
        
        // Create an array of people objects
        const people = names.map((name, i) => ({
            name,
            email: emails[i]
        }));
        
        console.log('Form data:', people);
        // In a real app, you would send this data to a server
    });
});</code></pre>
                </div>
                
                <p>This example demonstrates a form with dynamic rows that can be added or removed. It showcases creating complex elements with event handlers and preventing the removal of all elements when needed.</p>
            </div>
            
            <div class="infinite_scroll">
                <h4>Example 3: Infinite Scroll Content Loader</h4>
                
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div id="content-container"&gt;
//   &lt;!-- Initial content will be loaded here --&gt;
// &lt;/div&gt;
// &lt;div id="loading-spinner" style="display: none;"&gt;Loading...&lt;/div&gt;

// JavaScript:
document.addEventListener('DOMContentLoaded', function() {
    const contentContainer = document.getElementById('content-container');
    const loadingSpinner = document.getElementById('loading-spinner');
    
    let page = 1;
    let isLoading = false;
    
    // Function to create a content card
    function createContentCard(item) {
        const card = document.createElement('div');
        card.className = 'content-card';
        
        card.innerHTML = `
            &lt;h3&gt;${item.title}&lt;/h3&gt;
            &lt;p&gt;${item.description}&lt;/p&gt;
            &lt;a href="${item.link}"&gt;Read more&lt;/a&gt;
        `;
        
        return card;
    }
    
    // Function to load more content
    function loadMoreContent() {
        if (isLoading) return;
        
        isLoading = true;
        loadingSpinner.style.display = 'block';
        
        // Simulate API request with setTimeout
        setTimeout(() => {
            // In a real app, this would be a fetch() call to your API
            // Here we're generating dummy content
            const newItems = Array.from({ length: 5 }, (_, i) => ({
                title: `Item ${(page - 1) * 5 + i + 1}`,
                description: `This is the description for item ${(page - 1) * 5 + i + 1}...`,
                link: '#'
            }));
            
            // Create a fragment to hold all new content
            const fragment = document.createDocumentFragment();
            
            // Add each new item to the fragment
            newItems.forEach(item => {
                fragment.appendChild(createContentCard(item));
            });
            
            // Add all new content to the container at once
            contentContainer.appendChild(fragment);
            
            // Update state
            page++;
            isLoading = false;
            loadingSpinner.style.display = 'none';
        }, 1000); // Simulate network delay
    }
    
    // Load initial content
    loadMoreContent();
    
    // Check scroll position to load more content
    window.addEventListener('scroll', () => {
        // Check if user has scrolled to the bottom
        if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500) {
            loadMoreContent();
        }
    });
});</code></pre>
                </div>
                
                <p>This example demonstrates creating elements on-demand as the user scrolls down the page, a common pattern for social media feeds, article listings, and other content-heavy applications.</p>
            </div>
        </section>

        <section class="accessibility_considerations">
            <h3>Accessibility Considerations</h3>
            <p>When dynamically creating and removing elements, it's important to maintain accessibility:</p>
            
            <div class="aria_live">
                <h4>ARIA Live Regions</h4>
                
                <div class="code_example">
                    <pre><code>// HTML:
// &lt;div id="notification-area" aria-live="polite" aria-atomic="true"&gt;&lt;/div&gt;

// JavaScript:
function showNotification(message, type = 'info') {
    const notificationArea = document.getElementById('notification-area');
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    // Append to the live region
    notificationArea.appendChild(notification);
    
    // Remove after a delay
    setTimeout(() => {
        notification.classList.add('fade-out');
        notification.addEventListener('transitionend', () => {
            notification.remove();
        });
    }, 5000);
}</code></pre>
                </div>
                
                <p>ARIA live regions notify screen readers when their content changes. This is important for dynamic content like notifications, alerts, and real-time updates.</p>
            </div>
            
            <div class="focus_management">
                <h4>Focus Management</h4>
                
                <div class="code_example">
                    <pre><code>// After adding a new interactive element
function addNewInteractiveElement() {
    const container = document.getElementById('container');
    
    // Create a new button
    const newButton = document.createElement('button');
    newButton.textContent = 'New Action';
    newButton.id = 'new-action';
    
    // Add to the document
    container.appendChild(newButton);
    
    // Move focus to the new element
    newButton.focus();
}

// After removing an element that had focus
function removeWithFocusManagement(elementId) {
    const element = document.getElementById(elementId);
    const parent = element.parentElement;
    
    // Determine where to move focus next
    const nextFocus = element.nextElementSibling || 
                     element.previousElementSibling || 
                     parent;
    
    // Remove the element
    element.remove();
    
    // Move focus to the appropriate element
    nextFocus.focus();
}</code></pre>
                </div>
                
                <p>Proper focus management ensures that keyboard users can continue to navigate your interface efficiently after elements are added or removed.</p>
            </div>
            
            <div class="semantic_structure">
                <h4>Maintaining Semantic Structure</h4>
                
                <div class="code_example">
                    <pre><code>// Creating accessible elements
function createAccessibleDialog() {
    // Create the dialog container
    const dialog = document.createElement('div');
    dialog.role = 'dialog';
    dialog.setAttribute('aria-labelledby', 'dialog-title');
    dialog.setAttribute('aria-describedby', 'dialog-description');
    dialog.setAttribute('aria-modal', 'true');
    
    // Create the dialog header
    const header = document.createElement('header');
    
    const title = document.createElement('h2');
    title.id = 'dialog-title';
    title.textContent = 'Confirmation Required';
    
    const closeButton = document.createElement('button');
    closeButton.innerHTML = '&times;';
    closeButton.className = 'close-button';
    closeButton.setAttribute('aria-label', 'Close dialog');
    
    header.appendChild(title);
    header.appendChild(closeButton);
    
    // Create the dialog body
    const body = document.createElement('div');
    body.className = 'dialog-body';
    
    const description = document.createElement('p');
    description.id = 'dialog-description';
    description.textContent = 'Are you sure you want to delete this item?';
    
    body.appendChild(description);
    
    // Create the dialog actions
    const actions = document.createElement('div');
    actions.className = 'dialog-actions';
    
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.className = 'secondary-button';
    
    const confirmButton = document.createElement('button');
    confirmButton.textContent = 'Confirm';
    confirmButton.className = 'primary-button';
    
    actions.appendChild(cancelButton);
    actions.appendChild(confirmButton);
    
    // Assemble the dialog
    dialog.appendChild(header);
    dialog.appendChild(body);
    dialog.appendChild(actions);
    
    // Add event listeners
    closeButton.addEventListener('click', () => dialog.remove());
    cancelButton.addEventListener('click', () => dialog.remove());
    confirmButton.addEventListener('click', () => {
        // Handle the confirmation
        dialog.remove();
    });
    
    return dialog;
}

// Usage
document.body.appendChild(createAccessibleDialog());
// Remember to trap focus within the dialog too!</code></pre>
                </div>
                
                <p>When creating elements dynamically, ensure they maintain proper semantic structure with appropriate ARIA attributes, roles, and relationships.</p>
            </div>
        </section>

        <section class="modern_approaches">
            <h3>Modern Approaches and Framework Patterns</h3>
            <p>While direct DOM manipulation is fundamental, modern web development often uses more abstract approaches:</p>
            
            <div class="component_based">
                <h4>Component-Based Architecture</h4>
                <p>Modern frameworks use component-based architecture where components manage their own creation, update, and removal:</p>
                
                <div class="code_example">
                    <pre><code>// Vanilla JS component pattern
class TodoItem {
    constructor(text) {
        this.text = text;
        this.element = null;
        this.deleteCallback = null;
    }
    
    // Create the DOM element
    render() {
        if (this.element) return this.element;
        
        const li = document.createElement('li');
        li.className = 'todo-item';
        
        const span = document.createElement('span');
        span.textContent = this.text;
        span.className = 'todo-text';
        
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.className = 'delete-button';
        
        deleteButton.addEventListener('click', () => {
            if (this.deleteCallback) {
                this.deleteCallback(this);
            }
        });
        
        li.appendChild(span);
        li.appendChild(deleteButton);
        
        this.element = li;
        return li;
    }
    
    // Remove from the DOM
    remove() {
        if (this.element) {
            this.element.remove();
            this.element = null;
        }
    }
    
    // Update the text
    update(newText) {
        this.text = newText;
        if (this.element) {
            const span = this.element.querySelector('.todo-text');
            span.textContent = newText;
        }
    }
    
    // Set the deletion callback
    onDelete(callback) {
        this.deleteCallback = callback;
    }
}

// Usage
class TodoList {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.items = [];
    }
    
    addItem(text) {
        const item = new TodoItem(text);
        
        item.onDelete((item) => {
            this.removeItem(item);
        });
        
        this.items.push(item);
        this.container.appendChild(item.render());
    }
    
    removeItem(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
            item.remove();
        }
    }
}

// Initialize
const todoList = new TodoList('todo-list');
document.getElementById('add-button').addEventListener('click', () => {
    const input = document.getElementById('new-todo');
    const text = input.value.trim();
    if (text) {
        todoList.addItem(text);
        input.value = '';
        input.focus();
    }
});</code></pre>
                </div>
                
                <p>This component-based approach encapsulates element creation, event handling, and removal within reusable classes. Modern frameworks like React, Vue, and Angular extend this pattern with additional features like virtual DOM, data binding, and reactive updates.</p>
            </div>
            
            <div class="virtual_dom">
                <h4>Virtual DOM Approach</h4>
                <p>Frameworks like React use a virtual DOM to optimize updates:</p>
                
                <div class="code_example">
                    <pre><code>// React component example (not actual vanilla JS)
function TodoItem({ text, onDelete }) {
    return (
        &lt;li className="todo-item"&gt;
            &lt;span className="todo-text"&gt;{text}&lt;/span&gt;
            &lt;button 
                className="delete-button"
                onClick={onDelete}
            &gt;
                Delete
            &lt;/button&gt;
        &lt;/li&gt;
    );
}

function TodoList() {
    const [items, setItems] = useState([]);
    const [inputText, setInputText] = useState('');
    
    const addItem = () => {
        if (inputText.trim()) {
            setItems([...items, inputText]);
            setInputText('');
        }
    };
    
    const removeItem = (index) => {
        setItems(items.filter((_, i) => i !== index));
    };
    
    return (
        &lt;div&gt;
            &lt;input
                value={inputText}
                onChange={(e) => setInputText(e.target.value)}
                placeholder="Add a task"
            /&gt;
            &lt;button onClick={addItem}&gt;Add&lt;/button&gt;
            
            &lt;ul&gt;
                {items.map((text, index) => (
                    &lt;TodoItem
                        key={index}
                        text={text}
                        onDelete={() => removeItem(index)}
                    /&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>
                
                <p>The virtual DOM pattern abstracts away direct DOM manipulation. Instead of directly creating and removing elements, you describe the desired UI state, and the framework efficiently updates the real DOM to match.</p>
                
                <p><strong>Blueprint Metaphor:</strong> If vanilla DOM manipulation is like manually constructing a building brick by brick, the virtual DOM approach is like working with a detailed blueprint. You make all your changes to the blueprint, then the framework figures out the most efficient way to update the actual building to match your new design, minimizing construction disruption.</p>
            </div>
        </section>

        <section class="practice_exercises">
            <h3>Practice Exercises</h3>
            
            <div class="exercise">
                <h4>Exercise 1: Image Gallery Builder</h4>
                <p>Create a gallery builder that allows users to:</p>
                <ul>
                    <li>Add new images by URL</li>
                    <li>Remove existing images</li>
                    <li>Rearrange images via drag-and-drop or control buttons</li>
                    <li>Add captions to images</li>
                </ul>
                <p>This exercise will practice creating elements with complex structure and styling, as well as removing elements conditionally.</p>
            </div>
            
            <div class="exercise">
                <h4>Exercise 2: Dynamic Table Generator</h4>
                <p>Build a tool that allows users to:</p>
                <ul>
                    <li>Define a table structure (rows and columns)</li>
                    <li>Add and remove rows dynamically</li>
                    <li>Add and remove columns dynamically</li>
                    <li>Merge cells (advanced)</li>
                    <li>Export the table as HTML code</li>
                </ul>
                <p>This exercise will practice creating and manipulating complex nested structures like tables, along with maintaining proper relationships between elements.</p>
            </div>
            
            <div class="exercise">
                <h4>Exercise 3: Quiz Creator</h4>
                <p>Create an application that allows teachers to build a quiz:</p>
                <ul>
                    <li>Add different question types (multiple choice, true/false, short answer)</li>
                    <li>Edit questions after creation</li>
                    <li>Remove questions</li>
                    <li>Reorder questions</li>
                    <li>Preview the quiz as a student would see it</li>
                </ul>
                <p>This exercise will practice creating different element structures based on user choices, as well as updating existing elements without fully replacing them.</p>
            </div>
        </section>

        <section class="summary">
            <h3>Lecture Summary</h3>
            <p>In this exploration of creating and removing DOM elements, we've covered:</p>
            
            <ul>
                <li>Creating new elements with <code>createElement()</code> and other methods</li>
                <li>Building complex elements with nested structures</li>
                <li>Using fragments and templates for performance and reusability</li>
                <li>Adding elements to the DOM with various insertion methods</li>
                <li>Removing elements and cleaning up properly</li>
                <li>Memory management and performance considerations</li>
                <li>Practical applications for dynamic interfaces</li>
                <li>Accessibility considerations for dynamic content</li>
                <li>Modern component-based approaches</li>
            </ul>
            
            <p>These techniques for creating and removing elements are fundamental to building interactive web applications. Combined with element selection and traversal, you now have the core skills for comprehensive DOM manipulation.</p>
            
            <p>In our next session, we'll explore how to handle events, which will allow us to make our dynamic interfaces respond to user actions, completing our toolkit for creating truly interactive web experiences.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
        <p>This lecture: <code>/04week/04week_4day_g.html</code></p>
    </footer>
</body>
</html>
