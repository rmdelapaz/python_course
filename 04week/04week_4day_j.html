<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced DOM Patterns and Optimization</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
    <style>
        .code-example {
            background-color: #f5f5f5;
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
            margin-bottom: 20px;
            font-family: monospace;
        }
        
        .comparison {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .comparison-item {
            flex: 1;
            min-width: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
        }
        
        .comparison-item h4 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        .note {
            background-color: #e8f4f8;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
        }
        
        .warning {
            background-color: #fdebd0;
            border-left: 4px solid #f39c12;
            padding: 15px;
            margin: 20px 0;
        }
        
        .tip {
            background-color: #e9f7ef;
            border-left: 4px solid #27ae60;
            padding: 15px;
            margin: 20px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        table, th, td {
            border: 1px solid #ddd;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
        }
        
        th {
            background-color: #f5f5f5;
        }
        
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <header>
        <h1>Advanced DOM Patterns and Optimization</h1>
        <h2>Week 4: Thursday: Afternoon Session</h2>
        <h3>For JavaScript Developers</h3>
    </header>

    <main>
        <section id="introduction">
            <h2>Introduction</h2>
            <p>
                As JavaScript developers transitioning to full-stack development with Python, you already understand the basics of DOM manipulation. This session will focus on advanced patterns and optimization techniques that will help you build more performant web applications. We'll explore how these patterns integrate with backend Python frameworks and the broader full-stack architecture.
            </p>
            <p>
                By the end of this session, you'll have a deeper understanding of efficient DOM manipulation techniques that go beyond the basics, allowing you to create responsive and smooth user experiences regardless of which backend technology you're using.
            </p>
        </section>

        <section id="performance-considerations">
            <h2>Understanding DOM Performance</h2>
            <p>
                Before diving into advanced patterns, it's crucial to understand what makes DOM operations expensive and how browsers process them.
            </p>
            
            <h3>The Critical Rendering Path</h3>
            <ol>
                <li><strong>JavaScript</strong>: Execute scripts that might modify the DOM</li>
                <li><strong>Style Calculations</strong>: Compute styles based on CSS rules</li>
                <li><strong>Layout</strong>: Calculate the geometry of elements (reflow)</li>
                <li><strong>Paint</strong>: Fill in pixels for each element</li>
                <li><strong>Composite</strong>: Layer elements together to render on screen</li>
            </ol>
            
            <div class="note">
                <h4>Key Insight</h4>
                <p>
                    Modifying the DOM can trigger a partial or complete re-execution of this rendering pipeline. The deeper in the pipeline the change affects, the more expensive it becomes.
                </p>
            </div>
            
            <h3>Most Expensive DOM Operations</h3>
            <ul>
                <li><strong>Layout Thrashing</strong>: Repeatedly forcing the browser to recalculate layouts</li>
                <li><strong>Forced Synchronous Layout</strong>: Reading layout properties immediately after writing to the DOM</li>
                <li><strong>Excessive DOM Depth</strong>: Deep DOM trees take longer to process</li>
                <li><strong>Layout-triggering CSS Properties</strong>: Properties like width, height, top, left, etc.</li>
                <li><strong>Excessive DOM Size</strong>: Too many elements can slow down all operations</li>
            </ul>
        </section>

        <section id="batch-operations">
            <h2>Batch DOM Operations</h2>
            <p>
                One of the most effective patterns for optimizing DOM performance is batching operations to minimize browser reflows and repaints.
            </p>
            
            <h3>Document Fragments</h3>
            <p>
                Use DocumentFragment as an off-screen DOM container for preparing multiple DOM operations before a single insertion.
            </p>
            
            <div class="comparison">
                <div class="comparison-item">
                    <h4>Inefficient Approach</h4>
                    <div class="code-example">
<pre>
// Inefficient: causes multiple reflows
const list = document.querySelector('ul');
for (let i = 0; i < 100; i++) {
    const item = document.createElement('li');
    item.textContent = `Item ${i}`;
    list.appendChild(item); // Causes reflow on each iteration
}
</pre>
                    </div>
                </div>
                <div class="comparison-item">
                    <h4>Optimized Approach</h4>
                    <div class="code-example">
<pre>
// Efficient: single reflow
const list = document.querySelector('ul');
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
    const item = document.createElement('li');
    item.textContent = `Item ${i}`;
    fragment.appendChild(item);
}
list.appendChild(fragment); // Only one reflow
</pre>
                    </div>
                </div>
            </div>
            
            <h3>Avoiding Layout Thrashing</h3>
            <p>
                Layout thrashing occurs when you repeatedly force the browser to perform layout calculations by alternating between reading and writing to the DOM.
            </p>
            
            <div class="comparison">
                <div class="comparison-item">
                    <h4>Layout Thrashing Example</h4>
                    <div class="code-example">
<pre>
// Bad pattern: alternating reads and writes
const boxes = document.querySelectorAll('.box');
boxes.forEach(box => {
    const width = box.offsetWidth; // Read (forces layout)
    box.style.width = (width * 2) + 'px'; // Write
    const height = box.offsetHeight; // Read (forces another layout)
    box.style.height = (height * 2) + 'px'; // Write
});
</pre>
                    </div>
                </div>
                <div class="comparison-item">
                    <h4>Optimized Batching</h4>
                    <div class="code-example">
<pre>
// Good pattern: batch reads, then writes
const boxes = document.querySelectorAll('.box');
const dimensions = [];

// Read phase (all layout calculations done together)
boxes.forEach(box => {
    dimensions.push({
        width: box.offsetWidth,
        height: box.offsetHeight
    });
});

// Write phase (all DOM updates done together)
boxes.forEach((box, i) => {
    box.style.width = (dimensions[i].width * 2) + 'px';
    box.style.height = (dimensions[i].height * 2) + 'px';
});
</pre>
                    </div>
                </div>
            </div>
            
            <div class="tip">
                <h4>Pro Tip</h4>
                <p>
                    Consider using libraries like <a href="https://github.com/wilsonpage/fastdom" target="_blank">FastDOM</a> which automatically batch DOM reads and writes to prevent layout thrashing.
                </p>
            </div>
        </section>

        <section id="event-delegation">
            <h2>Advanced Event Delegation</h2>
            <p>
                Event delegation is a technique that leverages event bubbling to handle events at a higher level in the DOM rather than attaching listeners to individual elements.
            </p>
            
            <h3>Benefits of Event Delegation</h3>
            <ul>
                <li><strong>Memory Efficiency</strong>: Fewer event listeners means less memory usage</li>
                <li><strong>Dynamic Elements</strong>: Works with elements added to the DOM after initial page load</li>
                <li><strong>Less Code</strong>: Cleaner implementation with less setup code</li>
                <li><strong>Better Performance</strong>: Especially for large numbers of similar elements</li>
            </ul>
            
            <div class="comparison">
                <div class="comparison-item">
                    <h4>Without Event Delegation</h4>
                    <div class="code-example">
<pre>
// Inefficient for many elements
document.querySelectorAll('.menu-item').forEach(item => {
    item.addEventListener('click', function(e) {
        // Handle menu item click
        console.log('Menu item clicked:', this.textContent);
    });
});

// New items won't have listeners
const newItem = document.createElement('li');
newItem.className = 'menu-item';
newItem.textContent = 'New Item';
document.querySelector('.menu').appendChild(newItem);
</pre>
                    </div>
                </div>
                <div class="comparison-item">
                    <h4>With Event Delegation</h4>
                    <div class="code-example">
<pre>
// Single event listener
document.querySelector('.menu').addEventListener('click', function(e) {
    // Check if clicked element or its parent is a menu item
    const menuItem = e.target.closest('.menu-item');
    if (menuItem) {
        console.log('Menu item clicked:', menuItem.textContent);
    }
});

// New items will work automatically
const newItem = document.createElement('li');
newItem.className = 'menu-item';
newItem.textContent = 'New Item';
document.querySelector('.menu').appendChild(newItem);
</pre>
                    </div>
                </div>
            </div>
            
            <h3>Advanced Event Delegation Pattern</h3>
            <p>
                For complex applications, you can implement a more sophisticated event delegation system:
            </p>
            
            <div class="code-example">
<pre>
// Event delegation manager
class EventManager {
    constructor(rootElement = document) {
        this.rootElement = rootElement;
        this.handlersByEventType = {};
    }
    
    on(eventType, selector, handler) {
        if (!this.handlersByEventType[eventType]) {
            this.handlersByEventType[eventType] = [];
            
            // Create the delegated event handler
            this.rootElement.addEventListener(eventType, (e) => {
                this.handlersByEventType[eventType].forEach(entry => {
                    const matchingElements = Array.from(
                        this.rootElement.querySelectorAll(entry.selector)
                    );
                    
                    let element = e.target;
                    while (element && element !== this.rootElement) {
                        if (matchingElements.includes(element)) {
                            entry.handler.call(element, e, element);
                        }
                        element = element.parentElement;
                    }
                });
            });
        }
        
        this.handlersByEventType[eventType].push({ selector, handler });
        return this;
    }
    
    off(eventType, selector, handler) {
        if (!this.handlersByEventType[eventType]) return this;
        
        this.handlersByEventType[eventType] = this.handlersByEventType[eventType]
            .filter(entry => {
                return !(
                    entry.selector === selector && 
                    (!handler || entry.handler === handler)
                );
            });
            
        return this;
    }
}

// Usage example
const events = new EventManager();

// Multiple delegated handlers
events
    .on('click', '.btn-delete', function(e, element) {
        console.log('Delete clicked', element.dataset.id);
        e.preventDefault();
    })
    .on('click', '.btn-edit', function(e, element) {
        console.log('Edit clicked', element.dataset.id);
        e.preventDefault();
    })
    .on('change', '.item-checkbox', function(e, element) {
        console.log('Checkbox changed', element.checked);
    });
</pre>
            </div>
        </section>

        <section id="dom-recycling">
            <h2>DOM Recycling and Virtualization</h2>
            <p>
                For applications that need to display large datasets or lists, creating and destroying DOM elements can be expensive. DOM recycling and virtualization techniques reuse existing DOM elements instead of creating new ones.
            </p>
            
            <h3>DOM Recycling for Lists</h3>
            <p>
                The concept is simple: instead of removing elements from the DOM when they're no longer needed, hide them and reuse them when new data arrives.
            </p>
            
            <div class="code-example">
<pre>
class RecycledList {
    constructor(containerElement, itemTemplateId, itemHeight = 40) {
        this.container = containerElement;
        this.itemTemplate = document.getElementById(itemTemplateId).content;
        this.itemHeight = itemHeight;
        this.items = [];
        this.visibleItems = [];
        this.pool = []; // Recycled DOM elements
        this.visibleRange = { start: 0, end: 0 };
    }
    
    setItems(items) {
        this.items = items;
        this.container.style.height = `${items.length * this.itemHeight}px`;
        this.updateVisibleItems();
    }
    
    updateVisibleItems() {
        const containerRect = this.container.getBoundingClientRect();
        const scrollTop = this.container.scrollTop;
        
        // Calculate visible range
        const startIndex = Math.floor(scrollTop / this.itemHeight);
        const endIndex = Math.min(
            this.items.length - 1,
            Math.ceil((scrollTop + containerRect.height) / this.itemHeight)
        );
        
        // Get currently visible items
        const currentlyVisible = {};
        this.visibleItems.forEach(item => {
            currentlyVisible[item.index] = item;
        });
        
        const newVisibleItems = [];
        
        // Add new visible items
        for (let i = startIndex; i <= endIndex; i++) {
            if (currentlyVisible[i]) {
                // Keep existing visible item
                newVisibleItems.push(currentlyVisible[i]);
                delete currentlyVisible[i];
            } else {
                // Create new visible item
                const itemData = this.items[i];
                const element = this.pool.length > 0 
                    ? this.pool.pop() 
                    : this.createItemElement();
                
                // Position the element
                element.style.transform = `translateY(${i * this.itemHeight}px)`;
                
                // Update content
                this.updateItemElement(element, itemData);
                
                // Add to visible items
                newVisibleItems.push({ index: i, element, data: itemData });
            }
        }
        
        // Recycle items no longer visible
        Object.values(currentlyVisible).forEach(item => {
            this.container.removeChild(item.element);
            this.pool.push(item.element);
        });
        
        this.visibleItems = newVisibleItems;
    }
    
    createItemElement() {
        const element = document.importNode(this.itemTemplate, true).firstElementChild;
        element.style.position = 'absolute';
        element.style.width = '100%';
        element.style.height = `${this.itemHeight}px`;
        this.container.appendChild(element);
        return element;
    }
    
    updateItemElement(element, data) {
        // Override this method to update element content based on data
        element.textContent = JSON.stringify(data);
    }
}

// Usage example
const listContainer = document.querySelector('.virtual-list-container');
const virtualList = new RecycledList(listContainer, 'item-template');

// Extend the class to customize item rendering
class UserList extends RecycledList {
    updateItemElement(element, user) {
        element.querySelector('.user-name').textContent = user.name;
        element.querySelector('.user-email').textContent = user.email;
        element.querySelector('.user-avatar').src = user.avatar;
    }
}

// Handle scroll events
listContainer.addEventListener('scroll', () => {
    virtualList.updateVisibleItems();
});

// Load data
fetch('/api/users')
    .then(response => response.json())
    .then(users => {
        virtualList.setItems(users);
    });
</pre>
            </div>
            
            <div class="note">
                <h4>When to Use Virtualization</h4>
                <p>
                    Implement virtualization when you have lists with more than a few hundred items. For smaller lists, the complexity may not be worth the performance gain.
                </p>
            </div>
        </section>

        <section id="component-patterns">
            <h2>Component-Based Architecture Without Frameworks</h2>
            <p>
                While frameworks like React, Vue, and Angular provide robust component models, you can implement a similar architecture using vanilla JavaScript. This is particularly useful when integrating with Python backends that may have their own templating systems.
            </p>
            
            <h3>Simple Component Pattern</h3>
            <div class="code-example">
<pre>
class Component {
    constructor(props = {}) {
        this.props = props;
        this.state = {};
        this.element = null;
    }
    
    setState(newState) {
        const prevState = { ...this.state };
        this.state = { ...this.state, ...newState };
        this.update(prevState);
    }
    
    update(prevState) {
        // Override in subclasses
    }
    
    render() {
        // Override in subclasses
        return document.createElement('div');
    }
    
    mount(container) {
        this.element = this.render();
        container.appendChild(this.element);
        this.afterMount();
        return this;
    }
    
    afterMount() {
        // Hook for after mounting
    }
    
    unmount() {
        if (this.element && this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
    }
}

// Example component implementation
class TodoItem extends Component {
    constructor(props) {
        super(props);
        this.state = {
            completed: props.completed || false
        };
    }
    
    toggleComplete() {
        this.setState({ completed: !this.state.completed });
        if (this.props.onToggle) {
            this.props.onToggle(this.props.id, this.state.completed);
        }
    }
    
    update(prevState) {
        if (prevState.completed !== this.state.completed) {
            this.element.classList.toggle('completed', this.state.completed);
            this.element.querySelector('input').checked = this.state.completed;
        }
    }
    
    render() {
        const item = document.createElement('li');
        item.className = 'todo-item';
        if (this.state.completed) {
            item.classList.add('completed');
        }
        
        item.innerHTML = `
            <input type="checkbox" ${this.state.completed ? 'checked' : ''}>
            <span>${this.props.text}</span>
            <button class="delete-btn">×</button>
        `;
        
        item.querySelector('input').addEventListener('change', () => {
            this.toggleComplete();
        });
        
        item.querySelector('.delete-btn').addEventListener('click', () => {
            if (this.props.onDelete) {
                this.props.onDelete(this.props.id);
            }
        });
        
        return item;
    }
}

// Usage
const todoList = document.getElementById('todo-list');
const todos = [
    { id: 1, text: 'Learn advanced DOM patterns', completed: false },
    { id: 2, text: 'Build a component system', completed: true }
];

todos.forEach(todo => {
    new TodoItem({
        id: todo.id,
        text: todo.text,
        completed: todo.completed,
        onToggle: (id, completed) => {
            console.log(`Todo ${id} changed to ${completed ? 'completed' : 'active'}`);
        },
        onDelete: (id) => {
            console.log(`Delete todo ${id}`);
        }
    }).mount(todoList);
});
</pre>
            </div>
        </section>

        <section id="observer-pattern">
            <h2>Observer Pattern for DOM Updates</h2>
            <p>
                The Observer pattern (or Pub/Sub) can be extremely useful for managing DOM updates in response to data changes, especially in applications connected to Python backends.
            </p>
            
            <div class="code-example">
<pre>
class Observable {
    constructor() {
        this.observers = [];
    }
    
    subscribe(fn) {
        this.observers.push(fn);
        return () => {
            this.observers = this.observers.filter(obs => obs !== fn);
        };
    }
    
    notify(data) {
        this.observers.forEach(fn => fn(data));
    }
}

// Example: Todo List with Observer pattern
class TodoStore extends Observable {
    constructor() {
        super();
        this.todos = [];
    }
    
    addTodo(text) {
        const todo = {
            id: Date.now(),
            text,
            completed: false
        };
        
        this.todos = [...this.todos, todo];
        this.notify(this.todos);
    }
    
    toggleTodo(id) {
        this.todos = this.todos.map(todo => 
            todo.id === id 
                ? { ...todo, completed: !todo.completed } 
                : todo
        );
        this.notify(this.todos);
    }
    
    removeTodo(id) {
        this.todos = this.todos.filter(todo => todo.id !== id);
        this.notify(this.todos);
    }
}

class TodoListView {
    constructor(container, store) {
        this.container = container;
        this.store = store;
        this.unsubscribe = this.store.subscribe(todos => this.render(todos));
        
        // Form for adding new todos
        this.form = document.createElement('form');
        this.form.innerHTML = `
            <input type="text" placeholder="Add todo...">
            <button type="submit">Add</button>
        `;
        
        this.form.addEventListener('submit', e => {
            e.preventDefault();
            const input = this.form.querySelector('input');
            if (input.value.trim()) {
                this.store.addTodo(input.value.trim());
                input.value = '';
            }
        });
        
        this.list = document.createElement('ul');
        this.container.appendChild(this.form);
        this.container.appendChild(this.list);
    }
    
    render(todos) {
        // Clear previous items
        this.list.innerHTML = '';
        
        // Create fragment for batch update
        const fragment = document.createDocumentFragment();
        
        todos.forEach(todo => {
            const li = document.createElement('li');
            li.className = todo.completed ? 'completed' : '';
            li.innerHTML = `
                <input type="checkbox" ${todo.completed ? 'checked' : ''}>
                <span>${todo.text}</span>
                <button class="delete">×</button>
            `;
            
            li.querySelector('input').addEventListener('change', () => {
                this.store.toggleTodo(todo.id);
            });
            
            li.querySelector('.delete').addEventListener('click', () => {
                this.store.removeTodo(todo.id);
            });
            
            fragment.appendChild(li);
        });
        
        this.list.appendChild(fragment);
    }
    
    destroy() {
        // Clean up subscriptions when view is destroyed
        this.unsubscribe();
    }
}

// Usage
const todoStore = new TodoStore();
const todoListView = new TodoListView(
    document.getElementById('todo-container'),
    todoStore
);

// Simulate receiving data from Python backend
function syncWithBackend() {
    fetch('/api/todos')
        .then(response => response.json())
        .then(todos => {
            todos.forEach(todo => todoStore.addTodo(todo.text));
        });
}
</pre>
            </div>
            
            <div class="tip">
                <h4>Integration with Python Backends</h4>
                <p>
                    This pattern works well with Python frameworks like Flask or Django. You can use AJAX to fetch data from your API endpoints and then update your store, which will automatically trigger DOM updates through the observer pattern.
                </p>
            </div>
        </section>

        <section id="performance-monitoring">
            <h2>Performance Monitoring</h2>
            <p>
                Monitoring DOM performance is crucial for identifying optimization opportunities. Here are some techniques and tools to help you measure and improve performance.
            </p>
            
            <h3>Key Performance Metrics</h3>
            <table>
                <tr>
                    <th>Metric</th>
                    <th>Description</th>
                    <th>Ideal Target</th>
                </tr>
                <tr>
                    <td>First Contentful Paint (FCP)</td>
                    <td>Time until first content is rendered</td>
                    <td>&lt; 1.8s</td>
                </tr>
                <tr>
                    <td>Largest Contentful Paint (LCP)</td>
                    <td>Time until largest content element is visible</td>
                    <td>&lt; 2.5s</td>
                </tr>
                <tr>
                    <td>First Input Delay (FID)</td>
                    <td>Time from user interaction to browser response</td>
                    <td>&lt; 100ms</td>
                </tr>
                <tr>
                    <td>Cumulative Layout Shift (CLS)</td>
                    <td>Unexpected layout shifts during page loading</td>
                    <td>&lt; 0.1</td>
                </tr>
                <tr>
                    <td>Time to Interactive (TTI)</td>
                    <td>Time until page is fully interactive</td>
                    <td>&lt; 3.8s</td>
                </tr>
                <tr>
                    <td>Framerate</td>
                    <td>Frames per second during animations/scrolling</td>
                    <td>60fps</td>
                </tr>
            </table>
            
            <h3>Performance Monitoring Code</h3>
            <div class="code-example">
<pre>
// Simple performance monitoring utilities
const PerformanceMonitor = {
    // Start timing an operation
    startMeasure(label) {
        performance.mark(`${label}-start`);
    },
    
    // End timing and log result
    endMeasure(label) {
        performance.mark(`${label}-end`);
        performance.measure(label, `${label}-start`, `${label}-end`);
        
        const measure = performance.getEntriesByName(label)[0];
        console.log(`${label}: ${measure.duration.toFixed(2)}ms`);
        
        // Cleanup
        performance.clearMarks(`${label}-start`);
        performance.clearMarks(`${label}-end`);
        performance.clearMeasures(label);
        
        return measure.duration;
    },
    
    // Monitor frame rate during an operation
    monitorFrameRate(durationMs = 5000, callback) {
        let frameCount = 0;
        let startTime = performance.now();
        
        function countFrame() {
            frameCount++;
            
            const currentTime = performance.now();
            const elapsed = currentTime - startTime;
            
            if (elapsed < durationMs) {
                requestAnimationFrame(countFrame);
            } else {
                const fps = (frameCount / elapsed) * 1000;
                console.log(`Average FPS: ${fps.toFixed(1)}`);
                if (callback) callback(fps);
            }
        }
        
        requestAnimationFrame(countFrame);
    },
    
    // Check for layout thrashing
    detectLayoutThrashing() {
        // Override common properties that trigger layout
        const layoutTriggeringProps = [
            'offsetTop', 'offsetLeft', 'offsetWidth', 'offsetHeight',
            'clientTop', 'clientLeft', 'clientWidth', 'clientHeight',
            'getComputedStyle'
        ];
        
        let layoutReads = 0;
        let layoutReadWriteSequences = 0;
        let lastOperationType = null;
        
        // Monkey patch to detect reads
        layoutTriggeringProps.forEach(prop => {
            if (prop === 'getComputedStyle') {
                const original = window.getComputedStyle;
                window.getComputedStyle = function() {
                    layoutReads++;
                    if (lastOperationType === 'write') {
                        layoutReadWriteSequences++;
                        console.warn('Layout thrashing detected: Reading style after write');
                    }
                    lastOperationType = 'read';
                    return original.apply(this, arguments);
                };
            } else {
                const elementProto = Element.prototype;
                const originalDescriptor = Object.getOwnPropertyDescriptor(elementProto, prop);
                
                if (originalDescriptor && originalDescriptor.get) {
                    Object.defineProperty(elementProto, prop, {
                        get: function() {
                            layoutReads++;
                            if (lastOperationType === 'write') {
                                layoutReadWriteSequences++;
                                console.warn(`Layout thrashing detected: Reading ${prop} after write`);
                            }
                            lastOperationType = 'read';
                            return originalDescriptor.get.apply(this);
                        }
                    });
                }
            }
        });
        
        // Detect writes
        const originalSetAttribute = Element.prototype.setAttribute;
        Element.prototype.setAttribute = function() {
            lastOperationType = 'write';
            return originalSetAttribute.apply(this, arguments);
        };
        
        const originalStyleSetter = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'style').set;
        Object.defineProperty(HTMLElement.prototype, 'style', {
            set: function() {
                lastOperationType = 'write';
                return originalStyleSetter.apply(this, arguments);
            }
        });
        
        // Report stats periodically
        setInterval(() => {
            console.log(`Layout reads: ${layoutReads}, Layout thrashing sequences: ${layoutReadWriteSequences}`);
            layoutReads = 0;
            layoutReadWriteSequences = 0;
        }, 5000);
    }
};

// Usage examples
document.addEventListener('DOMContentLoaded', () => {
    // Example: Measure rendering performance
    PerformanceMonitor.startMeasure('initial-render');
    renderComplexTable();
    PerformanceMonitor.endMeasure('initial-render');
    
    // Example: Monitor framerate during scrolling
    document.querySelector('.scroll-container').addEventListener('scroll', () => {
        PerformanceMonitor.monitorFrameRate(2000, fps => {
            if (fps < 30) {
                console.warn('Scrolling performance is poor');
            }
        });
    });
    
    // Example: Detect layout thrashing in development
    if (process.env.NODE_ENV === 'development') {
        PerformanceMonitor.detectLayoutThrashing();
    }
});
</pre>
            </div>
        </section>

        <section id="browser-tools">
            <h2>Leveraging Browser DevTools for DOM Optimization</h2>
            <p>
                Modern browser developer tools provide powerful features for analyzing DOM performance.
            </p>
            
            <h3>Key DevTools Features</h3>
            <ul>
                <li><strong>Performance Panel</strong>: Record and analyze rendering, scripting, and painting</li>
                <li><strong>Memory Panel</strong>: Detect memory leaks and analyze heap snapshots</li>
                <li><strong>Layers Panel</strong>: Visualize composited layers</li>
                <li><strong>Paint Flashing</strong>: Visualize areas being repainted</li>
                <li><strong>FPS Meter</strong>: Monitor frame rate in real-time</li>
            </ul>
            
            <div class="note">
                <h4>DevTools Performance Analysis Workflow</h4>
                <ol>
                    <li>Open DevTools and navigate to the Performance panel</li>
                    <li>Click "Record" and perform the action you want to analyze</li>
                    <li>Click "Stop" and analyze the resulting timeline</li>
                    <li>Look for long tasks, layout recalculations, and excessive painting</li>
                    <li>Use the "Bottom-Up" and "Call Tree" tabs to identify problematic code</li>
                    <li>Optimize and repeat to confirm improvements</li>
                </ol>
            </div>
        </section>

        <section id="integration-with-python">
            <h2>Integrating with Python Backends</h2>
            <p>
                As you transition to full-stack development with Python, understanding how frontend DOM patterns integrate with backend frameworks is essential.
            </p>
            
            <h3>Flask Integration</h3>
            <div class="code-example">
<pre>
// Example: Fetching data from a Flask API
class FlaskApiClient {
    constructor(baseUrl = '') {
        this.baseUrl = baseUrl;
        this.csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
    }
    
    async get(endpoint) {
        const response = await fetch(`${this.baseUrl}${endpoint}`);
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        return response.json();
    }
    
    async post(endpoint, data) {
        const response = await fetch(`${this.baseUrl}${endpoint}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': this.csrfToken
            },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        return response.json();
    }
}

// Integrating with component architecture
class UserList extends Component {
    constructor(props) {
        super(props);
        this.state = {
            users: [],
            loading: true,
            error: null
        };
        
        this.api = new FlaskApiClient('/api');
    }
    
    async loadUsers() {
        try {
            this.setState({ loading: true, error: null });
            const users = await this.api.get('/users');
            this.setState({ users, loading: false });
        } catch (error) {
            this.setState({ error: error.message, loading: false });
        }
    }
    
    afterMount() {
        this.loadUsers();
    }
    
    render() {
        const container = document.createElement('div');
        container.className = 'user-list-container';
        
        if (this.state.loading) {
            container.innerHTML = '<div class="loading">Loading users...</div>';
        } else if (this.state.error) {
            container.innerHTML = `<div class="error">${this.state.error}</div>`;
        } else {
            const fragment = document.createDocumentFragment();
            const list = document.createElement('ul');
            list.className = 'user-list';
            
            this.state.users.forEach(user => {
                const item = document.createElement('li');
                item.className = 'user-item';
                item.innerHTML = `
                    <div class="user-avatar">
                        <img src="${user.avatar || '/static/default-avatar.png'}" alt="${user.name}">
                    </div>
                    <div class="user-info">
                        <h3>${user.name}</h3>
                        <p>${user.email}</p>
                    </div>
                `;
                list.appendChild(item);
            });
            
            fragment.appendChild(list);
            container.appendChild(fragment);
        }
        
        return container;
    }
}

// Usage
new UserList().mount(document.getElementById('app'));
</pre>
            </div>
            
            <h3>Django Integration</h3>
            <div class="code-example">
<pre>
// Handling Django CSRF protection
function getCsrfToken() {
    return document.querySelector('[name=csrfmiddlewaretoken]')?.value;
}

// Django API client
class DjangoApiClient {
    async request(url, options = {}) {
        const defaultOptions = {
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCsrfToken()
            },
            credentials: 'same-origin'
        };
        
        const response = await fetch(url, {...defaultOptions, ...options});
        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }
        
        return response.json();
    }
    
    async get(url) {
        return this.request(url);
    }
    
    async post(url, data) {
        return this.request(url, {
            method: 'POST',
            body: JSON.stringify(data)
        });
    }
    
    async put(url, data) {
        return this.request(url, {
            method: 'PUT',
            body: JSON.stringify(data)
        });
    }
    
    async delete(url) {
        return this.request(url, {
            method: 'DELETE'
        });
    }
}

// Django form submission with optimization
class EnhancedForm {
    constructor(formElement) {
        this.form = formElement;
        this.api = new DjangoApiClient();
        this.setupForm();
    }
    
    setupForm() {
        this.form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            try {
                await this.submitForm();
            } catch (error) {
                this.showError(error.message);
            }
        });
    }
    
    getFormData() {
        const formData = new FormData(this.form);
        const data = {};
        
        for (let [key, value] of formData.entries()) {
            data[key] = value;
        }
        
        return data;
    }
    
    async submitForm() {
        // Show loading state
        this.form.classList.add('loading');
        this.clearErrors();
        
        // Get form data
        const data = this.getFormData();
        
        try {
            // Submit to Django backend
            const response = await this.api.post(this.form.action, data);
            
            // Handle successful response
            if (response.success) {
                this.showSuccess(response.message || 'Form submitted successfully');
                
                // Redirect if specified
                if (response.redirect) {
                    window.location.href = response.redirect;
                }
            } else if (response.errors) {
                // Handle field errors
                this.showFieldErrors(response.errors);
            }
        } finally {
            // Remove loading state
            this.form.classList.remove('loading');
        }
    }
    
    clearErrors() {
        // Remove existing error messages
        this.form.querySelectorAll('.error-message').forEach(el => el.remove());
        this.form.querySelectorAll('.field-error').forEach(el => {
            el.classList.remove('field-error');
        });
    }
    
    showFieldErrors(errors) {
        // Efficiently add error messages using document fragment
        const fragment = document.createDocumentFragment();
        
        Object.entries(errors).forEach(([field, message]) => {
            const input = this.form.querySelector(`[name="${field}"]`);
            if (input) {
                input.classList.add('field-error');
                
                const errorElement = document.createElement('div');
                errorElement.className = 'error-message';
                errorElement.textContent = message;
                
                // Insert after the input
                input.parentNode.insertBefore(errorElement, input.nextSibling);
            }
        });
        
        this.form.appendChild(fragment);
    }
    
    showError(message) {
        const errorContainer = this.form.querySelector('.form-error') || 
            document.createElement('div');
        
        errorContainer.className = 'form-error';
        errorContainer.textContent = message;
        
        if (!errorContainer.parentNode) {
            this.form.insertBefore(errorContainer, this.form.firstChild);
        }
    }
    
    showSuccess(message) {
        const successContainer = this.form.querySelector('.form-success') || 
            document.createElement('div');
        
        successContainer.className = 'form-success';
        successContainer.textContent = message;
        
        if (!successContainer.parentNode) {
            this.form.insertBefore(successContainer, this.form.firstChild);
        }
    }
}

// Usage
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('form.enhanced').forEach(form => {
        new EnhancedForm(form);
    });
});
</pre>
            </div>
        </section>
</pre>
            </div>
        </section>

        <section id="exercises">
            <h2>Exercises</h2>
            
            <div class="exercise">
                <h3>Exercise 1: Performance Optimization</h3>
                <p>
                    Take the following code and optimize it for DOM performance:
                </p>
                <div class="code-example">
<pre>
// Original code to optimize
function renderTable(data) {
    const table = document.getElementById('data-table');
    table.innerHTML = '';
    
    data.forEach(row => {
        const tr = document.createElement('tr');
        
        // Create and append cells one by one
        const nameCell = document.createElement('td');
        nameCell.textContent = row.name;
        tr.appendChild(nameCell);
        
        const valueCell = document.createElement('td');
        valueCell.textContent = row.value;
        tr.appendChild(valueCell);
        
        const percentCell = document.createElement('td');
        percentCell.textContent = row.percentage + '%';
        tr.appendChild(percentCell);
        
        // Calculate and set width for bar visualization
        const barCell = document.createElement('td');
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.width = (barCell.offsetWidth * (row.percentage / 100)) + 'px';
        bar.style.backgroundColor = row.color;
        barCell.appendChild(bar);
        tr.appendChild(barCell);
        
        table.appendChild(tr);
    });
}
</pre>
                </div>
            </div>
            
            <div class="exercise">
                <h3>Exercise 2: Implement a Component System</h3>
                <p>
                    Create a simple component system that includes:
                </p>
                <ul>
                    <li>A base Component class with lifecycle methods (init, render, mount, update, unmount)</li>
                    <li>State management within components</li>
                    <li>Event handling and delegation</li>
                    <li>Parent-child component relationships</li>
                </ul>
                <p>
                    Use this system to build a simple to-do list application that connects to a Python/Flask backend.
                </p>
            </div>
            
            <div class="exercise">
                <h3>Exercise 3: Virtual List Implementation</h3>
                <p>
                    Implement a virtual list component that:
                </p>
                <ul>
                    <li>Only renders elements visible in the viewport</li>
                    <li>Recycles DOM nodes as the user scrolls</li>
                    <li>Efficiently handles a dataset of 10,000 items</li>
                    <li>Maintains smooth 60fps scrolling</li>
                </ul>
            </div>
        </section>

        <section id="summary">
            <h2>Summary and Best Practices</h2>
            
            <h3>Key DOM Optimization Principles</h3>
            <ul>
                <li><strong>Minimize DOM Manipulations:</strong> Batch operations and use document fragments</li>
                <li><strong>Avoid Layout Thrashing:</strong> Separate read and write operations</li>
                <li><strong>Use Event Delegation:</strong> Attach listeners to containers instead of individual elements</li>
                <li><strong>Optimize Rendering:</strong> Recycle DOM elements and implement virtualization for large lists</li>
                <li><strong>Leverage Component Patterns:</strong> Organize code in a modular, maintainable way</li>
                <li><strong>Measure Performance:</strong> Use browser tools to identify bottlenecks</li>
                <li><strong>Update Efficiently:</strong> Only update what has changed</li>
            </ul>
            
            <h3>Connecting to Python Backends</h3>
            <p>
                When working with Python backends like Flask or Django:
            </p>
            <ul>
                <li>Use async/await for API requests to keep the UI responsive</li>
                <li>Handle CSRF protection properly in your requests</li>
                <li>Consider the balance between server-side and client-side rendering</li>
                <li>Implement proper error handling for API requests</li>
                <li>Use optimistic UI updates for better user experience</li>
            </ul>
        </section>

        <section id="further-reading">
            <h2>Further Reading</h2>
            
            <ul>
                <li><a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank">Google Web Fundamentals: Rendering Performance</a></li>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" target="_blank">MDN: Introduction to the DOM</a></li>
                <li><a href="https://github.com/wilsonpage/fastdom" target="_blank">FastDOM: Eliminates layout thrashing</a></li>
                <li><a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank">JavaScript Design Patterns</a></li>
                <li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance" target="_blank">Chrome DevTools: Analyze Runtime Performance</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
        <p><a href="/index.html">Return to Course Index</a></p>
    </footer>
</body>
</html>
