<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS Preprocessors Introduction (SASS/SCSS) | Web Fundamentals</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>CSS Preprocessors Introduction: SASS/SCSS</h1>
        <p>Week 4: Web Fundamentals - Friday Morning Session</p>
    </header>

    <main>
        <section class="intro">
            <h2>Introduction to CSS Preprocessors</h2>
            <p>Writing CSS can sometimes feel like painting a masterpiece with only a single brush. While you can create beautiful results, the process can be tedious and repetitive. CSS preprocessors are like giving yourself an entire set of specialized tools—brushes of different sizes, palette knives, and blending tools—that make the painting process more efficient and the results more consistent.</p>
            
            <p>CSS preprocessors are scripting languages that extend regular CSS with programming features. They allow you to write more maintainable and reusable CSS code that gets compiled into standard CSS that browsers can understand. Today, we'll focus on Sass (Syntactically Awesome Style Sheets) and its syntax variants, particularly SCSS (Sassy CSS), which have become industry standards in modern web development.</p>
            
            <div class="key-points">
                <h3>By the end of this session, you'll understand:</h3>
                <ul>
                    <li>What CSS preprocessors are and why they're valuable</li>
                    <li>The difference between Sass and SCSS syntax</li>
                    <li>Core features of Sass/SCSS: variables, nesting, mixins, and more</li>
                    <li>How to set up and use Sass in your development workflow</li>
                    <li>Best practices for organizing your stylesheets</li>
                    <li>How preprocessors fit into modern frontend development</li>
                </ul>
            </div>
        </section>

        <section class="why-preprocessors">
            <h2>Why Use CSS Preprocessors?</h2>
            
            <p>Regular CSS, while powerful, lacks certain programming capabilities that could make stylesheets more maintainable and DRY (Don't Repeat Yourself). As your projects grow, CSS files can become unwieldy, with repeated color values, redundant declarations, and complex selector combinations.</p>
            
            <div class="benefits">
                <h3>Key Benefits of Preprocessors</h3>
                <ul>
                    <li><strong>Variables:</strong> Store and reuse values throughout your stylesheets</li>
                    <li><strong>Nesting:</strong> Write selectors that mirror your HTML hierarchy</li>
                    <li><strong>Mixins:</strong> Create reusable blocks of styles</li>
                    <li><strong>Functions:</strong> Perform computations and transformations</li>
                    <li><strong>Partials:</strong> Split your CSS into modular files</li>
                    <li><strong>Inheritance:</strong> Share properties between selectors</li>
                    <li><strong>Operators:</strong> Perform mathematical operations within your styles</li>
                    <li><strong>Control directives:</strong> Use programming logic like if/else statements and loops</li>
                </ul>
            </div>
            
            <div class="real-world">
                <h3>Real-World Analogy</h3>
                <p>Think of CSS preprocessors like modern kitchen appliances. Regular CSS is like cooking everything by hand—it works, but it's time-consuming and easy to make mistakes. Preprocessors are like having a food processor, stand mixer, and programmable oven that automate repetitive tasks, ensure consistency, and let you focus on creating the final product rather than the mechanical steps to get there.</p>
            </div>
            
            <div class="comparison">
                <h3>CSS vs. Preprocessed CSS: A Simple Comparison</h3>
                
                <div class="code-comparison">
                    <div class="vanilla-css">
                        <h4>Vanilla CSS</h4>
                        <pre><code>.button {
  background-color: #0066cc;
  color: white;
  padding: 10px 15px;
  border-radius: 4px;
}

.button-large {
  background-color: #0066cc;
  color: white;
  padding: 15px 25px;
  border-radius: 4px;
  font-size: 18px;
}

.button-danger {
  background-color: #cc0000;
  color: white;
  padding: 10px 15px;
  border-radius: 4px;
}</code></pre>
                    </div>
                    
                    <div class="scss">
                        <h4>SCSS</h4>
                        <pre><code>$primary-color: #0066cc;
$danger-color: #cc0000;
$border-radius: 4px;

@mixin button-base {
  color: white;
  padding: 10px 15px;
  border-radius: $border-radius;
}

.button {
  background-color: $primary-color;
  @include button-base;
  
  &-large {
    background-color: $primary-color;
    @include button-base;
    padding: 15px 25px;
    font-size: 18px;
  }
  
  &-danger {
    background-color: $danger-color;
    @include button-base;
  }
}</code></pre>
                    </div>
                </div>
                
                <p>Notice how the SCSS version eliminates repetition, centralizes values in variables, and creates a logical hierarchy through nesting and mixins. If you needed to change the border-radius across all buttons, you would only need to update it in one place!</p>
            </div>
        </section>

        <section class="sass-vs-scss">
            <h2>Sass vs. SCSS: Understanding the Difference</h2>
            
            <p>Sass was originally developed in 2006 and has had two major syntax variations over time. Understanding the distinction between them is important when reading documentation or working on different projects.</p>
            
            <div class="indented-syntax">
                <h3>Sass (Indented Syntax)</h3>
                <p>The original Sass syntax uses indentation instead of brackets to indicate nesting, and newlines instead of semicolons to separate properties. File extensions are typically <code>.sass</code>.</p>
                <pre><code>// Sass Indented Syntax
$primary-color: #0066cc

.button
  background-color: $primary-color
  color: white
  padding: 10px 15px
  
  &:hover
    background-color: darken($primary-color, 10%)
    
  &-large
    font-size: 18px</code></pre>
                <p>This syntax is concise but can be jarring for developers used to CSS's bracket notation.</p>
            </div>
            
            <div class="scss-syntax">
                <h3>SCSS (Sassy CSS)</h3>
                <p>SCSS was introduced in Sass 3.0 as a newer syntax that's a strict superset of CSS. Any valid CSS is also valid SCSS, but SCSS adds the powerful features of Sass. File extensions are typically <code>.scss</code>.</p>
                <pre><code>// SCSS Syntax
$primary-color: #0066cc;

.button {
  background-color: $primary-color;
  color: white;
  padding: 10px 15px;
  
  &:hover {
    background-color: darken($primary-color, 10%);
  }
  
  &-large {
    font-size: 18px;
  }
}</code></pre>
                <p>Most modern projects use SCSS syntax because of its similarity to CSS and easier learning curve.</p>
            </div>
            
            <div class="choosing">
                <h3>Which Should You Choose?</h3>
                <p>For most developers, especially those new to CSS preprocessors, SCSS is the recommended syntax because:</p>
                <ul>
                    <li>It's more familiar if you already know CSS</li>
                    <li>You can gradually add Sass features to existing CSS files</li>
                    <li>Most documentation, tutorials, and libraries use SCSS syntax</li>
                    <li>It's more widely used in the industry</li>
                </ul>
                <p>For this tutorial, we'll focus on SCSS, but the concepts apply to both syntaxes.</p>
            </div>
        </section>

        <section class="core-features">
            <h2>Core Features of Sass/SCSS</h2>
            
            <p>Let's explore the key features that make Sass/SCSS so powerful in detail, with practical examples of each.</p>
            
            <div class="feature">
                <h3>Variables</h3>
                <p>Variables store values that you can reuse throughout your stylesheets. Think of them as containers that hold information you'll use repeatedly—like brand colors, font stacks, or spacing values.</p>
                <pre><code>// Variables in SCSS
$primary-color: #0066cc;
$secondary-color: #ff9900;
$font-stack: 'Helvetica', 'Arial', sans-serif;
$base-spacing: 16px;

body {
  font-family: $font-stack;
  color: #333;
  line-height: 1.5;
  margin: $base-spacing;
}

h1 {
  color: $primary-color;
  margin-bottom: $base-spacing;
}

.button {
  background-color: $secondary-color;
  padding: $base-spacing / 2 $base-spacing;
}</code></pre>
                <p><strong>Real-world application:</strong> When your design system changes (for example, a brand color update), you only need to modify the variable value in one place rather than searching through your entire stylesheet for every instance.</p>
            </div>
            
            <div class="feature">
                <h3>Nesting</h3>
                <p>Nesting allows you to write selectors that follow the same visual hierarchy as your HTML. This creates more readable and organized code, especially for complex components.</p>
                <pre><code>// Nesting in SCSS
.card {
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 16px;
  
  .card-header {
    border-bottom: 1px solid #eee;
    padding-bottom: 8px;
    margin-bottom: 16px;
    
    h2 {
      margin: 0;
      font-size: 18px;
    }
  }
  
  .card-body {
    font-size: 14px;
    
    p {
      margin-bottom: 8px;
      
      &:last-child {
        margin-bottom: 0;
      }
    }
  }
}</code></pre>
                <p>The <code>&</code> symbol is a special placeholder that represents the parent selector. It's particularly useful for pseudo-classes, pseudo-elements, and modifier classes.</p>
                <pre><code>.button {
  padding: 10px 15px;
  background-color: #0066cc;
  color: white;
  
  &:hover {
    background-color: #0052a3;
  }
  
  &:active {
    background-color: #004080;
  }
  
  &.disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  &--large {
    padding: 15px 25px;
    font-size: 18px;
  }
}</code></pre>
                <p><strong>Warning:</strong> Excessive nesting can lead to overly specific selectors and CSS bloat. Try to limit nesting to 3-4 levels deep.</p>
                <p><strong>Real-world application:</strong> Nesting is particularly valuable when working with component-based architectures, as it allows you to encapsulate all the styles for a component in one logical block.</p>
            </div>
            
            <div class="feature">
                <h3>Mixins</h3>
                <p>Mixins are reusable blocks of CSS declarations that you can include in other selectors. Think of them as functions that output CSS. They can also accept parameters for greater flexibility.</p>
                <pre><code>// Basic mixin definition
@mixin flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

// Mixin with parameters
@mixin box-shadow($x: 0, $y: 2px, $blur: 4px, $color: rgba(0, 0, 0, 0.1)) {
  box-shadow: $x $y $blur $color;
}

// Using mixins
.modal {
  @include flex-center;
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
  
  .modal-content {
    background-color: white;
    padding: 20px;
    border-radius: 4px;
    @include box-shadow(0, 5px, 15px, rgba(0, 0, 0, 0.3));
  }
}

.card {
  @include box-shadow; // Uses default values
}

.button {
  @include box-shadow(1px, 1px, 3px, rgba(0, 0, 0, 0.2));
}</code></pre>
                <p><strong>Real-world application:</strong> Mixins are perfect for cross-browser prefixing, consistent styling patterns like buttons or form elements, and complex CSS properties that need to be applied consistently but with slight variations.</p>
            </div>
            
            <div class="feature">
                <h3>Extend/Inheritance</h3>
                <p>The <code>@extend</code> directive lets you share a set of CSS properties from one selector to another. It's useful when elements share common styles but also have their own specific styles.</p>
                <pre><code>// Base style
.message {
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

// Extending base styles
.success-message {
  @extend .message;
  border-color: green;
  color: green;
  background-color: #e6f9e6;
}

.error-message {
  @extend .message;
  border-color: red;
  color: red;
  background-color: #ffebeb;
}

.warning-message {
  @extend .message;
  border-color: orange;
  color: #856404;
  background-color: #fff3cd;
}</code></pre>
                <p><strong>Key difference from mixins:</strong> Unlike mixins, <code>@extend</code> doesn't copy the CSS properties; instead, it adds the selector to the original rule's selector group, which can result in more compact CSS output but also potentially complex selector chains.</p>
                <p><strong>Real-world application:</strong> Extend is ideal for variations of a base component, like different alert types, button styles, or form element states that share common styling.</p>
            </div>
            
            <div class="feature">
                <h3>Partials and Imports</h3>
                <p>Sass allows you to split your CSS into smaller, more manageable files (partials) and then import them into a main file. This helps organize your code and makes large projects more maintainable.</p>
                <p>Partials are named with a leading underscore (e.g., <code>_variables.scss</code>) to indicate they shouldn't be compiled individually.</p>
                <pre><code>// File: _variables.scss
$primary-color: #0066cc;
$secondary-color: #ff9900;
$font-stack: 'Helvetica', 'Arial', sans-serif;

// File: _typography.scss
@import 'variables';

body {
  font-family: $font-stack;
  line-height: 1.5;
}

h1 {
  font-size: 2em;
  color: $primary-color;
}

// File: _buttons.scss
@import 'variables';

.button {
  display: inline-block;
  padding: 10px 15px;
  background-color: $primary-color;
  color: white;
  border-radius: 4px;
}

// File: main.scss
@import 'variables';
@import 'typography';
@import 'buttons';
@import 'forms';
@import 'layout';
@import 'components/card';
@import 'components/modal';
@import 'pages/home';
@import 'pages/about';</code></pre>
                <p><strong>Note:</strong> In modern Sass, the <code>@use</code> rule is preferred over <code>@import</code> as it helps avoid global namespace pollution and provides more explicit dependency management.</p>
                <p><strong>Real-world application:</strong> File organization becomes critical in large projects. A common pattern is to organize files by functionality (variables, mixins, base styles) and by components, creating a modular structure that mirrors your application architecture.</p>
            </div>
            
            <div class="feature">
                <h3>Functions and Operators</h3>
                <p>Sass includes built-in functions and allows you to define your own functions to manipulate values. You can also use mathematical operators directly in your styles.</p>
                <pre><code>// Built-in functions
.dark-theme {
  background-color: #333;
  color: white;
  
  a {
    color: lighten(#0066cc, 20%);
    
    &:hover {
      color: lighten(#0066cc, 30%);
    }
  }
}

.box {
  // Mathematical operators
  width: 100% / 3;
  margin: 20px * 1.5;
  padding: (10px + 5px) (20px - 5px);
}

// Custom function
@function calculate-fluid-size($min-size, $max-size, $min-viewport, $max-viewport) {
  $size-difference: $max-size - $min-size;
  $viewport-difference: $max-viewport - $min-viewport;
  
  @return calc(#{$min-size}px + #{$size-difference} * ((100vw - #{$min-viewport}px) / #{$viewport-difference}));
}

h1 {
  // This creates a fluid font size that scales with the viewport width
  font-size: calculate-fluid-size(24, 48, 320, 1200);
}</code></pre>
                <p><strong>Common built-in functions:</strong></p>
                <ul>
                    <li><code>lighten($color, $amount)</code> and <code>darken($color, $amount)</code></li>
                    <li><code>rgba($color, $alpha)</code></li>
                    <li><code>mix($color1, $color2, $weight)</code></li>
                    <li><code>percentage($number)</code></li>
                    <li><code>if($condition, $if-true, $if-false)</code></li>
                </ul>
                <p><strong>Real-world application:</strong> Functions are especially useful for complex calculations like fluid typography, color manipulation for hover states or accessibility, and creating consistent spacing or sizing scales.</p>
            </div>
            
            <div class="feature">
                <h3>Control Directives</h3>
                <p>Sass provides programming constructs like conditionals and loops that can generate CSS dynamically based on conditions or iterate over values.</p>
                <pre><code>// If-else condition
$theme: 'dark';

.container {
  @if $theme == 'dark' {
    background-color: #333;
    color: white;
  } @else if $theme == 'light' {
    background-color: #fff;
    color: #333;
  } @else {
    background-color: #f5f5f5;
    color: #333;
  }
}

// For loop
$grid-columns: 12;

@for $i from 1 through $grid-columns {
  .col-#{$i} {
    width: percentage($i / $grid-columns);
  }
}

// Each loop with a list
$sizes: ('small': 0.875rem, 'medium': 1rem, 'large': 1.25rem, 'xlarge': 1.5rem);

@each $name, $size in $sizes {
  .text-#{$name} {
    font-size: $size;
  }
}

// While loop (less common)
$i: 1;
$max-size: 5;

@while $i <= $max-size {
  .spacer-#{$i} {
    margin-bottom: $i * 0.25rem;
  }
  $i: $i + 1;
}</code></pre>
                <p><strong>Real-world application:</strong> Control directives are powerful for generating utility classes (like spacing helpers or grid systems), creating responsive typography scales, or conditionally applying styles based on themes or feature flags.</p>
            </div>
        </section>

        <section class="setup-workflow">
            <h2>Setting Up Sass in Your Workflow</h2>
            
            <p>To use Sass in your projects, you need a way to compile Sass/SCSS files into regular CSS that browsers can understand. There are several ways to incorporate Sass into your development workflow.</p>
            
            <div class="installation">
                <h3>Installation Options</h3>
                
                <div class="option">
                    <h4>Command Line (Node.js)</h4>
                    <p>Using the Sass package from npm:</p>
                    <pre><code>// Install Sass globally
npm install -g sass

// Compile a file
sass input.scss output.css

// Watch for changes
sass --watch input.scss output.css

// Watch entire directories
sass --watch scss/:css/</code></pre>
                </div>
                
                <div class="option">
                    <h4>Build Tools and Task Runners</h4>
                    <p>Integrate Sass with modern build tools:</p>
                    <ul>
                        <li><strong>Webpack</strong> with sass-loader</li>
                        <li><strong>Parcel</strong> (automatically handles Sass files)</li>
                        <li><strong>Gulp</strong> with gulp-sass</li>
                        <li><strong>Vite</strong> with sass preprocessing</li>
                    </ul>
                    <p>Example with Webpack:</p>
                    <pre><code>// webpack.config.js
module.exports = {
  // ...other config
  module: {
    rules: [
      {
        test: /\.scss$/,
        use: [
          'style-loader', // Injects CSS into the DOM
          'css-loader',   // Interprets @import, url() etc.
          'sass-loader'   // Compiles Sass to CSS
        ]
      }
    ]
  }
};</code></pre>
                </div>
                
                <div class="option">
                    <h4>VS Code Extensions</h4>
                    <p>For simple projects or learning, you can use extensions like "Live Sass Compiler" that compile on save.</p>
                </div>
                
                <div class="option">
                    <h4>GUI Applications</h4>
                    <p>Several applications provide a visual interface for compiling Sass:</p>
                    <ul>
                        <li><strong>Prepros</strong></li>
                        <li><strong>Koala</strong></li>
                        <li><strong>Scout-App</strong></li>
                    </ul>
                </div>
            </div>
            
            <div class="dockerized">
                <h3>Using Sass in Docker (For this course)</h3>
                <p>Since we're using Docker in this course, we can set up a containerized environment for Sass compilation:</p>
                <pre><code>// Dockerfile addition
FROM node:14 as sass-builder
WORKDIR /app
COPY package*.json ./
RUN npm install sass --save-dev
COPY . .
RUN npx sass src/scss:public/css --style compressed

// Or in docker-compose.yml
services:
  frontend:
    build: ./frontend
    volumes:
      - ./frontend/src:/app/src
      - ./frontend/public:/app/public
    command: npx sass --watch src/scss:public/css</code></pre>
            </div>
            
            <div class="output-options">
                <h3>Output Styles</h3>
                <p>Sass offers different output styles for the compiled CSS:</p>
                <ul>
                    <li><strong>expanded:</strong> Standard, well-formatted CSS</li>
                    <li><strong>compressed:</strong> Minified CSS with no whitespace (best for production)</li>
                    <li><strong>nested:</strong> Indented CSS that reflects nesting structure</li>
                    <li><strong>compact:</strong> Each rule takes up only one line</li>
                </ul>
                <pre><code>// Example command with output style
sass input.scss output.css --style compressed</code></pre>
            </div>
            
            <div class="sourcemaps">
                <h3>Source Maps</h3>
                <p>Source maps help with debugging by mapping the compiled CSS back to the original Sass files. This is crucial for development as it allows browser dev tools to show you the exact Sass file and line number for each style.</p>
                <pre><code>// Enable source maps
sass input.scss output.css --source-map</code></pre>
                <p>Most build tools also have options to enable source maps during development.</p>
            </div>
        </section>

        <section class="architecture">
            <h2>Sass Architecture and Organization</h2>
            
            <p>As your projects grow, organizing your Sass files becomes increasingly important. A well-structured Sass codebase is easier to maintain, scale, and understand. Here are some common approaches to organizing your Sass files.</p>
            
            <div class="architecture-pattern">
                <h3>The 7-1 Pattern</h3>
                <p>A popular organization method is the 7-1 pattern: 7 folders, 1 main file. This structure separates your Sass code into logical categories:</p>
                <pre><code>scss/
|
|– abstracts/
|   |– _variables.scss    # Variables
|   |– _functions.scss    # Functions
|   |– _mixins.scss       # Mixins
|   |– _placeholders.scss # Placeholders & extends
|
|– base/
|   |– _reset.scss        # Reset/normalize
|   |– _typography.scss   # Typography rules
|   |– _animations.scss   # Animations
|
|– components/
|   |– _buttons.scss      # Buttons
|   |– _cards.scss        # Cards
|   |– _forms.scss        # Forms
|   |– _modals.scss       # Modals
|
|– layout/
|   |– _header.scss       # Header
|   |– _footer.scss       # Footer
|   |– _navigation.scss   # Navigation
|   |– _grid.scss         # Grid system
|
|– pages/
|   |– _home.scss         # Home page specific styles
|   |– _about.scss        # About page specific styles
|
|– themes/
|   |– _default.scss      # Default theme
|   |– _dark.scss         # Dark theme
|
|– vendors/
|   |– _bootstrap.scss    # Bootstrap
|   |– _jquery-ui.scss    # jQuery UI
|
`– main.scss              # Main file that imports all partials</code></pre>
                <p>The main.scss file would simply import all these partials in the correct order:</p>
                <pre><code>// Main file (main.scss)

// Abstracts
@import 'abstracts/variables';
@import 'abstracts/functions';
@import 'abstracts/mixins';
@import 'abstracts/placeholders';

// Vendors
@import 'vendors/bootstrap';
@import 'vendors/jquery-ui';

// Base
@import 'base/reset';
@import 'base/typography';
@import 'base/animations';

// Layout
@import 'layout/header';
@import 'layout/footer';
@import 'layout/navigation';
@import 'layout/grid';

// Components
@import 'components/buttons';
@import 'components/cards';
@import 'components/forms';
@import 'components/modals';

// Pages
@import 'pages/home';
@import 'pages/about';

// Themes
@import 'themes/default';
@import 'themes/dark';</code></pre>
            </div>
            
            <div class="naming-conventions">
                <h3>Naming Conventions</h3>
                <p>Consistent naming helps maintain a clear and understandable codebase. Here are some popular naming conventions:</p>
                
                <div class="convention">
                    <h4>BEM (Block, Element, Modifier)</h4>
                    <p>BEM is a naming methodology that helps create reusable components:</p>
                    <ul>
                        <li><strong>Block:</strong> The standalone component (e.g., <code>.card</code>)</li>
                        <li><strong>Element:</strong> A part of the block (e.g., <code>.card__title</code>)</li>
                        <li><strong>Modifier:</strong> A variation of the block or element (e.g., <code>.card--featured</code> or <code>.card__title--large</code>)</li>
                    </ul>
                    <pre><code>.card {
  background: white;
  border-radius: 4px;
  
  &__image {
    width: 100%;
    
    &--rounded {
      border-radius: 50%;
    }
  }
  
  &__title {
    font-size: 1.2rem;
    margin-bottom: 8px;
  }
  
  &__content {
    padding: 16px;
  }
  
  &--featured {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }
}</code></pre>
                    <p>This compiles to:</p>
                    <pre><code>.card {
  background: white;
  border-radius: 4px;
}
.card__image {
  width: 100%;
}
.card__image--rounded {
  border-radius: 50%;
}
.card__title {
  font-size: 1.2rem;
  margin-bottom: 8px;
}
.card__content {
  padding: 16px;
}
.card--featured {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}</code></pre>
                </div>
                
                <div class="convention">
                    <h4>ITCSS (Inverted Triangle CSS)</h4>
                    <p>ITCSS organizes CSS by specificity, from low to high:</p>
                    <ol>
                        <li><strong>Settings:</strong> Variables and config</li>
                        <li><strong>Tools:</strong> Mixins and functions</li>
                        <li><strong>Generic:</strong> Reset and normalize</li>
                        <li><strong>Elements:</strong> Bare HTML elements</li>
                        <li><strong>Objects:</strong> Layout patterns</li>
                        <li><strong>Components:</strong> UI components</li>
                        <li><strong>Utilities:</strong> Helper classes</li>
                    </ol>
                </div>
            </div>
            
            <div class="best-practices">
                <h3>Best Practices</h3>
                <ul>
                    <li><strong>Keep files focused:</strong> Each partial should have a single responsibility</li>
                    <li><strong>Limit nesting:</strong> Avoid nesting more than 3-4 levels deep</li>
                    <li><strong>Comment your code:</strong> Use Sass comments (<code>//</code>) for development and CSS comments (<code>/* */</code>) for documentation that should appear in the compiled CSS</li>
                    <li><strong>Use variables for all repeated values:</strong> Colors, spacing, breakpoints, etc.</li>
                    <li><strong>Namespace your helpers:</strong> Prefix mixins, functions, and placeholders with a project-specific namespace to avoid conflicts</li>
                    <li><strong>Order properties consistently:</strong> Follow a standard order for properties (e.g., positioning first, then box model, then typography)</li>
                    <li><strong>Break large components into smaller partials:</strong> If a component file grows too large, split it into multiple files</li>
                </ul>
            </div>
        </section>

        <section class="practical-example">
            <h2>Practical Example: Building a Component System</h2>
            
            <p>Let's apply what we've learned to create a small but comprehensive component system. We'll build a button component with different variants, sizes, and states.</p>
            
            <div class="example-structure">
                <h3>File Structure</h3>
                <pre><code>scss/
|
|– abstracts/
|   |– _variables.scss
|   |– _mixins.scss
|
|– components/
|   |– _buttons.scss
|
`– main.scss</code></pre>
            </div>
            
            <div class="example-variables">
                <h3>Variables (_variables.scss)</h3>
                <pre><code>// Colors
$color-primary: #0066cc;
$color-secondary: #ff9900;
$color-success: #28a745;
$color-danger: #dc3545;
$color-warning: #ffc107;
$color-info: #17a2b8;
$color-light: #f8f9fa;
$color-dark: #343a40;
$color-white: #ffffff;

// Typography
$font-family-base: 'Roboto', sans-serif;
$font-size-base: 1rem;
$font-weight-normal: 400;
$font-weight-bold: 700;

// Spacing
$spacing-xs: 0.25rem;
$spacing-sm: 0.5rem;
$spacing-md: 1rem;
$spacing-lg: 1.5rem;
$spacing-xl: 2rem;

// Borders
$border-radius-sm: 0.25rem;
$border-radius-md: 0.375rem;
$border-radius-lg: 0.5rem;
$border-width: 1px;

// Transitions
$transition-base: all 0.2s ease-in-out;</code></pre>
            </div>
            
            <div class="example-mixins">
                <h3>Mixins (_mixins.scss)</h3>
                <pre><code>// Button base styles mixin
@mixin button-base {
  display: inline-block;
  font-family: $font-family-base;
  font-weight: $font-weight-normal;
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  user-select: none;
  border: $border-width solid transparent;
  padding: $spacing-sm $spacing-md;
  border-radius: $border-radius-md;
  transition: $transition-base;
  
  &:focus {
    outline: none;
    box-shadow: 0 0 0 0.2rem rgba($color-primary, 0.25);
  }
  
  &:disabled,
  &.disabled {
    opacity: 0.65;
    pointer-events: none;
  }
}

// Button variant mixin
@mixin button-variant($background, $border, $color) {
  background-color: $background;
  border-color: $border;
  color: $color;
  
  &:hover,
  &:focus {
    background-color: darken($background, 7.5%);
    border-color: darken($border, 10%);
  }
  
  &:active {
    background-color: darken($background, 10%);
    border-color: darken($border, 12.5%);
    transform: translateY(1px);
  }
}

// Button size mixin
@mixin button-size($padding-y, $padding-x, $font-size, $border-radius) {
  padding: $padding-y $padding-x;
  font-size: $font-size;
  border-radius: $border-radius;
}</code></pre>
            </div>
            
            <div class="example-buttons">
                <h3>Button Component (_buttons.scss)</h3>
                <pre><code>.btn {
  @include button-base;
  
  // Button variants
  &-primary {
    @include button-variant($color-primary, $color-primary, $color-white);
  }
  
  &-secondary {
    @include button-variant($color-secondary, $color-secondary, $color-white);
  }
  
  &-success {
    @include button-variant($color-success, $color-success, $color-white);
  }
  
  &-danger {
    @include button-variant($color-danger, $color-danger, $color-white);
  }
  
  &-warning {
    @include button-variant($color-warning, $color-warning, $color-dark);
  }
  
  &-info {
    @include button-variant($color-info, $color-info, $color-white);
  }
  
  &-light {
    @include button-variant($color-light, $color-light, $color-dark);
  }
  
  &-dark {
    @include button-variant($color-dark, $color-dark, $color-white);
  }
  
  &-outline-primary {
    @include button-variant(transparent, $color-primary, $color-primary);
    
    &:hover,
    &:focus {
      background-color: $color-primary;
      color: $color-white;
    }
  }
  
  // Similar outline variants for other colors...
  
  // Button sizes
  &-sm {
    @include button-size($spacing-xs, $spacing-sm, $font-size-base * 0.875, $border-radius-sm);
  }
  
  &-lg {
    @include button-size($spacing-md, $spacing-lg, $font-size-base * 1.25, $border-radius-lg);
  }
  
  // Button states and modifiers
  &-block {
    display: block;
    width: 100%;
  }
  
  &-icon {
    padding: $spacing-sm;
    border-radius: 50%;
    line-height: 1;
    
    svg {
      vertical-align: middle;
    }
  }
}</code></pre>
            </div>
            
            <div class="example-main">
                <h3>Main File (main.scss)</h3>
                <pre><code>// Import abstracts
@import 'abstracts/variables';
@import 'abstracts/mixins';

// Import components
@import 'components/buttons';

// You would continue importing other components and styles</code></pre>
            </div>
            
            <div class="example-usage">
                <h3>Using the Button System (HTML)</h3>
                <pre><code>&lt;!-- Regular buttons -->
&lt;button class="btn btn-primary">Primary&lt;/button>
&lt;button class="btn btn-secondary">Secondary&lt;/button>
&lt;button class="btn btn-success">Success&lt;/button>
&lt;button class="btn btn-danger">Danger&lt;/button>

&lt;!-- Outlined buttons -->
&lt;button class="btn btn-outline-primary">Outline Primary&lt;/button>

&lt;!-- Sized buttons -->
&lt;button class="btn btn-primary btn-lg">Large Button&lt;/button>
&lt;button class="btn btn-primary">Regular Button&lt;/button>
&lt;button class="btn btn-primary btn-sm">Small Button&lt;/button>

&lt;!-- Block button -->
&lt;button class="btn btn-primary btn-block">Block Button&lt;/button>

&lt;!-- Disabled state -->
&lt;button class="btn btn-primary" disabled>Disabled&lt;/button>

&lt;!-- Icon button -->
&lt;button class="btn btn-icon btn-primary">
  &lt;svg width="16" height="16" viewBox="0 0 16 16">
    &lt;path d="M8 0l1.669 5.13h5.402l-4.37 3.175 1.669 5.13-4.37-3.175-4.37 3.175 1.669-5.13-4.37-3.175h5.402z"/>
  &lt;/svg>
&lt;/button></code></pre>
            </div>
            
            <div class="example-benefits">
                <h3>Benefits of This Approach</h3>
                <ul>
                    <li><strong>Modularity:</strong> Each component is self-contained</li>
                    <li><strong>Maintainability:</strong> Changes to button styles need to be made in one place</li>
                    <li><strong>Scalability:</strong> Easy to add new variants or modifiers</li>
                    <li><strong>Consistency:</strong> All buttons follow the same design patterns</li>
                    <li><strong>Efficiency:</strong> The compiled CSS is optimized and doesn't repeat common styles</li>
                </ul>
            </div>
        </section>

        <section class="modern-context">
            <h2>Sass in the Context of Modern Frontend Development</h2>
            
            <p>While Sass remains incredibly popular and useful, it's important to understand how it fits into the evolving landscape of frontend development.</p>
            
            <div class="trends">
                <h3>Current Trends and Alternatives</h3>
                <ul>
                    <li><strong>CSS Variables (Custom Properties):</strong> Native CSS now supports variables that can be changed at runtime, unlike Sass variables which are processed at compile time</li>
                    <li><strong>CSS Nesting:</strong> The CSS Nesting Module (in progress) will bring native nesting capabilities</li>
                    <li><strong>CSS-in-JS:</strong> Libraries like styled-components and Emotion allow writing CSS directly in JavaScript</li>
                    <li><strong>Utility-First CSS:</strong> Frameworks like Tailwind CSS use a different approach with predefined utility classes</li>
                    <li><strong>PostCSS:</strong> A tool for transforming CSS with JavaScript plugins that can provide some Sass-like features</li>
                </ul>
            </div>
            
            <div class="when-to-use">
                <h3>When to Use Sass Today</h3>
                <p>Sass remains an excellent choice for:</p>
                <ul>
                    <li>Projects where you want a mature, stable CSS preprocessor</li>
                    <li>Teams familiar with Sass</li>
                    <li>Situations where you need advanced features like mixins and functions</li>
                    <li>Working with legacy codebases that already use Sass</li>
                    <li>Creating complex design systems or component libraries</li>
                </ul>
            </div>
            
            <div class="hybrid-approach">
                <h3>Hybrid Approaches</h3>
                <p>Many projects now use a combination of techniques:</p>
                <ul>
                    <li>Using Sass for global styles and component structure</li>
                    <li>Leveraging CSS Custom Properties for values that need to change at runtime (like theme colors)</li>
                    <li>Incorporating utility classes for quick adjustments and prototyping</li>
                </ul>
                <pre><code>// _variables.scss
$primary-hue: 210;
$primary-saturation: 100%;

:root {
  // Sass variables used to generate CSS Custom Properties
  --color-primary: hsl(#{$primary-hue}, #{$primary-saturation}, 40%);
  --color-primary-light: hsl(#{$primary-hue}, #{$primary-saturation}, 60%);
  --color-primary-dark: hsl(#{$primary-hue}, #{$primary-saturation}, 20%);
}

.dark-theme {
  // These can be changed at runtime
  --color-primary: hsl(#{$primary-hue}, #{$primary-saturation}, 60%);
  --color-primary-light: hsl(#{$primary-hue}, #{$primary-saturation}, 80%);
  --color-primary-dark: hsl(#{$primary-hue}, #{$primary-saturation}, 40%);
}

.button {
  // Using the CSS Custom Properties defined above
  background-color: var(--color-primary);
  color: white;
  
  &:hover {
    background-color: var(--color-primary-dark);
  }
}</code></pre>
            </div>
        </section>

        <section class="conclusion">
            <h2>Conclusion and Next Steps</h2>
            
            <p>Sass is a powerful tool that can significantly improve your CSS workflow, allowing you to write more maintainable, reusable, and organized styles. We've covered the fundamental concepts and features, but there's always more to explore.</p>
            
            <div class="next-steps">
                <h3>What to Explore Next</h3>
                <ul>
                    <li>Advanced Sass techniques like building comprehensive design systems</li>
                    <li>Sass modules (@use and @forward)</li>
                    <li>Unit testing Sass code</li>
                    <li>Optimizing Sass compilation for production</li>
                    <li>Integrating Sass with specific frameworks (React, Vue, Angular)</li>
                </ul>
            </div>
            
            <div class="resources">
                <h3>Additional Resources</h3>
                <ul>
                    <li><a href="https://sass-lang.com/documentation/" target="_blank">Official Sass Documentation</a></li>
                    <li><a href="https://github.com/KittyGiraudel/sass-guidelines" target="_blank">Sass Guidelines by Kitty Giraudel</a></li>
                    <li><a href="https://www.smashingmagazine.com/2018/01/using-sass-efficiently/" target="_blank">Using Sass Efficiently</a></li>
                    <li><a href="https://css-tricks.com/introducing-sass-modules/" target="_blank">Sass Modules Explained</a></li>
                </ul>
            </div>
            
            <div class="exercise">
                <h3>Practical Exercise</h3>
                <p>Try converting a small section of vanilla CSS from one of your projects to SCSS:</p>
                <ol>
                    <li>Identify repeated values and convert them to variables</li>
                    <li>Look for nested structures that could benefit from Sass nesting</li>
                    <li>Create at least one mixin for repeated patterns</li>
                    <li>Organize your code into logical partials</li>
                    <li>Set up a basic compilation process</li>
                </ol>
                <p>This hands-on approach will help solidify your understanding of Sass fundamentals and demonstrate its practical benefits in a real-world context.</p>
            </div>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course</p>
    </footer>
</body>
</html>
