<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic Build Process Concepts | Web Fundamentals</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Basic Build Process Concepts</h1>
        <p>Week 4: Web Fundamentals - Friday Morning Session</p>
    </header>

    <main>
        <section class="intro">
            <h2>Introduction to Build Processes</h2>
            <p>Imagine you're a chef preparing a complex meal. You don't simply throw all the ingredients into a pot at once—you chop, measure, pre-cook, season, and assemble in a specific sequence to create the final dish. Similarly, modern web development requires processing raw code and assets through a series of transformations before they're ready to be served to users.</p>
            
            <p>A build process is the sequence of automated steps that transform your development code into production-ready files. While your development environment prioritizes readability, ease of debugging, and rapid iteration, production environments demand optimized performance, reduced file sizes, and browser compatibility.</p>
            
            <div class="key-points">
                <h3>In this session, you'll learn:</h3>
                <ul>
                    <li>Why modern web development requires build processes</li>
                    <li>The core components and steps in typical build workflows</li>
                    <li>Common build tools and how they work together</li>
                    <li>How to set up a basic build process for your projects</li>
                    <li>How to integrate build processes with your existing Docker workflow</li>
                </ul>
            </div>
        </section>

        <section class="why-build-processes">
            <h2>Why Build Processes Matter</h2>
            
            <p>In the early days of the web, developers wrote HTML, CSS, and JavaScript files that were directly served to browsers with minimal changes. Today's web applications involve complex ecosystems of code, frameworks, preprocessors, and dependencies that require transformation before deployment.</p>
            
            <div class="problems-solved">
                <h3>Problems Solved by Build Processes</h3>
                
                <div class="problem">
                    <h4>Developer Experience vs. Production Requirements</h4>
                    <p>During development, you write code optimized for readability and maintainability—using preprocessors like Sass, modern JavaScript features, separate modules, and detailed comments. For production, you need minified, bundled files with polyfills for older browsers. Build processes bridge this gap automatically.</p>
                </div>
                
                <div class="problem">
                    <h4>Managing Dependencies</h4>
                    <p>Modern web applications often rely on dozens or hundreds of third-party packages. Build processes resolve these dependencies, bundle only what's needed, and manage the order of inclusion.</p>
                </div>
                
                <div class="problem">
                    <h4>Optimization for Performance</h4>
                    <p>Techniques like code splitting, tree shaking (removing unused code), minification, and compression significantly improve load times but would be impractical to implement manually. Build processes automate these optimizations.</p>
                </div>
                
                <div class="problem">
                    <h4>Cross-Browser Compatibility</h4>
                    <p>Writing code that works across all target browsers would limit you to outdated techniques. Build processes can automatically add polyfills and transform modern code to be compatible with older browsers.</p>
                </div>
                
                <div class="problem">
                    <h4>Asset Optimization</h4>
                    <p>Images, fonts, and other assets can be automatically optimized, resized, or converted to more efficient formats during the build process.</p>
                </div>
            </div>
            
            <div class="real-world">
                <h3>Real-World Analogy</h3>
                <p>Think of the build process as the manufacturing pipeline for a car. The engineers and designers work with detailed blueprints, prototype components, and specialized tools (development environment). But before a car reaches consumers, these designs go through manufacturing processes that stamp, weld, assemble, and optimize the components for durability, safety, and efficiency (build process). The final car that reaches consumers (production code) looks quite different from the initial engineering files, but functions exactly as designed—often better.</p>
            </div>
        </section>

        <section class="core-components">
            <h2>Core Components of a Build Process</h2>
            
            <p>Although build processes vary widely depending on the project requirements, certain components appear in almost all modern web development workflows.</p>
            
            <div class="component">
                <h3>Package Management</h3>
                <p>Package managers like npm (Node Package Manager) or Yarn help you:</p>
                <ul>
                    <li>Install and manage dependencies</li>
                    <li>Define scripts for common tasks</li>
                    <li>Maintain consistent versions across development environments</li>
                </ul>
                
                <div class="example">
                    <h4>Example: package.json</h4>
                    <pre><code>{
  "name": "my-project",
  "version": "1.0.0",
  "dependencies": {
    "react": "^17.0.2",
    "react-dom": "^17.0.2"
  },
  "devDependencies": {
    "webpack": "^5.65.0",
    "webpack-cli": "^4.9.1",
    "sass": "^1.45.0",
    "babel-loader": "^8.2.3",
    "@babel/core": "^7.16.5",
    "@babel/preset-env": "^7.16.5",
    "@babel/preset-react": "^7.16.5"
  },
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack serve --mode development"
  }
}</code></pre>
                    <p>This package.json file defines the project's dependencies (packages used in the actual application), development dependencies (tools used to build the application), and scripts that automate common tasks.</p>
                </div>
            </div>
            
            <div class="component">
                <h3>Transpilation</h3>
                <p>Transpilation converts code from one language or version to another—most commonly:</p>
                <ul>
                    <li>Modern JavaScript (ES6+) to browser-compatible JavaScript</li>
                    <li>TypeScript to JavaScript</li>
                    <li>JSX (React) to JavaScript</li>
                </ul>
                
                <div class="example">
                    <h4>Example: Babel Configuration</h4>
                    <pre><code>// babel.config.js
module.exports = {
  presets: [
    ['@babel/preset-env', {
      targets: {
        browsers: ['last 2 versions', 'not dead', '> 0.5%']
      }
    }],
    '@babel/preset-react'
  ]
}</code></pre>
                    <p>This Babel configuration transpiles modern JavaScript and React JSX code to be compatible with the last 2 versions of major browsers, browsers that aren't "dead" (abandoned), and browsers with more than 0.5% market share.</p>
                </div>
                
                <div class="before-after">
                    <h4>Before and After Transpilation</h4>
                    <div class="before">
                        <h5>Before (Modern JavaScript)</h5>
                        <pre><code>// Arrow function
const multiply = (a, b) => a * b;

// Template literal
const greeting = `Hello, ${name}!`;

// Destructuring
const { id, title } = product;</code></pre>
                    </div>
                    <div class="after">
                        <h5>After (Compatible JavaScript)</h5>
                        <pre><code>// Transpiled arrow function
var multiply = function(a, b) {
  return a * b;
};

// Transpiled template literal
var greeting = "Hello, " + name + "!";

// Transpiled destructuring
var id = product.id;
var title = product.title;</code></pre>
                    </div>
                </div>
            </div>
            
            <div class="component">
                <h3>Preprocessing</h3>
                <p>Preprocessing converts higher-level syntaxes into standard web languages:</p>
                <ul>
                    <li>Sass/SCSS/Less to CSS</li>
                    <li>Pug/Handlebars to HTML</li>
                    <li>PostCSS transformations for CSS</li>
                </ul>
                
                <div class="example">
                    <h4>Example: Sass to CSS</h4>
                    <div class="before">
                        <h5>Before (SCSS)</h5>
                        <pre><code>$primary-color: #0066cc;

.button {
  background-color: $primary-color;
  border-radius: 4px;
  padding: 10px 15px;
  
  &:hover {
    background-color: darken($primary-color, 10%);
  }
  
  &-large {
    padding: 15px 25px;
    font-size: 18px;
  }
}</code></pre>
                    </div>
                    <div class="after">
                        <h5>After (CSS)</h5>
                        <pre><code>.button {
  background-color: #0066cc;
  border-radius: 4px;
  padding: 10px 15px;
}
.button:hover {
  background-color: #004c99;
}
.button-large {
  padding: 15px 25px;
  font-size: 18px;
}</code></pre>
                    </div>
                </div>
            </div>
            
            <div class="component">
                <h3>Bundling</h3>
                <p>Bundling combines multiple source files (modules) into a smaller number of optimized files for production. This improves loading performance by reducing HTTP requests and allowing for better optimization.</p>
                
                <div class="example">
                    <h4>Example: Module Imports Before Bundling</h4>
                    <pre><code>// utils.js
export function formatDate(date) {
  return new Date(date).toLocaleDateString();
}

// api.js
import axios from 'axios';

export async function fetchUser(id) {
  const response = await axios.get(`/api/users/${id}`);
  return response.data;
}

// user-profile.js
import { formatDate } from './utils.js';
import { fetchUser } from './api.js';

async function displayUser(id) {
  const user = await fetchUser(id);
  const formattedDate = formatDate(user.createdAt);
  // ...
}</code></pre>
                    <p>After bundling, these separate files and their dependencies would be combined into a single optimized file, resolving all imports and including only the code that's actually used.</p>
                </div>
            </div>
            
            <div class="component">
                <h3>Minification and Optimization</h3>
                <p>Minification reduces file sizes by removing unnecessary characters (whitespace, comments, long variable names) without changing functionality. Further optimizations might include:</p>
                <ul>
                    <li>Tree shaking (eliminating unused code)</li>
                    <li>Dead code elimination</li>
                    <li>Constant folding (pre-computing static expressions)</li>
                </ul>
                
                <div class="example">
                    <h4>Example: JavaScript Minification</h4>
                    <div class="before">
                        <h5>Before Minification</h5>
                        <pre><code>// Calculate the area of a rectangle
function calculateRectangleArea(width, height) {
  // Return width multiplied by height
  return width * height;
}

const buttonElement = document.getElementById('submitButton');
buttonElement.addEventListener('click', function(event) {
  event.preventDefault();
  const width = parseFloat(document.getElementById('width').value);
  const height = parseFloat(document.getElementById('height').value);
  const area = calculateRectangleArea(width, height);
  document.getElementById('result').textContent = 'The area is: ' + area;
});</code></pre>
                    </div>
                    <div class="after">
                        <h5>After Minification</h5>
                        <pre><code>function calculateRectangleArea(e,t){return e*t}const buttonElement=document.getElementById("submitButton");buttonElement.addEventListener("click",function(e){e.preventDefault();const t=parseFloat(document.getElementById("width").value),n=parseFloat(document.getElementById("height").value),a=calculateRectangleArea(t,n);document.getElementById("result").textContent="The area is: "+a});</code></pre>
                    </div>
                </div>
            </div>
            
            <div class="component">
                <h3>Asset Processing</h3>
                <p>Different types of assets require specific optimizations:</p>
                <ul>
                    <li>Images: Compression, resizing, format conversion (e.g., to WebP)</li>
                    <li>Fonts: Subsetting, WOFF/WOFF2 conversion</li>
                    <li>SVGs: Optimization, potential inlining</li>
                </ul>
                
                <div class="example">
                    <h4>Example: Image Processing Configuration</h4>
                    <pre><code>// webpack.config.js (partial)
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.(png|jpg|jpeg|gif)$/i,
        use: [
          {
            loader: 'image-webpack-loader',
            options: {
              mozjpeg: {
                progressive: true,
                quality: 80
              },
              optipng: {
                enabled: true,
              },
              webp: {
                quality: 85
              }
            }
          }
        ]
      }
    ]
  }
};</code></pre>
                </div>
            </div>
            
            <div class="component">
                <h3>Source Maps</h3>
                <p>Source maps are files that map the transformed code back to the original source, enabling debugging in the browser as if you were working with the original files. Without source maps, finding issues in minified production code would be nearly impossible.</p>
                
                <div class="example">
                    <h4>Example: Source Map Configuration</h4>
                    <pre><code>// webpack.config.js (partial)
module.exports = {
  // ...
  devtool: process.env.NODE_ENV === 'production' 
    ? 'source-map'  // Full source maps for production
    : 'eval-source-map', // Faster source maps for development
  // ...
};</code></pre>
                </div>
            </div>
            
            <div class="component">
                <h3>Linting and Testing</h3>
                <p>Although not always considered part of the "build" process, automated quality checks are frequently integrated into build workflows:</p>
                <ul>
                    <li>Linting: Enforcing code style and catching potential errors</li>
                    <li>Type checking: Verifying type safety in TypeScript or with Flow</li>
                    <li>Unit testing: Running automated tests to verify functionality</li>
                </ul>
                
                <div class="example">
                    <h4>Example: ESLint Configuration</h4>
                    <pre><code>// .eslintrc.js
module.exports = {
  extends: [
    'eslint:recommended',
    'plugin:react/recommended'
  ],
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true
    }
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'warn',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'warn',
    'react/prop-types': 'error'
  }
};</code></pre>
                </div>
            </div>
        </section>

        <section class="popular-tools">
            <h2>Popular Build Tools</h2>
            
            <p>The ecosystem of build tools is vast and constantly evolving. Here are some of the most widely used tools and how they fit into the build process:</p>
            
            <div class="tool">
                <h3>Task Runners</h3>
                <p>Task runners automate repetitive processes by defining custom scripts for common development tasks.</p>
                
                <div class="tool-example">
                    <h4>npm scripts</h4>
                    <p>The simplest form of task runner, built into npm itself:</p>
                    <pre><code>{
  "scripts": {
    "start": "webpack serve --mode development",
    "build": "webpack --mode production",
    "lint": "eslint src/**/*.js",
    "test": "jest",
    "predeploy": "npm run build",
    "deploy": "gh-pages -d dist"
  }
}</code></pre>
                    <p>Run with <code>npm run build</code>, <code>npm run lint</code>, etc.</p>
                </div>
                
                <div class="tool-example">
                    <h4>Gulp</h4>
                    <p>A streaming build system that uses JavaScript code to define tasks:</p>
                    <pre><code>const gulp = require('gulp');
const sass = require('gulp-sass')(require('sass'));
const autoprefixer = require('gulp-autoprefixer');
const minifyCSS = require('gulp-csso');

gulp.task('css', function() {
  return gulp.src('src/styles/**/*.scss')
    .pipe(sass())
    .pipe(autoprefixer())
    .pipe(minifyCSS())
    .pipe(gulp.dest('dist/css'));
});

gulp.task('watch', function() {
  gulp.watch('src/styles/**/*.scss', gulp.series('css'));
});

gulp.task('default', gulp.series('css', 'watch'));</code></pre>
                </div>
            </div>
            
            <div class="tool">
                <h3>Module Bundlers</h3>
                <p>Module bundlers combine separate JavaScript modules and their dependencies into optimized bundles.</p>
                
                <div class="tool-example">
                    <h4>Webpack</h4>
                    <p>The most widely used bundler, with a rich ecosystem of loaders and plugins:</p>
                    <pre><code>// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'js/[name].[contenthash].js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader'
        }
      },
      {
        test: /\.scss$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'sass-loader'
        ]
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    }),
    new MiniCssExtractPlugin({
      filename: 'css/[name].[contenthash].css'
    })
  ]
};</code></pre>
                </div>
                
                <div class="tool-example">
                    <h4>Parcel</h4>
                    <p>A zero-configuration bundler that works out of the box:</p>
                    <pre><code>// Just run parcel on your entry file
// parcel src/index.html

// package.json
{
  "scripts": {
    "dev": "parcel src/index.html",
    "build": "parcel build src/index.html"
  }
}</code></pre>
                </div>
                
                <div class="tool-example">
                    <h4>Rollup</h4>
                    <p>Focused on ES module bundling, especially good for libraries:</p>
                    <pre><code>// rollup.config.js
export default {
  input: 'src/main.js',
  output: {
    file: 'dist/bundle.js',
    format: 'esm',
    sourcemap: true
  }
};</code></pre>
                </div>
                
                <div class="tool-example">
                    <h4>Vite</h4>
                    <p>A newer, extremely fast build tool that leverages native ES modules:</p>
                    <pre><code>// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  build: {
    outDir: 'dist',
    minify: 'terser'
  }
});</code></pre>
                </div>
            </div>
            
            <div class="tool">
                <h3>Transpilers</h3>
                
                <div class="tool-example">
                    <h4>Babel</h4>
                    <p>The standard tool for JavaScript transpilation:</p>
                    <pre><code>// babel.config.js
module.exports = {
  presets: [
    '@babel/preset-env',
    '@babel/preset-react'
  ],
  plugins: [
    '@babel/plugin-proposal-class-properties',
    '@babel/plugin-transform-runtime'
  ]
};</code></pre>
                </div>
                
                <div class="tool-example">
                    <h4>TypeScript Compiler (tsc)</h4>
                    <p>Transpiles TypeScript to JavaScript and performs type checking:</p>
                    <pre><code>// tsconfig.json
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "outDir": "dist",
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}</code></pre>
                </div>
            </div>
            
            <div class="tool">
                <h3>CSS Processors</h3>
                
                <div class="tool-example">
                    <h4>Sass</h4>
                    <p>Preprocessor for SCSS/Sass files:</p>
                    <pre><code>// Using node-sass or sass package
sass src/styles/main.scss dist/css/main.css</code></pre>
                </div>
                
                <div class="tool-example">
                    <h4>PostCSS</h4>
                    <p>Transforms CSS with JavaScript plugins:</p>
                    <pre><code>// postcss.config.js
module.exports = {
  plugins: [
    require('autoprefixer'),
    require('cssnano')
  ]
};</code></pre>
                </div>
            </div>
            
            <div class="tool">
                <h3>Linters and Formatters</h3>
                
                <div class="tool-example">
                    <h4>ESLint</h4>
                    <p>Static code analysis for JavaScript:</p>
                    <pre><code>// .eslintrc.js
module.exports = {
  extends: ['eslint:recommended', 'airbnb'],
  rules: {
    'no-console': 'warn'
  }
};</code></pre>
                </div>
                
                <div class="tool-example">
                    <h4>Prettier</h4>
                    <p>Code formatter for consistent styling:</p>
                    <pre><code>// .prettierrc
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5"
}</code></pre>
                </div>
            </div>
        </section>

        <section class="build-process-lifecycle">
            <h2>The Build Process Lifecycle</h2>
            
            <p>A typical build process follows a sequence of operations, from raw source code to production-ready assets. Understanding this lifecycle helps you configure your tools effectively and troubleshoot issues.</p>
            
            <div class="lifecycle-diagram">
                <h3>Basic Build Lifecycle</h3>
                <pre>
   ┌───────────────┐        ┌───────────────┐        ┌───────────────┐
   │  Source Code  │        │  Development  │        │  Production   │
   │  Development  │ ──────▶│  Build        │ ──────▶│  Build        │
   └───────────────┘        └───────────────┘        └───────────────┘
          │                        │                        │
          ▼                        ▼                        ▼
   ┌───────────────┐        ┌───────────────┐        ┌───────────────┐
   │• Write code   │        │• Fast builds  │        │• Optimization │
   │• Test locally │        │• Source maps  │        │• Minification │
   │• Iterate      │        │• Hot reloading│        │• Compression  │
   └───────────────┘        └───────────────┘        └───────────────┘
                                                             │
                                                             ▼
                                                     ┌───────────────┐
                                                     │  Deployment   │
                                                     └───────────────┘
                </pre>
            </div>
            
            <div class="stage">
                <h3>Development Stage</h3>
                <p>During development, the build process prioritizes speed and developer experience:</p>
                <ul>
                    <li><strong>Watching for changes:</strong> Automatically rebuilding when files are modified</li>
                    <li><strong>Hot Module Replacement (HMR):</strong> Updating modules in the browser without a full refresh</li>
                    <li><strong>Detailed source maps:</strong> For effective debugging</li>
                    <li><strong>Development server:</strong> With features like auto-reload and proxy APIs</li>
                </ul>
                <pre><code>// Development build script example
"dev": "webpack serve --mode development --open"</code></pre>
            </div>
            
            <div class="stage">
                <h3>Production Stage</h3>
                <p>For production, the build process focuses on optimization:</p>
                <ul>
                    <li><strong>Minification:</strong> Reducing file sizes by removing whitespace, shortening variable names, etc.</li>
                    <li><strong>Tree shaking:</strong> Eliminating dead code and unused exports</li>
                    <li><strong>Code splitting:</strong> Breaking bundles into smaller chunks that can be loaded on demand</li>
                    <li><strong>Asset optimization:</strong> Compressing images, inlining small resources</li>
                    <li><strong>Cache busting:</strong> Adding content hashes to filenames to ensure cache invalidation when content changes</li>
                </ul>
                <pre><code>// Production build script example
"build": "webpack --mode production"</code></pre>
            </div>
            
            <div class="stage">
                <h3>Pre and Post Processing</h3>
                <p>Build processes often include additional steps before or after the main build:</p>
                <ul>
                    <li><strong>Pre-build:</strong> Cleaning output directories, validating configurations</li>
                    <li><strong>Post-build:</strong> Generating reports, preparing for deployment</li>
                </ul>
                <pre><code>// Pre and post build hooks
"prebuild": "rimraf dist",
"build": "webpack --mode production",
"postbuild": "node scripts/generate-build-report.js"</code></pre>
            </div>
            
            <div class="stage">
                <h3>Continuous Integration</h3>
                <p>In team environments, build processes are often integrated with CI/CD systems:</p>
                <ul>
                    <li><strong>Automated testing:</strong> Running unit, integration, and end-to-end tests</li>
                    <li><strong>Quality checks:</strong> Linting, type checking, code coverage</li>
                    <li><strong>Artifact generation:</strong> Creating deployable packages</li>
                    <li><strong>Deployment:</strong> Automatically deploying to staging or production environments</li>
                </ul>
            </div>
        </section>

        <section class="setting-up">
            <h2>Setting Up a Basic Build Process</h2>
            
            <p>Let's walk through setting up a simple but effective build process for a web project. We'll use webpack as our bundler, Babel for transpilation, Sass for CSS preprocessing, and some basic optimizations.</p>
            
            <div class="setup-steps">
                <h3>Step 1: Initialize a New Project</h3>
                <pre><code>mkdir my-project
cd my-project
npm init -y</code></pre>
            </div>
            
            <div class="setup-steps">
                <h3>Step 2: Install Dependencies</h3>
                <pre><code>npm install --save-dev webpack webpack-cli webpack-dev-server
npm install --save-dev babel-loader @babel/core @babel/preset-env
npm install --save-dev css-loader style-loader sass sass-loader
npm install --save-dev html-webpack-plugin mini-css-extract-plugin
npm install --save-dev terser-webpack-plugin css-minimizer-webpack-plugin</code></pre>
            </div>
            
            <div class="setup-steps">
                <h3>Step 3: Create Project Structure</h3>
                <pre><code>my-project/
├── src/
│   ├── index.js         # Main JavaScript entry point
│   ├── index.html       # HTML template
│   ├── styles/
│   │   └── main.scss    # Main stylesheet
│   ├── components/
│   │   └── example.js   # Component module
│   └── assets/
│       └── logo.png     # Example asset
├── webpack.config.js    # Webpack configuration
├── babel.config.js      # Babel configuration
└── package.json         # Project manifest</code></pre>
            </div>
            
            <div class="setup-steps">
                <h3>Step 4: Configure Babel</h3>
                <pre><code>// babel.config.js
module.exports = {
  presets: [
    ['@babel/preset-env', {
      targets: '> 0.25%, not dead',
      useBuiltIns: 'usage',
      corejs: 3
    }]
  ]
};</code></pre>
            </div>
            
            <div class="setup-steps">
                <h3>Step 5: Configure Webpack</h3>
                <pre><code>// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

// Determine if we're in development or production mode
const isProduction = process.env.NODE_ENV === 'production';

module.exports = {
  // Entry point for the application
  entry: './src/index.js',
  
  // Output configuration
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: isProduction ? 'js/[name].[contenthash].js' : 'js/[name].js',
    clean: true // Clean the output directory before emit
  },
  
  // Development server configuration
  devServer: {
    static: path.resolve(__dirname, 'dist'),
    hot: true,
    open: true,
    port: 8080
  },
  
  // Determine source map type based on environment
  devtool: isProduction ? 'source-map' : 'eval-source-map',
  
  // Optimization settings
  optimization: {
    minimize: isProduction,
    minimizer: [
      new TerserPlugin(), // Minify JavaScript
      new CssMinimizerPlugin() // Minify CSS
    ],
    // Split code into chunks
    splitChunks: {
      chunks: 'all',
      name: false
    }
  },
  
  // Module rules for different file types
  module: {
    rules: [
      // JavaScript
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader'
        }
      },
      // SCSS/CSS
      {
        test: /\.(scss|css)$/,
        use: [
          // In production, extract CSS to separate files
          // In development, inject CSS into the DOM
          isProduction ? MiniCssExtractPlugin.loader : 'style-loader',
          'css-loader', // Process CSS imports
          'sass-loader' // Compile Sass to CSS
        ]
      },
      // Images
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset', // Automatically choose between asset/resource and asset/inline
        parser: {
          dataUrlCondition: {
            // Inline images smaller than 8kb
            maxSize: 8 * 1024
          }
        },
        generator: {
          filename: 'images/[hash][ext][query]'
        }
      },
      // Fonts
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/i,
        type: 'asset/resource',
        generator: {
          filename: 'fonts/[hash][ext][query]'
        }
      }
    ]
  },
  
  // Plugins
  plugins: [
    // Generate HTML file with injected bundles
    new HtmlWebpackPlugin({
      template: './src/index.html',
      minify: isProduction ? {
        removeComments: true,
        collapseWhitespace: true,
        removeRedundantAttributes: true,
        useShortDoctype: true,
        removeEmptyAttributes: true,
        removeStyleLinkTypeAttributes: true,
        keepClosingSlash: true,
        minifyJS: true,
        minifyCSS: true,
        minifyURLs: true
      } : false
    }),
    
    // In production, extract CSS into separate files
    ...(isProduction ? [
      new MiniCssExtractPlugin({
        filename: 'css/[name].[contenthash].css'
      })
    ] : [])
  ],
  
  // Set mode based on environment
  mode: isProduction ? 'production' : 'development'
};</code></pre>
            </div>
            
            <div class="setup-steps">
                <h3>Step 6: Add NPM Scripts</h3>
                <pre><code>// package.json (scripts section)
"scripts": {
  "start": "webpack serve",
  "build": "NODE_ENV=production webpack",
  "build:dev": "webpack"
}</code></pre>
            </div>
            
            <div class="setup-steps">
                <h3>Step 7: Create Basic Source Files</h3>
                <pre><code>// src/index.html
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;My Project&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="app"&gt;
    &lt;h1&gt;Hello, World!&lt;/h1&gt;
    &lt;div class="container"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

                <pre><code>// src/styles/main.scss
$primary-color: #0066cc;
$secondary-color: #f5f5f5;

body {
  font-family: 'Arial', sans-serif;
  line-height: 1.6;
  color: #333;
  margin: 0;
  padding: 0;
}

#app {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

h1 {
  color: $primary-color;
}

.container {
  background-color: $secondary-color;
  padding: 20px;
  border-radius: 4px;
}</code></pre>

                <pre><code>// src/components/example.js
export function createGreeting(name) {
  const element = document.createElement('div');
  element.classList.add('greeting');
  element.textContent = `Hello, ${name}!`;
  return element;
}</code></pre>

                <pre><code>// src/index.js
import './styles/main.scss';
import { createGreeting } from './components/example';

document.addEventListener('DOMContentLoaded', () => {
  const container = document.querySelector('.container');
  const greeting = createGreeting('Web Developer');
  container.appendChild(greeting);
  
  console.log('Application initialized');
});</code></pre>
            </div>
            
            <div class="setup-steps">
                <h3>Step 8: Run the Build Process</h3>
                <pre><code>// Development mode with dev server
npm start

// Production build
npm run build</code></pre>
            </div>
        </section>

        <section class="docker-integration">
            <h2>Integrating with Docker</h2>
            
            <p>Since we're using Docker in this course, let's look at how to integrate your build process into a Docker workflow. This approach ensures consistent builds across different environments and simplifies deployment.</p>
            
            <div class="docker-approach">
                <h3>Multi-Stage Docker Build</h3>
                <p>A multi-stage Docker build separates the build environment from the production environment, resulting in smaller, more secure images:</p>
                <pre><code>FROM node:14 AS build

WORKDIR /app

# Copy package files and install dependencies
COPY package.json package-lock.json ./
RUN npm ci

# Copy source files
COPY . .

# Build the application
RUN npm run build

# Production stage
FROM nginx:alpine AS production

# Copy built assets from build stage
COPY --from=build /app/dist /usr/share/nginx/html

# Copy nginx configuration if needed
# COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]</code></pre>
                <p>This Dockerfile:</p>
                <ol>
                    <li>Starts with a Node.js base image for building</li>
                    <li>Installs dependencies and builds the application</li>
                    <li>Creates a final image based on Nginx (lightweight web server)</li>
                    <li>Copies only the build output (not source code or build tools) to the production image</li>
                </ol>
            </div>
            
            <div class="docker-compose">
                <h3>Development with Docker Compose</h3>
                <p>For local development, Docker Compose can provide a consistent environment with hot reloading:</p>
                <pre><code>version: '3'

services:
  frontend:
    build:
      context: .
      dockerfile: Dockerfile.dev
    volumes:
      - ./src:/app/src
      - ./webpack.config.js:/app/webpack.config.js
    ports:
      - "8080:8080"
    environment:
      - NODE_ENV=development

# Dockerfile.dev
FROM node:14

WORKDIR /app

COPY package.json package-lock.json ./
RUN npm ci

COPY . .

CMD ["npm", "start"]</code></pre>
                <p>This setup mounts your source directory as a volume, allowing changes to be immediately reflected in the container.</p>
            </div>
            
            <div class="ci-pipeline">
                <h3>CI/CD Pipeline with Docker</h3>
                <p>When integrating with CI systems like GitHub Actions or GitLab CI, you can use Docker to ensure consistent builds:</p>
                <pre><code># .github/workflows/build.yml
name: Build and Deploy

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v2
      with:
        context: .
        push: true
        tags: myapp:latest</code></pre>
            </div>
        </section>

        <section class="best-practices">
            <h2>Build Process Best Practices</h2>
            
            <div class="practice">
                <h3>Performance Optimization</h3>
                <ul>
                    <li><strong>Split configurations:</strong> Have separate configurations for development and production</li>
                    <li><strong>Cache dependencies:</strong> Use lockfiles (package-lock.json, yarn.lock) and CI caching</li>
                    <li><strong>Parallelize when possible:</strong> Many build tools support parallel processing</li>
                    <li><strong>Analyze your bundle:</strong> Use tools like webpack-bundle-analyzer to identify opportunities for optimization</li>
                </ul>
            </div>
            
            <div class="practice">
                <h3>Maintainability</h3>
                <ul>
                    <li><strong>Document your build process:</strong> Include a README explaining how to build and deploy</li>
                    <li><strong>Use configuration files:</strong> Keep build logic in dedicated configuration files rather than package.json scripts</li>
                    <li><strong>Version your build tools:</strong> Pin versions in package.json to ensure consistent builds</li>
                    <li><strong>Prefer smaller, focused packages:</strong> Choose tools that do one thing well over monolithic solutions</li>
                </ul>
            </div>
            
            <div class="practice">
                <h3>Security</h3>
                <ul>
                    <li><strong>Audit dependencies:</strong> Regularly run <code>npm audit</code> and update vulnerable packages</li>
                    <li><strong>Sanitize environment variables:</strong> Avoid exposing sensitive data in client-side code</li>
                    <li><strong>Use Content Security Policy:</strong> Configure CSP headers to prevent XSS attacks</li>
                    <li><strong>Validate input files:</strong> Implement checks for malicious code in third-party dependencies</li>
                </ul>
            </div>
            
            <div class="practice">
                <h3>Debugging and Monitoring</h3>
                <ul>
                    <li><strong>Configure proper source maps:</strong> Make debugging easier while maintaining security</li>
                    <li><strong>Implement error tracking:</strong> Use services like Sentry to monitor production errors</li>
                    <li><strong>Set up logging:</strong> Record build process details for troubleshooting</li>
                    <li><strong>Monitor build times:</strong> Track performance metrics to identify bottlenecks</li>
                </ul>
            </div>
        </section>

        <section class="future-trends">
            <h2>Future Trends in Build Processes</h2>
            
            <p>The landscape of build tools and processes continues to evolve. Here are some trends to watch:</p>
            
            <div class="trend">
                <h3>ESM-Native Tools</h3>
                <p>As browsers increasingly support ES Modules natively, build tools are adapting to leverage these capabilities for faster development experiences. Tools like Snowpack and Vite use native ESM during development and only bundle for production.</p>
            </div>
            
            <div class="trend">
                <h3>WebAssembly in Build Tools</h3>
                <p>WebAssembly is being used to improve build tool performance. Tools like esbuild (written in Go) and SWC (written in Rust) compile to WebAssembly for significantly faster JavaScript transformations.</p>
            </div>
            
            <div class="trend">
                <h3>Zero-Configuration Tools</h3>
                <p>The trend toward simpler developer experiences continues with more tools offering sensible defaults and minimal configuration requirements.</p>
            </div>
            
            <div class="trend">
                <h3>Build-Time vs. Runtime</h3>
                <p>The line between build-time and runtime is blurring with approaches like partial hydration, island architecture, and server components that optimize what code runs where and when.</p>
            </div>
        </section>

        <section class="conclusion">
            <h2>Conclusion</h2>
            
            <p>Build processes are an essential part of modern web development, bridging the gap between developer-friendly source code and optimized production assets. By understanding the core components, tools, and workflows of build processes, you can make informed decisions about how to structure your projects and optimize your development experience.</p>
            
            <p>As you continue in this course, you'll apply these concepts in increasingly sophisticated ways, integrating them with backend systems and deployment pipelines. The time invested in understanding build processes will pay dividends in productivity, performance, and maintainability.</p>
            
            <div class="resources">
                <h3>Additional Resources</h3>
                <ul>
                    <li><a href="https://webpack.js.org/concepts/" target="_blank">Webpack Documentation</a></li>
                    <li><a href="https://babeljs.io/docs/en/" target="_blank">Babel Documentation</a></li>
                    <li><a href="https://vitejs.dev/guide/" target="_blank">Vite Documentation</a></li>
                    <li><a href="https://docs.npmjs.com/cli/v7/using-npm/scripts" target="_blank">npm Scripts Guide</a></li>
                    <li><a href="https://web.dev/fast/" target="_blank">Web Performance Optimization Guide</a></li>
                </ul>
            </div>
            
            <div class="exercise">
                <h3>Practical Exercise</h3>
                <p>Try implementing a basic build process for one of your previous projects:</p>
                <ol>
                    <li>Set up webpack with babel-loader for JavaScript</li>
                    <li>Add a CSS preprocessor (Sass or Less)</li>
                    <li>Configure different development and production builds</li>
                    <li>Implement at least one optimization technique (minification, code splitting, etc.)</li>
                    <li>Dockerize your build process using a multi-stage approach</li>
                </ol>
                <p>This hands-on practice will solidify your understanding and prepare you for more complex build configurations in future projects.</p>
            </div>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course</p>
    </footer>
</body>
</html>
