<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debugging Techniques for Frontend | Web Fundamentals</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Debugging Techniques for Frontend</h1>
        <p>Week 4: Web Fundamentals - Friday Session</p>
    </header>

    <main>
        <section class="intro">
            <h2>Introduction to Frontend Debugging</h2>
            <p>Debugging is the art of finding and fixing issues in your code. Think of it as being a detective in a mystery novelâ€”you gather clues, form hypotheses, test them, and ultimately solve the case. In frontend development, this process can be particularly challenging due to the interaction of multiple technologies (HTML, CSS, JavaScript) and the variability of browser environments.</p>
            
            <p>Effective debugging is what separates beginner developers from experienced ones. While novices often resort to random changes hoping to fix issues (the "try and see" approach), skilled developers systematically track down bugs using specialized tools and techniques.</p>
            
            <div class="key-points">
                <h3>In this session, you'll learn:</h3>
                <ul>
                    <li>The debugging mindset and systematic approach to problem-solving</li>
                    <li>How to effectively use browser developer tools for debugging</li>
                    <li>Specialized techniques for HTML, CSS, and JavaScript debugging</li>
                    <li>Common frontend bugs and how to fix them</li>
                    <li>Preventive measures to write more bug-resistant code</li>
                    <li>Debugging in different environments (mobile, cross-browser)</li>
                </ul>
            </div>
            
            <div class="debugging-mindset">
                <h3>The Debugging Mindset</h3>
                <p>Before diving into specific techniques, let's establish the right approach to debugging:</p>
                
                <ul>
                    <li><strong>Be methodical:</strong> Random changes rarely solve problems permanently. Take a systematic approach.</li>
                    <li><strong>Isolate the issue:</strong> Break down complex problems into smaller, testable parts.</li>
                    <li><strong>Question assumptions:</strong> Often bugs exist because of incorrect assumptions about how something works.</li>
                    <li><strong>Keep a debugging journal:</strong> Document your debugging process to learn from it.</li>
                    <li><strong>Take breaks:</strong> A fresh perspective often leads to insights that were missed during prolonged debugging sessions.</li>
                </ul>
                
                <p>Remember: The time you invest in developing good debugging skills will pay off exponentially throughout your career.</p>
            </div>
        </section>

        <section class="browser-tools">
            <h2>Browser Developer Tools: Your Debugging Workbench</h2>
            
            <p>Modern browsers come equipped with powerful developer tools that serve as your primary debugging workbench. Let's explore the key components of these tools and how to use them effectively for debugging.</p>
            
            <div class="elements-panel">
                <h3>Elements Panel: Debugging HTML and CSS</h3>
                
                <p>The Elements panel provides a live view of your page's DOM and CSS, allowing you to inspect and modify elements on the fly.</p>
                
                <div class="technique">
                    <h4>DOM Inspection Techniques</h4>
                    <ul>
                        <li><strong>DOM tree navigation:</strong> Expand/collapse nodes to explore the element hierarchy</li>
                        <li><strong>Search:</strong> Use Ctrl+F/Cmd+F to find elements by tag, ID, class, or content</li>
                        <li><strong>Element selection:</strong> Right-click any element on the page and select "Inspect" to jump to it in the Elements panel</li>
                        <li><strong>Element highlighting:</strong> Hover over elements in the DOM tree to highlight them on the page</li>
                    </ul>
                    
                    <div class="debugging-example">
                        <h5>Debugging Missing Elements</h5>
                        <p>When elements aren't appearing on your page as expected:</p>
                        <ol>
                            <li>Search for the element by ID, class, or tag in the Elements panel</li>
                            <li>If found, check if it's visible (might be hidden by CSS)</li>
                            <li>If not found, check your JavaScript to see if the element is being added to the DOM correctly</li>
                            <li>Examine parent elements to see if there are structural issues</li>
                        </ol>
                    </div>
                </div>
                
                <div class="technique">
                    <h4>CSS Debugging with the Styles Pane</h4>
                    <ul>
                        <li><strong>Computed styles:</strong> See the final applied CSS properties after all rules are calculated</li>
                        <li><strong>Box model visualization:</strong> Examine an element's box model (content, padding, border, margin)</li>
                        <li><strong>Style tracing:</strong> See which CSS rules are being applied and which are being overridden</li>
                        <li><strong>Style toggling:</strong> Enable/disable CSS properties by clicking the checkboxes</li>
                        <li><strong>Live editing:</strong> Modify CSS properties and see immediate results</li>
                    </ul>
                    
                    <div class="debugging-example">
                        <h5>Debugging CSS Specificity Issues</h5>
                        <p>When your CSS styles aren't being applied as expected:</p>
                        <ol>
                            <li>Inspect the element and look at the Styles pane</li>
                            <li>Look for crossed-out properties (these are being overridden)</li>
                            <li>Check the cascade order and specificity of conflicting rules</li>
                            <li>Temporarily add a more specific selector or <code>!important</code> to confirm your hypothesis</li>
                            <li>Fix the specificity issue in your source CSS</li>
                        </ol>
                    </div>
                </div>
                
                <div class="technique">
                    <h4>Advanced Element Panel Techniques</h4>
                    <ul>
                        <li><strong>Force element states:</strong> Simulate :hover, :active, :focus, and other states</li>
                        <li><strong>DOM breakpoints:</strong> Pause JavaScript execution when the DOM changes</li>
                        <li><strong>CSS Grid/Flexbox inspection:</strong> Visualize and debug modern layout systems</li>
                        <li><strong>Color picker and accessibility tools:</strong> Check contrast ratios and color values</li>
                    </ul>
                    
                    <div class="debugging-example">
                        <h5>Setting DOM Breakpoints</h5>
                        <p>To debug JavaScript that's modifying the DOM unexpectedly:</p>
                        <ol>
                            <li>Right-click an element in the Elements panel</li>
                            <li>Select "Break on" and choose the type of modification you want to catch (subtree modifications, attribute modifications, or node removal)</li>
                            <li>Perform the action that causes the change</li>
                            <li>JavaScript execution will pause, showing you the exact code responsible for the DOM change</li>
                        </ol>
                    </div>
                </div>
            </div>
            
            <div class="console-panel">
                <h3>Console Panel: Interactive Debugging</h3>
                
                <p>The Console panel is your command center for JavaScript debugging and interactive exploration.</p>
                
                <div class="technique">
                    <h4>Console Methods Beyond console.log()</h4>
                    <pre><code>// Basic logging
console.log('Simple message');

// Formatted logging with placeholder syntax
console.log('Hello, %s!', 'World'); // Hello, World!

// Styling console output
console.log('%cAttention!', 'color: red; font-size: 20px; font-weight: bold;');

// Showing object structure
const user = { name: 'Alice', role: 'Admin', permissions: ['read', 'write'] };
console.log(user); // Interactive object explorer
console.dir(user); // Shows JavaScript object properties

// Tabular data
console.table(user);

// Grouping related logs
console.group('User Authentication');
console.log('Checking credentials...');
console.log('Authentication successful');
console.groupEnd();

// Asserting conditions (logs only if condition is false)
console.assert(user.role === 'Guest', 'User is not a guest!');

// Measuring execution time
console.time('Operation');
// ... some operation
console.timeEnd('Operation'); // Operation: 1.23ms

// Counting occurrences
function processItem(item) {
  console.count('Items processed');
  // Processing logic
}

// Creating a stack trace
console.trace('Execution reached this point');</code></pre>
                </div>
                
                <div class="technique">
                    <h4>Interactive JavaScript Execution</h4>
                    <ul>
                        <li><strong>Live evaluation:</strong> Type JavaScript expressions directly in the console</li>
                        <li><strong>Multi-line editor:</strong> Press Shift+Enter to create multi-line code blocks</li>
                        <li><strong>$ shorthand functions:</strong> Use <code>$(selector)</code> instead of <code>document.querySelector()</code> and <code>$$(selector)</code> instead of <code>document.querySelectorAll()</code></li>
                        <li><strong>Recently evaluated expressions:</strong> Access with <code>$_</code></li>
                    </ul>
                    
                    <div class="debugging-example">
                        <h5>Debugging Variable State</h5>
                        <p>To inspect the value of variables at runtime:</p>
                        <ol>
                            <li>Add a <code>debugger;</code> statement in your code where you want to pause execution</li>
                            <li>When execution pauses, use the console to:
                                <ul>
                                    <li>Examine variable values by typing their names</li>
                                    <li>Explore objects with <code>console.dir(object)</code></li>
                                    <li>Test potential fixes with live code execution</li>
                                </ul>
                            </li>
                            <li>Resume execution to see if your changes fixed the issue</li>
                        </ol>
                    </div>
                </div>
                
                <div class="technique">
                    <h4>Console Filters and Settings</h4>
                    <ul>
                        <li><strong>Log level filtering:</strong> Show/hide errors, warnings, info, etc.</li>
                        <li><strong>Regular expression filtering:</strong> Show only messages matching a pattern</li>
                        <li><strong>Context selection:</strong> Choose which frames/contexts to show messages from</li>
                        <li><strong>Preserve log:</strong> Keep logs between page refreshes</li>
                    </ul>
                </div>
            </div>
            
            <div class="sources-panel">
                <h3>Sources Panel: JavaScript Debugging Powerhouse</h3>
                
                <p>The Sources panel is where you'll spend most of your time debugging complex JavaScript issues.</p>
                
                <div class="technique">
                    <h4>Working with Breakpoints</h4>
                    <ul>
                        <li><strong>Line breakpoints:</strong> Click the line number to set a breakpoint</li>
                        <li><strong>Conditional breakpoints:</strong> Right-click a line number and set a condition</li>
                        <li><strong>Logpoint breakpoints:</strong> Print a message to the console without stopping execution</li>
                        <li><strong>Event listener breakpoints:</strong> Pause on specific events (clicks, timers, etc.)</li>
                        <li><strong>XHR/Fetch breakpoints:</strong> Pause when a request URL contains specific text</li>
                    </ul>
                    
                    <div class="debugging-example">
                        <h5>Using Conditional Breakpoints</h5>
                        <p>When debugging an issue that only occurs with specific values:</p>
                        <ol>
                            <li>Right-click on the line number where you want to break</li>
                            <li>Select "Add conditional breakpoint"</li>
                            <li>Enter a condition (e.g., <code>user.id === 123</code>)</li>
                            <li>Execution will only pause when the condition evaluates to true</li>
                        </ol>
                    </div>
                </div>
                
                <div class="technique">
                    <h4>Stepping Through Code</h4>
                    <ul>
                        <li><strong>Resume execution:</strong> Continue until the next breakpoint</li>
                        <li><strong>Step over:</strong> Execute the current line and move to the next one</li>
                        <li><strong>Step into:</strong> Enter the function being called on the current line</li>
                        <li><strong>Step out:</strong> Complete the current function and return to the caller</li>
                        <li><strong>Deactivate breakpoints:</strong> Run without stopping at breakpoints</li>
                    </ul>
                    
                    <div class="debugging-example">
                        <h5>Debugging a Function Call Chain</h5>
                        <p>When tracking down where a function receives incorrect data:</p>
                        <ol>
                            <li>Set a breakpoint at the start of the function</li>
                            <li>Examine the parameters using the Local scope in the Scope pane</li>
                            <li>If the values look correct, step through the function with "Step over"</li>
                            <li>If you see a function call that might be the source of the issue, use "Step into"</li>
                            <li>Once you've found where the incorrect value is introduced, fix the issue in your source code</li>
                        </ol>
                    </div>
                </div>
                
                <div class="technique">
                    <h4>Scope and Watch Expressions</h4>
                    <ul>
                        <li><strong>Scope pane:</strong> Examine variables in different scopes (local, closure, global)</li>
                        <li><strong>Watch expressions:</strong> Monitor specific expressions as you step through code</li>
                        <li><strong>Call stack:</strong> See the sequence of function calls that led to the current point</li>
                    </ul>
                    
                    <div class="debugging-example">
                        <h5>Using Watch Expressions</h5>
                        <p>To track calculated values or complex expressions:</p>
                        <ol>
                            <li>Add a breakpoint where you want to start debugging</li>
                            <li>When execution pauses, click the "+" in the Watch pane</li>
                            <li>Enter expressions to monitor (e.g., <code>user.isAdmin && user.hasPermission('delete')</code>)</li>
                            <li>As you step through code, watch how these expressions change</li>
                        </ol>
                    </div>
                </div>
                
                <div class="technique">
                    <h4>Source Maps and Transpiled Code</h4>
                    <p>Modern JavaScript development often involves transpilation (e.g., from TypeScript or ES6+ to ES5). Source maps allow you to debug the original source code rather than the transpiled version.</p>
                    
                    <div class="debugging-example">
                        <h5>Enabling Source Maps</h5>
                        <p>To debug original source code in a build environment:</p>
                        <ol>
                            <li>Ensure your build system generates source maps (e.g., in webpack: <code>devtool: 'source-map'</code>)</li>
                            <li>In Chrome DevTools, go to Settings (gear icon) â†’ Preferences â†’ Sources</li>
                            <li>Enable "Enable JavaScript source maps" and "Enable CSS source maps"</li>
                            <li>Reload the page and set breakpoints in your original source files</li>
                        </ol>
                    </div>
                </div>
            </div>
            
            <div class="network-panel">
                <h3>Network Panel: Debugging Data and API Issues</h3>
                
                <p>The Network panel helps you diagnose problems related to data fetching, API calls, and resource loading.</p>
                
                <div class="technique">
                    <h4>Inspecting Network Requests</h4>
                    <ul>
                        <li><strong>Request filtering:</strong> Filter by type (XHR, JS, CSS, etc.) or using the search box</li>
                        <li><strong>Request details:</strong> Click on a request to see headers, preview, response, timing, etc.</li>
                        <li><strong>Request/response bodies:</strong> Examine the data sent and received</li>
                        <li><strong>Status codes:</strong> Identify failed requests (4xx, 5xx status codes)</li>
                    </ul>
                    
                    <div class="debugging-example">
                        <h5>Debugging a Failed API Call</h5>
                        <p>When your application isn't receiving expected data:</p>
                        <ol>
                            <li>Open the Network panel and filter for XHR requests</li>
                            <li>Perform the action that should trigger the API call</li>
                            <li>Look for the request and check its status code (red indicates failure)</li>
                            <li>Examine the request details:
                                <ul>
                                    <li>Headers tab: Check authorization, content-type, etc.</li>
                                    <li>Payload tab: Verify the data being sent</li>
                                    <li>Response tab: Look for error messages or invalid data</li>
                                </ul>
                            </li>
                            <li>Fix the issue in your code (auth token, request format, etc.)</li>
                        </ol>
                    </div>
                </div>
                
                <div class="technique">
                    <h4>Network Conditions and Throttling</h4>
                    <ul>
                        <li><strong>Connection throttling:</strong> Simulate slow connections (3G, etc.)</li>
                        <li><strong>Offline mode:</strong> Test how your app behaves without connectivity</li>
                        <li><strong>Cache disabling:</strong> Force fresh requests to avoid cached responses</li>
                        <li><strong>User-Agent spoofing:</strong> Test with different user agent strings</li>
                    </ul>
                    
                    <div class="debugging-example">
                        <h5>Debugging Loading Performance</h5>
                        <p>To identify slow-loading resources:</p>
                        <ol>
                            <li>Apply 3G throttling in the Network panel</li>
                            <li>Reload the page with an empty cache (Ctrl+Shift+R/Cmd+Shift+R)</li>
                            <li>Sort the resources by "Time" to see the slowest-loading items</li>
                            <li>Look for patterns: large images, third-party scripts, etc.</li>
                            <li>Optimize identified resources (compression, lazy-loading, etc.)</li>
                        </ol>
                    </div>
                </div>
                
                <div class="technique">
                    <h4>Request Blocking and Modification</h4>
                    <p>Chrome DevTools and Firefox DevTools allow you to block or modify network requests, which is useful for testing how your application handles failures or different responses.</p>
                    
                    <div class="debugging-example">
                        <h5>Testing Error Handling</h5>
                        <p>To verify that your application handles API errors gracefully:</p>
                        <ol>
                            <li>In Chrome, go to the Network panel</li>
                            <li>Right-click a request and select "Block request URL" or "Block request domain"</li>
                            <li>Retry the action and observe how your application handles the failed request</li>
                            <li>Implement proper error handling if it's missing</li>
                        </ol>
                    </div>
                </div>
            </div>
            
            <div class="additional-panels">
                <h3>Other Useful Debugging Panels</h3>
                
                <div class="technique">
                    <h4>Performance Panel</h4>
                    <p>For debugging performance issues, slow animations, or excessive CPU usage:</p>
                    <ul>
                        <li>Record a performance profile during the problematic interaction</li>
                        <li>Analyze the flame chart to identify slow functions or rendering bottlenecks</li>
                        <li>Look for long tasks blocking the main thread</li>
                        <li>Check for layout thrashing or excessive style recalculations</li>
                    </ul>
                </div>
                
                <div class="technique">
                    <h4>Memory Panel</h4>
                    <p>For debugging memory leaks or excessive memory usage:</p>
                    <ul>
                        <li>Take heap snapshots before and after suspected leaking operations</li>
                        <li>Compare snapshots to find objects that weren't garbage collected</li>
                        <li>Analyze retained object chains to understand what's preventing garbage collection</li>
                    </ul>
                </div>
                
                <div class="technique">
                    <h4>Application Panel</h4>
                    <p>For debugging storage-related issues:</p>
                    <ul>
                        <li>Inspect and modify localStorage, sessionStorage, and cookies</li>
                        <li>Examine IndexedDB and Web SQL databases</li>
                        <li>Manage service workers and cached resources</li>
                        <li>Test clearing site data to reproduce first-visit experiences</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="html-debugging">
            <h2>HTML Debugging Techniques</h2>
            
            <p>HTML issues can be deceptively simple yet frustrating to track down. Here are specialized techniques for debugging HTML-specific problems.</p>
            
            <div class="common-issues">
                <h3>Common HTML Issues and Solutions</h3>
                
                <div class="issue">
                    <h4>Invalid HTML Structure</h4>
                    <p>Browsers try to repair invalid HTML, often leading to unexpected rendering.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>&lt;div&gt;
  &lt;p&gt;Some text
  &lt;ul&gt;
    &lt;li&gt;Item 1&lt;/li&gt;
    &lt;li&gt;Item 2&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Inspect the element structure in the Elements panel</li>
                            <li>Look for unexpected nesting or missing closing tags</li>
                            <li>Compare the DOM structure to your original HTML</li>
                            <li>Use HTML validation services to catch structural issues</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>&lt;div&gt;
  &lt;p&gt;Some text&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;Item 1&lt;/li&gt;
    &lt;li&gt;Item 2&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</code></pre>
                    </div>
                </div>
                
                <div class="issue">
                    <h4>HTML Attributes and Properties</h4>
                    <p>Issues with attributes can cause elements to behave unexpectedly.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>&lt;img src="image.jpg"/&gt; &lt;!-- Image doesn't appear --&gt;
&lt;a href="#" onclick="navigate('page.html')"&gt;Link&lt;/a&gt; &lt;!-- Link doesn't work --&gt;</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Check resource paths (src, href) in the Network panel</li>
                            <li>Verify that IDs and classes match your CSS selectors</li>
                            <li>Inspect event handlers in the Event Listeners tab</li>
                            <li>Test alternative attribute values directly in the Elements panel</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>&lt;img src="images/image.jpg" alt="Description"/&gt;
&lt;a href="javascript:void(0)" onclick="navigate('page.html')"&gt;Link&lt;/a&gt;</code></pre>
                    </div>
                </div>
                
                <div class="issue">
                    <h4>Form Elements</h4>
                    <p>Form controls often have special behavior that can be tricky to debug.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>&lt;form&gt;
  &lt;input type="text" name="username"/&gt;
  &lt;button&gt;Submit&lt;/button&gt; &lt;!-- Form submits but without data --&gt;
&lt;/form&gt;</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Check if the form is submitting (watch network requests)</li>
                            <li>Inspect the form data being sent</li>
                            <li>Verify form control names and values</li>
                            <li>Test form submission with the Console panel</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>&lt;form method="post" action="/submit"&gt;
  &lt;input type="text" name="username"/&gt;
  &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</code></pre>
                    </div>
                </div>
            </div>
            
            <div class="validation">
                <h3>Using HTML Validation</h3>
                <p>HTML validators check your markup against the standards, helping you catch structural issues that browsers might silently fix (potentially incorrectly).</p>
                
                <div class="technique">
                    <h4>Online Validation Tools</h4>
                    <ul>
                        <li><a href="https://validator.w3.org/" target="_blank">W3C Markup Validation Service</a> - Official validator for HTML</li>
                        <li><a href="https://html5.validator.nu/" target="_blank">Nu Html Checker</a> - Modern HTML5 validator</li>
                    </ul>
                </div>
                
                <div class="technique">
                    <h4>Local Validation</h4>
                    <p>For development environments or private projects:</p>
                    <ul>
                        <li>VS Code extensions like "HTMLHint" or "HTML Validator"</li>
                        <li>Linting tools in build processes (ESLint with HTML plugins)</li>
                        <li>Manual inspection with the Elements panel</li>
                    </ul>
                </div>
                
                <div class="debugging-example">
                    <h5>Validating HTML in Chrome DevTools</h5>
                    <ol>
                        <li>In the Elements panel, right-click the <code>&lt;html&gt;</code> element</li>
                        <li>Select "Copy" â†’ "Copy outerHTML"</li>
                        <li>Paste the HTML into an online validator</li>
                        <li>Address any validation errors or warnings</li>
                    </ol>
                </div>
            </div>
            
            <div class="accessibility">
                <h3>Debugging Accessibility Issues</h3>
                <p>HTML accessibility issues can be subtle but affect a significant portion of users.</p>
                
                <div class="technique">
                    <h4>Using Accessibility Inspection Tools</h4>
                    <ul>
                        <li>Chrome's Accessibility panel (in DevTools under "Elements" â†’ "Accessibility")</li>
                        <li>Lighthouse accessibility audits</li>
                        <li>Third-party tools like axe DevTools or WAVE</li>
                    </ul>
                </div>
                
                <div class="debugging-example">
                    <h5>Finding Missing Alt Text</h5>
                    <ol>
                        <li>Run a Lighthouse accessibility audit</li>
                        <li>Look for "Images without alt attributes" in the results</li>
                        <li>For each flagged image, add appropriate alt text in the Elements panel to test</li>
                        <li>Update your source HTML with the validated alt text</li>
                    </ol>
                </div>
            </div>
        </section>

        <section class="css-debugging">
            <h2>CSS Debugging Techniques</h2>
            
            <p>CSS can be particularly challenging to debug due to its cascading nature and the complex interactions between selectors.</p>
            
            <div class="common-issues">
                <h3>Common CSS Issues and Solutions</h3>
                
                <div class="issue">
                    <h4>Specificity Problems</h4>
                    <p>When your CSS rules don't apply as expected due to being overridden by more specific selectors.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>/* In your CSS */
.button {
  background-color: blue;
}

/* Later in CSS or in another file */
button {
  background-color: gray; /* Gets applied when you expected blue */
}</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Inspect the element in the Elements panel</li>
                            <li>Look at the Styles pane to see which rules are being applied and which are crossed out</li>
                            <li>Check the source location of each rule (file and line number)</li>
                            <li>Understand the specificity hierarchy of your selectors</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>/* Make your selector more specific */
.button {
  background-color: blue !important; /* Use !important sparingly */
}

/* OR adjust your selector specificity */
button.button {
  background-color: blue;
}</code></pre>
                    </div>
                </div>
                
                <div class="issue">
                    <h4>Box Model Confusion</h4>
                    <p>Unexpected layout due to misunderstanding of how width, padding, border, and margin interact.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>.container {
  width: 300px;
}

.box {
  width: 100%;
  padding: 20px;
  border: 1px solid black;
  /* Box is 342px wide, causing overflow */
}</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Inspect the element and check the Box Model diagram in the Computed tab</li>
                            <li>Hover over the diagram sections to highlight content, padding, border, and margin</li>
                            <li>Temporarily modify values to test different approaches</li>
                            <li>Consider using alternative box-sizing models</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>/* Apply box-sizing to all elements */
* {
  box-sizing: border-box;
}

.container {
  width: 300px;
}

.box {
  width: 100%;
  padding: 20px;
  border: 1px solid black;
  /* Now correctly 300px total width */
}</code></pre>
                    </div>
                </div>
                
                <div class="issue">
                    <h4>Layout and Positioning Issues</h4>
                    <p>Elements not appearing where expected due to positioning contexts and stacking.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>.modal {
  position: absolute;
  top: 50%;
  left: 50%;
  /* Not centered as expected */
}</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Inspect the element and its ancestors to identify positioning contexts</li>
                            <li>Toggle the position property and observe changes</li>
                            <li>Check z-index values if elements are stacked incorrectly</li>
                            <li>Use temporary background colors to visualize element boundaries</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>.modal {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  /* Now properly centered */
}</code></pre>
                    </div>
                </div>
                
                <div class="issue">
                    <h4>Media Query Debugging</h4>
                    <p>Responsive layouts that don't adapt correctly at different screen sizes.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>@media screen and (max-width: 768px) {
  .sidebar {
    display: none; /* Sidebar disappears at wrong breakpoint */
  }
}</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Use the Device Mode in DevTools to simulate different screen sizes</li>
                            <li>Check which media queries are active at different widths</li>
                            <li>Verify that your breakpoints match your design requirements</li>
                            <li>Test with real devices when possible</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>/* Add device-width to ensure consistent behavior */
@media screen and (max-width: 768px) and (min-device-width: 320px) {
  .sidebar {
    display: none;
  }
}</code></pre>
                    </div>
                </div>
            </div>
            
            <div class="technique">
                <h3>Using CSS Debugging Tools</h3>
                
                <div class="tool">
                    <h4>Style Editing and Visualization</h4>
                    <ul>
                        <li><strong>Chrome DevTools "Styles" tab:</strong> Edit and toggle CSS properties</li>
                        <li><strong>Firefox DevTools "Changes" panel:</strong> Track and export CSS changes</li>
                        <li><strong>Layout visualization tools:</strong> Highlight flexbox and grid containers</li>
                        <li><strong>Computed styles:</strong> See the final calculated values for all properties</li>
                    </ul>
                </div>
                
                <div class="debugging-example">
                    <h5>Debugging Flexbox Layout</h5>
                    <ol>
                        <li>Inspect a flex container in the Elements panel</li>
                        <li>Look for the "flex" badge next to the element in the DOM tree</li>
                        <li>Click the badge to highlight flex items and display a flex overlay</li>
                        <li>Experiment with flex properties in the Styles panel</li>
                        <li>Apply successful changes to your source CSS</li>
                    </ol>
                </div>
                
                <div class="tool">
                    <h4>CSS Coverage Analysis</h4>
                    <p>Find and remove unused CSS to simplify debugging and improve performance.</p>
                    
                    <div class="debugging-example">
                        <h5>Finding Unused CSS</h5>
                        <ol>
                            <li>In Chrome DevTools, open the Command Menu (Ctrl+Shift+P/Cmd+Shift+P)</li>
                            <li>Type "Coverage" and select "Show Coverage"</li>
                            <li>Click the "Start instrumenting coverage and reload page" button</li>
                            <li>Review the results to see how much CSS is unused</li>
                            <li>Click a file to see line-by-line usage highlighting</li>
                        </ol>
                    </div>
                </div>
            </div>
            
            <div class="technique">
                <h3>Isolating CSS Issues</h3>
                
                <div class="debugging-example">
                    <h5>Binary CSS Debugging</h5>
                    <p>A methodical approach to isolating CSS problems:</p>
                    <ol>
                        <li>Temporarily comment out approximately half of your CSS</li>
                        <li>If the issue disappears, the problem is in the commented section; otherwise, it's in the active section</li>
                        <li>Repeat the process with the problematic section, halving it each time</li>
                        <li>Continue until you've isolated the specific rule causing the issue</li>
                    </ol>
                </div>
                
                <div class="debugging-example">
                    <h5>Creating a Minimal Test Case</h5>
                    <p>For complex CSS issues:</p>
                    <ol>
                        <li>Create a new, empty HTML file</li>
                        <li>Add only the essential HTML structure relevant to the issue</li>
                        <li>Add CSS rules one at a time until the issue appears</li>
                        <li>Once isolated, the solution is often obvious</li>
                    </ol>
                </div>
            </div>
        </section>

        <section class="js-debugging">
            <h2>JavaScript Debugging Techniques</h2>
            
            <p>JavaScript bugs can range from simple syntax errors to complex logic issues. Here are specialized techniques for debugging JavaScript code.</p>
            
            <div class="common-issues">
                <h3>Common JavaScript Issues and Solutions</h3>
                
                <div class="issue">
                    <h4>Scope and Closure Problems</h4>
                    <p>Unexpected variable values due to misunderstanding of scope.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>function createButtons() {
  for (var i = 0; i < 3; i++) {
    var button = document.createElement('button');
    button.textContent = 'Button ' + i;
    button.addEventListener('click', function() {
      console.log('Button ' + i + ' clicked');
      // Always logs "Button 3 clicked" regardless of which button is clicked
    });
    document.body.appendChild(button);
  }
}</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Add breakpoints in the event listener function</li>
                            <li>When clicked, examine the value of <code>i</code> in the Scope pane</li>
                            <li>Understand that <code>var</code> has function scope, not block scope</li>
                            <li>Test different solutions in the Console</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>function createButtons() {
  // Option 1: Use let instead of var (block scope)
  for (let i = 0; i < 3; i++) {
    const button = document.createElement('button');
    button.textContent = 'Button ' + i;
    button.addEventListener('click', function() {
      console.log('Button ' + i + ' clicked');
    });
    document.body.appendChild(button);
  }
  
  // Option 2: Create a closure with an IIFE
  for (var i = 0; i < 3; i++) {
    (function(index) {
      const button = document.createElement('button');
      button.textContent = 'Button ' + index;
      button.addEventListener('click', function() {
        console.log('Button ' + index + ' clicked');
      });
      document.body.appendChild(button);
    })(i);
  }
}</code></pre>
                    </div>
                </div>
                
                <div class="issue">
                    <h4>Asynchronous Code Flow</h4>
                    <p>Unexpected behavior due to misunderstanding of promises, callbacks, or async/await.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>function fetchUserData() {
  let userData;
  
  fetch('/api/user')
    .then(response => response.json())
    .then(data => {
      userData = data;
    });
    
  return userData; // Always returns undefined
}</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Set breakpoints in the promise chain</li>
                            <li>Observe the execution order and when userData is assigned</li>
                            <li>Check the return value to confirm it's undefined</li>
                            <li>Understand that the function returns before the promises resolve</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>// Option 1: Return the promise
function fetchUserData() {
  return fetch('/api/user')
    .then(response => response.json());
}

// Usage
fetchUserData().then(userData => {
  console.log(userData);
});

// Option 2: Use async/await
async function fetchUserData() {
  const response = await fetch('/api/user');
  const userData = await response.json();
  return userData;
}

// Usage with async/await
async function init() {
  try {
    const userData = await fetchUserData();
    console.log(userData);
  } catch (error) {
    console.error('Failed to fetch user data:', error);
  }
}</code></pre>
                    </div>
                </div>
                
                <div class="issue">
                    <h4>Event Handling Issues</h4>
                    <p>Events not firing as expected or firing too many times.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>// Button click handler not working
document.getElementById('submit-button').addEventListener('click', function() {
  console.log('Button clicked');
  submitForm();
});</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Verify the element exists using <code>console.log(document.getElementById('submit-button'))</code></li>
                            <li>Check if other events are working on the element</li>
                            <li>Inspect the element to see if it has other event listeners</li>
                            <li>Check if the element is being recreated dynamically, which would require re-attaching the listener</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>// Option 1: Wait for DOM to be ready
document.addEventListener('DOMContentLoaded', function() {
  const button = document.getElementById('submit-button');
  if (button) {
    button.addEventListener('click', function() {
      console.log('Button clicked');
      submitForm();
    });
  } else {
    console.error('Submit button not found');
  }
});

// Option 2: Use event delegation for dynamically created elements
document.addEventListener('click', function(event) {
  if (event.target && event.target.id === 'submit-button') {
    console.log('Button clicked');
    submitForm();
  }
});</code></pre>
                    </div>
                </div>
                
                <div class="issue">
                    <h4>this Context Confusion</h4>
                    <p>The <code>this</code> keyword referring to an unexpected object.</p>
                    
                    <div class="example">
                        <h5>Problem:</h5>
                        <pre><code>const user = {
  name: 'Alice',
  greet: function() {
    setTimeout(function() {
      console.log('Hello, ' + this.name);
      // Logs "Hello, undefined" because this is not referring to user
    }, 1000);
  }
};</code></pre>
                        
                        <h5>Debugging Process:</h5>
                        <ol>
                            <li>Set a breakpoint inside the setTimeout callback</li>
                            <li>When it executes, examine <code>this</code> in the console</li>
                            <li>Understand that the callback creates a new context where <code>this</code> is the global object (window in browsers)</li>
                            <li>Test different solutions in the Console</li>
                        </ol>
                        
                        <h5>Fix:</h5>
                        <pre><code>const user = {
  name: 'Alice',
  greet: function() {
    // Option 1: Use arrow function which doesn't have its own this
    setTimeout(() => {
      console.log('Hello, ' + this.name);
    }, 1000);
    
    // Option 2: Store this in a variable
    const self = this;
    setTimeout(function() {
      console.log('Hello, ' + self.name);
    }, 1000);
    
    // Option 3: Use bind to set this explicitly
    setTimeout(function() {
      console.log('Hello, ' + this.name);
    }.bind(this), 1000);
  }
};</code></pre>
                    </div>
                </div>
            </div>
            
            <div class="technique">
                <h3>Advanced JavaScript Debugging Patterns</h3>
                
                <div class="pattern">
                    <h4>Using the debugger Statement</h4>
                    <p>Insert a programmatic breakpoint directly in your code:</p>
                    <pre><code>function complexCalculation(data) {
  // Stop execution when a specific condition is met
  if (data.value < 0) {
    debugger; // Execution will pause here when DevTools is open
  }
  
  // Continue with calculation
}</code></pre>
                    <p>This is particularly useful for:</p>
                    <ul>
                        <li>Conditional debugging based on runtime values</li>
                        <li>Debugging in production with console access but no DevTools access</li>
                        <li>Setting breakpoints in code that's difficult to locate in the Sources panel</li>
                    </ul>
                </div>
                
                <div class="pattern">
                    <h4>Call Stack Manipulation</h4>
                    <p>Use <code>console.trace()</code> to log the current call stack without pausing execution:</p>
                    <pre><code>function deeplyNestedFunction() {
  console.trace('Execution reached here');
  // Function logic
}</code></pre>
                    <p>This helps understand how functions are being called, especially in complex applications.</p>
                </div>
                
                <div class="pattern">
                    <h4>Monitoring Changes with Proxy</h4>
                    <p>Track property access and modifications with JavaScript Proxies:</p>
                    <pre><code>let user = { name: 'Alice', role: 'Admin' };

// Create a monitored version of the user object
const monitoredUser = new Proxy(user, {
  get(target, property) {
    console.log(`Property ${property} was accessed`);
    return target[property];
  },
  set(target, property, value) {
    console.log(`Property ${property} changed from ${target[property]} to ${value}`);
    target[property] = value;
    return true;
  }
});

// Now use monitoredUser instead of user to track all interactions
monitoredUser.name; // Logs: "Property name was accessed"
monitoredUser.role = 'User'; // Logs: "Property role changed from Admin to User"</code></pre>
                    <p>This pattern is extremely useful for:</p>
                    <ul>
                        <li>Debugging state management issues</li>
                        <li>Finding where unexpected property changes occur</li>
                        <li>Understanding property access patterns</li>
                    </ul>
                </div>
                
                <div class="pattern">
                    <h4>Performance Profiling</h4>
                    <p>Measure execution time to identify performance bottlenecks:</p>
                    <pre><code>// Basic timing
console.time('operationName');
expensiveOperation();
console.timeEnd('operationName'); // Logs: "operationName: 123.45ms"

// Advanced profiling
console.profile('My JavaScript Profile');
// Code to profile
expensiveOperation();
complexCalculation();
// More operations...
console.profileEnd();</code></pre>
                    <p>Use this to identify and optimize slow functions or operations.</p>
                </div>
            </div>
            
            <div class="technique">
                <h3>Debugging Modern JavaScript Features</h3>
                
                <div class="feature">
                    <h4>Destructuring and Spread Operators</h4>
                    <p>Modern JavaScript features can be confusing to debug:</p>
                    <pre><code>// Debugging destructuring assignments
function processUser({ name, roles = [], ...otherProps }) {
  console.log({ name, roles, otherProps }); // Log the destructured values
  
  // Process user data
}</code></pre>
                </div>
                
                <div class="feature">
                    <h4>Promise Debugging</h4>
                    <p>Trace through complex promise chains:</p>
                    <pre><code>fetchData()
  .then(data => {
    console.log('Data received:', data);
    return transformData(data);
  })
  .then(transformed => {
    console.log('Transformed data:', transformed);
    return saveData(transformed);
  })
  .catch(error => {
    console.error('Error in promise chain:', error);
    // Inspect error.stack for stack trace
  });</code></pre>
                    <p>For even better debugging, use async/await which allows standard try/catch error handling and easier breakpoint setting.</p>
                </div>
                
                <div class="feature">
                    <h4>Module Debugging</h4>
                    <p>For issues with ES modules or bundled code:</p>
                    <ul>
                        <li>Use source maps to map back to original files</li>
                        <li>Check import/export statements for typos or mismatches</li>
                        <li>Use the Network panel to verify module loading</li>
                        <li>Test modules in isolation to identify integration issues</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="cross-browser">
            <h2>Cross-Browser and Mobile Debugging</h2>
            
            <p>Some of the most challenging bugs occur only in specific browsers or on mobile devices. Here's how to tackle these environment-specific issues.</p>
            
            <div class="browsers">
                <h3>Cross-Browser Debugging Techniques</h3>
                
                <div class="technique">
                    <h4>Browser-Specific Developer Tools</h4>
                    <p>Each major browser has its own developer tools with unique features:</p>
                    <ul>
                        <li><strong>Chrome DevTools:</strong> Comprehensive tools for performance analysis</li>
                        <li><strong>Firefox Developer Tools:</strong> Excellent CSS inspection and grid visualization</li>
                        <li><strong>Safari Web Inspector:</strong> Useful for debugging iOS WebKit issues</li>
                        <li><strong>Edge DevTools:</strong> Similar to Chrome but with some unique features</li>
                    </ul>
                    <p>Become familiar with the unique strengths of each browser's tools.</p>
                </div>
                
                <div class="technique">
                    <h4>Feature Detection and Polyfills</h4>
                    <p>Identify missing feature support in browsers:</p>
                    <pre><code>// Check if a feature is supported
if ('IntersectionObserver' in window) {
  // Use IntersectionObserver
} else {
  // Use a fallback or load a polyfill
  loadScript('intersection-observer-polyfill.js').then(() => {
    // Now use IntersectionObserver
  });
}</code></pre>
                    <p>Tools like Modernizr can help automate feature detection.</p>
                </div>
                
                <div class="technique">
                    <h4>Browser Testing Services</h4>
                    <p>Use services that provide access to multiple browser environments:</p>
                    <ul>
                        <li>BrowserStack, Sauce Labs, or LambdaTest for live testing</li>
                        <li>CrossBrowserTesting for screenshots across browsers</li>
                        <li>Playwright or Cypress for automated cross-browser testing</li>
                    </ul>
                </div>
                
                <div class="debugging-example">
                    <h5>Identifying and Fixing Browser-Specific CSS Issues</h5>
                    <ol>
                        <li>Test your page in multiple browsers to find visual differences</li>
                        <li>Use browser developer tools to inspect the problematic elements</li>
                        <li>Look for vendor prefix issues or unsupported properties</li>
                        <li>Implement targeted fixes with feature queries or browser-specific hacks if necessary</li>
                    </ol>
                    
                    <pre><code>/* CSS feature query for flexbox gap support */
.container {
  display: flex;
  /* Fallback for browsers without gap support */
  margin: -10px;
}

.container > * {
  margin: 10px;
}

@supports (gap: 20px) {
  .container {
    gap: 20px;
    margin: 0;
  }
  
  .container > * {
    margin: 0;
  }
}</code></pre>
                </div>
            </div>
            
            <div class="mobile">
                <h3>Mobile Debugging Techniques</h3>
                
                <div class="technique">
                    <h4>Remote Debugging</h4>
                    <p>Connect desktop developer tools to mobile browsers:</p>
                    <ul>
                        <li><strong>Android:</strong> Use Chrome DevTools with USB debugging enabled</li>
                        <li><strong>iOS:</strong> Use Safari Web Inspector with an iOS device or simulator</li>
                    </ul>
                    
                    <div class="debugging-example">
                        <h5>Setting Up Chrome Remote Debugging for Android</h5>
                        <ol>
                            <li>Enable Developer Options on your Android device</li>
                            <li>Enable USB Debugging in Developer Options</li>
                            <li>Connect the device to your computer via USB</li>
                            <li>In Chrome, navigate to chrome://inspect</li>
                            <li>Find your device and the tab you want to debug</li>
                            <li>Click "inspect" to open DevTools connected to the mobile browser</li>
                        </ol>
                    </div>
                </div>
                
                <div class="technique">
                    <h4>Device Emulation</h4>
                    <p>Use built-in device emulation in browser developer tools:</p>
                    <ul>
                        <li>Chrome's Device Mode (Toggle Device Toolbar)</li>
                        <li>Firefox's Responsive Design Mode</li>
                        <li>Safari's Responsive Design Mode</li>
                    </ul>
                    <p>This allows testing different screen sizes, device pixel ratios, and user agent strings without physical devices.</p>
                </div>
                
                <div class="technique">
                    <h4>Touch Event Debugging</h4>
                    <p>Debug touch interaction issues specific to mobile devices:</p>
                    <pre><code>// Log touch events to understand behavior
element.addEventListener('touchstart', function(e) {
  console.log('Touch start', e.touches, e.targetTouches);
});

element.addEventListener('touchmove', function(e) {
  console.log('Touch move', e.touches, e.targetTouches);
});

element.addEventListener('touchend', function(e) {
  console.log('Touch end', e.changedTouches);
});</code></pre>
                </div>
                
                <div class="debugging-example">
                    <h5>Debugging the 300ms Tap Delay</h5>
                    <p>A common mobile issue is the 300ms delay between tap and click events:</p>
                    <ol>
                        <li>Monitor both touch and click events to confirm the delay</li>
                        <li>Add the viewport meta tag to eliminate the delay in modern browsers:
                            <pre><code>&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;</code></pre>
                        </li>
                        <li>Consider using libraries like FastClick for older browsers</li>
                    </ol>
                </div>
            </div>
        </section>

        <section class="prevention">
            <h2>Preventive Debugging Techniques</h2>
            
            <p>The best debugging is the debugging you don't have to do. Implement these preventive measures to catch issues early and reduce the need for extensive debugging.</p>
            
            <div class="technique">
                <h3>Static Analysis and Linting</h3>
                
                <p>Use tools that analyze your code without executing it to catch potential issues early:</p>
                
                <div class="tool">
                    <h4>ESLint for JavaScript</h4>
                    <pre><code>// .eslintrc.js
module.exports = {
  "extends": "eslint:recommended",
  "rules": {
    "no-unused-vars": "warn",
    "no-console": "off",
    "eqeqeq": "error" // Enforce === instead of ==
  },
  "parserOptions": {
    "ecmaVersion": 2020
  },
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  }
};</code></pre>
                </div>
                
                <div class="tool">
                    <h4>StyleLint for CSS</h4>
                    <pre><code>// .stylelintrc.js
module.exports = {
  "extends": "stylelint-config-standard",
  "rules": {
    "indentation": 2,
    "selector-class-pattern": "^[a-z][a-zA-Z0-9-_]*$",
    "declaration-no-important": true
  }
};</code></pre>
                </div>
                
                <div class="tool">
                    <h4>HTMLHint for HTML</h4>
                    <pre><code>// .htmlhintrc
{
  "tagname-lowercase": true,
  "attr-lowercase": true,
  "attr-value-double-quotes": true,
  "id-unique": true,
  "src-not-empty": true,
  "attr-no-duplication": true,
  "title-require": true
}</code></pre>
                </div>
                
                <div class="benefits">
                    <h4>Benefits of Static Analysis</h4>
                    <ul>
                        <li>Catches common mistakes before runtime</li>
                        <li>Enforces code style and best practices</li>
                        <li>Reduces time spent debugging trivial issues</li>
                        <li>Provides real-time feedback in code editors</li>
                        <li>Serves as a learning tool for new developers</li>
                    </ul>
                </div>
            </div>
            
            <div class="technique">
                <h3>Automated Testing</h3>
                
                <p>Implement different types of tests to catch bugs before they reach production:</p>
                
                <div class="test-type">
                    <h4>Unit Tests</h4>
                    <p>Test individual functions and components in isolation:</p>
                    <pre><code>// Using Jest to test a utility function
test('formatCurrency formats numbers correctly', () => {
  expect(formatCurrency(1234.56)).toBe('$1,234.56');
  expect(formatCurrency(0)).toBe('$0.00');
  expect(formatCurrency(-99.99)).toBe('-$99.99');
});</code></pre>
                </div>
                
                <div class="test-type">
                    <h4>Integration Tests</h4>
                    <p>Test how components work together:</p>
                    <pre><code>// Testing a form submission with a mock API
test('form submits data correctly', async () => {
  // Setup mock API
  const mockSubmit = jest.fn().mockResolvedValue({ success: true });
  api.submitForm = mockSubmit;
  
  // Render the form
  render(&lt;ContactForm /&gt;);
  
  // Fill out form fields
  fireEvent.change(screen.getByLabelText('Name'), {
    target: { value: 'Test User' }
  });
  fireEvent.change(screen.getByLabelText('Email'), {
    target: { value: 'test@example.com' }
  });
  
  // Submit the form
  fireEvent.click(screen.getByText('Submit'));
  
  // Wait for the submission to complete
  await waitFor(() => {
    // Verify API was called with correct data
    expect(mockSubmit).toHaveBeenCalledWith({
      name: 'Test User',
      email: 'test@example.com'
    });
  });
});</code></pre>
                </div>
                
                <div class="test-type">
                    <h4>End-to-End Tests</h4>
                    <p>Test the entire application as a user would experience it:</p>
                    <pre><code>// Using Cypress for end-to-end testing
describe('Login flow', () => {
  it('should allow a user to log in', () => {
    // Visit the login page
    cy.visit('/login');
    
    // Enter credentials
    cy.get('input[name="username"]').type('testuser');
    cy.get('input[name="password"]').type('password123');
    
    // Submit the form
    cy.get('button[type="submit"]').click();
    
    // Verify successful login
    cy.url().should('include', '/dashboard');
    cy.get('.welcome-message').should('contain', 'Welcome, Test User');
  });
});</code></pre>
                </div>
                
                <div class="benefits">
                    <h4>Benefits of Automated Testing</h4>
                    <ul>
                        <li>Catches regression bugs before they reach users</li>
                        <li>Provides clear documentation of expected behavior</li>
                        <li>Allows confident refactoring and feature additions</li>
                        <li>Identifies edge cases that manual testing might miss</li>
                        <li>Serves as a safety net for continuous integration and deployment</li>
                    </ul>
                </div>
            </div>
            
            <div class="technique">
                <h3>Error Logging and Monitoring</h3>
                
                <p>Set up systems to track and alert you about errors in production:</p>
                
                <div class="tool">
                    <h4>Client-Side Error Tracking</h4>
                    <pre><code>// Basic global error handler
window.addEventListener('error', function(event) {
  const { message, filename, lineno, colno, error } = event;
  
  // Log to your analytics or error tracking service
  logError({
    message,
    source: filename,
    line: lineno,
    column: colno,
    stack: error && error.stack,
    userAgent: navigator.userAgent,
    url: window.location.href
  });
  
  // Optionally prevent the browser's default error handling
  // event.preventDefault();
});</code></pre>
                </div>
                
                <div class="tool">
                    <h4>Promise Error Handling</h4>
                    <pre><code>// Catch unhandled promise rejections
window.addEventListener('unhandledrejection', function(event) {
  console.error('Unhandled promise rejection:', event.reason);
  
  // Log to your error tracking service
  logError({
    type: 'unhandledRejection',
    reason: event.reason,
    stack: event.reason && event.reason.stack,
    userAgent: navigator.userAgent,
    url: window.location.href
  });
});</code></pre>
                </div>
                
                <div class="benefits">
                    <h4>Benefits of Error Monitoring</h4>
                    <ul>
                        <li>Discover issues affecting real users</li>
                        <li>Prioritize fixes based on frequency and impact</li>
                        <li>Track error trends over time</li>
                        <li>Detect browser-specific or environment-specific bugs</li>
                        <li>Receive alerts for critical issues</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="debugging-workflow">
            <h2>Putting It All Together: A Debugging Workflow</h2>
            
            <p>Now that we've covered a wide range of debugging techniques, let's organize them into a systematic workflow that you can follow when facing any frontend issue.</p>
            
            <div class="workflow-steps">
                <h3>Step 1: Reproduce the Issue</h3>
                <ul>
                    <li>Create a clear, minimal test case that demonstrates the bug</li>
                    <li>Document the exact steps to reproduce the issue</li>
                    <li>Note the environment details (browser, device, screen size, etc.)</li>
                    <li>Determine if the issue is consistent or intermittent</li>
                </ul>
                
                <h3>Step 2: Isolate the Problem</h3>
                <ul>
                    <li>Determine which technology is causing the issue (HTML, CSS, JavaScript)</li>
                    <li>Use binary debugging to narrow down the problematic code section</li>
                    <li>Check if the issue appears in all browsers or just specific ones</li>
                    <li>Test with different data or user scenarios</li>
                </ul>
                
                <h3>Step 3: Analyze with DevTools</h3>
                <ul>
                    <li>Use the appropriate DevTools panel based on your isolation findings</li>
                    <li>Set breakpoints or use console logging to trace execution</li>
                    <li>Examine network requests if the issue involves data</li>
                    <li>Check for errors in the Console panel</li>
                </ul>
                
                <h3>Step 4: Formulate a Hypothesis</h3>
                <ul>
                    <li>Based on your analysis, form a theory about what's causing the issue</li>
                    <li>Predict how the system should behave if your theory is correct</li>
                    <li>Consider alternative explanations</li>
                </ul>
                
                <h3>Step 5: Test Your Solution</h3>
                <ul>
                    <li>Implement a potential fix based on your hypothesis</li>
                    <li>Test thoroughly to ensure the issue is resolved</li>
                    <li>Verify that your fix doesn't introduce new problems</li>
                    <li>Test in all relevant browsers and devices</li>
                </ul>
                
                <h3>Step 6: Document and Prevent</h3>
                <ul>
                    <li>Document the issue, analysis, and solution</li>
                    <li>Add tests to prevent regression</li>
                    <li>Consider updating coding standards or tooling to prevent similar issues</li>
                    <li>Share knowledge with your team</li>
                </ul>
            </div>
            
            <div class="debugging-case-study">
                <h3>Case Study: Debugging a Real-World Issue</h3>
                
                <p>Let's walk through a complete debugging session for a common frontend issue: a form that submits successfully but doesn't display the confirmation message as expected.</p>
                
                <div class="case-step">
                    <h4>Step 1: Reproduce</h4>
                    <ul>
                        <li>Fill out the form and submit</li>
                        <li>Observe that the form data seems to be submitted successfully (no errors in Console)</li>
                        <li>Note that the confirmation message doesn't appear</li>
                        <li>Verify this happens in multiple browsers</li>
                    </ul>
                </div>
                
                <div class="case-step">
                    <h4>Step 2: Isolate</h4>
                    <ul>
                        <li>Check Network panel to confirm the form submission is successful (200 OK response)</li>
                        <li>Examine the response data to verify it contains a success status</li>
                        <li>Investigate the JavaScript that handles the form submission</li>
                        <li>Focus on the code that should display the confirmation message</li>
                    </ul>
                </div>
                
                <div class="case-step">
                    <h4>Step 3: Analyze</h4>
                    <pre><code>// Form submission handler
document.getElementById('contactForm').addEventListener('submit', function(e) {
  e.preventDefault();
  
  const formData = new FormData(this);
  
  fetch('/api/contact', {
    method: 'POST',
    body: formData
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      // Show confirmation message
      document.getElementById('confirmationMsg').style.display = 'block';
    }
  })
  .catch(error => {
    console.error('Error:', error);
  });
});</code></pre>
                    <p>Setting breakpoints in this code reveals that:</p>
                    <ul>
                        <li>The API call succeeds and returns <code>{ success: true }</code></li>
                        <li>The code to show the confirmation message executes</li>
                        <li>Looking at the Elements panel, we find that <code>confirmationMsg</code> element exists but remains hidden</li>
                    </ul>
                </div>
                
                <div class="case-step">
                    <h4>Step 4: Hypothesize</h4>
                    <p>Based on our analysis, we have several possible hypotheses:</p>
                    <ol>
                        <li>CSS might be overriding our inline style</li>
                        <li>The element might have the correct <code>display: block</code> but be positioned off-screen</li>
                        <li>The element might have <code>visibility: hidden</code> in addition to display</li>
                        <li>JavaScript might be hiding the element after we show it</li>
                    </ol>
                </div>
                
                <div class="case-step">
                    <h4>Step 5: Test</h4>
                    <p>Inspecting the element in the Elements panel after form submission reveals:</p>
                    <pre><code>/* Computed styles for #confirmationMsg */
display: block;  /* Our code set this correctly */
opacity: 0;      /* But this is making it invisible! */</code></pre>
                    <p>Looking in the Styles panel, we find:</p>
                    <pre><code>/* In styles.css */
.confirmation-message {
  opacity: 0;
  transition: opacity 0.5s ease;
}

.confirmation-message.show {
  opacity: 1;
}</code></pre>
                    <p>The issue becomes clear: The confirmation message is designed to fade in using CSS transitions, but our code is only setting <code>display: block</code> and not adding the <code>show</code> class.</p>
                </div>
                
                <div class="case-step">
                    <h4>Step 6: Fix and Document</h4>
                    <p>Update the JavaScript code:</p>
                    <pre><code>.then(data => {
  if (data.success) {
    // Show confirmation message
    const confirmationMsg = document.getElementById('confirmationMsg');
    confirmationMsg.style.display = 'block';
    // Add this line to fix the issue:
    setTimeout(() => confirmationMsg.classList.add('show'), 10);
  }
})</code></pre>
                    <p>Document the issue:</p>
                    <ul>
                        <li>The confirmation message was not appearing because it required both <code>display: block</code> and the <code>show</code> class for the transition effect.</li>
                        <li>Fixed by adding the <code>show</code> class after setting display property.</li>
                        <li>Added a small timeout to ensure the display change is processed before starting the transition.</li>
                        <li>Added a comment in the code to explain the timing dependency.</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="conclusion">
            <h2>Conclusion and Next Steps</h2>
            
            <p>Debugging is as much an art as it is a science. While we've covered a comprehensive set of techniques and tools in this session, becoming a skilled debugger ultimately comes from practice and experience. Each bug you solve adds to your toolkit and intuition for future problems.</p>
            
            <div class="summary">
                <h3>Key Takeaways</h3>
                <ul>
                    <li>Adopt a systematic, methodical approach to debugging rather than making random changes</li>
                    <li>Master browser developer tools, especially Elements, Console, Sources, and Network panels</li>
                    <li>Learn specific debugging techniques for HTML, CSS, and JavaScript</li>
                    <li>Implement preventive measures like linting, testing, and error monitoring</li>
                    <li>Document both the bugs and your solutions to build institutional knowledge</li>
                </ul>
            </div>
            
            <div class="resources">
                <h3>Further Learning Resources</h3>
                <ul>
                    <li><a href="https://developers.google.com/web/tools/chrome-devtools" target="_blank">Chrome DevTools Documentation</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing" target="_blank">MDN Cross-Browser Testing Guide</a></li>
                    <li><a href="https://frontendmasters.com/courses/debugging-javascript/" target="_blank">Frontend Masters: Debugging and Fixing Common JavaScript Errors</a></li>
                    <li><a href="https://css-tricks.com/debugging-css/" target="_blank">CSS-Tricks: Debugging CSS</a></li>
                    <li><a href="https://web.dev/accessibility-auditing-debug/" target="_blank">Web.dev: Accessibility Debugging</a></li>
                </ul>
            </div>
            
            <div class="practice">
                <h3>Practice Exercises</h3>
                <ol>
                    <li>Find and fix three bugs in the course project's form validation</li>
                    <li>Set up ESLint and StyleLint in your development environment</li>
                    <li>Create a test case that reproduces a responsive design issue on mobile devices</li>
                    <li>Add comprehensive error handling to an asynchronous function</li>
                    <li>Debug and fix a cross-browser compatibility issue</li>
                </ol>
            </div>
            
            <div class="next-session">
                <h3>In Our Next Session</h3>
                <p>We'll be exploring "Web Development Workflow & Tools" where we'll build on these debugging skills and learn about automation, build processes, and development workflows that can make you a more productive web developer.</p>
            </div>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Python Full Stack Developer Course. All rights reserved.</p>
    </footer>
</body>
</html>
