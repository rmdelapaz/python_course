<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flask RESTful - Building Modern APIs</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Flask RESTful: Building Modern APIs</h1>
        <p class="subtitle">Python Full Stack Web Course - Week 3: Monday</p>
    </header>

    <main>
        <section class="introduction">
            <h2>Introduction to RESTful APIs</h2>
            <p>Welcome to Week 3 of our Python Full Stack journey! Today, we're diving into Flask RESTful, a powerful extension that simplifies building RESTful APIs with Flask.</p>
            
            <p>Think of RESTful APIs as the waiters in a restaurant. They take your order (request), deliver it to the kitchen (server), and bring back your food (response). Just as a good waiter follows certain protocols and etiquette, RESTful APIs follow standards that make them predictable and easy to work with.</p>
            
            <p>By the end of today's session, you'll be able to build structured, maintainable APIs that follow REST principles, making your applications more scalable and easier to integrate with other services.</p>
        </section>

        <section class="prerequisites">
            <h2>Prerequisites</h2>
            <p>Before we begin, ensure you have:</p>
            <ul>
                <li>Basic understanding of Flask (from Week 2)</li>
                <li>Familiarity with HTTP methods (GET, POST, PUT, DELETE)</li>
                <li>Python 3.6+ installed</li>
                <li>Virtual environment setup</li>
            </ul>
            
            <div class="code-section">
                <h3>Setting Up Your Project</h3>
                <p>Create a new folder structure:</p>
                <pre><code>flask_restful_project/
├── app.py
├── requirements.txt
└── resources/
    └── __init__.py</code></pre>
                
                <p>Install Flask-RESTful:</p>
                <pre><code>pip install flask flask-restful
pip freeze > requirements.txt</code></pre>
            </div>
        </section>

        <section class="rest_principles">
            <h2>Understanding REST Principles</h2>
            
            <p>REST (Representational State Transfer) is an architectural style for designing networked applications. It's like a set of design guidelines for building well-structured web services. Think of it as the building codes for constructing a house - following these standards ensures your API is robust, scalable, and easy to understand.</p>
            
            <h3>Key REST Principles</h3>
            <ul>
                <li><strong>Stateless:</strong> Like a vending machine that doesn't remember previous transactions, each request contains all the information needed to complete it.</li>
                <li><strong>Resource-Based:</strong> Everything is a resource (like a noun), identified by URLs.</li>
                <li><strong>Standard HTTP Methods:</strong> Actions (verbs) are performed using standard HTTP methods (GET, POST, PUT, DELETE).</li>
                <li><strong>Multiple Representations:</strong> Resources can be represented in different formats (JSON, XML, etc.).</li>
                <li><strong>Stateless Communication:</strong> Server doesn't store client context between requests.</li>
            </ul>
            
            <div class="example">
                <h3>Real-World Analogy</h3>
                <p>Think of a RESTful API like a library system:</p>
                <ul>
                    <li>Resources are books (identified by ISBN numbers)</li>
                    <li>GET: Checking out books</li>
                    <li>POST: Adding new books to the collection</li>
                    <li>PUT: Updating book information</li>
                    <li>DELETE: Removing books from the collection</li>
                </ul>
                <p>The library doesn't need to remember your previous visits to help you with the current request - each interaction is complete and self-contained.</p>
            </div>
        </section>

        <section class="flask_restful_intro">
            <h2>Introduction to Flask RESTful</h2>
            
            <p>Flask-RESTful is an extension for Flask that adds support for quickly building REST APIs. It encourages best practices with minimal setup.</p>
            
            <p>Think of Flask-RESTful as a specialized toolkit that extends your basic Flask toolbox. While Flask gives you the basic tools to build any web application, Flask-RESTful provides specialized instruments specifically designed for building APIs efficiently.</p>
            
            <div class="code-section">
                <h3>Your First Flask-RESTful Application</h3>
                <p>Create a file named <code>app.py</code> in your project root:</p>
                <pre><code>from flask import Flask
from flask_restful import Api, Resource

# Create Flask application
app = Flask(__name__)

# Create API object
api = Api(app)

# Create a Resource class
class HelloWorld(Resource):
    def get(self):
        return {'message': 'Hello, World!'}

# Add resource to API
api.add_resource(HelloWorld, '/hello')

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
                
                <p>Run your application:</p>
                <pre><code>python app.py</code></pre>
                
                <p>Test your API by navigating to: <code>http://127.0.0.1:5000/hello</code> in your browser or using a tool like Postman. You should see: <code>{"message": "Hello, World!"}</code></p>
            </div>
            
            <div class="breakdown">
                <h3>Code Breakdown</h3>
                <ul>
                    <li><code>from flask_restful import Api, Resource</code>: Imports the core classes from Flask-RESTful.</li>
                    <li><code>api = Api(app)</code>: Creates an API wrapper around our Flask application.</li>
                    <li><code>class HelloWorld(Resource)</code>: Creates a resource by extending the Resource class.</li>
                    <li><code>def get(self)</code>: Defines what happens when a GET request is received.</li>
                    <li><code>api.add_resource(HelloWorld, '/hello')</code>: Registers the resource at the specified URL.</li>
                </ul>
                <p>This pattern of creating Resource classes and registering them with the API is the foundation of Flask-RESTful applications.</p>
            </div>
        </section>

        <section class="resources_endpoints">
            <h2>Resources and Endpoints</h2>
            
            <p>In Flask-RESTful, a Resource is a class that represents an entity in your application. Each method in the class corresponds to an HTTP method that can be performed on that resource.</p>
            
            <p>Think of a Resource as a noun (a person, place, or thing) in your application domain. For example, in a bookstore API, you might have resources like Book, Author, and Publisher.</p>
            
            <div class="code-section">
                <h3>Implementing Multiple HTTP Methods</h3>
                <pre><code>from flask import Flask, request
from flask_restful import Api, Resource

app = Flask(__name__)
api = Api(app)

# In-memory database for demonstration
books = [
    {"id": 1, "title": "Python Crash Course", "author": "Eric Matthes"},
    {"id": 2, "title": "Flask Web Development", "author": "Miguel Grinberg"}
]

class BookResource(Resource):
    def get(self, book_id=None):
        # Return a specific book if book_id is provided
        if book_id:
            for book in books:
                if book["id"] == book_id:
                    return book
            return {"message": "Book not found"}, 404
        
        # Return all books if no book_id is provided
        return books
    
    def post(self):
        # Add a new book
        new_book = request.get_json()
        # Generate a new ID (in a real app, this would be handled by the database)
        new_book["id"] = max(book["id"] for book in books) + 1 if books else 1
        books.append(new_book)
        return new_book, 201
    
    def put(self, book_id):
        # Update an existing book
        book_data = request.get_json()
        
        for i, book in enumerate(books):
            if book["id"] == book_id:
                # Update the book while preserving its ID
                book_data["id"] = book_id
                books[i] = book_data
                return book_data
        
        return {"message": "Book not found"}, 404
    
    def delete(self, book_id):
        # Delete a book
        for i, book in enumerate(books):
            if book["id"] == book_id:
                deleted_book = books.pop(i)
                return {"message": f"Book '{deleted_book['title']}' deleted successfully"}
        
        return {"message": "Book not found"}, 404

# Register resources
api.add_resource(BookResource, '/books', '/books/<int:book_id>')

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
            </div>
            
            <div class="example">
                <h3>Testing Your API</h3>
                <p>You can test this API using tools like Postman, curl, or the Requests library in Python:</p>
                
                <h4>Using curl:</h4>
                <pre><code># Get all books
curl http://127.0.0.1:5000/books

# Get a specific book
curl http://127.0.0.1:5000/books/1

# Create a new book
curl -X POST http://127.0.0.1:5000/books \
  -H "Content-Type: application/json" \
  -d '{"title": "Fluent Python", "author": "Luciano Ramalho"}'

# Update a book
curl -X PUT http://127.0.0.1:5000/books/1 \
  -H "Content-Type: application/json" \
  -d '{"title": "Python Crash Course (2nd Edition)", "author": "Eric Matthes"}'

# Delete a book
curl -X DELETE http://127.0.0.1:5000/books/2</code></pre>
            </div>
            
            <div class="explanation">
                <h3>Understanding URL Patterns</h3>
                <p>Notice how we registered one resource with two URL patterns:</p>
                <code>api.add_resource(BookResource, '/books', '/books/&lt;int:book_id&gt;')</code>
                
                <p>This allows our resource to handle both collection endpoints (/books) and individual item endpoints (/books/1). The <code>&lt;int:book_id&gt;</code> part is a converter that captures and converts the URL parameter to an integer, which is then passed to our methods.</p>
                
                <p>This is similar to how in a library, you can ask to see all books in a collection, or you can request a specific book by its call number.</p>
            </div>
        </section>

        <section class="request_parsing">
            <h2>Request Parsing and Validation</h2>
            
            <p>One of the most powerful features of Flask-RESTful is its ability to parse and validate incoming request data. This is like having a bouncer at a club checking IDs - it ensures only valid data gets into your application.</p>
            
            <p>The <code>reqparse</code> module helps you define the expected format of input data and automatically validates it against these rules.</p>
            
            <div class="code-section">
                <h3>Using RequestParser</h3>
                <pre><code>from flask import Flask
from flask_restful import Api, Resource, reqparse

app = Flask(__name__)
api = Api(app)

# In-memory database
books = []

# Create request parser
book_parser = reqparse.RequestParser()
book_parser.add_argument('title', type=str, required=True, help='Title cannot be blank')
book_parser.add_argument('author', type=str, required=True, help='Author cannot be blank')
book_parser.add_argument('pages', type=int, help='Pages must be an integer')
book_parser.add_argument('genre', type=str, choices=('fiction', 'non-fiction', 'reference'), 
                        help='Genre must be one of: fiction, non-fiction, reference')

class BookList(Resource):
    def post(self):
        # Parse arguments
        args = book_parser.parse_args()
        
        # Create new book
        book_id = len(books) + 1
        book = {
            'id': book_id,
            'title': args['title'],
            'author': args['author'],
            'pages': args['pages'],
            'genre': args['genre']
        }
        
        books.append(book)
        return book, 201

    def get(self):
        return books

api.add_resource(BookList, '/books')

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
            </div>
            
            <div class="breakdown">
                <h3>Parser Breakdown</h3>
                <ul>
                    <li><code>book_parser = reqparse.RequestParser()</code>: Creates a new parser object.</li>
                    <li><code>add_argument()</code>: Defines expected arguments and their validation rules.</li>
                    <li><code>type=str</code>: Specifies the expected data type.</li>
                    <li><code>required=True</code>: Makes the field mandatory.</li>
                    <li><code>help='Title cannot be blank'</code>: Provides an error message if validation fails.</li>
                    <li><code>choices=(...)</code>: Restricts input to a set of allowed values.</li>
                </ul>
                
                <p>When <code>parse_args()</code> is called, Flask-RESTful automatically validates the incoming request data against these rules and returns a dictionary of validated arguments.</p>
            </div>
            
            <div class="example">
                <h3>Test Cases</h3>
                <p>Here's what happens with different request payloads:</p>
                <pre><code># Valid payload
curl -X POST http://127.0.0.1:5000/books \
  -H "Content-Type: application/json" \
  -d '{"title": "Python Cookbook", "author": "David Beazley", "pages": 706, "genre": "reference"}'
# Response: 201 Created with book object

# Missing required field
curl -X POST http://127.0.0.1:5000/books \
  -H "Content-Type: application/json" \
  -d '{"title": "Python Cookbook", "pages": 706}'
# Response: 400 Bad Request with message "Author cannot be blank"

# Invalid genre
curl -X POST http://127.0.0.1:5000/books \
  -H "Content-Type: application/json" \
  -d '{"title": "Python Cookbook", "author": "David Beazley", "genre": "mystery"}'
# Response: 400 Bad Request with message about invalid genre</code></pre>
            </div>
            
            <div class="explanation">
                <h3>Practical Application</h3>
                <p>Request parsing is crucial in real-world applications for several reasons:</p>
                <ul>
                    <li><strong>Data Validation:</strong> Ensures the data meets your requirements before processing.</li>
                    <li><strong>Security:</strong> Helps prevent injection attacks by validating input types.</li>
                    <li><strong>Error Handling:</strong> Provides clear error messages to API consumers.</li>
                    <li><strong>Documentation:</strong> The parser definition serves as implicit documentation of expected inputs.</li>
                </ul>
                
                <p>Think of request parsing as a contract between your API and its clients. It clearly communicates what data is expected and enforces those expectations.</p>
            </div>
        </section>

        <section class="authentication">
            <h2>Authentication and Authorization</h2>
            
            <p>Most real-world APIs need to restrict access to certain endpoints. This is like having different access cards in a building - some people can enter any room, while others are restricted to specific areas.</p>
            
            <p>Flask-RESTful can be combined with various authentication methods, including token-based authentication, which is commonly used in RESTful APIs.</p>
            
            <div class="code-section">
                <h3>Implementing Token Authentication</h3>
                <pre><code>from flask import Flask, request
from flask_restful import Api, Resource
from functools import wraps
import secrets

app = Flask(__name__)
api = Api(app)

# Simple in-memory user database
users = {
    "admin": {
        "password": "admin123",
        "token": None
    },
    "user1": {
        "password": "user123",
        "token": None
    }
}

# Decorator for requiring token authentication
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        
        if not token:
            return {'message': 'Authentication token is missing'}, 401
        
        # Check if token is valid
        for username, user_data in users.items():
            if user_data['token'] == token:
                # Add user to kwargs
                kwargs['username'] = username
                return f(*args, **kwargs)
        
        return {'message': 'Invalid token'}, 401
    
    return decorated

class Login(Resource):
    def post(self):
        auth = request.authorization
        
        if not auth or not auth.username or not auth.password:
            return {'message': 'Could not verify'}, 401
        
        if auth.username in users and users[auth.username]['password'] == auth.password:
            # Generate token
            token = secrets.token_hex(16)
            users[auth.username]['token'] = token
            
            return {'token': token}
        
        return {'message': 'Invalid credentials'}, 401

class ProtectedResource(Resource):
    @token_required
    def get(self, username):
        return {'message': f'Hello, {username}! This is a protected resource.'}

api.add_resource(Login, '/login')
api.add_resource(ProtectedResource, '/protected')

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
            </div>
            
            <div class="explanation">
                <h3>How It Works</h3>
                <ol>
                    <li>The user sends their credentials to the <code>/login</code> endpoint.</li>
                    <li>If valid, the server generates a token and returns it to the client.</li>
                    <li>For subsequent requests, the client includes this token in the Authorization header.</li>
                    <li>The <code>token_required</code> decorator checks if the token is valid before executing the method.</li>
                </ol>
                
                <p>This is similar to how a hotel works - you identify yourself at check-in (login) and receive a key card (token) that grants you access to specific areas of the hotel.</p>
            </div>
            
            <div class="example">
                <h3>Testing Authentication</h3>
                <pre><code># Login to get a token
curl -X POST http://127.0.0.1:5000/login \
  -u admin:admin123
# Response: {"token": "3a7c4f8e2b1d9e6a0c5f2d8e7b3a9c1f"}

# Access protected resource with token
curl -X GET http://127.0.0.1:5000/protected \
  -H "Authorization: 3a7c4f8e2b1d9e6a0c5f2d8e7b3a9c1f"
# Response: {"message": "Hello, admin! This is a protected resource."}</code></pre>
            </div>
            
            <div class="important-note">
                <h3>Security Considerations</h3>
                <p>For production applications, consider:</p>
                <ul>
                    <li>Using established authentication libraries like Flask-JWT-Extended</li>
                    <li>Storing passwords securely (hashed, not plain text)</li>
                    <li>Using HTTPS to encrypt all communication</li>
                    <li>Implementing token expiration</li>
                    <li>Using refresh tokens for improved security</li>
                </ul>
                
                <p>This example is intentionally simplified for educational purposes. In real applications, security should be given much more attention.</p>
            </div>
        </section>

        <section class="structuring">
            <h2>Structuring Larger Applications</h2>
            
            <p>As your API grows, keeping everything in a single file becomes unwieldy. A well-structured project is like a well-organized toolbox - it makes finding and maintaining components much easier.</p>
            
            <p>Let's explore how to structure a larger Flask-RESTful application using the package pattern:</p>
            
            <div class="folder-structure">
                <h3>Recommended Folder Structure</h3>
                <pre><code>flask_api_project/
├── app.py                  # Application entry point
├── config.py               # Configuration settings
├── requirements.txt        # Project dependencies
├── models/                 # Data models
│   ├── __init__.py
│   └── book.py
├── resources/              # API resources
│   ├── __init__.py
│   ├── auth.py
│   └── book.py
└── utils/                  # Utility functions
    ├── __init__.py
    └── auth_utils.py</code></pre>
            </div>
            
            <div class="code-section">
                <h3>Implementation Example</h3>
                
                <h4>config.py</h4>
                <pre><code>class Config:
    DEBUG = False
    SECRET_KEY = 'my-secret-key'

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False

config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}</code></pre>
                
                <h4>models/book.py</h4>
                <pre><code>class Book:
    def __init__(self, id, title, author, pages=None, genre=None):
        self.id = id
        self.title = title
        self.author = author
        self.pages = pages
        self.genre = genre
    
    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'author': self.author,
            'pages': self.pages,
            'genre': self.genre
        }
    
    @classmethod
    def from_dict(cls, data):
        return cls(
            id=data.get('id'),
            title=data.get('title'),
            author=data.get('author'),
            pages=data.get('pages'),
            genre=data.get('genre')
        )</code></pre>
                
                <h4>resources/book.py</h4>
                <pre><code>from flask_restful import Resource, reqparse
from models.book import Book
from utils.auth_utils import token_required

# In-memory storage (in a real app, this would be a database)
books_db = []

# Request parser
book_parser = reqparse.RequestParser()
book_parser.add_argument('title', type=str, required=True, help='Title cannot be blank')
book_parser.add_argument('author', type=str, required=True, help='Author cannot be blank')
book_parser.add_argument('pages', type=int)
book_parser.add_argument('genre', type=str)

class BookResource(Resource):
    @token_required
    def get(self, username, book_id=None):
        if book_id:
            for book in books_db:
                if book.id == book_id:
                    return book.to_dict()
            return {'message': 'Book not found'}, 404
        
        return [book.to_dict() for book in books_db]
    
    @token_required
    def post(self, username):
        args = book_parser.parse_args()
        
        # Generate new ID
        book_id = len(books_db) + 1
        
        # Create new book
        new_book = Book(
            id=book_id,
            title=args['title'],
            author=args['author'],
            pages=args['pages'],
            genre=args['genre']
        )
        
        books_db.append(new_book)
        return new_book.to_dict(), 201
    
    @token_required
    def put(self, username, book_id):
        args = book_parser.parse_args()
        
        for i, book in enumerate(books_db):
            if book.id == book_id:
                # Update book
                updated_book = Book(
                    id=book_id,
                    title=args['title'],
                    author=args['author'],
                    pages=args['pages'],
                    genre=args['genre']
                )
                books_db[i] = updated_book
                return updated_book.to_dict()
        
        return {'message': 'Book not found'}, 404
    
    @token_required
    def delete(self, username, book_id):
        for i, book in enumerate(books_db):
            if book.id == book_id:
                deleted_book = books_db.pop(i)
                return {'message': f"Book '{deleted_book.title}' deleted successfully"}
        
        return {'message': 'Book not found'}, 404</code></pre>
                
                <h4>app.py</h4>
                <pre><code>import os
from flask import Flask
from flask_restful import Api
from config import config
from resources.book import BookResource
from resources.auth import Login

# Create Flask application
def create_app(config_name='default'):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    
    # Initialize API
    api = Api(app)
    
    # Register resources
    api.add_resource(Login, '/login')
    api.add_resource(BookResource, '/books', '/books/<int:book_id>')
    
    return app

if __name__ == '__main__':
    config_name = os.getenv('FLASK_CONFIG', 'default')
    app = create_app(config_name)
    app.run()</code></pre>
            </div>
            
            <div class="explanation">
                <h3>Benefits of This Structure</h3>
                <ul>
                    <li><strong>Separation of Concerns:</strong> Each file has a single responsibility, making the code easier to understand and maintain.</li>
                    <li><strong>Modularity:</strong> Components can be developed and tested independently.</li>
                    <li><strong>Scalability:</strong> New resources can be added without modifying existing code.</li>
                    <li><strong>Testability:</strong> The modular structure makes unit testing easier.</li>
                    <li><strong>Collaboration:</strong> Different team members can work on different parts of the application simultaneously.</li>
                </ul>
                
                <p>Think of this structure as building with LEGO blocks - each piece has a specific function, and they all fit together to create a complete application.</p>
            </div>
        </section>

        <section class="best_practices">
            <h2>Best Practices and Common Patterns</h2>
            
            <p>As you develop RESTful APIs, following established patterns and best practices will make your APIs more intuitive, maintainable, and powerful. These are like the unwritten rules of API design that experienced developers follow.</p>
            
            <div class="practices">
                <h3>API Design Best Practices</h3>
                <ul>
                    <li><strong>Use Nouns for Resources:</strong> Use plural nouns for collection endpoints (e.g., /books instead of /book).</li>
                    <li><strong>Consistent URL Patterns:</strong> Follow consistent patterns, like /resources for collections and /resources/&lt;id&gt; for individual items.</li>
                    <li><strong>Use HTTP Methods Correctly:</strong>
                        <ul>
                            <li>GET: Retrieve resources (never modify data)</li>
                            <li>POST: Create new resources</li>
                            <li>PUT: Update existing resources (full update)</li>
                            <li>PATCH: Partial update of resources</li>
                            <li>DELETE: Remove resources</li>
                        </ul>
                    </li>
                    <li><strong>Use Appropriate Status Codes:</strong>
                        <ul>
                            <li>200: OK</li>
                            <li>201: Created</li>
                            <li>204: No Content (successful but no response body)</li>
                            <li>400: Bad Request</li>
                            <li>401: Unauthorized</li>
                            <li>403: Forbidden</li>
                            <li>404: Not Found</li>
                            <li>500: Internal Server Error</li>
                        </ul>
                    </li>
                    <li><strong>Version Your API:</strong> Include version in the URL (e.g., /api/v1/books) to allow for future changes.</li>
                    <li><strong>Pagination:</strong> Implement pagination for endpoints that return multiple items.</li>
                    <li><strong>Filtering, Sorting, and Searching:</strong> Allow clients to filter, sort, and search resources.</li>
                    <li><strong>HATEOAS (Hypertext as the Engine of Application State):</strong> Include links to related resources in responses.</li>
                </ul>
            </div>
            
            <div class="code-section">
                <h3>Implementing Pagination</h3>
                <pre><code>from flask import Flask, request
from flask_restful import Api, Resource

app = Flask(__name__)
api = Api(app)

# Generate sample data
books = [{"id": i, "title": f"Book {i}", "author": f"Author {i}"} for i in range(1, 101)]

class BookList(Resource):
    def get(self):
        # Parse pagination parameters
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 10))
        
        # Calculate start and end indices
        start = (page - 1) * per_page
        end = start + per_page
        
        # Paginate the data
        paginated_books = books[start:end]
        
        # Create response with pagination info
        response = {
            "books": paginated_books,
            "pagination": {
                "total_items": len(books),
                "total_pages": (len(books) + per_page - 1) // per_page,
                "current_page": page,
                "per_page": per_page
            }
        }
        
        # Add navigation links (HATEOAS)
        links = {}
        
        # First page
        links["first"] = f"/books?page=1&per_page={per_page}"
        
        # Previous page
        if page > 1:
            links["prev"] = f"/books?page={page-1}&per_page={per_page}"
        
        # Next page
        if page < (len(books) + per_page - 1) // per_page:
            links["next"] = f"/books?page={page+1}&per_page={per_page}"
        
        # Last page
        last_page = (len(books) + per_page - 1) // per_page
        links["last"] = f"/books?page={last_page}&per_page={per_page}"
        
        response["links"] = links
        
        return response

api.add_resource(BookList, '/books')

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
            </div>
            
            <div class="example">
                <h3>Example Response</h3>
                <pre><code>{
  "books": [
    {"id": 1, "title": "Book 1", "author": "Author 1"},
    {"id": 2, "title": "Book 2", "author": "Author 2"},
    ...
  ],
  "pagination": {
    "total_items": 100,
    "total_pages": 10,
    "current_page": 1,
    "per_page": 10
  },
  "links": {
    "first": "/books?page=1&per_page=10",
    "next": "/books?page=2&per_page=10",
    "last": "/books?page=10&per_page=10"
  }
}</code></pre>
            </div>
            
            <div class="explanation">
                <h3>Real-World Applications</h3>
                <p>These patterns are used extensively in popular APIs:</p>
                <ul>
                    <li><strong>GitHub API:</strong> Uses pagination, consistent resource naming, and HATEOAS.</li>
                    <li><strong>Twitter API:</strong> Implements versioning and comprehensive filtering options.</li>
                    <li><strong>Stripe API:</strong> Known for excellent documentation and consistent error handling.</li>
                </ul>
                
                <p>By following these established patterns, you make your API intuitive for developers who are already familiar with other well-designed APIs. It's like driving a car - once you know how to drive one car, you can generally drive any car because they follow similar patterns.</p>
            </div>
        </section>

        <section class="testing">
            <h2>Testing Your API</h2>
            
            <p>Testing is a crucial part of API development. An untested API is like an unchecked parachute - you won't know if it works until it's too late. Flask provides excellent tools for testing, and these can be extended to test Flask-RESTful APIs.</p>
            
            <div class="code-section">
                <h3>Writing Tests for Your API</h3>
                <p>Create a file named <code>test_api.py</code> in your project:</p>
                <pre><code>import unittest
import json
from app import create_app

class BookAPITestCase(unittest.TestCase):
    def setUp(self):
        # Create test client
        self.app = create_app('testing')
        self.client = self.app.test_client()
        
        # Get authentication token
        auth_response = self.client.post('/login',
            headers={"Authorization": "Basic dXNlcjE6dXNlcjEyMw=="}  # Base64 encoded user1:user123
        )
        auth_data = json.loads(auth_response.data)
        self.token = auth_data.get('token')
        
        # Add test data
        self.client.post('/books',
            headers={"Authorization": self.token},
            json={"title": "Test Book", "author": "Test Author"}
        )
    
    def test_get_books(self):
        # Test getting all books
        response = self.client.get('/books',
            headers={"Authorization": self.token}
        )
        
        self.assertEqual(response.status_code, 200)
        data = json.loads(response.data)
        self.assertIsInstance(data, list)
        self.assertGreaterEqual(len(data), 1)
    
    def test_get_book(self):
        # Test getting a specific book
        response = self.client.get('/books/1',
            headers={"Authorization": self.token}
        )
        
        self.assertEqual(response.status_code, 200)
        data = json.loads(response.data)
        self.assertEqual(data['id'], 1)
    
    def test_create_book(self):
        # Test creating a new book
        response = self.client.post('/books',
            headers={"Authorization": self.token},
            json={"title": "New Book", "author": "New Author"}
        )
        
        self.assertEqual(response.status_code, 201)
        data = json.loads(response.data)
        self.assertEqual(data['title'], "New Book")
        self.assertEqual(data['author'], "New Author")
    
    def test_update_book(self):
        # Test updating a book
        response = self.client.put('/books/1',
            headers={"Authorization": self.token},
            json={"title": "Updated Book", "author": "Updated Author"}
        )
        
        self.assertEqual(response.status_code, 200)
        data = json.loads(response.data)
        self.assertEqual(data['title'], "Updated Book")
        self.assertEqual(data['author'], "Updated Author")
    
    def test_delete_book(self):
        # Test deleting a book
        response = self.client.delete('/books/1',
            headers={"Authorization": self.token}
        )
        
        self.assertEqual(response.status_code, 200)
        
        # Verify book is deleted
        get_response = self.client.get('/books/1',
            headers={"Authorization": self.token}
        )
        self.assertEqual(get_response.status_code, 404)

if __name__ == '__main__':
    unittest.main()</code></pre>
            </div>
            
            <div class="explanation">
                <h3>Test Breakdown</h3>
                <ul>
                    <li><code>setUp()</code>: Runs before each test, setting up the test environment.</li>
                    <li><code>test_get_books()</code>: Tests retrieving all books.</li>
                    <li><code>test_get_book()</code>: Tests retrieving a specific book.</li>
                    <li><code>test_create_book()</code>: Tests creating a new book.</li>
                    <li><code>test_update_book()</code>: Tests updating an existing book.</li>
                    <li><code>test_delete_book()</code>: Tests deleting a book and verifies it's gone.</li>
                </ul>
                
                <p>Running tests is simple:</p>
                <pre><code>python test_api.py</code></pre>
            </div>
            
            <div class="important-note">
                <h3>Testing Best Practices</h3>
                <ul>
                    <li><strong>Test Each Endpoint:</strong> Ensure complete coverage of your API.</li>
                    <li><strong>Test Edge Cases:</strong> Try invalid inputs, missing parameters, etc.</li>
                    <li><strong>Use Mocks:</strong> For external dependencies like databases.</li>
                    <li><strong>Automate Testing:</strong> Include tests in your CI/CD pipeline.</li>
                    <li><strong>Test Authentication:</strong> Ensure protected endpoints are properly secured.</li>
                </ul>
                
                <p>Think of testing as a safety net for your API. The more comprehensive your tests, the more confident you can be when making changes or adding features.</p>
            </div>
        </section>

        <section class="real_world">
            <h2>Real-World Application Example</h2>
            
            <p>Let's tie everything together with a more complete example of a book management API that incorporates all the concepts we've discussed.</p>
            
            <p>In a real-world scenario, you would typically use a database instead of in-memory storage, add more robust error handling, and include more sophisticated authentication. This example includes simplified versions of these components for clarity.</p>
            
            <div class="code-section">
                <h3>A Complete Book Management API</h3>
                <pre><code>from flask import Flask, request
from flask_restful import Api, Resource, reqparse
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash
import jwt
import datetime
from functools import wraps

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///api.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
api = Api(app)

# Models
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    password_hash = db.Column(db.String(100), nullable=False)
    
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

class Book(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    author = db.Column(db.String(100), nullable=False)
    pages = db.Column(db.Integer)
    genre = db.Column(db.String(50))
    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'author': self.author,
            'pages': self.pages,
            'genre': self.genre,
            'created_by': self.created_by,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

# Authentication decorator
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        
        if not token:
            return {'message': 'Authentication token is missing'}, 401
        
        try:
            # Decode token
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            current_user = User.query.filter_by(id=data['user_id']).first()
            
            if not current_user:
                return {'message': 'Invalid token'}, 401
                
            # Add user to kwargs
            kwargs['current_user'] = current_user
            
        except jwt.ExpiredSignatureError:
            return {'message': 'Token has expired'}, 401
        except jwt.InvalidTokenError:
            return {'message': 'Invalid token'}, 401
        
        return f(*args, **kwargs)
    
    return decorated

# Request parsers
user_parser = reqparse.RequestParser()
user_parser.add_argument('username', type=str, required=True, help='Username cannot be blank')
user_parser.add_argument('password', type=str, required=True, help='Password cannot be blank')

book_parser = reqparse.RequestParser()
book_parser.add_argument('title', type=str, required=True, help='Title cannot be blank')
book_parser.add_argument('author', type=str, required=True, help='Author cannot be blank')
book_parser.add_argument('pages', type=int)
book_parser.add_argument('genre', type=str)

# Resources
class UserRegistration(Resource):
    def post(self):
        args = user_parser.parse_args()
        
        # Check if user already exists
        if User.query.filter_by(username=args['username']).first():
            return {'message': 'User already exists'}, 400
        
        # Create new user
        user = User(username=args['username'])
        user.set_password(args['password'])
        
        db.session.add(user)
        db.session.commit()
        
        return {'message': 'User created successfully'}, 201

class UserLogin(Resource):
    def post(self):
        args = user_parser.parse_args()
        
        # Check credentials
        user = User.query.filter_by(username=args['username']).first()
        
        if not user or not user.check_password(args['password']):
            return {'message': 'Invalid credentials'}, 401
        
        # Generate token
        token = jwt.encode({
            'user_id': user.id,
            'exp': datetime.datetime.utcnow() + datetime.timedelta(days=1)
        }, app.config['SECRET_KEY'], algorithm='HS256')
        
        return {'token': token}

class BookResource(Resource):
    @token_required
    def get(self, current_user, book_id=None):
        if book_id:
            book = Book.query.filter_by(id=book_id).first()
            
            if not book:
                return {'message': 'Book not found'}, 404
            
            return book.to_dict()
        
        # Get query parameters for pagination
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        
        # Query books with pagination
        pagination = Book.query.paginate(page=page, per_page=per_page)
        
        # Prepare response
        response = {
            'books': [book.to_dict() for book in pagination.items],
            'pagination': {
                'total_items': pagination.total,
                'total_pages': pagination.pages,
                'current_page': pagination.page,
                'per_page': pagination.per_page
            }
        }
        
        # Add navigation links
        links = {}
        
        # First page
        links['first'] = f"/books?page=1&per_page={per_page}"
        
        # Previous page
        if pagination.has_prev:
            links['prev'] = f"/books?page={pagination.prev_num}&per_page={per_page}"
        
        # Next page
        if pagination.has_next:
            links['next'] = f"/books?page={pagination.next_num}&per_page={per_page}"
        
        # Last page
        links['last'] = f"/books?page={pagination.pages}&per_page={per_page}"
        
        response['links'] = links
        
        return response
    
    @token_required
    def post(self, current_user):
        args = book_parser.parse_args()
        
        # Create new book
        book = Book(
            title=args['title'],
            author=args['author'],
            pages=args['pages'],
            genre=args['genre'],
            created_by=current_user.id
        )
        
        db.session.add(book)
        db.session.commit()
        
        return book.to_dict(), 201
    
    @token_required
    def put(self, current_user, book_id):
        book = Book.query.filter_by(id=book_id).first()
        
        if not book:
            return {'message': 'Book not found'}, 404
        
        # Check if user is the creator
        if book.created_by != current_user.id:
            return {'message': 'You do not have permission to update this book'}, 403
        
        args = book_parser.parse_args()
        
        # Update book
        book.title = args['title']
        book.author = args['author']
        book.pages = args['pages']
        book.genre = args['genre']
        
        db.session.commit()
        
        return book.to_dict()
    
    @token_required
    def delete(self, current_user, book_id):
        book = Book.query.filter_by(id=book_id).first()
        
        if not book:
            return {'message': 'Book not found'}, 404
        
        # Check if user is the creator
        if book.created_by != current_user.id:
            return {'message': 'You do not have permission to delete this book'}, 403
        
        db.session.delete(book)
        db.session.commit()
        
        return {'message': f"Book '{book.title}' deleted successfully"}

# Register resources
api.add_resource(UserRegistration, '/register')
api.add_resource(UserLogin, '/login')
api.add_resource(BookResource, '/books', '/books/<int:book_id>')

# Create database tables
@app.before_first_request
def create_tables():
    db.create_all()

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
            </div>
            
            <div class="explanation">
                <h3>Key Features of This Implementation</h3>
                <ul>
                    <li><strong>Database Integration:</strong> Uses SQLAlchemy for database operations.</li>
                    <li><strong>User Authentication:</strong> Implements secure password hashing and JWT-based authentication.</li>
                    <li><strong>Pagination:</strong> Returns paginated results with navigation links.</li>
                    <li><strong>Permission Checking:</strong> Ensures users can only modify their own resources.</li>
                    <li><strong>Timestamp Tracking:</strong> Records creation and update times automatically.</li>
                    <li><strong>Structured Responses:</strong> Returns consistent, well-formatted JSON responses.</li>
                </ul>
                
                <p>This example demonstrates how the concepts we've learned can be combined to create a robust, production-ready API. While still simplified, it includes many of the patterns and practices you would encounter in real-world applications.</p>
            </div>
        </section>

        <section class="next_steps">
            <h2>Next Steps and Further Learning</h2>
            
            <p>We've covered the fundamentals of Flask-RESTful, but there's always more to learn. Here are some topics to explore as you continue your journey:</p>
            
            <ul>
                <li><strong>Advanced Authentication:</strong> OAuth2, OpenID Connect, and token refresh mechanisms.</li>
                <li><strong>API Documentation:</strong> Tools like Swagger/OpenAPI and Flask-RESTPlus for automatic documentation.</li>
                <li><strong>Rate Limiting:</strong> Protect your API from abuse by limiting request rates.</li>
                <li><strong>Caching:</strong> Improve performance by caching frequently accessed resources.</li>
                <li><strong>WebSockets:</strong> For real-time communication between clients and servers.</li>
                <li><strong>Microservices:</strong> Breaking down large APIs into smaller, more manageable services.</li>
                <li><strong>Containerization:</strong> Deploying your API with Docker and Kubernetes.</li>
                <li><strong>API Gateways:</strong> Managing multiple APIs with tools like Kong or AWS API Gateway.</li>
            </ul>
            
            <div class="resources">
                <h3>Recommended Resources</h3>
                <ul>
                    <li><strong>Books:</strong>
                        <ul>
                            <li>"Flask Web Development" by Miguel Grinberg</li>
                            <li>"RESTful Web APIs" by Leonard Richardson</li>
                            <li>"Designing Web APIs" by Brenda Jin, Saurabh Sahni, and Amir Shevat</li>
                        </ul>
                    </li>
                    <li><strong>Documentation:</strong>
                        <ul>
                            <li><a href="#">Flask-RESTful Official Documentation</a></li>
                            <li><a href="#">SQLAlchemy Documentation</a></li>
                            <li><a href="#">JWT Documentation</a></li>
                        </ul>
                    </li>
                    <li><strong>Tutorials and Courses:</strong>
                        <ul>
                            <li>Flask Mega-Tutorial by Miguel Grinberg</li>
                            <li>Real Python - Flask-RESTful API Development</li>
                            <li>Pluralsight - Building RESTful APIs with Flask</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </section>

        <section class="conclusion">
            <h2>Conclusion</h2>
            
            <p>Congratulations on completing this introduction to Flask-RESTful! You've learned how to:</p>
            
            <ul>
                <li>Understand and apply REST principles</li>
                <li>Create resources and endpoints</li>
                <li>Parse and validate requests</li>
                <li>Implement authentication and authorization</li>
                <li>Structure larger applications</li>
                <li>Apply best practices for API design</li>
                <li>Test your API</li>
                <li>Build a complete, real-world API example</li>
            </ul>
            
            <p>Remember, building good APIs is both an art and a science. The technical aspects are important, but so is the design thinking that goes into creating intuitive, developer-friendly interfaces.</p>
            
            <p>As you build your own APIs, think about the developers who will use them. A well-designed API is a joy to work with, while a poorly designed one can be a source of frustration. Strive to create APIs that you would want to use yourself.</p>
            
            <p>Happy coding!</p>
        </section>
    </main>

    <footer>
        <p>Python Full Stack Web Course - Flask RESTful Tutorial</p>
    </footer>
</body>
</html>
