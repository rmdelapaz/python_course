<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Best Practices for Python Full Stack Development</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>API Best Practices for Python Full Stack Development</h1>
        <p class="subtitle">Python Full Stack Web Course</p>
    </header>

    <main>
        <section class="introduction">
            <h2>Introduction to API Best Practices</h2>
            <p>Welcome to our comprehensive guide on API best practices for Python Full Stack development! In today's interconnected digital landscape, APIs (Application Programming Interfaces) serve as the crucial bridges that connect different software systems, enabling them to communicate and work together seamlessly.</p>
            
            <p>Think of APIs as the diplomatic ambassadors in the software world. Just as ambassadors follow diplomatic protocols to ensure smooth international relations, well-designed APIs follow established practices to ensure seamless system interactions. The quality of these interactions can make or break your application's success.</p>
            
            <p>Throughout this tutorial, we'll explore the essential best practices for designing, building, documenting, securing, and maintaining robust APIs using Python's rich ecosystem of tools and frameworks. By the end, you'll have a comprehensive understanding of how to create APIs that developers love to use and that stand the test of time in production environments.</p>
        </section>

        <section class="fundamentals">
            <h2>API Design Fundamentals</h2>
            
            <p>Before diving into specific Python implementations, let's establish the core principles that guide excellent API design regardless of technology stack.</p>
            
            <h3>REST Architectural Principles</h3>
            <p>RESTful (Representational State Transfer) design remains the gold standard for web APIs. Think of REST as a set of architectural guidelines, similar to how city planning principles create navigable, functional urban spaces.</p>
            
            <ul>
                <li><strong>Resource-Based:</strong> Model your API around resources (nouns) rather than actions (verbs). For example, use <code>/users</code> instead of <code>/getUsers</code>.</li>
                <li><strong>Statelessness:</strong> Each request should contain all the information needed to complete it, like a self-contained letter with complete instructions.</li>
                <li><strong>Uniform Interface:</strong> Standardize your endpoints with consistent patterns that make your API intuitive to use.</li>
                <li><strong>HATEOAS (Hypertext as the Engine of Application State):</strong> Include links in responses that guide clients to related resources.</li>
                <li><strong>Client-Server Separation:</strong> Keep a clear boundary between client concerns and server concerns.</li>
            </ul>
            
            <div class="example">
                <h3>Resource Naming: Good vs. Bad Practices</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Good Practice</th>
                            <th>Bad Practice</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>/users</code> (Get all users)</td>
                            <td><code>/getUsers</code> (Uses verb instead of noun)</td>
                        </tr>
                        <tr>
                            <td><code>/users/123</code> (Get specific user)</td>
                            <td><code>/user?id=123</code> (Inconsistent with collection)</td>
                        </tr>
                        <tr>
                            <td><code>/users/123/orders</code> (Nested resources)</td>
                            <td><code>/getUserOrders?userId=123</code> (Verbose, action-based)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <h3>HTTP Methods and Status Codes</h3>
            <p>Use HTTP methods as they were intended, like using the right tool for each job in your toolbox:</p>
            
            <ul>
                <li><strong>GET:</strong> Retrieve resources (read-only, no side effects)</li>
                <li><strong>POST:</strong> Create new resources</li>
                <li><strong>PUT:</strong> Update resources by replacing them entirely</li>
                <li><strong>PATCH:</strong> Partially update resources</li>
                <li><strong>DELETE:</strong> Remove resources</li>
            </ul>
            
            <p>Use appropriate status codes to communicate results clearly:</p>
            
            <ul>
                <li><strong>2xx (Success):</strong> 200 OK, 201 Created, 204 No Content</li>
                <li><strong>3xx (Redirection):</strong> 301 Moved Permanently, 304 Not Modified</li>
                <li><strong>4xx (Client Errors):</strong> 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found</li>
                <li><strong>5xx (Server Errors):</strong> 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable</li>
            </ul>
            
            <div class="analogy">
                <h3>The Library Analogy</h3>
                <p>Think of your API as a well-organized library:</p>
                <ul>
                    <li>Resources (books) are organized into collections (shelves)</li>
                    <li>Each book has a unique identifier (call number)</li>
                    <li>HTTP methods are like library actions:
                        <ul>
                            <li>GET = Browsing or checking out books</li>
                            <li>POST = Adding new books to the collection</li>
                            <li>PUT = Replacing a book with a new edition</li>
                            <li>PATCH = Updating a book's information card</li>
                            <li>DELETE = Removing a book from circulation</li>
                        </ul>
                    </li>
                    <li>Status codes are like responses from the librarian:
                        <ul>
                            <li>"Here's your book" (200 OK)</li>
                            <li>"We've added that book to our collection" (201 Created)</li>
                            <li>"That book doesn't exist" (404 Not Found)</li>
                            <li>"You're not allowed to access that special collection" (403 Forbidden)</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </section>

        <section class="python_frameworks">
            <h2>Choosing the Right Python Framework</h2>
            
            <p>Python offers several excellent frameworks for building APIs. Selecting the right one for your project is like choosing the right vehicle for a journey - it depends on your destination, cargo, and road conditions.</p>
            
            <h3>Framework Comparison</h3>
            
            <table>
                <thead>
                    <tr>
                        <th>Framework</th>
                        <th>Strengths</th>
                        <th>Best For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Flask + Flask-RESTful</td>
                        <td>Lightweight, flexible, minimal boilerplate</td>
                        <td>Small to medium projects, microservices, learning API development</td>
                    </tr>
                    <tr>
                        <td>Django REST Framework</td>
                        <td>Full-featured, built-in authentication, serialization</td>
                        <td>Complex projects, teams familiar with Django, projects requiring admin interfaces</td>
                    </tr>
                    <tr>
                        <td>FastAPI</td>
                        <td>Modern, async-first, automatic documentation</td>
                        <td>High-performance needs, projects benefiting from type annotations, OpenAPI documentation</td>
                    </tr>
                    <tr>
                        <td>Falcon</td>
                        <td>Speed-focused, minimal abstraction</td>
                        <td>High-throughput services, when performance is critical</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="code-section">
                <h3>Basic API Implementations</h3>
                
                <h4>Flask-RESTful Example</h4>
                <pre><code>from flask import Flask
from flask_restful import Api, Resource

app = Flask(__name__)
api = Api(app)

class UserResource(Resource):
    def get(self, user_id=None):
        if user_id:
            # Return specific user
            return {"id": user_id, "name": "John Doe"}
        else:
            # Return all users
            return [{"id": 1, "name": "John Doe"}, {"id": 2, "name": "Jane Smith"}]
    
    def post(self):
        # Create new user
        return {"message": "User created successfully"}, 201

# Register routes
api.add_resource(UserResource, '/users', '/users/<int:user_id>')

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h4>Django REST Framework Example</h4>
                <pre><code># models.py
from django.db import models

class User(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    created_at = models.DateTimeField(auto_now_add=True)

# serializers.py
from rest_framework import serializers
from .models import User

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'name', 'email', 'created_at']

# views.py
from rest_framework import viewsets
from .models import User
from .serializers import UserSerializer

class UserViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer

# urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import UserViewSet

router = DefaultRouter()
router.register(r'users', UserViewSet)

urlpatterns = [
    path('api/', include(router.urls)),
]</code></pre>

                <h4>FastAPI Example</h4>
                <pre><code>from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI()

# Data model
class User(BaseModel):
    id: Optional[int] = None
    name: str
    email: str

# Sample data
users_db = [
    User(id=1, name="John Doe", email="john@example.com"),
    User(id=2, name="Jane Smith", email="jane@example.com")
]

@app.get("/users", response_model=List[User])
async def get_users():
    return users_db

@app.get("/users/{user_id}", response_model=User)
async def get_user(user_id: int):
    for user in users_db:
        if user.id == user_id:
            return user
    raise HTTPException(status_code=404, detail="User not found")

@app.post("/users", response_model=User, status_code=201)
async def create_user(user: User):
    # Generate ID
    user.id = max(u.id for u in users_db) + 1
    users_db.append(user)
    return user</code></pre>
            </div>
            
            <div class="explanation">
                <h3>Framework Selection Criteria</h3>
                <p>Consider these factors when choosing a framework:</p>
                <ul>
                    <li><strong>Team Experience:</strong> Leverage existing knowledge if your team already knows Django or Flask.</li>
                    <li><strong>Project Size:</strong> Smaller projects benefit from Flask's simplicity; larger ones from Django's structure.</li>
                    <li><strong>Performance Requirements:</strong> High-throughput services might favor FastAPI or Falcon.</li>
                    <li><strong>Development Speed:</strong> FastAPI and Django REST Framework offer more built-in functionality.</li>
                    <li><strong>API Documentation:</strong> FastAPI generates OpenAPI docs automatically.</li>
                    <li><strong>Future Maintenance:</strong> Consider the longevity and community support of the framework.</li>
                </ul>
                
                <p>Remember, the best tool is the one that solves your specific problems efficiently while aligning with your team's skills and project requirements.</p>
            </div>
        </section>

        <section class="versioning">
            <h2>API Versioning Strategies</h2>
            
            <p>As your API evolves, versioning becomes essential to preserve backward compatibility while enabling innovation. Think of versioning as creating new models of a product line - the old models still work for existing customers, while new customers can enjoy enhanced features.</p>
            
            <h3>Common Versioning Approaches</h3>
            
            <table>
                <thead>
                    <tr>
                        <th>Approach</th>
                        <th>Example</th>
                        <th>Pros</th>
                        <th>Cons</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>URL Path</td>
                        <td><code>/api/v1/users</code></td>
                        <td>Simple, explicit, easy to understand</td>
                        <td>URLs change with versions, can look cluttered</td>
                    </tr>
                    <tr>
                        <td>Query Parameter</td>
                        <td><code>/api/users?version=1</code></td>
                        <td>URLs remain consistent, optional versioning</td>
                        <td>Easy to overlook, less conventional</td>
                    </tr>
                    <tr>
                        <td>Custom Header</td>
                        <td><code>X-API-Version: 1</code></td>
                        <td>Clean URLs, separates versioning from resource identification</td>
                        <td>Less visible, requires header manipulation</td>
                    </tr>
                    <tr>
                        <td>Accept Header</td>
                        <td><code>Accept: application/vnd.company.v1+json</code></td>
                        <td>Follows HTTP content negotiation standards</td>
                        <td>More complex, less intuitive for some developers</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="code-section">
                <h3>Implementing URL Path Versioning in Flask</h3>
                <pre><code>from flask import Flask, Blueprint
from flask_restful import Api, Resource

app = Flask(__name__)

# Create versioned blueprints
v1_blueprint = Blueprint('v1', __name__, url_prefix='/api/v1')
v2_blueprint = Blueprint('v2', __name__, url_prefix='/api/v2')

v1_api = Api(v1_blueprint)
v2_api = Api(v2_blueprint)

# V1 resource
class UserResourceV1(Resource):
    def get(self, user_id=None):
        # V1 implementation
        if user_id:
            return {"id": user_id, "name": "John Doe"}
        return [{"id": 1, "name": "John Doe"}, {"id": 2, "name": "Jane Smith"}]

# V2 resource with enhanced data
class UserResourceV2(Resource):
    def get(self, user_id=None):
        # V2 implementation with additional fields
        if user_id:
            return {
                "id": user_id,
                "name": "John Doe",
                "email": "john@example.com",
                "role": "admin"
            }
        return [
            {"id": 1, "name": "John Doe", "email": "john@example.com", "role": "admin"},
            {"id": 2, "name": "Jane Smith", "email": "jane@example.com", "role": "user"}
        ]

# Register resources
v1_api.add_resource(UserResourceV1, '/users', '/users/<int:user_id>')
v2_api.add_resource(UserResourceV2, '/users', '/users/<int:user_id>')

# Register blueprints
app.register_blueprint(v1_blueprint)
app.register_blueprint(v2_blueprint)

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h3>Implementing Header Versioning in FastAPI</h3>
                <pre><code>from fastapi import FastAPI, Header, HTTPException
from pydantic import BaseModel
from typing import List, Optional, Union

app = FastAPI()

# Base model
class UserBase(BaseModel):
    id: int
    name: str

# V1 model
class UserV1(UserBase):
    pass

# V2 model with additional fields
class UserV2(UserBase):
    email: str
    role: str

# Sample data
users_v1 = [
    {"id": 1, "name": "John Doe"},
    {"id": 2, "name": "Jane Smith"}
]

users_v2 = [
    {"id": 1, "name": "John Doe", "email": "john@example.com", "role": "admin"},
    {"id": 2, "name": "Jane Smith", "email": "jane@example.com", "role": "user"}
]

@app.get("/api/users")
async def get_users(x_api_version: Optional[str] = Header(None)):
    if x_api_version == "2":
        return users_v2
    # Default to v1
    return users_v1

@app.get("/api/users/{user_id}")
async def get_user(
    user_id: int,
    x_api_version: Optional[str] = Header(None)
):
    if x_api_version == "2":
        for user in users_v2:
            if user["id"] == user_id:
                return user
    else:
        for user in users_v1:
            if user["id"] == user_id:
                return user
                
    raise HTTPException(status_code=404, detail="User not found")</code></pre>
            </div>
            
            <div class="best-practices">
                <h3>Versioning Best Practices</h3>
                <ul>
                    <li><strong>Start with Versioning:</strong> Include versioning from the beginning; it's harder to add later.</li>
                    <li><strong>Semantic Versioning:</strong> Consider using semantic versioning (major.minor.patch) principles.</li>
                    <li><strong>Documentation:</strong> Clearly document differences between versions.</li>
                    <li><strong>Deprecation Policy:</strong> Establish and communicate a clear deprecation timeline for older versions.</li>
                    <li><strong>Backward Compatibility:</strong> Maintain backward compatibility within the same major version.</li>
                    <li><strong>Version Lifecycle:</strong> Define how long each version will be supported.</li>
                </ul>
                
                <p>Remember, the goal of versioning is to maintain a balance between innovation and stability. The best versioning strategy is one that allows your API to evolve while minimizing disruption for existing clients.</p>
            </div>
            
            <div class="real-world">
                <h3>Real-World Example: Stripe API</h3>
                <p>Stripe's API is a gold standard for versioning done right. They use a date-based versioning system through custom headers:</p>
                <pre><code>curl https://api.stripe.com/v1/charges \
  -H "Authorization: Bearer sk_test_..." \
  -H "Stripe-Version: 2020-08-27"</code></pre>
                
                <p>This approach allows Stripe to:</p>
                <ul>
                    <li>Release new API features without breaking existing integrations</li>
                    <li>Give developers control over when to upgrade</li>
                    <li>Support multiple versions simultaneously</li>
                    <li>Communicate versioning through clear, date-based identifiers</li>
                </ul>
            </div>
        </section>

        <section class="authentication_security">
            <h2>Authentication and Security</h2>
            
            <p>Securing your API is not optional—it's essential. Think of API security like securing your home: you need proper locks on the doors (authentication), surveillance systems to monitor activity (logging), and a plan for what to do if someone tries to break in (rate limiting, threat detection).</p>
            
            <h3>Authentication Methods</h3>
            
            <table>
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Best For</th>
                        <th>Implementation Complexity</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>API Keys</td>
                        <td>Internal APIs, simple integrations</td>
                        <td>Low</td>
                    </tr>
                    <tr>
                        <td>JWT (JSON Web Tokens)</td>
                        <td>Stateless authentication, microservices</td>
                        <td>Medium</td>
                    </tr>
                    <tr>
                        <td>OAuth 2.0</td>
                        <td>Third-party integrations, user consent flows</td>
                        <td>High</td>
                    </tr>
                    <tr>
                        <td>OpenID Connect</td>
                        <td>User authentication, single sign-on</td>
                        <td>High</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="code-section">
                <h3>Implementing JWT Authentication in Flask</h3>
                <pre><code>from flask import Flask, request, jsonify
from flask_restful import Api, Resource
from functools import wraps
import jwt
import datetime

app = Flask(__name__)
api = Api(app)

# Secret key for JWT
app.config['SECRET_KEY'] = 'your-secret-key'

# Mock user database
users_db = {
    "john": {"password": "password123", "role": "admin"},
    "jane": {"password": "password456", "role": "user"}
}

# JWT authentication decorator
def jwt_required(func):
    @wraps(func)
    def jwt_required_wrapper(*args, **kwargs):
        token = None
        
        # Check if token is in headers
        if 'Authorization' in request.headers:
            auth_header = request.headers['Authorization']
            token_parts = auth_header.split()
            
            if len(token_parts) == 2 and token_parts[0].lower() == 'bearer':
                token = token_parts[1]
        
        if not token:
            return {'message': 'Token is missing'}, 401
        
        try:
            # Decode the token
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            # Add username to kwargs for the resource to use
            kwargs['current_user'] = data['username']
        except:
            return {'message': 'Token is invalid'}, 401
            
        return func(*args, **kwargs)
    
    return jwt_required_wrapper

class LoginResource(Resource):
    def post(self):
        auth = request.authorization
        
        if not auth or not auth.username or not auth.password:
            return {'message': 'Authentication required'}, 401
            
        if auth.username not in users_db or users_db[auth.username]['password'] != auth.password:
            return {'message': 'Invalid credentials'}, 401
            
        # Generate token
        token = jwt.encode({
            'username': auth.username,
            'role': users_db[auth.username]['role'],
            'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
        }, app.config['SECRET_KEY'], algorithm='HS256')
        
        return {'token': token}

class ProtectedResource(Resource):
    @jwt_required
    def get(self, current_user):
        return {'message': f'Hello, {current_user}! This is protected data.'}

# Register resources
api.add_resource(LoginResource, '/login')
api.add_resource(ProtectedResource, '/protected')

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h3>Implementing OAuth 2.0 in FastAPI</h3>
                <pre><code>from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel
from datetime import datetime, timedelta
from jose import JWTError, jwt
from typing import Optional

# Initialize FastAPI app
app = FastAPI()

# Security constants
SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# OAuth2 password bearer scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# Models
class User(BaseModel):
    username: str
    email: Optional[str] = None
    disabled: Optional[bool] = None

class Token(BaseModel):
    access_token: str
    token_type: str

# Mock user database
fake_users_db = {
    "john": {
        "username": "john",
        "email": "john@example.com",
        "password": "password123",
        "disabled": False,
    },
    "jane": {
        "username": "jane",
        "email": "jane@example.com",
        "password": "password456",
        "disabled": False,
    }
}

def get_user(username: str):
    if username in fake_users_db:
        user_dict = fake_users_db[username]
        return User(**user_dict)

def authenticate_user(username: str, password: str):
    user = get_user(username)
    if not user:
        return False
    if password != fake_users_db[username]["password"]:  # In production, use proper password hashing
        return False
    return user

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
        
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
        
    user = get_user(username)
    if user is None:
        raise credentials_exception
    return user

@app.post("/token", response_model=Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me", response_model=User)
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user</code></pre>
            </div>
            
            <div class="security-checklist">
                <h3>API Security Checklist</h3>
                
                <h4>Basic Security</h4>
                <ul>
                    <li><strong>HTTPS Everywhere:</strong> Always use TLS/SSL for all API endpoints.</li>
                    <li><strong>Proper Authentication:</strong> Choose appropriate authentication methods.</li>
                    <li><strong>Token Expiration:</strong> Set reasonable expiration times for tokens.</li>
                    <li><strong>Input Validation:</strong> Validate all input to prevent injection attacks.</li>
                </ul>
                
                <h4>Advanced Security</h4>
                <ul>
                    <li><strong>Rate Limiting:</strong> Protect against brute force and DoS attacks.</li>
                    <li><strong>IP Filtering:</strong> Restrict access to known IP addresses when appropriate.</li>
                    <li><strong>CORS Configuration:</strong> Set proper Cross-Origin Resource Sharing policies.</li>
                    <li><strong>Sensitive Data Handling:</strong> Never expose sensitive data in URLs or logs.</li>
                    <li><strong>Content Security Policy:</strong> Implement proper CSP headers.</li>
                </ul>
                
                <h4>Operational Security</h4>
                <ul>
                    <li><strong>Logging and Monitoring:</strong> Implement comprehensive logging for security events.</li>
                    <li><strong>Regular Audits:</strong> Conduct security audits and penetration testing.</li>
                    <li><strong>Dependency Management:</strong> Keep dependencies updated to avoid known vulnerabilities.</li>
                    <li><strong>Security Headers:</strong> Implement recommended security headers.</li>
                </ul>
            </div>
            
            <div class="code-section">
                <h3>Implementing Rate Limiting in Flask</h3>
                <pre><code>from flask import Flask, request
from flask_restful import Api, Resource
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

app = Flask(__name__)
api = Api(app)

# Configure rate limiter
limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["100 per day", "10 per hour"]
)

class UserResource(Resource):
    decorators = [
        limiter.limit("5 per minute")  # Custom limit for this endpoint
    ]
    
    def get(self, user_id=None):
        if user_id:
            return {"id": user_id, "name": "John Doe"}
        return [{"id": 1, "name": "John Doe"}, {"id": 2, "name": "Jane Smith"}]

# Register resources
api.add_resource(UserResource, '/users', '/users/<int:user_id>')

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
            </div>
            
            <div class="security-analogy">
                <h3>The Castle Analogy</h3>
                <p>Think of your API security as a medieval castle:</p>
                <ul>
                    <li><strong>HTTPS</strong> is the moat around your castle, providing a basic barrier to entry.</li>
                    <li><strong>Authentication</strong> is the drawbridge guard who checks visitor credentials.</li>
                    <li><strong>Authorization</strong> determines which rooms in the castle each visitor can access.</li>
                    <li><strong>Input validation</strong> is like inspecting incoming goods for contraband.</li>
                    <li><strong>Rate limiting</strong> prevents any single visitor from overwhelming the castle.</li>
                    <li><strong>Logging</strong> keeps records of all castle activities for later review.</li>
                </ul>
                <p>Just as a castle has multiple layers of defense, your API should implement security at multiple levels to protect against various threats.</p>
            </div>
        </section>

        <section class="data_validation">
            <h2>Data Validation and Error Handling</h2>
            
            <p>Robust APIs validate input data and handle errors gracefully. Think of data validation as a quality control checkpoint in a manufacturing process—catching problems early prevents defects further down the line.</p>
            
            <h3>Input Validation Approaches</h3>
            
            <table>
                <thead>
                    <tr>
                        <th>Approach</th>
                        <th>Example</th>
                        <th>Benefits</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Schema Validation</td>
                        <td>Pydantic models, Marshmallow schemas</td>
                        <td>Type checking, comprehensive validation, automatic documentation</td>
                    </tr>
                    <tr>
                        <td>Manual Validation</td>
                        <td>Custom validation functions</td>
                        <td>Complete control, custom validation logic</td>
                    </tr>
                    <tr>
                        <td>Form Validation</td>
                        <td>WTForms, Django Forms</td>
                        <td>Integrated with web forms, field-specific validators</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="code-section">
                <h3>Validation with Pydantic in FastAPI</h3>
                <pre><code>from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, EmailStr, Field, validator
from typing import Optional, List
import re

app = FastAPI()

class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(..., min_length=8)
    age: Optional[int] = Field(None, ge=18, lt=120)
    
    # Custom validator
    @validator('username')
    def username_alphanumeric(cls, v):
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('Username must be alphanumeric')
        return v
    
    # Password complexity validator
    @validator('password')
    def password_complexity(cls, v):
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not re.search(r'[0-9]', v):
            raise ValueError('Password must contain at least one digit')
        return v

@app.post("/users")
async def create_user(user: UserCreate):
    # At this point, the data has already been validated
    # You can now safely process the data
    return {"username": user.username, "email": user.email, "age": user.age}</code></pre>

                <h3>Validation with Marshmallow in Flask</h3>
                <pre><code>from flask import Flask, request, jsonify
from marshmallow import Schema, fields, validate, ValidationError

app = Flask(__name__)

# Define schema for validation
class UserSchema(Schema):
    username = fields.Str(required=True, validate=[
        validate.Length(min=3, max=50),
        validate.Regexp(r'^[a-zA-Z0-9_]+$', error='Username must be alphanumeric')
    ])
    email = fields.Email(required=True)
    password = fields.Str(required=True, validate=validate.Length(min=8))
    age = fields.Int(validate=validate.Range(min=18, max=120))

# Create schema instance
user_schema = UserSchema()

@app.route('/users', methods=['POST'])
def create_user():
    json_data = request.get_json()
    
    if not json_data:
        return jsonify({"message": "No input data provided"}), 400
    
    # Validate input data
    try:
        # Validate against schema
        data = user_schema.load(json_data)
    except ValidationError as err:
        return jsonify({"errors": err.messages}), 422
    
    # Process validated data
    return jsonify({
        "message": "User created successfully",
        "user": {
            "username": data["username"],
            "email": data["email"],
            "age": data.get("age")
        }
    }), 201

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
            </div>
            
            <h3>Error Handling Best Practices</h3>
            
            <p>Proper error handling is like good customer service—it helps users understand what went wrong and how to fix it.</p>
            
            <div class="code-section">
                <h3>Consistent Error Responses in Flask</h3>
                <pre><code>from flask import Flask, jsonify
from werkzeug.exceptions import HTTPException

app = Flask(__name__)

# Standard error response format
def error_response(error_code, message, details=None):
    response = {
        "error": {
            "code": error_code,
            "message": message
        }
    }
    
    if details:
        response["error"]["details"] = details
        
    return jsonify(response), error_code

# Custom exception handler for all HTTP exceptions
@app.errorhandler(HTTPException)
def handle_http_exception(e):
    return error_response(e.code, e.description)

# Custom exception handler for all other exceptions
@app.errorhandler(Exception)
def handle_generic_exception(e):
    # Log the exception here
    return error_response(500, "An unexpected error occurred", str(e))

@app.route('/users/<int:user_id>')
def get_user(user_id):
    # Example: user not found
    if user_id > 100:
        return error_response(404, "User not found", f"No user with ID {user_id}")
    
    # Example: unauthorized access
    if user_id == 42:
        return error_response(403, "Access forbidden", "You don't have permission to access this user")
    
    # Normal response
    return jsonify({"id": user_id, "name": "John Doe"})

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h3>Exception Handling in FastAPI</h3>
                <pre><code>from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import BaseModel
from typing import Any, Dict, List, Optional

app = FastAPI()

# Custom exception for business logic errors
class BusinessLogicException(Exception):
    def __init__(self, detail: str, code: str = "BUSINESS_ERROR"):
        self.detail = detail
        self.code = code

# Define error response model for consistency
class ErrorDetail(BaseModel):
    loc: Optional[List[str]] = None
    msg: str
    type: str

class ErrorResponse(BaseModel):
    detail: List[ErrorDetail]

# Handle validation errors from Pydantic
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    errors = []
    for error in exc.errors():
        errors.append(ErrorDetail(
            loc=error.get("loc", []),
            msg=error.get("msg", ""),
            type=error.get("type", "")
        ))
    
    return JSONResponse(
        status_code=422,
        content={"detail": errors}
    )

# Handle custom business exceptions
@app.exception_handler(BusinessLogicException)
async def business_exception_handler(request: Request, exc: BusinessLogicException):
    return JSONResponse(
        status_code=400,
        content={
            "detail": [
                {
                    "msg": exc.detail,
                    "type": exc.code
                }
            ]
        }
    )

# Example endpoint that might raise various errors
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    if user_id == 0:
        raise HTTPException(status_code=404, detail="User not found")
    
    if user_id < 0:
        raise BusinessLogicException(detail="User ID cannot be negative")
    
    return {"id": user_id, "name": "John Doe"}</code></pre>
            </div>
            
            <div class="best-practices">
                <h3>Error Handling Best Practices</h3>
                <ul>
                    <li><strong>Consistent Format:</strong> Use a consistent error response format across your API.</li>
                    <li><strong>Informative Messages:</strong> Provide clear error messages that help users understand and fix the issue.</li>
                    <li><strong>Appropriate Status Codes:</strong> Use the correct HTTP status codes for different error types.</li>
                    <li><strong>Avoid Exposing Internals:</strong> Never expose internal implementation details, stack traces, or sensitive information in error responses.</li>
                    <li><strong>Include Request Identifiers:</strong> For production systems, include a unique identifier for each request to help with troubleshooting.</li>
                    <li><strong>Localization:</strong> Consider providing error messages in multiple languages for international users.</li>
                </ul>
                
                <h3>Sample Error Response</h3>
                <pre><code>{
  "error": {
    "code": 400,
    "message": "Invalid input",
    "details": [
      {
        "field": "email",
        "message": "Invalid email format"
      },
      {
        "field": "password",
        "message": "Password must be at least 8 characters"
      }
    ],
    "request_id": "abc-123-xyz"
  }
}</code></pre>
            </div>
            
            <div class="analogy">
                <h3>The Restaurant Order Analogy</h3>
                <p>Think of data validation and error handling like a restaurant order process:</p>
                <ul>
                    <li><strong>Data Validation</strong> is like the waiter checking your order before sending it to the kitchen:
                        <ul>
                            <li>Is the requested dish on the menu? (Valid resource)</li>
                            <li>Are all required choices specified? (Required fields)</li>
                            <li>Are special requests reasonable? (Business logic validation)</li>
                        </ul>
                    </li>
                    <li><strong>Error Handling</strong> is how the waiter communicates issues back to you:
                        <ul>
                            <li>"I'm sorry, we're out of the salmon." (Resource not available)</li>
                            <li>"The chef can't make it extra spicy." (Business logic constraint)</li>
                            <li>"Could you please clarify how you want your steak cooked?" (Missing information)</li>
                        </ul>
                    </li>
                </ul>
                <p>Just as a good waiter handles order issues politely and helpfully, your API should handle validation errors gracefully and informatively.</p>
            </div>
        </section>

        <section class="documentation">
            <h2>API Documentation Best Practices</h2>
            
            <p>Great APIs are well-documented. Think of API documentation as a map and guidebook for a new city—it helps visitors navigate efficiently and understand the local customs. Without clear documentation, even the best-designed API can be frustrating to use.</p>
            
            <h3>Documentation Tools and Frameworks</h3>
            
            <table>
                <thead>
                    <tr>
                        <th>Tool</th>
                        <th>Best For</th>
                        <th>Python Integration</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Swagger/OpenAPI</td>
                        <td>Comprehensive API documentation, interactive testing</td>
                        <td>FastAPI (automatic), Flask-RESTPlus, Flask-OpenAPI</td>
                    </tr>
                    <tr>
                        <td>Redoc</td>
                        <td>Clean, responsive documentation rendering</td>
                        <td>FastAPI (built-in), OpenAPI specs</td>
                    </tr>
                    <tr>
                        <td>API Blueprint</td>
                        <td>Markdown-based documentation</td>
                        <td>Various third-party tools</td>
                    </tr>
                    <tr>
                        <td>Sphinx</td>
                        <td>Python-centric documentation</td>
                        <td>Native Python support</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="code-section">
                <h3>Automatic Documentation with FastAPI</h3>
                <pre><code>from fastapi import FastAPI, Path, Query
from pydantic import BaseModel, Field
from enum import Enum
from typing import Optional, List

app = FastAPI(
    title="My Amazing API",
    description="This is a sample API for demonstrating documentation",
    version="1.0.0",
    terms_of_service="https://example.com/terms/",
    contact={
        "name": "API Support",
        "url": "https://example.com/support",
        "email": "support@example.com",
    },
    license_info={
        "name": "Apache 2.0",
        "url": "https://www.apache.org/licenses/LICENSE-2.0.html",
    },
)

class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"

class UserBase(BaseModel):
    username: str = Field(
        ..., 
        min_length=3, 
        max_length=50,
        description="The username for the user account"
    )
    email: str = Field(
        ...,
        description="User's email address"
    )
    role: UserRole = Field(
        default=UserRole.USER,
        description="User's role in the system"
    )
    
    class Config:
        schema_extra = {
            "example": {
                "username": "johndoe",
                "email": "john@example.com",
                "role": "user"
            }
        }

class UserCreate(UserBase):
    password: str = Field(
        ..., 
        min_length=8,
        description="User's password (will be hashed)"
    )

class User(UserBase):
    id: int = Field(..., description="Unique user identifier")
    is_active: bool = Field(default=True, description="Whether the user account is active")

    class Config:
        schema_extra = {
            "example": {
                "id": 123,
                "username": "johndoe",
                "email": "john@example.com",
                "role": "user",
                "is_active": True
            }
        }

@app.post(
    "/users/", 
    response_model=User,
    status_code=201,
    summary="Create a new user",
    description="Create a new user with the provided details",
    response_description="The created user information"
)
async def create_user(
    user: UserCreate = Field(..., description="User information to create")
):
    """
    Create a new user in the system
    
    - **username**: required, must be between 3 and 50 characters
    - **email**: required, must be a valid email address
    - **password**: required, must be at least 8 characters
    - **role**: optional, defaults to "user"
    
    The API will return the created user with a generated ID.
    """
    # In a real API, you would save the user to a database
    new_user = User(
        id=123,  # Would be generated by the database
        username=user.username,
        email=user.email,
        role=user.role
    )
    return new_user

@app.get(
    "/users/", 
    response_model=List[User],
    summary="Get all users",
    description="Retrieve a list of all users in the system"
)
async def get_users(
    skip: int = Query(0, description="Number of users to skip", ge=0),
    limit: int = Query(100, description="Maximum number of users to return", ge=1, le=100),
    role: Optional[UserRole] = Query(None, description="Filter users by role")
):
    """
    Retrieve a list of users with pagination and optional filtering by role.
    
    - **skip**: Number of users to skip (for pagination)
    - **limit**: Maximum number of users to return
    - **role**: Optional filter by user role
    """
    # Mock data for example
    users = [
        User(id=1, username="user1", email="user1@example.com", role=UserRole.ADMIN),
        User(id=2, username="user2", email="user2@example.com", role=UserRole.USER),
    ]
    
    # Filter by role if provided
    if role:
        users = [user for user in users if user.role == role]
    
    # Apply pagination
    users = users[skip:skip+limit]
    
    return users

@app.get(
    "/users/{user_id}", 
    response_model=User,
    summary="Get user by ID",
    description="Retrieve a specific user by their ID"
)
async def get_user(
    user_id: int = Path(..., description="The ID of the user to retrieve", ge=1)
):
    """
    Retrieve a specific user by their unique user ID.
    
    - **user_id**: Required path parameter, must be a positive integer
    
    Returns the user details or a 404 error if the user doesn't exist.
    """
    # In a real API, you would fetch the user from a database
    # This is mock data for the example
    return User(
        id=user_id,
        username=f"user{user_id}",
        email=f"user{user_id}@example.com",
        role=UserRole.USER
    )</code></pre>

                <p>With this code, FastAPI automatically generates:</p>
                <ul>
                    <li>Interactive API documentation at <code>/docs</code> using Swagger UI</li>
                    <li>Alternative documentation at <code>/redoc</code> using ReDoc</li>
                    <li>OpenAPI schema at <code>/openapi.json</code></li>
                </ul>

                <h3>Adding Documentation to Flask with Flask-RESTPlus</h3>
                <pre><code>from flask import Flask
from flask_restplus import Api, Resource, fields, Namespace

app = Flask(__name__)

# Configure API
api = Api(
    app,
    version='1.0',
    title='My API',
    description='A sample API for documentation demonstration',
    doc='/docs'
)

# Create a namespace
ns = Namespace('users', description='User operations')
api.add_namespace(ns)

# Define models for documentation
user_model = ns.model('User', {
    'id': fields.Integer(readonly=True, description='Unique user identifier'),
    'username': fields.String(required=True, description='The user username'),
    'email': fields.String(required=True, description='The user email'),
})

user_input_model = ns.model('UserInput', {
    'username': fields.String(required=True, description='The user username'),
    'email': fields.String(required=True, description='The user email'),
    'password': fields.String(required=True, description='The user password'),
})

# Mock database
users = []

@ns.route('/')
class UserList(Resource):
    @ns.doc('list_users')
    @ns.marshal_list_with(user_model)
    def get(self):
        '''List all users'''
        return users
    
    @ns.doc('create_user')
    @ns.expect(user_input_model)
    @ns.marshal_with(user_model, code=201)
    def post(self):
        '''Create a new user'''
        new_user = {
            'id': len(users) + 1,
            'username': api.payload['username'],
            'email': api.payload['email']
        }
        users.append(new_user)
        return new_user, 201

@ns.route('/<int:id>')
@ns.response(404, 'User not found')
@ns.param('id', 'The user identifier')
class User(Resource):
    @ns.doc('get_user')
    @ns.marshal_with(user_model)
    def get(self, id):
        '''Fetch a user by ID'''
        for user in users:
            if user['id'] == id:
                return user
        ns.abort(404, f"User {id} not found")

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
            </div>
            
            <div class="documentation-elements">
                <h3>Essential Documentation Elements</h3>
                <ul>
                    <li><strong>API Overview:</strong> High-level description of what the API does and its core concepts.</li>
                    <li><strong>Authentication:</strong> Clear instructions on how to authenticate with the API.</li>
                    <li><strong>Endpoints:</strong> Comprehensive listing of all available endpoints.</li>
                    <li><strong>Request Parameters:</strong> Detailed description of all possible parameters.</li>
                    <li><strong>Request/Response Examples:</strong> Sample requests and responses for each endpoint.</li>
                    <li><strong>Error Codes:</strong> Explanation of possible error responses and their meanings.</li>
                    <li><strong>Rate Limits:</strong> Information about any rate limiting policies.</li>
                    <li><strong>Versioning:</strong> How versioning works and how to specify versions.</li>
                    <li><strong>SDK/Library Support:</strong> Links to official client libraries if available.</li>
                    <li><strong>Tutorials/Guides:</strong> Step-by-step guidance for common use cases.</li>
                </ul>
            </div>
            
            <div class="documentation-best-practices">
                <h3>Documentation Best Practices</h3>
                <ul>
                    <li><strong>Keep It Updated:</strong> Documentation should evolve alongside your API.</li>
                    <li><strong>Code-First or Documentation-First?</strong> Consider whether you want to generate docs from code annotations or write docs that generate code stubs.</li>
                    <li><strong>Use Plain Language:</strong> Write documentation that's easy to understand, even for non-technical users.</li>
                    <li><strong>Include Authentication Examples:</strong> Show how to authenticate with real examples.</li>
                    <li><strong>Provide Realistic Examples:</strong> Use realistic data in examples, not placeholder text.</li>
                    <li><strong>Document Edge Cases:</strong> Explain what happens in unusual situations.</li>
                    <li><strong>Include Error Handling:</strong> Show how to handle errors properly.</li>
                    <li><strong>Organize Logically:</strong> Group related endpoints together in the documentation.</li>
                </ul>
            </div>
            
            <div class="real-world">
                <h3>Examples of Great API Documentation</h3>
                <ul>
                    <li><strong>Stripe:</strong> Known for clear, comprehensive documentation with excellent examples and interactive elements.</li>
                    <li><strong>Twilio:</strong> Provides documentation in multiple programming languages with code snippets you can run directly.</li>
                    <li><strong>GitHub:</strong> Well-organized, comprehensive documentation with clear explanations.</li>
                </ul>
                <p>Study these examples to understand what makes documentation truly useful to developers.</p>
            </div>
        </section>

        <section class="performance">
            <h2>Performance Optimization</h2>
            
            <p>Fast, efficient APIs provide better user experiences and cost less to operate. Performance optimization is like tuning a race car—adjustments at every level can contribute to better overall performance.</p>
            
            <h3>Common Performance Bottlenecks</h3>
            <ul>
                <li><strong>Database Operations:</strong> Inefficient queries, missing indexes, or excessive queries</li>
                <li><strong>Network I/O:</strong> Multiple round trips, large payload sizes</li>
                <li><strong>Serialization/Deserialization:</strong> Converting between data formats</li>
                <li><strong>Authentication/Authorization:</strong> Complex permission checks</li>
                <li><strong>External Service Dependencies:</strong> Slow third-party APIs</li>
                <li><strong>In-Memory Processing:</strong> Inefficient algorithms or data structures</li>
            </ul>
            
            <div class="code-section">
                <h3>Database Optimization</h3>
                <pre><code>from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import joinedload, contains_eager
from datetime import datetime

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Define models
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True)
    posts = db.relationship('Post', backref='author', lazy='dynamic')

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    comments = db.relationship('Comment', backref='post', lazy='dynamic')

class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    post_id = db.Column(db.Integer, db.ForeignKey('post.id'))
    
# Routes - Bad Example (N+1 problem)
@app.route('/api/posts/inefficient')
def get_posts_inefficient():
    posts = Post.query.all()
    result = []
    
    for post in posts:
        post_data = {
            'id': post.id,
            'title': post.title,
            'author': post.author.username,  # This causes an additional query for each post
            'comment_count': post.comments.count()  # This causes an additional query for each post
        }
        result.append(post_data)
    
    return {'posts': result}

# Routes - Optimized Example
@app.route('/api/posts/efficient')
def get_posts_efficient():
    # Using eager loading to avoid N+1 queries
    posts = Post.query.options(
        joinedload(Post.author)
    ).all()
    
    # Prefetch comment counts with a single query
    post_ids = [post.id for post in posts]
    comment_counts = db.session.query(
        Comment.post_id, 
        db.func.count(Comment.id).label('count')
    ).filter(
        Comment.post_id.in_(post_ids)
    ).group_by(
        Comment.post_id
    ).all()
    
    # Convert to dict for O(1) lookup
    count_map = {post_id: count for post_id, count in comment_counts}
    
    result = [
        {
            'id': post.id,
            'title': post.title,
            'author': post.author.username,
            'comment_count': count_map.get(post.id, 0)
        }
        for post in posts
    ]
    
    return {'posts': result}</code></pre>

                <h3>Caching with Flask-Caching</h3>
                <pre><code>from flask import Flask
from flask_restful import Api, Resource
from flask_caching import Cache
import time

app = Flask(__name__)

# Configure cache
cache_config = {
    "DEBUG": True,
    "CACHE_TYPE": "SimpleCache",  # Use Redis or Memcached in production
    "CACHE_DEFAULT_TIMEOUT": 300
}
app.config.from_mapping(cache_config)
cache = Cache(app)

api = Api(app)

# Slow operation (simulated)
def expensive_operation():
    # Simulate a slow database query or external API call
    time.sleep(2)
    return {"data": [i for i in range(100)]}

class DataResource(Resource):
    # Without caching
    def get_without_cache(self):
        # Perform expensive operation on every request
        result = expensive_operation()
        return result

    # With caching
    @cache.cached(timeout=60, key_prefix='all_data')
    def get(self):
        # Result will be cached for 60 seconds
        result = expensive_operation()
        return result

class UserDataResource(Resource):
    @cache.memoize(timeout=60)
    def get_user_data(self, user_id):
        # This will cache separately for each user_id
        time.sleep(1)  # Simulate slow operation
        return {"user_id": user_id, "data": [i for i in range(10)]}
        
    def get(self, user_id):
        return self.get_user_data(user_id)

# Register resources
api.add_resource(DataResource, '/data')
api.add_resource(UserDataResource, '/users/<int:user_id>/data')

# Manual cache invalidation example
@app.route('/clear-cache')
def clear_cache():
    # Clear all caches
    cache.clear()
    return {"message": "Cache cleared"}

@app.route('/clear-user-cache/<int:user_id>')
def clear_user_cache(user_id):
    # Clear cache for a specific user
    cache.delete_memoized(UserDataResource.get_user_data, user_id)
    return {"message": f"Cache cleared for user {user_id}"}</code></pre>

                <h3>Asynchronous Processing with FastAPI</h3>
                <pre><code>from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel
import time
import asyncio
import httpx

app = FastAPI()

class EmailRequest(BaseModel):
    email: str
    subject: str
    body: str

# Simulate sending an email (slow operation)
def send_email(email: str, subject: str, body: str):
    # In a real app, this would connect to an email service
    time.sleep(2)  # Simulate slow external service
    print(f"Email sent to {email} with subject: {subject}")
    return True

# Non-async endpoint (blocks during email sending)
@app.post("/send-email/sync")
def send_email_sync(email_req: EmailRequest):
    send_email(email_req.email, email_req.subject, email_req.body)
    return {"message": "Email sent"}

# Background task endpoint (returns immediately, processes in background)
@app.post("/send-email/background")
def send_email_background(email_req: EmailRequest, background_tasks: BackgroundTasks):
    background_tasks.add_task(send_email, email_req.email, email_req.subject, email_req.body)
    return {"message": "Email will be sent in the background"}

# Async endpoint for external API calls
@app.get("/users/github/{username}")
async def get_github_profile(username: str):
    """
    Make async HTTP requests to external APIs
    """
    async with httpx.AsyncClient() as client:
        # Make multiple API calls concurrently
        response = await client.get(f"https://api.github.com/users/{username}")
        
        if response.status_code == 200:
            data = response.json()
            return {
                "username": data["login"],
                "name": data["name"],
                "followers": data["followers"],
                "public_repos": data["public_repos"]
            }
        else:
            return {"error": "User not found"}

# Parallel API requests
@app.get("/aggregate-data/{username}")
async def aggregate_data(username: str):
    """
    Demonstrate making multiple API calls in parallel
    """
    async with httpx.AsyncClient() as client:
        # Define the requests we want to make concurrently
        tasks = [
            client.get(f"https://api.github.com/users/{username}"),
            client.get(f"https://api.github.com/users/{username}/repos"),
            client.get(f"https://api.github.com/users/{username}/followers")
        ]
        
        # Execute all requests concurrently
        responses = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Process the results
        result = {}
        
        if isinstance(responses[0], httpx.Response) and responses[0].status_code == 200:
            user_data = responses[0].json()
            result["user"] = {
                "name": user_data.get("name"),
                "followers_count": user_data.get("followers"),
                "following_count": user_data.get("following")
            }
            
        if isinstance(responses[1], httpx.Response) and responses[1].status_code == 200:
            repos_data = responses[1].json()
            result["repos_count"] = len(repos_data)
            result["repos"] = [repo["name"] for repo in repos_data[:5]]  # First 5 repos
            
        if isinstance(responses[2], httpx.Response) and responses[2].status_code == 200:
            followers_data = responses[2].json()
            result["followers"] = [follower["login"] for follower in followers_data[:5]]  # First 5 followers
            
        return result</code></pre>
            </div>
            
            <div class="performance-tips">
                <h3>Performance Optimization Techniques</h3>
                <ul>
                    <li><strong>Database Optimization:</strong>
                        <ul>
                            <li>Use appropriate indexes for frequently queried fields</li>
                            <li>Avoid the N+1 query problem with eager loading</li>
                            <li>Use pagination to limit result sets</li>
                            <li>Select only the fields you need (avoid SELECT *)</li>
                        </ul>
                    </li>
                    <li><strong>Caching Strategies:</strong>
                        <ul>
                            <li>Response caching for frequently accessed, rarely changed data</li>
                            <li>Object caching for expensive computations</li>
                            <li>Query caching for database results</li>
                            <li>Cache invalidation strategies to ensure fresh data</li>
                        </ul>
                    </li>
                    <li><strong>Asynchronous Processing:</strong>
                        <ul>
                            <li>Use async/await for I/O-bound operations</li>
                            <li>Implement background tasks for slow operations</li>
                            <li>Consider message queues for heavy processing</li>
                        </ul>
                    </li>
                    <li><strong>Response Optimization:</strong>
                        <ul>
                            <li>Minimize payload sizes with specific field selection</li>
                            <li>Use compression (gzip, brotli) for responses</li>
                            <li>Implement partial responses based on client needs</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <div class="code-section">
                <h3>Implementing Pagination</h3>
                <pre><code>from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import desc

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Define model
class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    price = db.Column(db.Float, nullable=False)
    category = db.Column(db.String(50))
    created_at = db.Column(db.DateTime, server_default=db.func.now())

# Pagination endpoint
@app.route('/api/products')
def get_products():
    # Get pagination parameters from query string
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    
    # Limit per_page to prevent abuse
    per_page = min(per_page, 100)
    
    # Get optional filters
    category = request.args.get('category')
    min_price = request.args.get('min_price', type=float)
    max_price = request.args.get('max_price', type=float)
    sort_by = request.args.get('sort_by', 'id')
    sort_dir = request.args.get('sort_dir', 'asc')
    
    # Build query
    query = Product.query
    
    # Apply filters if provided
    if category:
        query = query.filter(Product.category == category)
    if min_price is not None:
        query = query.filter(Product.price >= min_price)
    if max_price is not None:
        query = query.filter(Product.price <= max_price)
    
    # Apply sorting
    if sort_dir == 'desc':
        query = query.order_by(desc(getattr(Product, sort_by)))
    else:
        query = query.order_by(getattr(Product, sort_by))
    
    # Execute paginated query
    pagination = query.paginate(page=page, per_page=per_page)
    
    # Prepare response
    products = [
        {
            'id': p.id,
            'name': p.name,
            'price': p.price,
            'category': p.category
        }
        for p in pagination.items
    ]
    
    # Include pagination metadata
    response = {
        'products': products,
        'pagination': {
            'page': pagination.page,
            'per_page': pagination.per_page,
            'total_pages': pagination.pages,
            'total_items': pagination.total
        }
    }
    
    # Include HATEOAS links
    links = {}
    
    if pagination.has_prev:
        links['prev'] = f"/api/products?page={pagination.prev_num}&per_page={per_page}"
    
    if pagination.has_next:
        links['next'] = f"/api/products?page={pagination.next_num}&per_page={per_page}"
    
    links['first'] = f"/api/products?page=1&per_page={per_page}"
    links['last'] = f"/api/products?page={pagination.pages}&per_page={per_page}"
    
    response['links'] = links
    
    return jsonify(response)</code></pre>
            </div>
            
            <div class="analogy">
                <h3>The Highway Analogy</h3>
                <p>Think of API performance optimization like improving a highway system:</p>
                <ul>
                    <li><strong>Database Indexes</strong> are like highway signs that help you find the right exit quickly.</li>
                    <li><strong>Caching</strong> is like building local distribution centers so goods don't have to travel the entire highway for every delivery.</li>
                    <li><strong>N+1 Query Problem</strong> is like making 100 separate trips to deliver 100 packages instead of using one truck.</li>
                    <li><strong>Pagination</strong> is like shipping goods in manageable batches rather than one massive convoy.</li>
                    <li><strong>Asynchronous Processing</strong> is like having multiple lanes so slow vehicles don't block the entire highway.</li>
                    <li><strong>Compression</strong> is like using more efficient packaging to fit more goods on each truck.</li>
                </ul>
                <p>Just as highway engineers use traffic data to identify bottlenecks, you should use performance monitoring to guide your optimization efforts.</p>
            </div>
            
            <div class="monitoring">
                <h3>Performance Monitoring and Profiling</h3>
                <p>You can't improve what you don't measure. Implement monitoring to identify bottlenecks:</p>
                <ul>
                    <li><strong>Application Performance Monitoring (APM):</strong> Tools like New Relic, Datadog, or Prometheus/Grafana</li>
                    <li><strong>Database Query Monitoring:</strong> Slow query logs, execution plans</li>
                    <li><strong>Profiling:</strong> Python profilers (cProfile, py-spy) to identify code hotspots</li>
                    <li><strong>Load Testing:</strong> Tools like Locust or JMeter to simulate heavy traffic</li>
                </ul>
                
                <p>Monitor key metrics like:</p>
                <ul>
                    <li>Response time (average, 95th percentile, max)</li>
                    <li>Database query performance</li>
                    <li>Cache hit/miss ratios</li>
                    <li>Error rates</li>
                    <li>Resource utilization (CPU, memory, network, disk)</li>
                </ul>
            </div>
        </section>

        <section class="testing">
            <h2>Testing Strategies for APIs</h2>
            
            <p>Comprehensive testing ensures your API functions correctly, maintains backward compatibility, and performs well under load. Think of testing as quality control for your API—catching issues before they reach production saves time, money, and reputation.</p>
            
            <h3>Types of API Tests</h3>
            
            <table>
                <thead>
                    <tr>
                        <th>Test Type</th>
                        <th>Purpose</th>
                        <th>Tools</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Unit Tests</td>
                        <td>Test individual components in isolation</td>
                        <td>pytest, unittest</td>
                    </tr>
                    <tr>
                        <td>Integration Tests</td>
                        <td>Test interactions between components</td>
                        <td>pytest, requests</td>
                    </tr>
                    <tr>
                        <td>Functional Tests</td>
                        <td>Test complete API workflows</td>
                        <td>requests, pytest-flask, pytest-django</td>
                    </tr>
                    <tr>
                        <td>Contract Tests</td>
                        <td>Ensure API adheres to its contract/specification</td>
                        <td>pact-python, openapi-spec-validator</td>
                    </tr>
                    <tr>
                        <td>Load Tests</td>
                        <td>Test performance under expected load</td>
                        <td>Locust, JMeter</td>
                    </tr>
                    <tr>
                        <td>Stress Tests</td>
                        <td>Test behavior under extreme conditions</td>
                        <td>Locust, JMeter</td>
                    </tr>
                    <tr>
                        <td>Security Tests</td>
                        <td>Identify security vulnerabilities</td>
                        <td>OWASP ZAP, Bandit</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="code-section">
                <h3>Unit Testing with pytest</h3>
                <pre><code>import pytest
from app.services.user_service import UserService
from app.models.user import User
from unittest.mock import Mock, patch

# Test the user service in isolation
class TestUserService:
    def setup_method(self):
        # Setup for each test
        self.user_repo_mock = Mock()
        self.user_service = UserService(self.user_repo_mock)
    
    def test_get_user_by_id_returns_user_when_found(self):
        # Arrange
        user_id = 123
        expected_user = User(id=user_id, username="test_user", email="test@example.com")
        self.user_repo_mock.get_by_id.return_value = expected_user
        
        # Act
        result = self.user_service.get_user_by_id(user_id)
        
        # Assert
        assert result is not None
        assert result.id == user_id
        assert result.username == "test_user"
        self.user_repo_mock.get_by_id.assert_called_once_with(user_id)
    
    def test_get_user_by_id_returns_none_when_not_found(self):
        # Arrange
        user_id = 456
        self.user_repo_mock.get_by_id.return_value = None
        
        # Act
        result = self.user_service.get_user_by_id(user_id)
        
        # Assert
        assert result is None
        self.user_repo_mock.get_by_id.assert_called_once_with(user_id)
    
    def test_create_user_validates_username(self):
        # Arrange
        invalid_username = "u"  # Too short
        
        # Act & Assert
        with pytest.raises(ValueError) as excinfo:
            self.user_service.create_user(invalid_username, "test@example.com", "password123")
        
        assert "Username must be at least 3 characters" in str(excinfo.value)
        # Verify repository was never called
        self.user_repo_mock.save.assert_not_called()
    
    @patch('app.services.user_service.hash_password')
    def test_create_user_hashes_password(self, hash_password_mock):
        # Arrange
        username = "test_user"
        email = "test@example.com"
        password = "password123"
        hashed_password = "hashed_password_value"
        hash_password_mock.return_value = hashed_password
        
        # Act
        self.user_service.create_user(username, email, password)
        
        # Assert
        hash_password_mock.assert_called_once_with(password)
        # Verify user was saved with hashed password
        self.user_repo_mock.save.assert_called_once()
        saved_user = self.user_repo_mock.save.call_args[0][0]
        assert saved_user.username == username
        assert saved_user.email == email
        assert saved_user.password == hashed_password</code></pre>

                <h3>API Integration Testing</h3>
                <pre><code>import pytest
import json
from app import create_app
from app.models import db, User
import os

# Set test configuration
os.environ['FLASK_ENV'] = 'testing'

@pytest.fixture
def client():
    """Create and configure a Flask app for testing"""
    app = create_app()
    app.config['TESTING'] = True
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
    
    # Create the database and tables
    with app.app_context():
        db.create_all()
    
    # Setup test client
    with app.test_client() as client:
        yield client
    
    # Teardown
    with app.app_context():
        db.drop_all()

@pytest.fixture
def auth_token(client):
    """Get an authentication token for testing protected endpoints"""
    # Create a test user
    with client.application.app_context():
        user = User(username='testuser', email='test@example.com')
        user.set_password('password123')
        db.session.add(user)
        db.session.commit()
    
    # Login to get token
    response = client.post(
        '/api/login',
        json={'username': 'testuser', 'password': 'password123'}
    )
    
    data = json.loads(response.data)
    return data['token']

def test_get_users_without_token(client):
    """Test that users endpoint requires authentication"""
    response = client.get('/api/users')
    assert response.status_code == 401

def test_get_users_with_token(client, auth_token):
    """Test getting users with valid token"""
    response = client.get(
        '/api/users',
        headers={'Authorization': f'Bearer {auth_token}'}
    )
    
    assert response.status_code == 200
    data = json.loads(response.data)
    assert 'users' in data
    assert isinstance(data['users'], list)

def test_create_user(client):
    """Test user creation endpoint"""
    response = client.post(
        '/api/users',
        json={
            'username': 'newuser',
            'email': 'newuser@example.com',
            'password': 'securepass123'
        }
    )
    
    assert response.status_code == 201
    data = json.loads(response.data)
    assert data['username'] == 'newuser'
    assert data['email'] == 'newuser@example.com'
    assert 'id' in data
    
    # Verify user exists in database
    with client.application.app_context():
        user = User.query.filter_by(username='newuser').first()
        assert user is not None
        assert user.email == 'newuser@example.com'

def test_get_user_by_id(client, auth_token):
    """Test getting a specific user by ID"""
    # Create a user to retrieve
    with client.application.app_context():
        user = User(username='retrieveuser', email='retrieve@example.com')
        user.set_password('password123')
        db.session.add(user)
        db.session.commit()
        user_id = user.id
    
    response = client.get(
        f'/api/users/{user_id}',
        headers={'Authorization': f'Bearer {auth_token}'}
    )
    
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['id'] == user_id
    assert data['username'] == 'retrieveuser'
    assert data['email'] == 'retrieve@example.com'

def test_update_user(client, auth_token):
    """Test updating a user"""
    # Create a user to update
    with client.application.app_context():
        user = User(username='updateuser', email='update@example.com')
        user.set_password('password123')
        db.session.add(user)
        db.session.commit()
        user_id = user.id
    
    response = client.put(
        f'/api/users/{user_id}',
        headers={'Authorization': f'Bearer {auth_token}'},
        json={
            'username': 'updateduser',
            'email': 'updated@example.com'
        }
    )
    
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['username'] == 'updateduser'
    assert data['email'] == 'updated@example.com'
    
    # Verify user was updated in database
    with client.application.app_context():
        updated_user = User.query.get(user_id)
        assert updated_user.username == 'updateduser'
        assert updated_user.email == 'updated@example.com'</code></pre>

                <h3>Load Testing with Locust</h3>
                <pre><code>from locust import HttpUser, task, between

class ApiUser(HttpUser):
    # Wait between 1 and 5 seconds between tasks
    wait_time = between(1, 5)
    
    def on_start(self):
        """Log in and get token when a simulated user starts"""
        response = self.client.post(
            "/api/login",
            json={"username": "testuser", "password": "password123"}
        )
        data = response.json()
        self.token = data["token"]
        self.headers = {"Authorization": f"Bearer {self.token}"}
    
    @task(3)  # Higher weight makes this task more common
    def get_users(self):
        """Simulate getting users list (common operation)"""
        self.client.get("/api/users", headers=self.headers)
    
    @task(1)
    def get_specific_user(self):
        """Simulate getting a specific user (less common)"""
        # Get a random user ID between 1 and 100
        user_id = self.random.randint(1, 100)
        self.client.get(f"/api/users/{user_id}", headers=self.headers)
    
    @task(1)
    def create_user(self):
        """Simulate creating a new user (less common)"""
        # Generate random username to avoid conflicts
        username = f"user_{self.random.randint(1000, 9999)}"
        self.client.post(
            "/api/users",
            json={
                "username": username,
                "email": f"{username}@example.com",
                "password": "password123"
            },
            headers=self.headers
        )

# Run with: locust -f locustfile.py</code></pre>
            </div>
            
            <div class="testing-best-practices">
                <h3>API Testing Best Practices</h3>
                <ul>
                    <li><strong>Test Pyramid:</strong> Follow the test pyramid principle—many unit tests, fewer integration tests, even fewer end-to-end tests.</li>
                    <li><strong>Isolation:</strong> Ensure tests are isolated and don't depend on each other's state.</li>
                    <li><strong>Fixtures:</strong> Use fixtures to set up and tear down test environments.</li>
                    <li><strong>Database Management:</strong> Use in-memory databases or transactions for test isolation.</li>
                    <li><strong>Mock External Dependencies:</strong> Use mocks for external services to ensure reliable tests.</li>
                    <li><strong>Continuous Integration:</strong> Run tests automatically with each commit.</li>
                    <li><strong>Coverage:</strong> Monitor test coverage to identify untested code.</li>
                    <li><strong>Regression Testing:</strong> When fixing bugs, add tests to prevent regressions.</li>
                    <li><strong>Security Testing:</strong> Include tests for common security vulnerabilities.</li>
                </ul>
            </div>
            
            <div class="analogy">
                <h3>The Quality Control Analogy</h3>
                <p>Think of API testing like quality control in a manufacturing plant:</p>
                <ul>
                    <li><strong>Unit Tests</strong> are like inspecting individual components before assembly.</li>
                    <li><strong>Integration Tests</strong> are like checking that assembled subunits work together correctly.</li>
                    <li><strong>Functional Tests</strong> are like testing the complete product against specifications.</li>
                    <li><strong>Load Tests</strong> are like stress testing the product under typical usage conditions.</li>
                    <li><strong>Stress Tests</strong> are like testing the product to the breaking point to determine its limits.</li>
                    <li><strong>Security Tests</strong> are like checking for vulnerabilities that could compromise the product.</li>
                </ul>
                <p>Just as a manufacturer would never ship products without quality control, you should never deploy an API without comprehensive testing.</p>
            </div>
        </section>

        <section class="deployment">
            <h2>Deployment and Operation Best Practices</h2>
            
            <p>Getting your API from development to production involves more than just copying files. Proper deployment and operational practices ensure your API is reliable, scalable, and maintainable in production.</p>
            
            <h3>Deployment Strategies</h3>
            
            <table>
                <thead>
                    <tr>
                        <th>Strategy</th>
                        <th>Description</th>
                        <th>Best For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Blue-Green Deployment</td>
                        <td>Maintain two identical environments, switch traffic when new version is ready</td>
                        <td>Minimizing downtime, quick rollbacks</td>
                    </tr>
                    <tr>
                        <td>Canary Releases</td>
                        <td>Gradually roll out to a small percentage of users before full deployment</td>
                        <td>Cautious testing in production, gradual rollouts</td>
                    </tr>
                    <tr>
                        <td>Rolling Updates</td>
                        <td>Update instances one by one in a continuous fashion</td>
                        <td>Continuous deployment with minimal impact</td>
                    </tr>
                    <tr>
                        <td>Feature Flags</td>
                        <td>Deploy code but control feature activation with configuration</td>
                        <td>Separating deployment from release, A/B testing</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="deployment-considerations">
                <h3>Essential Deployment Considerations</h3>
                <ul>
                    <li><strong>Environment Configuration:</strong> Use environment variables or secrets management to separate configuration from code.</li>
                    <li><strong>Database Migrations:</strong> Plan and test database schema changes carefully.</li>
                    <li><strong>Dependencies:</strong> Lock dependency versions for reproducible builds.</li>
                    <li><strong>Static Resources:</strong> Consider using CDNs for static assets.</li>
                    <li><strong>Caching Strategy:</strong> Configure appropriate cache headers and invalidation.</li>
                    <li><strong>Logging and Monitoring:</strong> Ensure proper setup for observability.</li>
                    <li><strong>Security:</strong> Protect sensitive endpoints and data.</li>
                    <li><strong>Backup and Recovery:</strong> Implement regular data backups and test restoration.</li>
                </ul>
            </div>
            
            <div class="code-section">
                <h3>Containerization with Docker</h3>
                <pre><code># Dockerfile for a Python API
FROM python:3.10-slim

# Set working directory
WORKDIR /app

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    FLASK_APP=app.py \
    FLASK_ENV=production

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . .

# Run database migrations
RUN flask db upgrade

# Expose port
EXPOSE 5000

# Start gunicorn
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "4", "app:app"]</code></pre>

                <h3>Docker Compose for Local Development</h3>
                <pre><code># docker-compose.yml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "5000:5000"
    environment:
      - FLASK_APP=app.py
      - FLASK_ENV=development
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/myapp
      - SECRET_KEY=dev_secret_key
    volumes:
      - .:/app
    depends_on:
      - db
    command: flask run --host=0.0.0.0

  db:
    image: postgres:13
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=myapp
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
      
  redis:
    image: redis:6
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:</code></pre>

                <h3>CI/CD Pipeline with GitHub Actions</h3>
                <pre><code># .github/workflows/ci.yml
name: API CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 pytest
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    
    - name: Lint with flake8
      run: |
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: Test with pytest
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        FLASK_ENV: testing
        SECRET_KEY: test_secret
      run: |
        pytest --cov=app tests/
    
    - name: Upload coverage report
      uses: codecov/codecov-action@v1
  
  deploy:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Login to DockerHub
      uses: docker/login-action@v1
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v2
      with:
        context: .
        push: true
        tags: myapp/api:latest,myapp/api:${{ github.sha }}
    
    - name: Deploy to production
      # Replace with your deployment steps (e.g., Kubernetes, AWS ECS, etc.)
      run: |
        echo "Deploying to production..."
        # kubectl set image deployment/api api=myapp/api:${{ github.sha }}</code></pre>
            </div>
            
            <div class="observability">
                <h3>Observability and Monitoring</h3>
                <p>Proper observability helps you understand what's happening in your system and quickly identify issues.</p>
                
                <h4>Key Components of Observability</h4>
                <ul>
                    <li><strong>Logging:</strong> Record events and errors for debugging and auditing.</li>
                    <li><strong>Metrics:</strong> Measure system performance and behavior over time.</li>
                    <li><strong>Tracing:</strong> Track requests as they flow through distributed systems.</li>
                    <li><strong>Alerting:</strong> Notify operators when something requires attention.</li>
                </ul>
                
                <h4>Logging Best Practices</h4>
                <ul>
                    <li>Use structured logging (JSON) for machine-parseable logs.</li>
                    <li>Include context (request ID, user ID) in logs for correlation.</li>
                    <li>Log at appropriate levels (DEBUG, INFO, WARNING, ERROR, CRITICAL).</li>
                    <li>Implement log rotation to manage disk space.</li>
                    <li>Use a centralized logging system (ELK, Graylog) for aggregation and search.</li>
                </ul>
                
                <h4>Essential Metrics to Monitor</h4>
                <ul>
                    <li>Request rate, response time, and error rate for each endpoint.</li>
                    <li>Database query performance and connection pool usage.</li>
                    <li>Cache hit/miss ratio.</li>
                    <li>Resource utilization (CPU, memory, disk, network).</li>
                    <li>Queue depths and processing times for background jobs.</li>
                    <li>Third-party API call performance.</li>
                </ul>
            </div>
            
            <div class="scaling">
                <h3>Scaling Strategies</h3>
                <p>As your API grows in usage, you'll need strategies to scale efficiently:</p>
                
                <h4>Horizontal Scaling (Scale Out)</h4>
                <ul>
                    <li>Add more instances of your API service.</li>
                    <li>Use load balancers to distribute traffic.</li>
                    <li>Ensure services are stateless to allow easy scaling.</li>
                    <li>Implement session stickiness or distributed session storage if needed.</li>
                </ul>
                
                <h4>Vertical Scaling (Scale Up)</h4>
                <ul>
                    <li>Increase resources (CPU, memory) for existing instances.</li>
                    <li>Optimize database performance through tuning.</li>
                    <li>Upgrade database to more powerful hardware.</li>
                </ul>
                
                <h4>Database Scaling</h4>
                <ul>
                    <li>Read replicas for read-heavy workloads.</li>
                    <li>Sharding for distributing data across multiple servers.</li>
                    <li>Connection pooling to manage database connections efficiently.</li>
                </ul>
                
                <h4>Caching Layers</h4>
                <ul>
                    <li>In-memory caching (Redis, Memcached) for frequent data.</li>
                    <li>CDN for static assets.</li>
                    <li>Response caching for frequently requested data.</li>
                </ul>
            </div>
            
            <div class="analogy">
                <h3>The Restaurant Chain Analogy</h3>
                <p>Think of operating a production API like running a successful restaurant chain:</p>
                <ul>
                    <li><strong>Deployment Pipeline</strong> is like the process of opening new locations with consistent quality.</li>
                    <li><strong>Monitoring</strong> is like having managers who watch for problems and ensure smooth operation.</li>
                    <li><strong>Scaling</strong> is like adding more tables (vertical scaling) or opening new locations (horizontal scaling) as demand grows.</li>
                    <li><strong>Load Balancing</strong> is like having hosts direct customers to available tables across different sections.</li>
                    <li><strong>Canary Releases</strong> are like testing a new menu item in one location before rolling it out to all restaurants.</li>
                    <li><strong>Feature Flags</strong> are like having menu items that can be quickly added or removed based on availability or popularity.</li>
                </ul>
                <p>Just as successful restaurants require both excellent food and efficient operations, successful APIs need both good code and robust operational practices.</p>
            </div>
        </section>

        <section class="serverless">
            <h2>Serverless API Development</h2>
            
            <p>Serverless architecture offers a different approach to building and deploying APIs, focusing on individual functions rather than maintaining servers. It's like having a personal assistant who only charges you when actively performing tasks, rather than paying for their time regardless of workload.</p>
            
            <h3>Serverless Benefits and Challenges</h3>
            
            <table>
                <thead>
                    <tr>
                        <th>Benefits</th>
                        <th>Challenges</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>No server management</td>
                        <td>Cold start latency</td>
                    </tr>
                    <tr>
                        <td>Pay-per-use pricing</td>
                        <td>Vendor lock-in concerns</td>
                    </tr>
                    <tr>
                        <td>Automatic scaling</td>
                        <td>Limited execution time</td>
                    </tr>
                    <tr>
                        <td>Built-in high availability</td>
                        <td>More complex debugging</td>
                    </tr>
                    <tr>
                        <td>Reduced operational overhead</td>
                        <td>Statelessness challenges</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="code-section">
                <h3>AWS Lambda with API Gateway (Serverless Framework)</h3>
                <pre><code># serverless.yml
service: my-python-api

provider:
  name: aws
  runtime: python3.9
  stage: ${opt:stage, 'dev'}
  region: ${opt:region, 'us-east-1'}
  environment:
    DYNAMODB_TABLE: ${self:service}-${self:provider.stage}
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
      Resource: "arn:aws:dynamodb:${self:provider.region}:*:table/${self:provider.environment.DYNAMODB_TABLE}"

functions:
  create:
    handler: handler.create
    events:
      - http:
          path: users
          method: post
          cors: true

  list:
    handler: handler.list
    events:
      - http:
          path: users
          method: get
          cors: true

  get:
    handler: handler.get
    events:
      - http:
          path: users/{id}
          method: get
          cors: true
          request:
            parameters:
              paths:
                id: true

  update:
    handler: handler.update
    events:
      - http:
          path: users/{id}
          method: put
          cors: true
          request:
            parameters:
              paths:
                id: true

  delete:
    handler: handler.delete
    events:
      - http:
          path: users/{id}
          method: delete
          cors: true
          request:
            parameters:
              paths:
                id: true

resources:
  Resources:
    UsersDynamoDbTable:
      Type: 'AWS::DynamoDB::Table'
      DeletionPolicy: Retain
      Properties:
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 1
          WriteCapacityUnits: 1
        TableName: ${self:provider.environment.DYNAMODB_TABLE}</code></pre>

                <h3>Lambda Handler Implementation</h3>
                <pre><code># handler.py
import json
import logging
import os
import time
import uuid
from datetime import datetime

import boto3
from botocore.exceptions import ClientError

logger = logging.getLogger()
logger.setLevel(logging.INFO)

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table(os.environ['DYNAMODB_TABLE'])

def create(event, context):
    """Create a new user"""
    data = json.loads(event['body'])
    
    # Validate input
    if 'username' not in data or 'email' not in data:
        return {
            'statusCode': 400,
            'headers': {'Content-Type': 'application/json'},
            'body': json.dumps({'error': 'Please provide both username and email'})
        }
    
    timestamp = str(datetime.utcnow().timestamp())
    
    # Create user item
    item = {
        'id': str(uuid.uuid4()),
        'username': data['username'],
        'email': data['email'],
        'createdAt': timestamp,
        'updatedAt': timestamp,
    }
    
    # Write to DynamoDB
    try:
        table.put_item(Item=item)
    except ClientError as e:
        logger.error(e.response['Error']['Message'])
        return {
            'statusCode': 500,
            'headers': {'Content-Type': 'application/json'},
            'body': json.dumps({'error': 'Could not create user'})
        }
    
    # Create response
    response = {
        'statusCode': 201,
        'headers': {'Content-Type': 'application/json'},
        'body': json.dumps(item)
    }
    
    return response

def list(event, context):
    """List all users"""
    try:
        # Scan DynamoDB table
        result = table.scan()
    except ClientError as e:
        logger.error(e.response['Error']['Message'])
        return {
            'statusCode': 500,
            'headers': {'Content-Type': 'application/json'},
            'body': json.dumps({'error': 'Could not fetch users'})
        }
    
    # Create response
    response = {
        'statusCode': 200,
        'headers': {'Content-Type': 'application/json'},
        'body': json.dumps(result['Items'])
    }
    
    return response

def get(event, context):
    """Get a specific user by id"""
    try:
        # Get user from DynamoDB
        result = table.get_item(
            Key={
                'id': event['pathParameters']['id']
            }
        )
    except ClientError as e:
        logger.error(e.response['Error']['Message'])
        return {
            'statusCode': 500,
            'headers': {'Content-Type': 'application/json'},
            'body': json.dumps({'error': 'Could not fetch user'})
        }
    
    # Check if user exists
    if 'Item' not in result:
        return {
            'statusCode': 404,
            'headers': {'Content-Type': 'application/json'},
            'body': json.dumps({'error': 'User not found'})
        }
    
    # Create response
    response = {
        'statusCode': 200,
        'headers': {'Content-Type': 'application/json'},
        'body': json.dumps(result['Item'])
    }
    
    return response</code></pre>

                <h3>Serverless with FastAPI and Mangum</h3>
                <pre><code># app.py
from fastapi import FastAPI, HTTPException
from mangum import Mangum
from pydantic import BaseModel
from typing import List, Optional
import boto3
import os
import uuid
from datetime import datetime

app = FastAPI(
    title="Serverless FastAPI",
    description="A serverless API using FastAPI and AWS Lambda",
    version="0.1.0"
)

# Initialize DynamoDB client
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table(os.environ.get('DYNAMODB_TABLE', 'Users'))

# Models
class UserCreate(BaseModel):
    username: str
    email: str

class User(BaseModel):
    id: str
    username: str
    email: str
    created_at: str
    updated_at: str

@app.post("/users", response_model=User, status_code=201)
async def create_user(user: UserCreate):
    """Create a new user"""
    timestamp = str(datetime.utcnow().timestamp())
    
    # Create user item
    item = {
        'id': str(uuid.uuid4()),
        'username': user.username,
        'email': user.email,
        'created_at': timestamp,
        'updated_at': timestamp,
    }
    
    # Write to DynamoDB
    try:
        table.put_item(Item=item)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    
    return item

@app.get("/users", response_model=List[User])
async def list_users():
    """List all users"""
    try:
        # Scan DynamoDB table
        result = table.scan()
        return result['Items']
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/users/{user_id}", response_model=User)
async def get_user(user_id: str):
    """Get a specific user by id"""
    try:
        # Get user from DynamoDB
        result = table.get_item(Key={'id': user_id})
        
        if 'Item' not in result:
            raise HTTPException(status_code=404, detail="User not found")
            
        return result['Item']
    except Exception as e:
        if hasattr(e, 'status_code') and e.status_code == 404:
            raise e
        raise HTTPException(status_code=500, detail=str(e))

# Create handler for AWS Lambda
handler = Mangum(app)</code></pre>
            </div>
            
            <div class="serverless-best-practices">
                <h3>Serverless Best Practices</h3>
                <ul>
                    <li><strong>Function Size:</strong> Keep functions small and focused on a single responsibility.</li>
                    <li><strong>Cold Start Optimization:</strong> Minimize dependencies and function size to reduce cold start latency.</li>
                    <li><strong>Statelessness:</strong> Design functions to be stateless, as they may be recreated for each invocation.</li>
                    <li><strong>Timeout Handling:</strong> Be aware of timeout limits and design functions accordingly.</li>
                    <li><strong>Error Handling:</strong> Implement robust error handling and retry mechanisms.</li>
                    <li><strong>Authentication:</strong> Use managed auth services (e.g., AWS Cognito, Auth0) rather than implementing your own.</li>
                    <li><strong>Testing:</strong> Use frameworks like serverless-offline to test locally before deployment.</li>
                    <li><strong>Monitoring:</strong> Set up appropriate logging and monitoring to track function performance.</li>
                </ul>
            </div>
            
            <div class="serverless-use-cases">
                <h3>When to Use Serverless</h3>
                <p><strong>Good Use Cases:</strong></p>
                <ul>
                    <li>APIs with variable or unpredictable traffic</li>
                    <li>Microservices architecture</li>
                    <li>Event-driven processing</li>
                    <li>Startups or projects with limited DevOps resources</li>
                    <li>APIs that need rapid scaling</li>
                </ul>
                
                <p><strong>Less Ideal Use Cases:</strong></p>
                <ul>
                    <li>Long-running processes (beyond function timeout limits)</li>
                    <li>Applications requiring very low latency</li>
                    <li>Stateful applications</li>
                    <li>Applications with predictable, constant high traffic</li>
                    <li>Legacy applications that are difficult to refactor</li>
                </ul>
            </div>
            
            <div class="analogy">
                <h3>The Taxi vs. Car Ownership Analogy</h3>
                <p>Think of serverless computing compared to traditional server management like taking taxis versus owning a car:</p>
                <ul>
                    <li><strong>Serverless (Taxi):</strong>
                        <ul>
                            <li>Pay only when you use it</li>
                            <li>No maintenance responsibilities</li>
                            <li>Scales automatically (just hail more taxis as needed)</li>
                            <li>May cost more for constant, heavy usage</li>
                            <li>Less control over the exact vehicle</li>
                        </ul>
                    </li>
                    <li><strong>Traditional Servers (Car Ownership):</strong>
                        <ul>
                            <li>Pay fixed costs regardless of usage</li>
                            <li>Responsible for maintenance and updates</li>
                            <li>Limited capacity without buying more cars</li>
                            <li>More economical for constant, predictable usage</li>
                            <li>Complete control over the vehicle</li>
                        </ul>
                    </li>
                </ul>
                <p>Just as you might choose taxis for occasional travel but buy a car for daily commuting, you might choose serverless for variable workloads but dedicated servers for constant, predictable ones.</p>
            </div>
        </section>

        <section class="conclusion">
            <h2>Conclusion and Next Steps</h2>
            
            <p>As we've explored throughout this tutorial, creating robust APIs involves much more than just writing code. From thoughtful design to secure authentication, from comprehensive testing to efficient deployment, each aspect plays a crucial role in building APIs that developers love to use and that stand the test of time in production environments.</p>
            
            <h3>Key Takeaways</h3>
            <ul>
                <li><strong>Design First:</strong> Spend time designing your API before diving into implementation. A well-designed API is intuitive, consistent, and future-proof.</li>
                <li><strong>Choose the Right Tools:</strong> Select frameworks and tools that match your project requirements and team expertise.</li>
                <li><strong>Secure by Default:</strong> Implement robust authentication, input validation, and error handling from day one.</li>
                <li><strong>Test Thoroughly:</strong> Comprehensive testing ensures your API functions correctly and performs well under load.</li>
                <li><strong>Document Clearly:</strong> Great documentation makes your API accessible and easy to use.</li>
                <li><strong>Monitor Continuously:</strong> Observability is key to maintaining and improving your API in production.</li>
                <li><strong>Evolve Carefully:</strong> Use versioning to add features while maintaining backward compatibility.</li>
            </ul>
            
            <h3>Further Learning Resources</h3>
            <ul>
                <li><strong>Books:</strong>
                    <ul>
                        <li>"RESTful Web APIs" by Leonard Richardson and Mike Amundsen</li>
                        <li>"API Design Patterns" by JJ Geewax</li>
                        <li>"Building Microservices" by Sam Newman</li>
                        <li>"Designing Web APIs" by Brenda Jin, Saurabh Sahni, and Amir Shevat</li>
                    </ul>
                </li>
                <li><strong>Online Resources:</strong>
                    <ul>
                        <li>The Django REST Framework documentation</li>
                        <li>FastAPI documentation</li>
                        <li>Flask-RESTful documentation</li>
                        <li>AWS API Gateway documentation</li>
                        <li>OpenAPI Specification</li>
                    </ul>
                </li>
                <li><strong>Courses:</strong>
                    <ul>
                        <li>Advanced REST API Design with Python</li>
                        <li>API Security Best Practices</li>
                        <li>Microservices Architecture</li>
                        <li>Serverless Application Development</li>
                    </ul>
                </li>
            </ul>
            
            <h3>Final Thoughts</h3>
            <p>Building APIs is both an art and a science. The technical aspects matter, but so does the empathy for the developers who will use your API. Always ask yourself: "Would I enjoy using this API?" If the answer is yes, you're on the right track.</p>
            
            <p>Remember that the best APIs evolve over time based on real-world usage and feedback. Stay open to improvements, monitor how your API is being used, and continuously refine your approach.</p>
            
            <p>Now it's time to apply these principles to your own API projects. Happy coding!</p>
        </section>
    </main>

    <footer>
        <p>Python Full Stack Web Course - API Best Practices</p>
    </footer>
</body>
</html>
