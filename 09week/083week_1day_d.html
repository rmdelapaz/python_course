<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication in APIs: A Comprehensive Guide</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
</head>
<body>
    <header>
        <h1>Authentication in APIs: A Comprehensive Guide</h1>
        <p class="subtitle">Python Full Stack Web Course</p>
    </header>

    <main>
        <section class="introduction">
            <h2>Introduction to API Authentication</h2>
            
            <p>Welcome to our comprehensive guide on API authentication for Python Full Stack development! APIs serve as the critical connective tissue of modern applications, enabling different systems to communicate and share data. However, with this power comes the responsibility to ensure that only authorized users and systems can access your API endpoints.</p>
            
            <p>Think of API authentication as the security checkpoint at an airport. Just as travelers must present valid identification before boarding a flight, clients must prove their identity before accessing protected API resources. Without these security measures, sensitive data and functionalities would be exposed to potential misuse.</p>
            
            <p>Throughout this tutorial, we'll explore the various authentication methods available for securing your Python APIs, including implementation details, security considerations, and best practices. By the end, you'll have a thorough understanding of how to implement robust authentication for your API projects.</p>
            
            <div class="key-concepts">
                <h3>Key Authentication Concepts</h3>
                <ul>
                    <li><strong>Authentication vs. Authorization:</strong> Authentication verifies identity ("Who are you?"), while authorization determines permissions ("What are you allowed to do?").</li>
                    <li><strong>Credentials:</strong> Information used to verify identity (passwords, tokens, certificates, etc.).</li>
                    <li><strong>Tokens:</strong> Pieces of data that represent authentication status, often replacing the need to repeatedly send credentials.</li>
                    <li><strong>Sessions:</strong> Server-side records of authentication state.</li>
                    <li><strong>Stateless vs. Stateful:</strong> Whether authentication state is stored server-side (stateful) or contained within tokens sent with each request (stateless).</li>
                </ul>
            </div>
        </section>

        <section class="authentication_overview">
            <h2>Authentication Methods Overview</h2>
            
            <p>Selecting the right authentication method depends on your specific requirements, including security needs, client types, and architecture. Think of these methods as different locks on doors—each with varying levels of security, complexity, and ease of use.</p>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Security Level</th>
                        <th>Complexity</th>
                        <th>Best For</th>
                        <th>Limitations</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>API Keys</td>
                        <td>Basic</td>
                        <td>Low</td>
                        <td>Internal APIs, Simple integrations</td>
                        <td>Limited granularity, no user context</td>
                    </tr>
                    <tr>
                        <td>Basic Authentication</td>
                        <td>Basic</td>
                        <td>Low</td>
                        <td>Development, Simple scenarios</td>
                        <td>Credentials sent with every request</td>
                    </tr>
                    <tr>
                        <td>Session-based</td>
                        <td>Good</td>
                        <td>Medium</td>
                        <td>Web applications with server-side rendering</td>
                        <td>Not ideal for stateless APIs</td>
                    </tr>
                    <tr>
                        <td>JWT (JSON Web Tokens)</td>
                        <td>Good</td>
                        <td>Medium</td>
                        <td>Stateless APIs, Microservices</td>
                        <td>Token revocation challenges</td>
                    </tr>
                    <tr>
                        <td>OAuth 2.0</td>
                        <td>High</td>
                        <td>High</td>
                        <td>Third-party integrations, Complex ecosystems</td>
                        <td>Implementation complexity</td>
                    </tr>
                    <tr>
                        <td>OpenID Connect</td>
                        <td>High</td>
                        <td>High</td>
                        <td>User authentication, Single sign-on</td>
                        <td>Overhead for simple use cases</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="analogy">
                <h3>The Key Analogy</h3>
                <p>Think of the different authentication methods like different types of keys:</p>
                <ul>
                    <li><strong>API Keys</strong> are like a simple door key—easy to use but can be copied and used by anyone who obtains it.</li>
                    <li><strong>Basic Authentication</strong> is like providing your name and ID each time you enter a building—simple but requires sharing your identity repeatedly.</li>
                    <li><strong>Session Authentication</strong> is like receiving a visitor badge after checking in—you only identify yourself once, then show the badge for subsequent access.</li>
                    <li><strong>JWT</strong> is like a smart card containing your credentials and permissions—self-contained, but harder to invalidate if stolen.</li>
                    <li><strong>OAuth 2.0</strong> is like a sophisticated key card system with different access levels—complex but highly secure and flexible.</li>
                </ul>
            </div>
        </section>

        <section class="api_keys">
            <h2>API Keys</h2>
            
            <p>API keys are simple string identifiers that clients include with their requests to authenticate themselves. They're like membership cards—simple to implement and use, but they offer limited security features.</p>
            
            <h3>How API Keys Work</h3>
            <ol>
                <li>The server generates a unique API key for each client</li>
                <li>Clients include this key with each request (typically in a header, query parameter, or request body)</li>
                <li>The server validates the key against stored valid keys</li>
                <li>If valid, the server processes the request; otherwise, it returns an authentication error</li>
            </ol>
            
            <div class="code-section">
                <h3>Implementing API Key Authentication in Flask</h3>
                <pre><code>from flask import Flask, request, jsonify
from functools import wraps

app = Flask(__name__)

# In a real application, store these in a database with proper hashing
API_KEYS = {
    "client1_key_12345": {"client_name": "Client 1", "role": "basic"},
    "admin_key_67890": {"client_name": "Admin Client", "role": "admin"}
}

def require_api_key(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        
        if not api_key:
            api_key = request.args.get('api_key')
            
        if not api_key or api_key not in API_KEYS:
            return jsonify({"error": "Invalid or missing API key"}), 401
            
        # Add client info to request context
        request.client = API_KEYS[api_key]
        
        return f(*args, **kwargs)
    return decorated

@app.route('/api/public')
def public_endpoint():
    return jsonify({"message": "This is a public endpoint"})

@app.route('/api/protected')
@require_api_key
def protected_endpoint():
    return jsonify({
        "message": "This is a protected endpoint",
        "client": request.client["client_name"]
    })

@app.route('/api/admin')
@require_api_key
def admin_endpoint():
    if request.client["role"] != "admin":
        return jsonify({"error": "Admin access required"}), 403
        
    return jsonify({
        "message": "This is an admin endpoint",
        "client": request.client["client_name"]
    })

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h3>Using API Keys with Django REST Framework</h3>
                <pre><code># settings.py
INSTALLED_APPS = [
    # ... other apps
    'rest_framework',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
    ],
}

# models.py
from django.db import models
import uuid

class APIClient(models.Model):
    name = models.CharField(max_length=100)
    api_key = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.name

# authentication.py
from rest_framework import authentication, exceptions
from .models import APIClient

class APIKeyAuthentication(authentication.BaseAuthentication):
    def authenticate(self, request):
        api_key = request.META.get('HTTP_X_API_KEY') or request.query_params.get('api_key')
        
        if not api_key:
            return None
            
        try:
            client = APIClient.objects.get(api_key=api_key, is_active=True)
        except (APIClient.DoesNotExist, ValueError):
            raise exceptions.AuthenticationFailed('Invalid API Key')
            
        return (None, client)  # No user, just the client

# views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from .authentication import APIKeyAuthentication

class ProtectedView(APIView):
    authentication_classes = [APIKeyAuthentication]
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        return Response({
            "message": "This is a protected endpoint",
            "client": request.auth.name
        })</code></pre>
            </div>
            
            <div class="best-practices">
                <h3>API Key Best Practices</h3>
                <ul>
                    <li><strong>Key Generation:</strong> Use cryptographically secure random generators to create API keys.</li>
                    <li><strong>Key Length:</strong> Use sufficiently long keys (at least 32 characters) to prevent brute-force attacks.</li>
                    <li><strong>Transport Security:</strong> Always use HTTPS to prevent key interception.</li>
                    <li><strong>Header vs. Query Parameter:</strong> Prefer using HTTP headers (e.g., <code>X-API-Key</code>) over query parameters to avoid keys appearing in logs.</li>
                    <li><strong>Key Rotation:</strong> Implement processes for regular key rotation and revocation.</li>
                    <li><strong>Rate Limiting:</strong> Apply rate limiting based on API keys to prevent abuse.</li>
                    <li><strong>Monitoring:</strong> Log and monitor API key usage for suspicious activity.</li>
                </ul>
            </div>
            
            <div class="limitations">
                <h3>Limitations of API Keys</h3>
                <ul>
                    <li>No built-in expiration mechanism</li>
                    <li>Limited to client/application authentication (not individual users)</li>
                    <li>If compromised, attackers have access until the key is manually revoked</li>
                    <li>No granular permission control without additional implementation</li>
                    <li>Key management becomes complex with many clients</li>
                </ul>
            </div>
        </section>

        <section class="basic_auth">
            <h2>Basic Authentication</h2>
            
            <p>HTTP Basic Authentication is one of the simplest authentication methods, where clients send their username and password with each request. It's like presenting your ID card every time you enter a building—simple but repetitive and potentially risky.</p>
            
            <h3>How Basic Authentication Works</h3>
            <ol>
                <li>The client combines the username and password with a colon (username:password)</li>
                <li>The resulting string is encoded using Base64</li>
                <li>The encoded string is included in the HTTP Authorization header (Authorization: Basic [encoded-string])</li>
                <li>The server decodes the string, extracts the credentials, and validates them</li>
            </ol>
            
            <div class="code-section">
                <h3>Implementing Basic Authentication in Flask</h3>
                <pre><code>from flask import Flask, request, jsonify
from functools import wraps
import base64

app = Flask(__name__)

# In a real app, store passwords securely with proper hashing
USERS = {
    "user1": {"password": "password1", "role": "basic"},
    "admin": {"password": "adminpass", "role": "admin"}
}

def require_basic_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        
        if not auth_header or not auth_header.startswith('Basic '):
            return jsonify({"error": "Basic authentication required"}), 401
        
        try:
            # Extract and decode the base64 encoded credentials
            encoded_credentials = auth_header[6:]  # Remove 'Basic '
            decoded_credentials = base64.b64decode(encoded_credentials).decode('utf-8')
            username, password = decoded_credentials.split(':', 1)
            
            if username not in USERS or USERS[username]["password"] != password:
                return jsonify({"error": "Invalid credentials"}), 401
            
            # Add user info to request context
            request.user = {
                "username": username,
                "role": USERS[username]["role"]
            }
            
            return f(*args, **kwargs)
        except Exception as e:
            return jsonify({"error": "Authentication failed", "details": str(e)}), 401
    
    return decorated

@app.route('/api/basic-auth')
@require_basic_auth
def protected_endpoint():
    return jsonify({
        "message": "Authentication successful",
        "user": request.user["username"],
        "role": request.user["role"]
    })

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h3>Using Basic Authentication with Django REST Framework</h3>
                <pre><code># settings.py
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.BasicAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

# views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.authentication import BasicAuthentication

class ProtectedView(APIView):
    authentication_classes = [BasicAuthentication]
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        return Response({
            "message": "Authentication successful",
            "user": request.user.username,
        })</code></pre>

                <h3>Testing Basic Authentication</h3>
                <pre><code># Using curl
curl -X GET http://localhost:5000/api/basic-auth -H "Authorization: Basic dXNlcjE6cGFzc3dvcmQx"

# The header is "Basic " followed by base64 encoded "user1:password1"

# Using Python requests
import requests
import base64

username = "user1"
password = "password1"
encoded_credentials = base64.b64encode(f"{username}:{password}".encode('utf-8')).decode('utf-8')

headers = {
    "Authorization": f"Basic {encoded_credentials}"
}

response = requests.get("http://localhost:5000/api/basic-auth", headers=headers)
print(response.json())</code></pre>
            </div>
            
            <div class="best-practices">
                <h3>Basic Authentication Best Practices</h3>
                <ul>
                    <li><strong>HTTPS Required:</strong> Always use HTTPS to encrypt the credentials in transit.</li>
                    <li><strong>Limited Use:</strong> Use only for development, internal APIs, or as a fallback mechanism.</li>
                    <li><strong>Password Security:</strong> Store passwords securely using modern hashing algorithms (e.g., bcrypt, Argon2).</li>
                    <li><strong>Brute Force Protection:</strong> Implement rate limiting to prevent brute force attacks.</li>
                    <li><strong>Alternative Authentication:</strong> Consider providing token-based authentication as an alternative.</li>
                </ul>
            </div>
            
            <div class="limitations">
                <h3>Limitations of Basic Authentication</h3>
                <ul>
                    <li>Credentials are sent with every request (even if encoded)</li>
                    <li>Base64 encoding is easily reversible (it's encoding, not encryption)</li>
                    <li>No built-in mechanism for token revocation</li>
                    <li>No support for token expiration</li>
                    <li>Requires secure credential storage on the client side</li>
                    <li>Increased network overhead due to repeated credential transmission</li>
                </ul>
            </div>
        </section>

        <section class="session_auth">
            <h2>Session-Based Authentication</h2>
            
            <p>Session-based authentication uses server-side storage to maintain authentication state between requests. It's like checking into a hotel—you identify yourself once at reception and receive a room key that grants you access during your stay.</p>
            
            <h3>How Session Authentication Works</h3>
            <ol>
                <li>The user provides credentials (typically username/password) through a login endpoint</li>
                <li>The server verifies the credentials and, if valid, creates a session with a unique identifier</li>
                <li>The server sends the session ID to the client (usually as a cookie)</li>
                <li>The client includes this cookie with subsequent requests</li>
                <li>The server validates the session ID against stored sessions to authenticate the request</li>
            </ol>
            
            <div class="code-section">
                <h3>Implementing Session Authentication in Flask</h3>
                <pre><code>from flask import Flask, request, jsonify, session
from werkzeug.security import generate_password_hash, check_password_hash
import os

app = Flask(__name__)
app.secret_key = os.urandom(24)  # Use a strong, random secret key

# In a real app, store users in a database with properly hashed passwords
USERS = {
    "user1": {
        "password": generate_password_hash("password1"),
        "role": "basic"
    },
    "admin": {
        "password": generate_password_hash("adminpass"),
        "role": "admin"
    }
}

@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    
    if not data or 'username' not in data or 'password' not in data:
        return jsonify({"error": "Missing username or password"}), 400
    
    username = data['username']
    password = data['password']
    
    if username not in USERS or not check_password_hash(USERS[username]["password"], password):
        return jsonify({"error": "Invalid credentials"}), 401
    
    # Create session
    session['username'] = username
    session['role'] = USERS[username]["role"]
    
    return jsonify({
        "message": "Login successful",
        "user": {
            "username": username,
            "role": USERS[username]["role"]
        }
    })

@app.route('/api/logout', methods=['POST'])
def logout():
    # Clear session
    session.clear()
    return jsonify({"message": "Logout successful"})

@app.route('/api/profile')
def profile():
    if 'username' not in session:
        return jsonify({"error": "Authentication required"}), 401
    
    return jsonify({
        "message": "Profile data",
        "user": {
            "username": session['username'],
            "role": session['role']
        }
    })

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h3>Session Authentication in Django REST Framework</h3>
                <pre><code># settings.py
INSTALLED_APPS = [
    # ... other apps
    'rest_framework',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

# urls.py
from django.urls import path
from .views import LoginView, LogoutView, ProfileView

urlpatterns = [
    path('api/login/', LoginView.as_view(), name='login'),
    path('api/logout/', LogoutView.as_view(), name='logout'),
    path('api/profile/', ProfileView.as_view(), name='profile'),
]

# views.py
from django.contrib.auth import authenticate, login, logout
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAuthenticated, AllowAny

class LoginView(APIView):
    permission_classes = [AllowAny]
    
    def post(self, request):
        username = request.data.get('username')
        password = request.data.get('password')
        
        if not username or not password:
            return Response({'error': 'Please provide username and password'}, status=status.HTTP_400_BAD_REQUEST)
        
        user = authenticate(username=username, password=password)
        
        if not user:
            return Response({'error': 'Invalid credentials'}, status=status.HTTP_401_UNAUTHORIZED)
        
        login(request, user)
        
        return Response({
            'message': 'Login successful',
            'user': {
                'username': user.username,
                'email': user.email
            }
        })

class LogoutView(APIView):
    def post(self, request):
        logout(request)
        return Response({'message': 'Logout successful'})

class ProfileView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        return Response({
            'message': 'Profile data',
            'user': {
                'username': request.user.username,
                'email': request.user.email
            }
        })</code></pre>
            </div>
            
            <div class="security-considerations">
                <h3>Security Considerations for Session Authentication</h3>
                <ul>
                    <li><strong>Session Expiration:</strong> Implement timeout for inactive sessions.</li>
                    <li><strong>Secure Cookie Settings:</strong>
                        <ul>
                            <li><code>Secure</code> flag to ensure cookies are only sent over HTTPS</li>
                            <li><code>HttpOnly</code> flag to prevent JavaScript access to the cookie</li>
                            <li><code>SameSite</code> attribute to prevent CSRF attacks</li>
                        </ul>
                    </li>
                    <li><strong>Session Fixation Prevention:</strong> Regenerate session IDs after authentication.</li>
                    <li><strong>CSRF Protection:</strong> Implement Cross-Site Request Forgery protections.</li>
                    <li><strong>Session Storage:</strong> Use secure storage backends (Redis, database) rather than file-based sessions in production.</li>
                </ul>
            </div>
            
            <div class="flask-session-config">
                <h3>Advanced Flask Session Configuration</h3>
                <pre><code>from flask import Flask
from flask_session import Session
from datetime import timedelta
import redis

app = Flask(__name__)

# Configure session to use Redis
app.config['SESSION_TYPE'] = 'redis'
app.config['SESSION_REDIS'] = redis.from_url('redis://localhost:6379/0')
app.config['SESSION_USE_SIGNER'] = True  # Sign session cookie
app.config['SESSION_PERMANENT'] = True  # Make session permanent
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(hours=1)  # Set session lifetime
app.config['SESSION_COOKIE_SECURE'] = True  # Only send over HTTPS
app.config['SESSION_COOKIE_HTTPONLY'] = True  # Prevent JavaScript access
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'  # CSRF protection

# Initialize Flask-Session
Session(app)</code></pre>
            </div>
            
            <div class="pros-cons">
                <h3>Pros and Cons of Session Authentication</h3>
                
                <h4>Pros:</h4>
                <ul>
                    <li>Server has complete control over sessions (easy to invalidate)</li>
                    <li>Session data is stored server-side, not exposed to clients</li>
                    <li>Well-established pattern with robust libraries and frameworks</li>
                    <li>Works well with server-rendered web applications</li>
                </ul>
                
                <h4>Cons:</h4>
                <ul>
                    <li>Requires server-side storage, which can be challenging to scale</li>
                    <li>Not ideal for stateless architectures or distributed systems</li>
                    <li>Relies on cookies, which can be problematic for non-browser clients</li>
                    <li>Session state needs to be shared across server instances</li>
                </ul>
            </div>
        </section>

        <section class="jwt_auth">
            <h2>JWT (JSON Web Token) Authentication</h2>
            
            <p>JWT authentication uses digitally signed tokens to securely transmit information between parties. Think of a JWT as a tamper-evident package—it contains information about the sender and can be verified to ensure it hasn't been altered.</p>
            
            <h3>How JWT Authentication Works</h3>
            <ol>
                <li>The user provides credentials through a login endpoint</li>
                <li>The server verifies the credentials and, if valid, creates a JWT containing user information (claims)</li>
                <li>The server signs the JWT with a secret key or private key</li>
                <li>The server sends the JWT to the client</li>
                <li>The client stores the JWT (typically in local storage or memory) and includes it in the Authorization header for subsequent requests</li>
                <li>The server validates the JWT signature and extracts user information from the token</li>
            </ol>
            
            <div class="jwt-structure">
                <h3>JWT Structure</h3>
                <p>A JWT consists of three parts, separated by dots:</p>
                <pre><code>header.payload.signature</code></pre>
                
                <h4>Header</h4>
                <p>Typically contains the token type and signing algorithm:</p>
                <pre><code>{
  "alg": "HS256",
  "typ": "JWT"
}</code></pre>
                
                <h4>Payload</h4>
                <p>Contains the claims (data) being transmitted:</p>
                <pre><code>{
  "sub": "1234567890",
  "name": "John Doe",
  "role": "admin",
  "iat": 1516239022,
  "exp": 1516242622
}</code></pre>
                
                <h4>Signature</h4>
                <p>Created by signing the encoded header and payload with a secret:</p>
                <pre><code>HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)</code></pre>
            </div>
            
            <div class="code-section">
                <h3>Implementing JWT Authentication in Flask with PyJWT</h3>
                <pre><code>from flask import Flask, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
from functools import wraps
import jwt
import datetime
import os

app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key')

# In a real app, store users in a database with properly hashed passwords
USERS = {
    "user1": {
        "password": generate_password_hash("password1"),
        "role": "basic"
    },
    "admin": {
        "password": generate_password_hash("adminpass"),
        "role": "admin"
    }
}

def generate_token(username, role):
    """Generate a JWT token for a user"""
    payload = {
        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24),  # Expiration time
        'iat': datetime.datetime.utcnow(),  # Issued at time
        'sub': username,  # Subject
        'role': role  # Custom claim
    }
    
    return jwt.encode(
        payload,
        app.config['SECRET_KEY'],
        algorithm='HS256'
    )

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        
        # Get token from the Authorization header
        auth_header = request.headers.get('Authorization')
        if auth_header and auth_header.startswith('Bearer '):
            token = auth_header.split(' ')[1]
        
        if not token:
            return jsonify({'error': 'Token is missing'}), 401
        
        try:
            # Decode the token
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            
            # Add user info to request
            request.user = {
                'username': data['sub'],
                'role': data['role']
            }
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
        
        return f(*args, **kwargs)
    
    return decorated

def admin_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        # Must be called after token_required
        if request.user['role'] != 'admin':
            return jsonify({'error': 'Admin privilege required'}), 403
        
        return f(*args, **kwargs)
    
    return decorated

@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    
    if not data or 'username' not in data or 'password' not in data:
        return jsonify({"error": "Missing username or password"}), 400
    
    username = data['username']
    password = data['password']
    
    if username not in USERS or not check_password_hash(USERS[username]["password"], password):
        return jsonify({"error": "Invalid credentials"}), 401
    
    # Generate token
    token = generate_token(username, USERS[username]['role'])
    
    return jsonify({
        "message": "Login successful",
        "token": token,
        "user": {
            "username": username,
            "role": USERS[username]["role"]
        }
    })

@app.route('/api/protected')
@token_required
def protected():
    return jsonify({
        "message": "This is a protected endpoint",
        "user": request.user
    })

@app.route('/api/admin')
@token_required
@admin_required
def admin():
    return jsonify({
        "message": "This is an admin endpoint",
        "user": request.user
    })

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h3>Implementing JWT in Django REST Framework</h3>
                <pre><code># settings.py
INSTALLED_APPS = [
    # ... other apps
    'rest_framework',
    'rest_framework_simplejwt',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
}

from datetime import timedelta

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': 'your-secret-key',  # Use environment variable in production
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
}

# urls.py
from django.urls import path
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)
from .views import ProtectedView

urlpatterns = [
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('api/protected/', ProtectedView.as_view(), name='protected'),
]

# views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

class ProtectedView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        return Response({
            'message': 'This is a protected endpoint',
            'user': {
                'username': request.user.username,
                'email': request.user.email
            }
        })</code></pre>
            </div>
            
            <div class="refresh-tokens">
                <h3>Implementing Refresh Tokens</h3>
                <p>Refresh tokens provide a way to obtain new access tokens without requiring the user to log in again. This allows for short-lived access tokens while maintaining a good user experience.</p>
                
                <pre><code>from flask import Flask, request, jsonify
import jwt
import datetime
import os
import uuid

app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key')

# In-memory token store (use a database in production)
REFRESH_TOKENS = {}

def generate_tokens(username, role):
    """Generate access and refresh tokens"""
    # Create access token
    access_payload = {
        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=15),  # Short-lived
        'iat': datetime.datetime.utcnow(),
        'sub': username,
        'role': role,
        'type': 'access'
    }
    
    access_token = jwt.encode(
        access_payload,
        app.config['SECRET_KEY'],
        algorithm='HS256'
    )
    
    # Create refresh token
    refresh_token_id = str(uuid.uuid4())
    refresh_payload = {
        'exp': datetime.datetime.utcnow() + datetime.timedelta(days=7),  # Longer-lived
        'iat': datetime.datetime.utcnow(),
        'jti': refresh_token_id,  # JWT ID
        'sub': username,
        'type': 'refresh'
    }
    
    refresh_token = jwt.encode(
        refresh_payload,
        app.config['SECRET_KEY'],
        algorithm='HS256'
    )
    
    # Store refresh token (with user info)
    REFRESH_TOKENS[refresh_token_id] = {
        'username': username,
        'role': role,
        'expires': datetime.datetime.utcnow() + datetime.timedelta(days=7)
    }
    
    return access_token, refresh_token

@app.route('/api/login', methods=['POST'])
def login():
    # ... authentication logic from previous example
    
    # Generate tokens
    access_token, refresh_token = generate_tokens(username, USERS[username]['role'])
    
    return jsonify({
        "message": "Login successful",
        "access_token": access_token,
        "refresh_token": refresh_token,
        "user": {
            "username": username,
            "role": USERS[username]["role"]
        }
    })

@app.route('/api/token/refresh', methods=['POST'])
def refresh():
    data = request.get_json()
    
    if not data or 'refresh_token' not in data:
        return jsonify({"error": "Refresh token required"}), 400
    
    refresh_token = data['refresh_token']
    
    try:
        # Decode the refresh token
        payload = jwt.decode(refresh_token, app.config['SECRET_KEY'], algorithms=['HS256'])
        
        # Verify it's a refresh token
        if payload['type'] != 'refresh':
            return jsonify({"error": "Invalid token type"}), 401
        
        token_id = payload['jti']
        
        # Check if token exists and is not expired
        if token_id not in REFRESH_TOKENS:
            return jsonify({"error": "Token has been revoked"}), 401
        
        token_data = REFRESH_TOKENS[token_id]
        if datetime.datetime.utcnow() > token_data['expires']:
            del REFRESH_TOKENS[token_id]
            return jsonify({"error": "Token has expired"}), 401
        
        # Generate a new access token
        access_payload = {
            'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=15),
            'iat': datetime.datetime.utcnow(),
            'sub': token_data['username'],
            'role': token_data['role'],
            'type': 'access'
        }
        
        new_access_token = jwt.encode(
            access_payload,
            app.config['SECRET_KEY'],
            algorithm='HS256'
        )
        
        return jsonify({
            "access_token": new_access_token
        })
        
    except jwt.ExpiredSignatureError:
        return jsonify({'error': 'Refresh token has expired'}), 401
    except jwt.InvalidTokenError:
        return jsonify({'error': 'Invalid refresh token'}), 401

@app.route('/api/logout', methods=['POST'])
def logout():
    data = request.get_json()
    
    if not data or 'refresh_token' not in data:
        return jsonify({"error": "Refresh token required"}), 400
    
    refresh_token = data['refresh_token']
    
    try:
        # Decode the refresh token
        payload = jwt.decode(refresh_token, app.config['SECRET_KEY'], algorithms=['HS256'])
        
        # Remove the refresh token
        token_id = payload['jti']
        if token_id in REFRESH_TOKENS:
            del REFRESH_TOKENS[token_id]
        
        return jsonify({"message": "Logout successful"})
        
    except (jwt.ExpiredSignatureError, jwt.InvalidTokenError):
        # Even if token is invalid, we return success
        return jsonify({"message": "Logout successful"})
</code></pre>
            </div>
            
            <div class="best-practices">
                <h3>JWT Best Practices</h3>
                <ul>
                    <li><strong>Keep It Small:</strong> Include only necessary data in the payload to minimize token size.</li>
                    <li><strong>Use Short Expiration Times:</strong> Set short expiration times for access tokens (minutes, not days).</li>
                    <li><strong>Implement Refresh Tokens:</strong> Use refresh tokens for obtaining new access tokens without re-authentication.</li>
                    <li><strong>Store Securely:</strong> Never store tokens in local storage due to XSS vulnerabilities. Use HTTP-only cookies or memory.</li>
                    <li><strong>Include Standard Claims:</strong> Use standard claims like 'exp' (expiration time), 'iat' (issued at), 'sub' (subject).</li>
                    <li><strong>Add Token Identifiers:</strong> Include a unique ID ('jti' claim) for each token to enable revocation.</li>
                    <li><strong>Use Strong Keys:</strong> Use strong, randomly generated keys to sign tokens.</li>
                    <li><strong>Consider Token Revocation:</strong> Implement a blacklist/whitelist for token revocation if needed.</li>
                </ul>
            </div>
            
            <div class="security-concerns">
                <h3>JWT Security Concerns</h3>
                <ul>
                    <li><strong>Algorithm Choice:</strong> Avoid 'none' algorithm and be cautious with 'alg' field in general.</li>
                    <li><strong>XSS Vulnerabilities:</strong> Tokens stored in JavaScript-accessible locations are vulnerable to XSS attacks.</li>
                    <li><strong>JWT Complexity:</strong> Improper implementation can lead to security issues.</li>
                    <li><strong>Token Size:</strong> Large tokens increase bandwidth usage.</li>
                    <li><strong>Revocation Challenges:</strong> JWTs are stateless by design, making revocation more complex.</li>
                </ul>
            </div>
        </section>

        <section class="oauth2">
            <h2>OAuth 2.0 and OpenID Connect</h2>
            
            <p>OAuth 2.0 is an authorization framework that enables third-party applications to obtain limited access to a user's account on a server. Think of it as a valet key for your car—it allows someone to park your car but doesn't give them full access to your vehicle.</p>
            
            <p>OpenID Connect (OIDC) is an identity layer built on top of OAuth 2.0, adding authentication capabilities. If OAuth 2.0 answers "What can this app do on behalf of the user?", OIDC answers "Who is this user?"</p>
            
            <h3>OAuth 2.0 Roles</h3>
            <ul>
                <li><strong>Resource Owner:</strong> The user who owns the data/resources</li>
                <li><strong>Client:</strong> The application requesting access to resources</li>
                <li><strong>Authorization Server:</strong> The server that authenticates the Resource Owner and issues tokens</li>
                <li><strong>Resource Server:</strong> The server hosting the protected resources</li>
            </ul>
            
            <h3>Common OAuth 2.0 Flows</h3>
            
            <div class="flow-comparison">
                <h4>Authorization Code Flow</h4>
                <p>Best for server-side applications:</p>
                <ol>
                    <li>Client redirects user to Authorization Server</li>
                    <li>User authenticates and grants permissions</li>
                    <li>Authorization Server redirects back to Client with an authorization code</li>
                    <li>Client exchanges the code for an access token (server-to-server)</li>
                    <li>Client uses the access token to access protected resources</li>
                </ol>
                
                <h4>Implicit Flow</h4>
                <p>Simplified flow for browser-based applications (less secure, now discouraged):</p>
                <ol>
                    <li>Client redirects user to Authorization Server</li>
                    <li>User authenticates and grants permissions</li>
                    <li>Authorization Server redirects back to Client with an access token in the URL fragment</li>
                    <li>Client uses the access token to access protected resources</li>
                </ol>
                
                <h4>Client Credentials Flow</h4>
                <p>For machine-to-machine communication:</p>
                <ol>
                    <li>Client authenticates directly with the Authorization Server</li>
                    <li>Authorization Server issues an access token to the Client</li>
                    <li>Client uses the access token to access protected resources</li>
                </ol>
            </div>
            
            <div class="code-section">
                <h3>Implementing OAuth 2.0 Client in Flask with Authlib</h3>
                <pre><code>from flask import Flask, redirect, url_for, session, request, jsonify
from authlib.integrations.flask_client import OAuth
import os

app = Flask(__name__)
app.secret_key = os.urandom(24)

# OAuth setup
oauth = OAuth(app)
oauth.register(
    name='github',
    client_id='your-github-client-id',
    client_secret='your-github-client-secret',
    access_token_url='https://github.com/login/oauth/access_token',
    access_token_params=None,
    authorize_url='https://github.com/login/oauth/authorize',
    authorize_params=None,
    api_base_url='https://api.github.com/',
    client_kwargs={'scope': 'user:email'},
)

@app.route('/')
def index():
    user = session.get('user')
    if user:
        return jsonify(user)
    return 'Welcome! <a href="/login">Login with GitHub</a>'

@app.route('/login')
def login():
    redirect_uri = url_for('authorize', _external=True)
    return oauth.github.authorize_redirect(redirect_uri)

@app.route('/authorize')
def authorize():
    token = oauth.github.authorize_access_token()
    resp = oauth.github.get('user', token=token)
    user_info = resp.json()
    # Store user info in session
    session['user'] = user_info
    return redirect('/')

@app.route('/logout')
def logout():
    session.pop('user', None)
    return redirect('/')

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h3>Implementing an OAuth 2.0 Server in Python with Authlib</h3>
                <pre><code>from flask import Flask, request, jsonify
from authlib.integrations.flask_oauth2 import AuthorizationServer, ResourceProtector
from authlib.integrations.sqla_oauth2 import create_query_client_func, create_save_token_func
from authlib.oauth2.rfc6749 import grants
from authlib.oauth2.rfc7636 import CodeChallenge
from werkzeug.security import generate_password_hash, check_password_hash
from models import db, User, OAuth2Client, OAuth2Token  # Define your own models
import os

app = Flask(__name__)
app.config['SECRET_KEY'] = os.urandom(24)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///oauth2.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Initialize database
db.init_app(app)

# Initialize OAuth2 server
authorization = AuthorizationServer(
    query_client=create_query_client_func(OAuth2Client),
    save_token=create_save_token_func(OAuth2Token)
)

# Resource protector for API endpoints
require_oauth = ResourceProtector()

# Define grants
class AuthorizationCodeGrant(grants.AuthorizationCodeGrant):
    TOKEN_ENDPOINT_AUTH_METHODS = ['client_secret_basic', 'client_secret_post']
    
    def save_authorization_code(self, code, request):
        # Save authorization code
        code_challenge = request.data.get('code_challenge')
        code_challenge_method = request.data.get('code_challenge_method')
        auth_code = OAuth2AuthorizationCode(
            code=code,
            client_id=request.client.client_id,
            redirect_uri=request.redirect_uri,
            scope=request.scope,
            user_id=request.user.id,
            code_challenge=code_challenge,
            code_challenge_method=code_challenge_method
        )
        db.session.add(auth_code)
        db.session.commit()
        return auth_code
    
    def query_authorization_code(self, code, client):
        auth_code = OAuth2AuthorizationCode.query.filter_by(
            code=code, client_id=client.client_id
        ).first()
        if auth_code and not auth_code.is_expired():
            return auth_code
    
    def delete_authorization_code(self, authorization_code):
        db.session.delete(authorization_code)
        db.session.commit()
    
    def authenticate_user(self, authorization_code):
        return User.query.get(authorization_code.user_id)

# Register grants
authorization.register_grant(AuthorizationCodeGrant, [CodeChallenge(required=True)])
authorization.register_grant(grants.RefreshTokenGrant)

# Initialize the oauth2 server with the flask app
authorization.init_app(app)

@app.route('/oauth/authorize', methods=['GET', 'POST'])
def authorize():
    # Implement user authentication and consent page
    user = get_current_user()  # Your own function to get current user
    if request.method == 'GET':
        try:
            grant = authorization.validate_consent_request(end_user=user)
            return render_template('authorize.html', user=user, grant=grant)
        except OAuth2Error as error:
            return jsonify(error.error)
    
    if request.method == 'POST':
        if 'confirm' in request.form:
            grant_user = user
        else:
            grant_user = None
        
        return authorization.create_authorization_response(grant_user=grant_user)

@app.route('/oauth/token', methods=['POST'])
def issue_token():
    return authorization.create_token_response()

@app.route('/api/me')
@require_oauth('profile')
def api_me():
    user = request.oauth_token.user
    return jsonify({
        'id': user.id,
        'username': user.username,
        'email': user.email
    })

if __name__ == '__main__':
    app.run(debug=True)</code></pre>
            </div>
            
            <div class="practical-considerations">
                <h3>Practical Considerations for OAuth 2.0</h3>
                <ul>
                    <li><strong>Use Established Libraries:</strong> OAuth 2.0 and OIDC are complex protocols. Leverage well-maintained libraries like Authlib, python-oauth2, or django-oauth-toolkit.</li>
                    <li><strong>Consider Hosted Solutions:</strong> For most applications, using a hosted identity provider (Auth0, Okta, Firebase Auth) is more secure than building your own.</li>
                    <li><strong>Security First:</strong> Follow OAuth security best practices, especially for redirect URIs validation and PKCE for mobile/SPA applications.</li>
                    <li><strong>User Experience:</strong> Design a clear and informative consent screen that explains what data your application is requesting.</li>
                    <li><strong>Token Storage:</strong> Store tokens securely according to application type (server-side for web apps, secure storage for mobile).</li>
                </ul>
            </div>
            
            <div class="use-cases">
                <h3>OAuth 2.0 Use Cases</h3>
                <ul>
                    <li><strong>Third-Party Integrations:</strong> Allow users to connect your application with their accounts on other services.</li>
                    <li><strong>API Gateways:</strong> Secure access to your API for various types of clients.</li>
                    <li><strong>Single Sign-On (SSO):</strong> When combined with OIDC, provides unified authentication across multiple applications.</li>
                    <li><strong>Microservices:</strong> Secure service-to-service communication.</li>
                    <li><strong>Mobile Applications:</strong> Provide secure authentication without embedding credentials.</li>
                </ul>
            </div>
            
            <div class="django-oauth-toolkit">
                <h3>Implementing OAuth 2.0 with Django OAuth Toolkit</h3>
                <pre><code># settings.py
INSTALLED_APPS = [
    # ...
    'oauth2_provider',
    'corsheaders',
    # ...
]

MIDDLEWARE = [
    # ...
    'corsheaders.middleware.CorsMiddleware',
    # ...
]

CORS_ORIGIN_ALLOW_ALL = True  # Not recommended for production

OAUTH2_PROVIDER = {
    'SCOPES': {
        'read': 'Read scope',
        'write': 'Write scope',
    },
    'ACCESS_TOKEN_EXPIRE_SECONDS': 3600,  # 1 hour
    'REFRESH_TOKEN_EXPIRE_SECONDS': 86400,  # 1 day
}

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'oauth2_provider.contrib.rest_framework.OAuth2Authentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ]
}

# urls.py
from django.urls import path, include
from oauth2_provider.views import TokenView, AuthorizationView

urlpatterns = [
    path('o/', include('oauth2_provider.urls', namespace='oauth2_provider')),
    path('api/', include('your_app.urls')),
]

# views.py
from oauth2_provider.contrib.rest_framework import TokenHasReadWriteScope
from rest_framework import viewsets, permissions
from .models import Product
from .serializers import ProductSerializer

class ProductViewSet(viewsets.ModelViewSet):
    permission_classes = [permissions.IsAuthenticated, TokenHasReadWriteScope]
    queryset = Product.objects.all()
    serializer_class = ProductSerializer</code></pre>
            </div>
        </section>

        <section class="social_auth">
            <h2>Social Authentication</h2>
            
            <p>Social authentication allows users to sign in using their existing accounts from social platforms like Google, Facebook, Twitter, or GitHub. It's like having a universal key that works on multiple doors, making the login process faster and more convenient for users.</p>
            
            <h3>Benefits of Social Authentication</h3>
            <ul>
                <li><strong>Reduced Friction:</strong> Users don't need to create and remember a new account</li>
                <li><strong>Increased Trust:</strong> Users can leverage their trusted relationship with the social provider</li>
                <li><strong>Rich User Data:</strong> Access to profile information (with user consent)</li>
                <li><strong>Delegated Security:</strong> Social providers handle complex security requirements</li>
            </ul>
            
            <div class="code-section">
                <h3>Implementing Social Auth with Flask-Dance</h3>
                <pre><code>from flask import Flask, redirect, url_for, flash, session
from flask_dance.contrib.google import make_google_blueprint, google
from flask_dance.contrib.github import make_github_blueprint, github
from flask_login import LoginManager, login_user, logout_user, login_required, current_user
from your_models import db, User  # Define your own User model

app = Flask(__name__)
app.secret_key = "your-secret-key"
app.config["GOOGLE_OAUTH_CLIENT_ID"] = "your-google-client-id"
app.config["GOOGLE_OAUTH_CLIENT_SECRET"] = "your-google-client-secret"
app.config["GITHUB_OAUTH_CLIENT_ID"] = "your-github-client-id"
app.config["GITHUB_OAUTH_CLIENT_SECRET"] = "your-github-client-secret"

# Initialize login manager
login_manager = LoginManager(app)
login_manager.login_view = "login"

# Create OAuth blueprints
google_bp = make_google_blueprint(scope=["profile", "email"])
github_bp = make_github_blueprint()

# Register blueprints
app.register_blueprint(google_bp, url_prefix="/login")
app.register_blueprint(github_bp, url_prefix="/login")

# User loader for Flask-Login
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

@app.route("/")
def home():
    return "Home Page <a href='/login'>Login</a>"

@app.route("/login")
def login():
    return """
    <h1>Login</h1>
    <a href='/login/google'>Login with Google</a><br>
    <a href='/login/github'>Login with GitHub</a>
    """

@app.route("/login/google")
def google_login():
    if not google.authorized:
        return redirect(url_for("google.login"))
    
    resp = google.get("/oauth2/v2/userinfo")
    if resp.ok:
        user_info = resp.json()
        email = user_info["email"]
        
        # Check if user exists, create if not
        user = User.query.filter_by(email=email).first()
        if not user:
            user = User(
                email=email,
                username=user_info.get("name", email),
                social_id=f"google:{user_info['id']}",
                profile_pic=user_info.get("picture")
            )
            db.session.add(user)
            db.session.commit()
        
        # Log in the user
        login_user(user)
        flash("Successfully signed in with Google.")
        
        return redirect(url_for("profile"))
    
    return "Failed to fetch user info from Google."

@app.route("/login/github")
def github_login():
    if not github.authorized:
        return redirect(url_for("github.login"))
    
    resp = github.get("/user")
    if resp.ok:
        user_info = resp.json()
        
        # Also get email from GitHub (it's not in the basic profile)
        email_resp = github.get("/user/emails")
        if email_resp.ok:
            emails = email_resp.json()
            primary_email = next((e["email"] for e in emails if e["primary"]), None)
        else:
            primary_email = f"{user_info['login']}@github.example.com"
        
        # Check if user exists, create if not
        user = User.query.filter_by(email=primary_email).first()
        if not user:
            user = User(
                email=primary_email,
                username=user_info.get("name", user_info["login"]),
                social_id=f"github:{user_info['id']}",
                profile_pic=user_info.get("avatar_url")
            )
            db.session.add(user)
            db.session.commit()
        
        # Log in the user
        login_user(user)
        flash("Successfully signed in with GitHub.")
        
        return redirect(url_for("profile"))
    
    return "Failed to fetch user info from GitHub."

@app.route("/profile")
@login_required
def profile():
    return f"""
    <h1>Profile</h1>
    <p>Username: {current_user.username}</p>
    <p>Email: {current_user.email}</p>
    <img src="{current_user.profile_pic}" alt="Profile Picture" width="100">
    <p><a href="/logout">Logout</a></p>
    """

@app.route("/logout")
@login_required
def logout():
    logout_user()
    flash("You have been logged out.")
    return redirect(url_for("home"))

if __name__ == "__main__":
    app.run(debug=True)</code></pre>

                <h3>Implementing Social Auth with Django Allauth</h3>
                <pre><code># settings.py
INSTALLED_APPS = [
    # ...
    'django.contrib.sites',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',
    'allauth.socialaccount.providers.github',
    # ...
]

MIDDLEWARE = [
    # ...
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    # ...
]

AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
]

SITE_ID = 1

# Provider specific settings
SOCIALACCOUNT_PROVIDERS = {
    'google': {
        'APP': {
            'client_id': 'your-client-id',
            'secret': 'your-client-secret',
            'key': ''
        },
        'SCOPE': ['profile', 'email'],
        'AUTH_PARAMS': {
            'access_type': 'online',
        }
    },
    'github': {
        'APP': {
            'client_id': 'your-client-id',
            'secret': 'your-client-secret',
            'key': ''
        },
        'SCOPE': ['user'],
    }
}

# urls.py
from django.urls import path, include

urlpatterns = [
    # ...
    path('accounts/', include('allauth.urls')),
    # ...
]

# views.py
from django.shortcuts import render
from django.contrib.auth.decorators import login_required

@login_required
def profile(request):
    return render(request, 'profile.html')

# templates/profile.html
{% extends "base.html" %}

{% block content %}
<h1>Profile</h1>
<p>Username: {{ user.username }}</p>
<p>Email: {{ user.email }}</p>
{% if user.socialaccount_set.all %}
  <p>Connected accounts:</p>
  <ul>
    {% for account in user.socialaccount_set.all %}
      <li>
        {{ account.provider|title }} ({{ account.uid }})
        {% if account.extra_data %}
          <br>
          {% if account.provider == 'google' and account.extra_data.picture %}
            <img src="{{ account.extra_data.picture }}" alt="Profile Picture" width="100">
          {% elif account.provider == 'github' and account.extra_data.avatar_url %}
            <img src="{{ account.extra_data.avatar_url }}" alt="Profile Picture" width="100">
          {% endif %}
        {% endif %}
      </li>
    {% endfor %}
  </ul>
{% endif %}
<p><a href="{% url 'account_logout' %}">Logout</a></p>
{% endblock %}</code></pre>
            </div>
            
            <div class="best-practices">
                <h3>Social Authentication Best Practices</h3>
                <ul>
                    <li><strong>Provide Multiple Options:</strong> Offer multiple social login providers to accommodate user preferences.</li>
                    <li><strong>Request Minimal Permissions:</strong> Only request the permissions you actually need (e.g., basic profile, email).</li>
                    <li><strong>Implement Email Verification:</strong> Verify email addresses, even from social providers.</li>
                    <li><strong>Account Linking:</strong> Allow users to link multiple social accounts to a single user account.</li>
                    <li><strong>Traditional Login Option:</strong> Always provide a traditional email/password option for users who prefer it.</li>
                    <li><strong>Clear Privacy Policy:</strong> Be transparent about what data you collect and how you use it.</li>
                    <li><strong>Fallback Authentication:</strong> Implement alternative login methods in case social providers are unavailable.</li>
                </ul>
            </div>
            
            <div class="security-considerations">
                <h3>Security Considerations for Social Auth</h3>
                <ul>
                    <li><strong>CSRF Protection:</strong> Implement state parameter to prevent cross-site request forgery attacks.</li>
                    <li><strong>Secure Storage:</strong> Store social profile information securely, especially access tokens.</li>
                    <li><strong>Account Hijacking:</strong> Beware of account hijacking through email changes.</li>
                    <li><strong>Provider Dependencies:</strong> Have contingency plans for when social providers change their APIs or experience downtime.</li>
                    <li><strong>Identity Conflicts:</strong> Handle cases where the same email is used with different providers.</li>
                </ul>
            </div>
        </section>

        <section class="mfa">
            <h2>Multi-Factor Authentication (MFA)</h2>
            
            <p>Multi-Factor Authentication significantly increases security by requiring multiple forms of verification before granting access. It's like requiring both a key and a passcode to enter a secure facility—even if attackers steal one credential, they still can't gain access without the others.</p>
            
            <h3>Authentication Factors</h3>
            <ul>
                <li><strong>Knowledge factors:</strong> Something the user knows (password, PIN, security question)</li>
                <li><strong>Possession factors:</strong> Something the user has (mobile phone, hardware token, smart card)</li>
                <li><strong>Inherence factors:</strong> Something the user is (fingerprint, facial recognition, voice recognition)</li>
                <li><strong>Location factors:</strong> Somewhere the user is (GPS location, network location)</li>
                <li><strong>Time factors:</strong> When the user is authenticating (time-based restrictions)</li>
            </ul>
            
            <h3>Common MFA Methods</h3>
            <ul>
                <li><strong>Time-based One-Time Passwords (TOTP):</strong> Temporary codes generated by authenticator apps</li>
                <li><strong>SMS/Email Codes:</strong> One-time codes sent via text message or email</li>
                <li><strong>Push Notifications:</strong> Approval requests sent to a trusted device</li>
                <li><strong>Hardware Tokens:</strong> Physical devices that generate codes or respond to challenges</li>
                <li><strong>Biometric Verification:</strong> Fingerprint or facial recognition</li>
            </ul>
            
            <div class="code-section">
                <h3>Implementing TOTP-Based MFA with PyOTP in Flask</h3>
                <pre><code>from flask import Flask, request, jsonify, session
from werkzeug.security import generate_password_hash, check_password_hash
import pyotp
import qrcode
from io import BytesIO
import base64
import os

app = Flask(__name__)
app.secret_key = os.urandom(24)

# In a real app, store these in a database
USERS = {}

@app.route('/api/register', methods=['POST'])
def register():
    data = request.get_json()
    
    if not data or 'username' not in data or 'password' not in data:
        return jsonify({"error": "Username and password required"}), 400
    
    username = data['username']
    password = data['password']
    
    if username in USERS:
        return jsonify({"error": "Username already exists"}), 400
    
    # Generate a random secret for TOTP
    totp_secret = pyotp.random_base32()
    
    # Store user data
    USERS[username] = {
        'password_hash': generate_password_hash(password),
        'totp_secret': totp_secret,
        'mfa_enabled': False
    }
    
    return jsonify({
        "message": "User registered successfully",
        "username": username
    }), 201

@app.route('/api/setup-mfa', methods=['GET'])
def setup_mfa():
    if 'username' not in session:
        return jsonify({"error": "Authentication required"}), 401
    
    username = session['username']
    user = USERS.get(username)
    
    if not user:
        return jsonify({"error": "User not found"}), 404
    
    # Create a TOTP URI for the authenticator app
    totp = pyotp.TOTP(user['totp_secret'])
    provisioning_uri = totp.provisioning_uri(
        name=username,
        issuer_name="YourApp"
    )
    
    # Generate QR code
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    qr.add_data(provisioning_uri)
    qr.make(fit=True)
    
    img = qr.make_image(fill_color="black", back_color="white")
    buffered = BytesIO()
    img.save(buffered)
    img_str = base64.b64encode(buffered.getvalue()).decode()
    
    return jsonify({
        "secret": user['totp_secret'],
        "qr_code": f"data:image/png;base64,{img_str}",
        "provisioning_uri": provisioning_uri
    })

@app.route('/api/verify-mfa', methods=['POST'])
def verify_mfa():
    if 'username' not in session:
        return jsonify({"error": "Authentication required"}), 401
    
    data = request.get_json()
    if not data or 'token' not in data:
        return jsonify({"error": "TOTP token required"}), 400
    
    username = session['username']
    user = USERS.get(username)
    
    if not user:
        return jsonify({"error": "User not found"}), 404
    
    # Verify the TOTP token
    totp = pyotp.TOTP(user['totp_secret'])
    if totp.verify(data['token']):
        # Enable MFA for the user
        user['mfa_enabled'] = True
        return jsonify({"message": "MFA enabled successfully"})
    else:
        return jsonify({"error": "Invalid token"}), 400

@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    
    if not data or 'username' not in data or 'password' not in data:
        return jsonify({"error": "Username and password required"}), 400
    
    username = data['username']
    password = data['password']
    
    user = USERS.get(username)
    if not user or not check_password_hash(user['password_hash'], password):
        return jsonify({"error": "Invalid credentials"}), 401
    
    # If MFA is enabled, require TOTP verification
    if user['mfa_enabled']:
        if 'token' not in data:
            return jsonify({
                "message": "MFA required",
                "mfa_required": True
            }), 200
        
        # Verify the TOTP token
        totp = pyotp.TOTP(user['totp_secret'])
        if not totp.verify(data['token']):
            return jsonify({"error": "Invalid MFA token"}), 401
    
    # Create session
    session['username'] = username
    
    return jsonify({
        "message": "Login successful",
        "username": username
    })

@app.route('/api/logout', methods=['POST'])
def logout():
    session.clear()
    return jsonify({"message": "Logout successful"})

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h3>Implementing SMS-Based MFA with Twilio in Django</h3>
                <pre><code># settings.py
INSTALLED_APPS = [
    # ...
    'django.contrib.auth',
    'rest_framework',
    'rest_framework.authtoken',
    # ...
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
    ],
}

# Twilio settings
TWILIO_ACCOUNT_SID = 'your-account-sid'
TWILIO_AUTH_TOKEN = 'your-auth-token'
TWILIO_PHONE_NUMBER = 'your-twilio-phone-number'

# models.py
from django.db import models
from django.contrib.auth.models import User
import random

class MFAProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    phone_number = models.CharField(max_length=15, blank=True, null=True)
    mfa_enabled = models.BooleanField(default=False)
    mfa_secret = models.CharField(max_length=16, blank=True)
    
    def generate_mfa_code(self):
        """Generate a 6-digit MFA code and save it"""
        code = str(random.randint(100000, 999999))
        self.mfa_secret = code
        self.save()
        return code

# views.py
from django.contrib.auth import authenticate
from django.conf import settings
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework.authtoken.models import Token
from twilio.rest import Client
from .models import MFAProfile

# Initialize Twilio client
twilio_client = Client(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)

@api_view(['POST'])
@permission_classes([AllowAny])
def register(request):
    username = request.data.get('username')
    password = request.data.get('password')
    phone_number = request.data.get('phone_number')
    
    if not username or not password or not phone_number:
        return Response(
            {'error': 'Username, password, and phone number required'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # Create user
    try:
        user = User.objects.create_user(username=username, password=password)
    except:
        return Response(
            {'error': 'Username already exists'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # Create MFA profile
    MFAProfile.objects.create(user=user, phone_number=phone_number)
    
    return Response({'message': 'User registered successfully'}, status=status.HTTP_201_CREATED)

@api_view(['POST'])
@permission_classes([AllowAny])
def login(request):
    username = request.data.get('username')
    password = request.data.get('password')
    mfa_code = request.data.get('mfa_code')
    
    if not username or not password:
        return Response(
            {'error': 'Username and password required'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    user = authenticate(username=username, password=password)
    
    if not user:
        return Response(
            {'error': 'Invalid credentials'},
            status=status.HTTP_401_UNAUTHORIZED
        )
    
    try:
        mfa_profile = MFAProfile.objects.get(user=user)
    except MFAProfile.DoesNotExist:
        mfa_profile = MFAProfile.objects.create(user=user)
    
    # If MFA is enabled
    if mfa_profile.mfa_enabled:
        # If MFA code is not provided, send one
        if not mfa_code:
            # Generate and send MFA code
            code = mfa_profile.generate_mfa_code()
            
            try:
                message = twilio_client.messages.create(
                    body=f"Your verification code is: {code}",
                    from_=settings.TWILIO_PHONE_NUMBER,
                    to=mfa_profile.phone_number
                )
                
                return Response({
                    'message': 'MFA code sent',
                    'mfa_required': True
                })
                
            except Exception as e:
                return Response(
                    {'error': f'Failed to send MFA code: {str(e)}'},
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR
                )
        
        # Verify MFA code
        if mfa_profile.mfa_secret != mfa_code:
            return Response(
                {'error': 'Invalid MFA code'},
                status=status.HTTP_401_UNAUTHORIZED
            )
    
    # Create or get token
    token, created = Token.objects.get_or_create(user=user)
    
    return Response({
        'token': token.key,
        'username': user.username
    })

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def setup_mfa(request):
    user = request.user
    
    try:
        mfa_profile = MFAProfile.objects.get(user=user)
    except MFAProfile.DoesNotExist:
        return Response(
            {'error': 'MFA profile not found'},
            status=status.HTTP_404_NOT_FOUND
        )
    
    # Generate and send MFA code
    code = mfa_profile.generate_mfa_code()
    
    try:
        message = twilio_client.messages.create(
            body=f"Your MFA verification code is: {code}",
            from_=settings.TWILIO_PHONE_NUMBER,
            to=mfa_profile.phone_number
        )
        
        return Response({
            'message': 'MFA code sent for verification'
        })
        
    except Exception as e:
        return Response(
            {'error': f'Failed to send MFA code: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def verify_mfa(request):
    user = request.user
    mfa_code = request.data.get('mfa_code')
    
    if not mfa_code:
        return Response(
            {'error': 'MFA code required'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    try:
        mfa_profile = MFAProfile.objects.get(user=user)
    except MFAProfile.DoesNotExist:
        return Response(
            {'error': 'MFA profile not found'},
            status=status.HTTP_404_NOT_FOUND
        )
    
    # Verify MFA code
    if mfa_profile.mfa_secret != mfa_code:
        return Response(
            {'error': 'Invalid MFA code'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # Enable MFA
    mfa_profile.mfa_enabled = True
    mfa_profile.save()
    
    return Response({
        'message': 'MFA enabled successfully'
    })</code></pre>
            </div>
            
            <div class="best-practices">
                <h3>MFA Best Practices</h3>
                <ul>
                    <li><strong>Multiple Recovery Options:</strong> Provide secure recovery methods for users who lose their MFA device.</li>
                    <li><strong>Balance Security and Usability:</strong> Choose MFA methods appropriate for your user base.</li>
                    <li><strong>Fallback Authentication:</strong> Implement secure fallback methods for when primary MFA is unavailable.</li>
                    <li><strong>Session Management:</strong> Define appropriate session lengths after MFA verification.</li>
                    <li><strong>Risk-Based Authentication:</strong> Consider triggering MFA only for high-risk actions or suspicious activity.</li>
                    <li><strong>Secure Enrollment:</strong> Ensure the MFA enrollment process itself is secure.</li>
                    <li><strong>Testing:</strong> Thoroughly test MFA flows, including edge cases and recovery paths.</li>
                </ul>
            </div>
            
            <div class="avoiding-common-pitfalls">
                <h3>Avoiding Common MFA Pitfalls</h3>
                <ul>
                    <li><strong>SMS Vulnerabilities:</strong> Be aware that SMS is vulnerable to SIM swapping and interception.</li>
                    <li><strong>Account Recovery Attacks:</strong> Ensure recovery methods aren't weaker than the primary authentication.</li>
                    <li><strong>Backup Codes:</strong> Provide backup codes for users who lose access to their MFA device.</li>
                    <li><strong>User Experience:</strong> Design the MFA flow to be user-friendly to prevent frustration.</li>
                    <li><strong>Rate Limiting:</strong> Implement rate limiting for MFA attempts to prevent brute force attacks.</li>
                </ul>
            </div>
        </section>

        <section class="passwordless">
            <h2>Passwordless Authentication</h2>
            
            <p>Passwordless authentication eliminates passwords entirely, instead relying on other authentication factors. Think of it as using a digital fingerprint or a personalized key fob instead of remembering a combination—it's often both more secure and more convenient.</p>
            
            <h3>Common Passwordless Methods</h3>
            <ul>
                <li><strong>Magic Links:</strong> One-time login links sent via email</li>
                <li><strong>One-Time Codes:</strong> Verification codes sent via SMS or email</li>
                <li><strong>Biometric Authentication:</strong> Fingerprint, face recognition</li>
                <li><strong>WebAuthn/FIDO2:</strong> Hardware security keys and platform authenticators</li>
                <li><strong>Push Notifications:</strong> Authentication requests sent to a trusted device</li>
            </ul>
            
            <div class="code-section">
                <h3>Implementing Magic Link Authentication in Flask</h3>
                <pre><code>from flask import Flask, request, jsonify, redirect, url_for
from werkzeug.security import generate_password_hash
from itsdangerous import URLSafeTimedSerializer, SignatureExpired, BadSignature
import uuid
import datetime
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import os

app = Flask(__name__)
app.config['SECRET_KEY'] = os.urandom(24)
app.config['SECURITY_PASSWORD_SALT'] = os.urandom(24)

# Email configuration
app.config['MAIL_SERVER'] = 'smtp.example.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USERNAME'] = 'your-email@example.com'
app.config['MAIL_PASSWORD'] = 'your-email-password'

# In a real app, store these in a database
USERS = {}
SESSIONS = {}

# Initialize serializer for tokens
ts = URLSafeTimedSerializer(app.config["SECRET_KEY"])

def send_email(to, subject, body_html):
    """Send an email"""
    msg = MIMEMultipart('alternative')
    msg['Subject'] = subject
    msg['From'] = app.config['MAIL_USERNAME']
    msg['To'] = to
    
    # Attach HTML content
    html_part = MIMEText(body_html, 'html')
    msg.attach(html_part)
    
    # Send email
    try:
        server = smtplib.SMTP(app.config['MAIL_SERVER'], app.config['MAIL_PORT'])
        server.starttls()
        server.login(app.config['MAIL_USERNAME'], app.config['MAIL_PASSWORD'])
        server.sendmail(app.config['MAIL_USERNAME'], to, msg.as_string())
        server.quit()
        return True
    except Exception as e:
        print(f"Failed to send email: {str(e)}")
        return False

def generate_magic_link(email):
    """Generate a magic link for the user"""
    # Create a token with the email and an expiration
    token = ts.dumps(email, salt=app.config['SECURITY_PASSWORD_SALT'])
    
    # Build the verification URL
    verification_url = url_for('verify_magic_link', token=token, _external=True)
    
    return verification_url

@app.route('/api/register', methods=['POST'])
def register():
    """Register a new user with email only"""
    data = request.get_json()
    
    if not data or 'email' not in data:
        return jsonify({"error": "Email required"}), 400
    
    email = data['email']
    
    if email in USERS:
        return jsonify({"error": "Email already registered"}), 400
    
    # Store user data
    USERS[email] = {
        'user_id': str(uuid.uuid4()),
        'email': email,
        'created_at': datetime.datetime.utcnow().isoformat()
    }
    
    return jsonify({
        "message": "User registered successfully",
        "email": email
    }), 201

@app.route('/api/login', methods=['POST'])
def login():
    """Send a magic link to the user's email"""
    data = request.get_json()
    
    if not data or 'email' not in data:
        return jsonify({"error": "Email required"}), 400
    
    email = data['email']
    
    # Check if user exists
    if email not in USERS:
        # For security reasons, don't reveal that the user doesn't exist
        return jsonify({"message": "If your email is registered, you will receive a login link"}), 200
    
    # Generate magic link
    magic_link = generate_magic_link(email)
    
    # Email content
    subject = "Your Login Link"
    body_html = f"""
    <html>
    <body>
        <h1>Login to Your App</h1>
        <p>Click the link below to log in:</p>
        <p><a href="{magic_link}">Login now</a></p>
        <p>This link will expire in 10 minutes.</p>
        <p>If you didn't request this link, you can safely ignore this email.</p>
    </body>
    </html>
    """
    
    # Send email
    email_sent = send_email(email, subject, body_html)
    
    if email_sent:
        return jsonify({
            "message": "If your email is registered, you will receive a login link"
        }), 200
    else:
        return jsonify({"error": "Failed to send login link"}), 500

@app.route('/verify-magic-link')
def verify_magic_link():
    """Verify the magic link and log the user in"""
    token = request.args.get('token')
    
    if not token:
        return jsonify({"error": "Invalid link"}), 400
    
    try:
        # Verify the token and extract the email
        # The max_age parameter sets the expiration time (in seconds)
        email = ts.loads(token, salt=app.config['SECURITY_PASSWORD_SALT'], max_age=600)
    except SignatureExpired:
        return jsonify({"error": "Link has expired"}), 400
    except BadSignature:
        return jsonify({"error": "Invalid link"}), 400
    
    # Check if user exists
    if email not in USERS:
        return jsonify({"error": "User not found"}), 404
    
    # Create a session
    session_id = str(uuid.uuid4())
    
    SESSIONS[session_id] = {
        'user_id': USERS[email]['user_id'],
        'email': email,
        'created_at': datetime.datetime.utcnow().isoformat(),
        'expires_at': (datetime.datetime.utcnow() + datetime.timedelta(days=7)).isoformat()
    }
    
    # In a real app, you would redirect to the frontend with the session token
    # For this example, we'll just return the session ID
    return jsonify({
        "message": "Login successful",
        "session_id": session_id,
        "user": {
            "email": email,
            "user_id": USERS[email]['user_id']
        }
    }), 200

@app.route('/api/me')
def get_user_info():
    """Get the current user's information"""
    session_id = request.headers.get('Authorization')
    
    if not session_id:
        return jsonify({"error": "Authentication required"}), 401
    
    session = SESSIONS.get(session_id)
    
    if not session:
        return jsonify({"error": "Invalid session"}), 401
    
    # Check if session has expired
    expires_at = datetime.datetime.fromisoformat(session['expires_at'])
    if datetime.datetime.utcnow() > expires_at:
        del SESSIONS[session_id]
        return jsonify({"error": "Session expired"}), 401
    
    email = session['email']
    user = USERS.get(email)
    
    if not user:
        return jsonify({"error": "User not found"}), 404
    
    return jsonify({
        "user": {
            "email": email,
            "user_id": user['user_id'],
            "created_at": user['created_at']
        }
    }), 200

@app.route('/api/logout', methods=['POST'])
def logout():
    """Log the user out by invalidating their session"""
    session_id = request.headers.get('Authorization')
    
    if not session_id:
        return jsonify({"error": "Authentication required"}), 401
    
    if session_id in SESSIONS:
        del SESSIONS[session_id]
    
    return jsonify({"message": "Logout successful"}), 200

if __name__ == '__main__':
    app.run(debug=True)</code></pre>

                <h3>Implementing WebAuthn/FIDO2 in Django</h3>
                <pre><code># This is a simplified example using the django-webauthn library
# pip install django-webauthn

# settings.py
INSTALLED_APPS = [
    # ...
    'django_webauthn',
    # ...
]

DJANGO_WEBAUTHN = {
    'RP_ID': 'example.com',  # Your domain
    'RP_NAME': 'Your App Name',
    'AUTHENTICATOR_ATTACHMENT': 'platform',  # or 'cross-platform'
    'USER_VERIFICATION': 'preferred',  # or 'required', 'discouraged'
    'ATTESTATION': 'none',  # or 'direct', 'indirect'
}

# models.py
from django.db import models
from django.contrib.auth.models import User
from django_webauthn.models import WebauthnCredential

class WebauthnUser(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    webauthn_enabled = models.BooleanField(default=False)

# views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login, logout
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.models import User
from django_webauthn.models import WebauthnCredential
from django_webauthn.views import (
    create_options, create_verify, get_options, get_verify
)
from .models import WebauthnUser
import json

@csrf_exempt
def register_user(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        email = data.get('email')
        
        if not email:
            return JsonResponse({'error': 'Email required'}, status=400)
        
        # Check if user exists
        if User.objects.filter(email=email).exists():
            return JsonResponse({'error': 'Email already registered'}, status=400)
        
        # Create user with unusable password (passwordless auth)
        user = User.objects.create(
            username=email,
            email=email
        )
        user.set_unusable_password()
        user.save()
        
        # Create WebauthnUser profile
        WebauthnUser.objects.create(user=user)
        
        return JsonResponse({
            'message': 'User registered successfully',
            'email': email
        }, status=201)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@csrf_exempt
def register_webauthn_begin(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        email = data.get('email')
        
        if not email:
            return JsonResponse({'error': 'Email required'}, status=400)
        
        try:
            user = User.objects.get(email=email)
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Generate registration options
        options = create_options(request, user)
        
        return JsonResponse(options)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@csrf_exempt
def register_webauthn_complete(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        email = data.get('email')
        
        if not email:
            return JsonResponse({'error': 'Email required'}, status=400)
        
        try:
            user = User.objects.get(email=email)
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        
        # Verify registration
        credential = create_verify(request, user)
        
        if credential:
            # Enable WebAuthn for the user
            webauthn_user = WebauthnUser.objects.get(user=user)
            webauthn_user.webauthn_enabled = True
            webauthn_user.save()
            
            return JsonResponse({
                'message': 'WebAuthn registration successful',
                'credential_id': credential.credential_id.hex()
            })
        
        return JsonResponse({'error': 'WebAuthn registration failed'}, status=400)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@csrf_exempt
def login_webauthn_begin(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        email = data.get('email')
        
        if not email:
            return JsonResponse({'error': 'Email required'}, status=400)
        
        try:
            user = User.objects.get(email=email)
            webauthn_user = WebauthnUser.objects.get(user=user)
        except (User.DoesNotExist, WebauthnUser.DoesNotExist):
            return JsonResponse({'error': 'User not found'}, status=404)
        
        if not webauthn_user.webauthn_enabled:
            return JsonResponse({'error': 'WebAuthn not enabled for this user'}, status=400)
        
        # Generate authentication options
        options = get_options(request, user)
        
        return JsonResponse(options)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@csrf_exempt
def login_webauthn_complete(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        
        # Verify authentication
        user = get_verify(request)
        
        if user:
            # Log the user in
            login(request, user)
            
            return JsonResponse({
                'message': 'Login successful',
                'email': user.email
            })
        
        return JsonResponse({'error': 'Authentication failed'}, status=401)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def logout_view(request):
    logout(request)
    return JsonResponse({'message': 'Logout successful'})</code></pre>
            </div>
            
            <div class="pros-cons">
                <h3>Pros and Cons of Passwordless Authentication</h3>
                
                <h4>Pros:</h4>
                <ul>
                    <li><strong>Improved User Experience:</strong> No passwords to remember or type</li>
                    <li><strong>Enhanced Security:</strong> Eliminates weak or reused passwords</li>
                    <li><strong>Reduced Support Costs:</strong> Fewer password reset requests</li>
                    <li><strong>Phishing Resistance:</strong> Methods like WebAuthn are resistant to phishing attacks</li>
                    <li><strong>Simplified Onboarding:</strong> Faster, easier account creation</li>
                </ul>
                
                <h4>Cons:</h4>
                <ul>
                    <li><strong>Device Dependency:</strong> Users must have access to their authentication device</li>
                    <li><strong>Email/Phone Dependency:</strong> Magic links and OTPs rely on access to email or phone</li>
                    <li><strong>Implementation Complexity:</strong> More complex to implement correctly than passwords</li>
                    <li><strong>Recovery Challenges:</strong> May require more complex account recovery mechanisms</li>
                    <li><strong>User Adoption:</strong> Some users may be unfamiliar or uncomfortable with passwordless methods</li>
                </ul>
            </div>
            
            <div class="best-practices">
                <h3>Passwordless Authentication Best Practices</h3>
                <ul>
                    <li><strong>Secure Token Generation:</strong> Use cryptographically secure methods to generate tokens.</li>
                    <li><strong>Limited Token Lifetime:</strong> Set short expiration times for magic links and OTPs.</li>
                    <li><strong>Single-Use Tokens:</strong> Ensure tokens can only be used once.</li>
                    <li><strong>Secure Delivery:</strong> Use secure channels for token delivery.</li>
                    <li><strong>Rate Limiting:</strong> Implement rate limiting to prevent abuse.</li>
                    <li><strong>Account Recovery:</strong> Provide secure fallback authentication methods.</li>
                    <li><strong>Clear User Communication:</strong> Explain the authentication process clearly to users.</li>
                    <li><strong>Secure Session Management:</strong> Implement proper session handling after authentication.</li>
                </ul>
            </div>
        </section>

        <section class="real_world_architecture">
            <h2>Building a Comprehensive Authentication System</h2>
            
            <p>A robust authentication system often combines multiple approaches to balance security, usability, and flexibility. Let's explore a practical, layered authentication architecture for a modern web application.</p>
            
            <div class="architecture-diagram">
                <h3>Layered Authentication Architecture</h3>
                <img src="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgODAwIDQwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8IS0tIEhlYWRlciAtLT4KICA8dGV4dCB4PSI0MDAiIHk9IjMwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjI0IiBmb250LXdlaWdodD0iYm9sZCI+TGF5ZXJlZCBBdXRoZW50aWNhdGlvbiBBcmNoaXRlY3R1cmU8L3RleHQ+CiAgCiAgPCEtLSBDbGllbnQgLS0+CiAgPHJlY3QgeD0iNTAiIHk9IjgwIiB3aWR0aD0iMTUwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjZjVmNWY1IiBzdHJva2U9IiMzMzMiIHN0cm9rZS13aWR0aD0iMiIgcng9IjUiIHJ5PSI1Ii8+CiAgPHRleHQgeD0iMTI1IiB5PSI5NSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxOCIgZm9udC13ZWlnaHQ9ImJvbGQiPkNsaWVudCBBcHA8L3RleHQ+CiAgPHRleHQgeD0iMTI1IiB5PSIxMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9IiM1NTUiPihXZWIsIE1vYmlsZSwgSW9UKTwvdGV4dD4KICAKICA8IS0tIEFQSSBHYXRld2F5IC0tPgogIDxyZWN0IHg9IjMwMCIgeT0iODAiIHdpZHRoPSIyMDAiIGhlaWdodD0iODAiIGZpbGw9IiNlNmYyZmYiIHN0cm9rZT0iIzMzMyIgc3Ryb2tlLXdpZHRoPSIyIiByeD0iNSIgcnk9IjUiLz4KICA8dGV4dCB4PSI0MDAiIHk9IjEyMCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxOCIgZm9udC13ZWlnaHQ9ImJvbGQiPkFQSSBHYXRld2F5PC90ZXh0PgogIAogIDwhLS0gQXV0aCBTZXJ2aWNlIC0tPgogIDxyZWN0IHg9IjYwMCIgeT0iODAiIHdpZHRoPSIxNTAiIGhlaWdodD0iODAiIGZpbGw9IiNlNmZmZTYiIHN0cm9rZT0iIzMzMyIgc3Ryb2tlLXdpZHRoPSIyIiByeD0iNSIgcnk9IjUiLz4KICA8dGV4dCB4PSI2NzUiIHk9IjEyMCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxOCIgZm9udC13ZWlnaHQ9ImJvbGQiPkF1dGggU2VydmljZTwvdGV4dD4KCiAgPCEtLSBBcnJvd3MgLS0+CiAgPGxpbmUgeDE9IjIwMCIgeTE9IjEyMCIgeDI9IjI5NSIgeTI9IjEyMCIgc3Ryb2tlPSIjMzMzIiBzdHJva2Utd2lkdGg9IjIiIG1hcmtlci1lbmQ9InVybCgjYXJyb3doZWFkKSIvPgogIDxsaW5lIHgxPSI1MDAiIHkxPSIxMjAiIHgyPSI1OTUiIHkyPSIxMjAiIHN0cm9rZT0iIzMzMyIgc3Ryb2tlLXdpZHRoPSIyIiBtYXJrZXItZW5kPSJ1cmwoI2Fycm93aGVhZCkiLz4KCiAgPCEtLSBBdXRoIFNlcnZpY2UgQ29tcG9uZW50cyAtLT4KICA8IS0tIFRva2VuIEhhbmRsaW5nIC0tPgogIDxyZWN0IHg9IjU1MCIgeT0iMjAwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjZjVmMGZmIiBzdHJva2U9IiMzMzMiIHN0cm9rZS13aWR0aD0iMiIgcng9IjUiIHJ5PSI1Ii8+CiAgPHRleHQgeD0iNjAwIiB5PSIyMzAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiPkpXVCBUb2tlbnM8L3RleHQ+CiAgCiAgPCEtLSBTZXNzaW9uIEhhbmRsaW5nIC0tPgogIDxyZWN0IHg9IjY3MCIgeT0iMjAwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjZjVmMGZmIiBzdHJva2U9IiMzMzMiIHN0cm9rZS13aWR0aD0iMiIgcng9IjUiIHJ5PSI1Ii8+CiAgPHRleHQgeD0iNzIwIiB5PSIyMzAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiPlNlc3Npb25zPC90ZXh0PgogIAogIDwhLS0gQXV0aCBNZXRob2RzIC0tPgogIDxyZWN0IHg9IjQwMCIgeT0iMjkwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjZmZmMGUwIiBzdHJva2U9IiMzMzMiIHN0cm9rZS13aWR0aD0iMiIgcng9IjUiIHJ5PSI1Ii8+CiAgPHRleHQgeD0iNDUwIiB5PSIzMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiPlBhc3N3b3JkPC90ZXh0PgogIAogIDxyZWN0IHg9IjUyMCIgeT0iMjkwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjZmZmMGUwIiBzdHJva2U9IiMzMzMiIHN0cm9rZS13aWR0aD0iMiIgcng9IjUiIHJ5PSI1Ii8+CiAgPHRleHQgeD0iNTcwIiB5PSIzMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiPlNvY2lhbCBBdXRoPC90ZXh0PgogIAogIDxyZWN0IHg9IjY0MCIgeT0iMjkwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjZmZmMGUwIiBzdHJva2U9IiMzMzMiIHN0cm9rZS13aWR0aD0iMiIgcng9IjUiIHJ5PSI1Ii8+CiAgPHRleHQgeD0iNjkwIiB5PSIzMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiPk1GQTwvdGV4dD4KICAKICA8cmVjdCB4PSI3NjAiIHk9IjI5MCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSI2MCIgZmlsbD0iI2ZmZjBlMCIgc3Ryb2tlPSIjMzMzIiBzdHJva2Utd2lkdGg9IjIiIHJ4PSI1IiByeT0iNSIvPgogIDx0ZXh0IHg9IjgxMCIgeT0iMzIwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjE0Ij5QYXNzd29yZGxlc3M8L3RleHQ+CiAgCiAgPCEtLSBDb25uZWN0aW9ucyAtLT4KICA8bGluZSB4MT0iNjAwIiB5MT0iMTYwIiB4Mj0iNjAwIiB5Mj0iMTk1IiBzdHJva2U9IiMzMzMiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWRhc2hhcnJheT0iNSw1IiAvPgogIDxsaW5lIHgxPSI3MjAiIHkxPSIxNjAiIHgyPSI3MjAiIHkyPSIxOTUiIHN0cm9rZT0iIzMzMyIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtZGFzaGFycmF5PSI1LDUiIC8+CiAgCiAgPGxpbmUgeDE9IjQ1MCIgeTE9IjI2NSIgeDI9IjQ1MCIgeTI9IjI4NSIgc3Ryb2tlPSIjMzMzIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1kYXNoYXJyYXk9IjUsNSIgLz4KICA8bGluZSB4MT0iNTcwIiB5MT0iMjY1IiB4Mj0iNTcwIiB5Mj0iMjg1IiBzdHJva2U9IiMzMzMiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWRhc2hhcnJheT0iNSw1IiAvPgogIDxsaW5lIHgxPSI2OTAiIHkxPSIyNjUiIHgyPSI2OTAiIHkyPSIyODUiIHN0cm9rZT0iIzMzMyIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtZGFzaGFycmF5PSI1LDUiIC8+CiAgPGxpbmUgeDE9IjgxMCIgeTE9IjI2NSIgeDI9IjgxMCIgeTI9IjI4NSIgc3Ryb2tlPSIjMzMzIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1kYXNoYXJyYXk9IjUsNSIgLz4KICAKICA8IS0tIENvbm5lY3Rpb24gZnJvbSBBdXRoIFNlcnZpY2UgdG8gQXV0aCBNZXRob2RzIC0tPgogIDxwYXRoIGQ9Ik02NzUsMTYwIEM2NzUsMjgwIDYzMCwyODAgNDUwLDI4MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMzMzIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1kYXNoYXJyYXk9IjUsNSIgLz4KICAKICA8IS0tIEFycm93aGVhZCBtYXJrZXIgLS0+CiAgPGRlZnM+CiAgICA8bWFya2VyIGlkPSJhcnJvd2hlYWQiIG1hcmtlcldpZHRoPSIxMCIgbWFya2VySGVpZ2h0PSI3IiByZWZYPSIwIiByZWZZPSIzLjUiIG9yaWVudD0iYXV0byI+CiAgICAgIDxwb2x5Z29uIHBvaW50cz0iMCAwLCAxMCAzLjUsIDAgNyIgZmlsbD0iIzMzMyIvPgogICAgPC9tYXJrZXI+CiAgPC9kZWZzPgogIAogIDwhLS0gQVBJIFJlc291cmNlcyAtLT4KICA8cmVjdCB4PSIzMDAiIHk9IjIwMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSI2MCIgZmlsbD0iI2ViZWJlYiIgc3Ryb2tlPSIjMzMzIiBzdHJva2Utd2lkdGg9IjIiIHJ4PSI1IiByeT0iNSIvPgogIDx0ZXh0IHg9IjM1MCIgeT0iMjMwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjE0Ij5BUEkgUmVzb3VyY2VzPC90ZXh0PgogIDxsaW5lIHgxPSIzNTAiIHkxPSIxNjAiIHgyPSIzNTAiIHkyPSIxOTUiIHN0cm9rZT0iIzMzMyIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtZGFzaGFycmF5PSI1LDUiIC8+CiAgCiAgPCEtLSBEYXRhYmFzZSAtLT4KICA8ZWxsaXBzZSBjeD0iNDUwIiBjeT0iMjMwIiByeD0iNDAiIHJ5PSIyMCIgZmlsbD0iI2YwZjBmMCIgc3Ryb2tlPSIjMzMzIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8dGV4dCB4PSI0NTAiIHk9IjIzMCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxMiIgZm9udC13ZWlnaHQ9ImJvbGQiPkRCPC90ZXh0PgogIDxsaW5lIHgxPSI0MDgiIHkxPSIyMzAiIHgyPSIzNzAiIHkyPSIyMzAiIHN0cm9rZT0iIzMzMyIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtZGFzaGFycmF5PSI1LDUiIC8+Cjwvc3ZnPg==" alt="Layered Authentication Architecture Diagram" width="100%">
            </div>
            
            <div class="component-overview">
                <h3>Key Components</h3>
                
                <h4>Authentication Service</h4>
                <p>A dedicated service responsible for handling all authentication-related functionality:</p>
                <ul>
                    <li>User registration and management</li>
                    <li>Credential verification</li>
                    <li>Token issuance and validation</li>
                    <li>MFA implementation</li>
                    <li>Session management</li>
                </ul>
                
                <h4>API Gateway</h4>
                <p>The entry point for all API requests, responsible for:</p>
                <ul>
                    <li>Token validation</li>
                    <li>Request routing</li>
                    <li>Rate limiting</li>
                    <li>Basic request filtering</li>
                </ul>
                
                <h4>Identity Providers</h4>
                <p>External services for social/federated authentication:</p>
                <ul>
                    <li>OAuth 2.0/OpenID Connect providers (Google, GitHub, etc.)</li>
                    <li>Enterprise identity providers (Okta, Auth0, etc.)</li>
                </ul>
                
                <h4>User Database</h4>
                <p>Secure storage for user profiles and credentials:</p>
                <ul>
                    <li>User identities and profiles</li>
                    <li>Securely hashed credentials</li>
                    <li>MFA configuration</li>
                    <li>Account status and history</li>
                </ul>
            </div>
            
            <div class="authentication-flow">
                <h3>Primary Authentication Flow</h3>
                <ol>
                    <li><strong>Registration:</strong> User creates an account through one or more authentication methods</li>
                    <li><strong>Login:</strong> User authenticates using their preferred method</li>
                    <li><strong>MFA (if enabled):</strong> User provides a second factor</li>
                    <li><strong>Token Issuance:</strong> Authentication service issues access and refresh tokens</li>
                    <li><strong>Token Usage:</strong> Client includes tokens with API requests</li>
                    <li><strong>Token Validation:</strong> API Gateway validates tokens before allowing access to resources</li>
                    <li><strong>Token Refresh:</strong> Client uses refresh token to obtain new access tokens when needed</li>
                    <li><strong>Logout:</strong> Tokens are invalidated when the user logs out</li>
                </ol>
            </div>
            
            <div class="integration-options">
                <h3>Integration Options</h3>
                <ul>
                    <li><strong>Build vs. Buy:</strong> Consider using established authentication services (Auth0, Firebase Auth, AWS Cognito) vs. building your own solution.</li>
                    <li><strong>Microservices vs. Monolith:</strong> Decide whether authentication should be a separate service or part of your main application.</li>
                    <li><strong>Library Selection:</strong> Choose appropriate libraries based on your framework and requirements (e.g., Passport.js, Django Auth, Flask-Login).</li>
                    <li><strong>Protocol Selection:</strong> Decide which authentication protocols to support (OAuth 2.0, SAML, LDAP, etc.).</li>
                </ul>
            </div>
            
            <div class="security-checklist">
                <h3>Security Implementation Checklist</h3>
                <ul>
                    <li><strong>HTTPS Everywhere:</strong> Enforce HTTPS for all authentication endpoints and token transmission.</li>
                    <li><strong>Password Policies:</strong> Implement strong password requirements if using password authentication.</li>
                    <li><strong>Secure Storage:</strong> Use appropriate hashing algorithms (bcrypt, Argon2) for passwords and sensitive data.</li>
                    <li><strong>Rate Limiting:</strong> Implement rate limiting for login attempts and token generation.</li>
                    <li><strong>Token Security:</strong> Set appropriate expiration times, implement refresh token rotation.</li>
                    <li><strong>CSRF Protection:</strong> Implement CSRF tokens for session-based authentication.</li>
                    <li><strong>XSS Prevention:</strong> Store tokens securely (HttpOnly cookies or secure browser storage).</li>
                    <li><strong>Logging and Monitoring:</strong> Log authentication events and monitor for suspicious activity.</li>
                    <li><strong>Account Recovery:</strong> Implement secure account recovery mechanisms.</li>
                </ul>
            </div>
        </section>

        <section class="conclusion">
            <h2>Conclusion and Next Steps</h2>
            
            <p>Authentication is a critical foundation for any API or web application. Implementing it correctly requires understanding various approaches and selecting the right mix of methods to balance security and usability for your specific use case.</p>
            
            <h3>Key Takeaways</h3>
            <ul>
                <li><strong>No One-Size-Fits-All:</strong> Choose authentication methods based on your specific security requirements, user base, and application type.</li>
                <li><strong>Defense in Depth:</strong> Implement multiple layers of security, including MFA when possible.</li>
                <li><strong>User Experience Matters:</strong> Balance security with usability to ensure user adoption.</li>
                <li><strong>Evolving Landscape:</strong> Stay updated on authentication best practices and evolving threats.</li>
                <li><strong>Framework Support:</strong> Leverage the authentication capabilities of your chosen Python frameworks.</li>
                <li><strong>Third-Party Solutions:</strong> Consider using established authentication services when appropriate.</li>
            </ul>
            
            <h3>Next Steps</h3>
            <ul>
                <li><strong>Threat Modeling:</strong> Conduct a thorough threat analysis for your specific application.</li>
                <li><strong>Authentication Strategy:</strong> Develop a comprehensive authentication strategy based on your requirements.</li>
                <li><strong>Implementation Planning:</strong> Plan your authentication implementation, including phased rollout if needed.</li>
                <li><strong>Testing:</strong> Thoroughly test your authentication system, including security testing.</li>
                <li><strong>Monitoring:</strong> Implement monitoring and alerting for authentication systems.</li>
                <li><strong>User Education:</strong> Educate users about security best practices.</li>
            </ul>
            
            <h3>Further Resources</h3>
            <ul>
                <li><strong>OWASP Authentication Cheat Sheet:</strong> Comprehensive guide to secure authentication practices.</li>
                <li><strong>NIST Digital Identity Guidelines:</strong> Standard guidelines for authentication and identity proofing.</li>
                <li><strong>Web Authentication API (WebAuthn):</strong> Specification for strong, passwordless authentication.</li>
                <li><strong>OAuth 2.0 and OpenID Connect Documentation:</strong> Official specifications and guides.</li>
                <li><strong>Framework-Specific Documentation:</strong> Authentication guides for Django, Flask, FastAPI, etc.</li>
            </ul>
            
            <p>Remember that authentication is not a set-it-and-forget-it feature—it requires ongoing maintenance, updates, and improvements to stay secure against evolving threats. By implementing a robust, layered authentication system using Python's rich ecosystem of tools and libraries, you can provide a secure and user-friendly experience for your application's users.</p>
        </section>
    </main>

    <footer>
        <p>Python Full Stack Web Course - Authentication in APIs</p>
    </footer>
</body>
</html>
